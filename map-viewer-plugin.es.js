var Kg = Object.defineProperty;
var Vg = (i, t, e) => t in i ? Kg(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;
var jg = (i, t) => () => (t || i((t = { exports: {} }).exports, t), t.exports);
var En = (i, t, e) => Vg(i, typeof t != "symbol" ? t + "" : t, e);
var R2 = jg((nt) => {
  (function() {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload"))
      return;
    for (const s of document.querySelectorAll('link[rel="modulepreload"]'))
      n(s);
    new MutationObserver((s) => {
      for (const r of s)
        if (r.type === "childList")
          for (const a of r.addedNodes)
            a.tagName === "LINK" && a.rel === "modulepreload" && n(a);
    }).observe(document, { childList: !0, subtree: !0 });
    function e(s) {
      const r = {};
      return s.integrity && (r.integrity = s.integrity), s.referrerPolicy && (r.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? r.credentials = "include" : s.crossOrigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r;
    }
    function n(s) {
      if (s.ep)
        return;
      s.ep = !0;
      const r = e(s);
      fetch(s.href, r);
    }
  })();
  /**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  const Ta = globalThis, Yl = Ta.ShadowRoot && (Ta.ShadyCSS === void 0 || Ta.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, Zl = Symbol(), vc = /* @__PURE__ */ new WeakMap();
  let ed = class {
    constructor(t, e, n) {
      if (this._$cssResult$ = !0, n !== Zl) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
      this.cssText = t, this.t = e;
    }
    get styleSheet() {
      let t = this.o;
      const e = this.t;
      if (Yl && t === void 0) {
        const n = e !== void 0 && e.length === 1;
        n && (t = vc.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), n && vc.set(e, t));
      }
      return t;
    }
    toString() {
      return this.cssText;
    }
  };
  const Hg = (i) => new ed(typeof i == "string" ? i : i + "", void 0, Zl), ql = (i, ...t) => {
    const e = i.length === 1 ? i[0] : t.reduce((n, s, r) => n + ((a) => {
      if (a._$cssResult$ === !0) return a.cssText;
      if (typeof a == "number") return a;
      throw Error("Value passed to 'css' function must be a 'css' function result: " + a + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
    })(s) + i[r + 1], i[0]);
    return new ed(e, i, Zl);
  }, Jg = (i, t) => {
    if (Yl) i.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet);
    else for (const e of t) {
      const n = document.createElement("style"), s = Ta.litNonce;
      s !== void 0 && n.setAttribute("nonce", s), n.textContent = e.cssText, i.appendChild(n);
    }
  }, Ec = Yl ? (i) => i : (i) => i instanceof CSSStyleSheet ? ((t) => {
    let e = "";
    for (const n of t.cssRules) e += n.cssText;
    return Hg(e);
  })(i) : i;
  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  const { is: Qg, defineProperty: t0, getOwnPropertyDescriptor: e0, getOwnPropertyNames: i0, getOwnPropertySymbols: n0, getPrototypeOf: s0 } = Object, Zi = globalThis, Mc = Zi.trustedTypes, r0 = Mc ? Mc.emptyScript : "", Bo = Zi.reactiveElementPolyfillSupport, cr = (i, t) => i, vl = { toAttribute(i, t) {
    switch (t) {
      case Boolean:
        i = i ? r0 : null;
        break;
      case Object:
      case Array:
        i = i == null ? i : JSON.stringify(i);
    }
    return i;
  }, fromAttribute(i, t) {
    let e = i;
    switch (t) {
      case Boolean:
        e = i !== null;
        break;
      case Number:
        e = i === null ? null : Number(i);
        break;
      case Object:
      case Array:
        try {
          e = JSON.parse(i);
        } catch {
          e = null;
        }
    }
    return e;
  } }, id = (i, t) => !Qg(i, t), xc = { attribute: !0, type: String, converter: vl, reflect: !1, hasChanged: id };
  Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), Zi.litPropertyMetadata ?? (Zi.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
  class ss extends HTMLElement {
    static addInitializer(t) {
      this._$Ei(), (this.l ?? (this.l = [])).push(t);
    }
    static get observedAttributes() {
      return this.finalize(), this._$Eh && [...this._$Eh.keys()];
    }
    static createProperty(t, e = xc) {
      if (e.state && (e.attribute = !1), this._$Ei(), this.elementProperties.set(t, e), !e.noAccessor) {
        const n = Symbol(), s = this.getPropertyDescriptor(t, n, e);
        s !== void 0 && t0(this.prototype, t, s);
      }
    }
    static getPropertyDescriptor(t, e, n) {
      const { get: s, set: r } = e0(this.prototype, t) ?? { get() {
        return this[e];
      }, set(a) {
        this[e] = a;
      } };
      return { get() {
        return s == null ? void 0 : s.call(this);
      }, set(a) {
        const o = s == null ? void 0 : s.call(this);
        r.call(this, a), this.requestUpdate(t, o, n);
      }, configurable: !0, enumerable: !0 };
    }
    static getPropertyOptions(t) {
      return this.elementProperties.get(t) ?? xc;
    }
    static _$Ei() {
      if (this.hasOwnProperty(cr("elementProperties"))) return;
      const t = s0(this);
      t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
    }
    static finalize() {
      if (this.hasOwnProperty(cr("finalized"))) return;
      if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(cr("properties"))) {
        const e = this.properties, n = [...i0(e), ...n0(e)];
        for (const s of n) this.createProperty(s, e[s]);
      }
      const t = this[Symbol.metadata];
      if (t !== null) {
        const e = litPropertyMetadata.get(t);
        if (e !== void 0) for (const [n, s] of e) this.elementProperties.set(n, s);
      }
      this._$Eh = /* @__PURE__ */ new Map();
      for (const [e, n] of this.elementProperties) {
        const s = this._$Eu(e, n);
        s !== void 0 && this._$Eh.set(s, e);
      }
      this.elementStyles = this.finalizeStyles(this.styles);
    }
    static finalizeStyles(t) {
      const e = [];
      if (Array.isArray(t)) {
        const n = new Set(t.flat(1 / 0).reverse());
        for (const s of n) e.unshift(Ec(s));
      } else t !== void 0 && e.push(Ec(t));
      return e;
    }
    static _$Eu(t, e) {
      const n = e.attribute;
      return n === !1 ? void 0 : typeof n == "string" ? n : typeof t == "string" ? t.toLowerCase() : void 0;
    }
    constructor() {
      super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
    }
    _$Ev() {
      var t;
      this._$ES = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (t = this.constructor.l) == null || t.forEach((e) => e(this));
    }
    addController(t) {
      var e;
      (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t), this.renderRoot !== void 0 && this.isConnected && ((e = t.hostConnected) == null || e.call(t));
    }
    removeController(t) {
      var e;
      (e = this._$EO) == null || e.delete(t);
    }
    _$E_() {
      const t = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
      for (const n of e.keys()) this.hasOwnProperty(n) && (t.set(n, this[n]), delete this[n]);
      t.size > 0 && (this._$Ep = t);
    }
    createRenderRoot() {
      const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
      return Jg(t, this.constructor.elementStyles), t;
    }
    connectedCallback() {
      var t;
      this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (t = this._$EO) == null || t.forEach((e) => {
        var n;
        return (n = e.hostConnected) == null ? void 0 : n.call(e);
      });
    }
    enableUpdating(t) {
    }
    disconnectedCallback() {
      var t;
      (t = this._$EO) == null || t.forEach((e) => {
        var n;
        return (n = e.hostDisconnected) == null ? void 0 : n.call(e);
      });
    }
    attributeChangedCallback(t, e, n) {
      this._$AK(t, n);
    }
    _$EC(t, e) {
      var r;
      const n = this.constructor.elementProperties.get(t), s = this.constructor._$Eu(t, n);
      if (s !== void 0 && n.reflect === !0) {
        const a = (((r = n.converter) == null ? void 0 : r.toAttribute) !== void 0 ? n.converter : vl).toAttribute(e, n.type);
        this._$Em = t, a == null ? this.removeAttribute(s) : this.setAttribute(s, a), this._$Em = null;
      }
    }
    _$AK(t, e) {
      var r;
      const n = this.constructor, s = n._$Eh.get(t);
      if (s !== void 0 && this._$Em !== s) {
        const a = n.getPropertyOptions(s), o = typeof a.converter == "function" ? { fromAttribute: a.converter } : ((r = a.converter) == null ? void 0 : r.fromAttribute) !== void 0 ? a.converter : vl;
        this._$Em = s, this[s] = o.fromAttribute(e, a.type), this._$Em = null;
      }
    }
    requestUpdate(t, e, n) {
      if (t !== void 0) {
        if (n ?? (n = this.constructor.getPropertyOptions(t)), !(n.hasChanged ?? id)(this[t], e)) return;
        this.P(t, e, n);
      }
      this.isUpdatePending === !1 && (this._$ES = this._$ET());
    }
    P(t, e, n) {
      this._$AL.has(t) || this._$AL.set(t, e), n.reflect === !0 && this._$Em !== t && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(t);
    }
    async _$ET() {
      this.isUpdatePending = !0;
      try {
        await this._$ES;
      } catch (e) {
        Promise.reject(e);
      }
      const t = this.scheduleUpdate();
      return t != null && await t, !this.isUpdatePending;
    }
    scheduleUpdate() {
      return this.performUpdate();
    }
    performUpdate() {
      var n;
      if (!this.isUpdatePending) return;
      if (!this.hasUpdated) {
        if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
          for (const [r, a] of this._$Ep) this[r] = a;
          this._$Ep = void 0;
        }
        const s = this.constructor.elementProperties;
        if (s.size > 0) for (const [r, a] of s) a.wrapped !== !0 || this._$AL.has(r) || this[r] === void 0 || this.P(r, this[r], a);
      }
      let t = !1;
      const e = this._$AL;
      try {
        t = this.shouldUpdate(e), t ? (this.willUpdate(e), (n = this._$EO) == null || n.forEach((s) => {
          var r;
          return (r = s.hostUpdate) == null ? void 0 : r.call(s);
        }), this.update(e)) : this._$EU();
      } catch (s) {
        throw t = !1, this._$EU(), s;
      }
      t && this._$AE(e);
    }
    willUpdate(t) {
    }
    _$AE(t) {
      var e;
      (e = this._$EO) == null || e.forEach((n) => {
        var s;
        return (s = n.hostUpdated) == null ? void 0 : s.call(n);
      }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
    }
    _$EU() {
      this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
    }
    get updateComplete() {
      return this.getUpdateComplete();
    }
    getUpdateComplete() {
      return this._$ES;
    }
    shouldUpdate(t) {
      return !0;
    }
    update(t) {
      this._$Ej && (this._$Ej = this._$Ej.forEach((e) => this._$EC(e, this[e]))), this._$EU();
    }
    updated(t) {
    }
    firstUpdated(t) {
    }
  }
  ss.elementStyles = [], ss.shadowRootOptions = { mode: "open" }, ss[cr("elementProperties")] = /* @__PURE__ */ new Map(), ss[cr("finalized")] = /* @__PURE__ */ new Map(), Bo == null || Bo({ ReactiveElement: ss }), (Zi.reactiveElementVersions ?? (Zi.reactiveElementVersions = [])).push("2.0.4");
  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  const ur = globalThis, Fa = ur.trustedTypes, wc = Fa ? Fa.createPolicy("lit-html", { createHTML: (i) => i }) : void 0, nd = "$lit$", Bi = `lit$${Math.random().toFixed(9).slice(2)}$`, sd = "?" + Bi, a0 = `<${sd}>`, Nn = document, yr = () => Nn.createComment(""), vr = (i) => i === null || typeof i != "object" && typeof i != "function", Kl = Array.isArray, o0 = (i) => Kl(i) || typeof (i == null ? void 0 : i[Symbol.iterator]) == "function", Wo = `[ 	
\f\r]`, Ks = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, Sc = /-->/g, Cc = />/g, Mn = RegExp(`>|${Wo}(?:([^\\s"'>=/]+)(${Wo}*=${Wo}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), Rc = /'/g, Ic = /"/g, rd = /^(?:script|style|textarea|title)$/i, l0 = (i) => (t, ...e) => ({ _$litType$: i, strings: t, values: e }), Pn = l0(1), Ss = Symbol.for("lit-noChange"), qt = Symbol.for("lit-nothing"), Tc = /* @__PURE__ */ new WeakMap(), Cn = Nn.createTreeWalker(Nn, 129);
  function ad(i, t) {
    if (!Kl(i) || !i.hasOwnProperty("raw")) throw Error("invalid template strings array");
    return wc !== void 0 ? wc.createHTML(t) : t;
  }
  const h0 = (i, t) => {
    const e = i.length - 1, n = [];
    let s, r = t === 2 ? "<svg>" : t === 3 ? "<math>" : "", a = Ks;
    for (let o = 0; o < e; o++) {
      const l = i[o];
      let h, c, u = -1, d = 0;
      for (; d < l.length && (a.lastIndex = d, c = a.exec(l), c !== null); ) d = a.lastIndex, a === Ks ? c[1] === "!--" ? a = Sc : c[1] !== void 0 ? a = Cc : c[2] !== void 0 ? (rd.test(c[2]) && (s = RegExp("</" + c[2], "g")), a = Mn) : c[3] !== void 0 && (a = Mn) : a === Mn ? c[0] === ">" ? (a = s ?? Ks, u = -1) : c[1] === void 0 ? u = -2 : (u = a.lastIndex - c[2].length, h = c[1], a = c[3] === void 0 ? Mn : c[3] === '"' ? Ic : Rc) : a === Ic || a === Rc ? a = Mn : a === Sc || a === Cc ? a = Ks : (a = Mn, s = void 0);
      const g = a === Mn && i[o + 1].startsWith("/>") ? " " : "";
      r += a === Ks ? l + a0 : u >= 0 ? (n.push(h), l.slice(0, u) + nd + l.slice(u) + Bi + g) : l + Bi + (u === -2 ? o : g);
    }
    return [ad(i, r + (i[e] || "<?>") + (t === 2 ? "</svg>" : t === 3 ? "</math>" : "")), n];
  };
  class Er {
    constructor({ strings: t, _$litType$: e }, n) {
      let s;
      this.parts = [];
      let r = 0, a = 0;
      const o = t.length - 1, l = this.parts, [h, c] = h0(t, e);
      if (this.el = Er.createElement(h, n), Cn.currentNode = this.el.content, e === 2 || e === 3) {
        const u = this.el.content.firstChild;
        u.replaceWith(...u.childNodes);
      }
      for (; (s = Cn.nextNode()) !== null && l.length < o; ) {
        if (s.nodeType === 1) {
          if (s.hasAttributes()) for (const u of s.getAttributeNames()) if (u.endsWith(nd)) {
            const d = c[a++], g = s.getAttribute(u).split(Bi), _ = /([.?@])?(.*)/.exec(d);
            l.push({ type: 1, index: r, name: _[2], strings: g, ctor: _[1] === "." ? u0 : _[1] === "?" ? d0 : _[1] === "@" ? f0 : ao }), s.removeAttribute(u);
          } else u.startsWith(Bi) && (l.push({ type: 6, index: r }), s.removeAttribute(u));
          if (rd.test(s.tagName)) {
            const u = s.textContent.split(Bi), d = u.length - 1;
            if (d > 0) {
              s.textContent = Fa ? Fa.emptyScript : "";
              for (let g = 0; g < d; g++) s.append(u[g], yr()), Cn.nextNode(), l.push({ type: 2, index: ++r });
              s.append(u[d], yr());
            }
          }
        } else if (s.nodeType === 8) if (s.data === sd) l.push({ type: 2, index: r });
        else {
          let u = -1;
          for (; (u = s.data.indexOf(Bi, u + 1)) !== -1; ) l.push({ type: 7, index: r }), u += Bi.length - 1;
        }
        r++;
      }
    }
    static createElement(t, e) {
      const n = Nn.createElement("template");
      return n.innerHTML = t, n;
    }
  }
  function Cs(i, t, e = i, n) {
    var a, o;
    if (t === Ss) return t;
    let s = n !== void 0 ? (a = e._$Co) == null ? void 0 : a[n] : e._$Cl;
    const r = vr(t) ? void 0 : t._$litDirective$;
    return (s == null ? void 0 : s.constructor) !== r && ((o = s == null ? void 0 : s._$AO) == null || o.call(s, !1), r === void 0 ? s = void 0 : (s = new r(i), s._$AT(i, e, n)), n !== void 0 ? (e._$Co ?? (e._$Co = []))[n] = s : e._$Cl = s), s !== void 0 && (t = Cs(i, s._$AS(i, t.values), s, n)), t;
  }
  let c0 = class {
    constructor(t, e) {
      this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
    }
    get parentNode() {
      return this._$AM.parentNode;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    u(t) {
      const { el: { content: e }, parts: n } = this._$AD, s = ((t == null ? void 0 : t.creationScope) ?? Nn).importNode(e, !0);
      Cn.currentNode = s;
      let r = Cn.nextNode(), a = 0, o = 0, l = n[0];
      for (; l !== void 0; ) {
        if (a === l.index) {
          let h;
          l.type === 2 ? h = new Vl(r, r.nextSibling, this, t) : l.type === 1 ? h = new l.ctor(r, l.name, l.strings, this, t) : l.type === 6 && (h = new g0(r, this, t)), this._$AV.push(h), l = n[++o];
        }
        a !== (l == null ? void 0 : l.index) && (r = Cn.nextNode(), a++);
      }
      return Cn.currentNode = Nn, s;
    }
    p(t) {
      let e = 0;
      for (const n of this._$AV) n !== void 0 && (n.strings !== void 0 ? (n._$AI(t, n, e), e += n.strings.length - 2) : n._$AI(t[e])), e++;
    }
  }, Vl = class od {
    get _$AU() {
      var t;
      return ((t = this._$AM) == null ? void 0 : t._$AU) ?? this._$Cv;
    }
    constructor(t, e, n, s) {
      this.type = 2, this._$AH = qt, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = n, this.options = s, this._$Cv = (s == null ? void 0 : s.isConnected) ?? !0;
    }
    get parentNode() {
      let t = this._$AA.parentNode;
      const e = this._$AM;
      return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;
    }
    get startNode() {
      return this._$AA;
    }
    get endNode() {
      return this._$AB;
    }
    _$AI(t, e = this) {
      t = Cs(this, t, e), vr(t) ? t === qt || t == null || t === "" ? (this._$AH !== qt && this._$AR(), this._$AH = qt) : t !== this._$AH && t !== Ss && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : o0(t) ? this.k(t) : this._(t);
    }
    O(t) {
      return this._$AA.parentNode.insertBefore(t, this._$AB);
    }
    T(t) {
      this._$AH !== t && (this._$AR(), this._$AH = this.O(t));
    }
    _(t) {
      this._$AH !== qt && vr(this._$AH) ? this._$AA.nextSibling.data = t : this.T(Nn.createTextNode(t)), this._$AH = t;
    }
    $(t) {
      var r;
      const { values: e, _$litType$: n } = t, s = typeof n == "number" ? this._$AC(t) : (n.el === void 0 && (n.el = Er.createElement(ad(n.h, n.h[0]), this.options)), n);
      if (((r = this._$AH) == null ? void 0 : r._$AD) === s) this._$AH.p(e);
      else {
        const a = new c0(s, this), o = a.u(this.options);
        a.p(e), this.T(o), this._$AH = a;
      }
    }
    _$AC(t) {
      let e = Tc.get(t.strings);
      return e === void 0 && Tc.set(t.strings, e = new Er(t)), e;
    }
    k(t) {
      Kl(this._$AH) || (this._$AH = [], this._$AR());
      const e = this._$AH;
      let n, s = 0;
      for (const r of t) s === e.length ? e.push(n = new od(this.O(yr()), this.O(yr()), this, this.options)) : n = e[s], n._$AI(r), s++;
      s < e.length && (this._$AR(n && n._$AB.nextSibling, s), e.length = s);
    }
    _$AR(t = this._$AA.nextSibling, e) {
      var n;
      for ((n = this._$AP) == null ? void 0 : n.call(this, !1, !0, e); t && t !== this._$AB; ) {
        const s = t.nextSibling;
        t.remove(), t = s;
      }
    }
    setConnected(t) {
      var e;
      this._$AM === void 0 && (this._$Cv = t, (e = this._$AP) == null || e.call(this, t));
    }
  };
  class ao {
    get tagName() {
      return this.element.tagName;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    constructor(t, e, n, s, r) {
      this.type = 1, this._$AH = qt, this._$AN = void 0, this.element = t, this.name = e, this._$AM = s, this.options = r, n.length > 2 || n[0] !== "" || n[1] !== "" ? (this._$AH = Array(n.length - 1).fill(new String()), this.strings = n) : this._$AH = qt;
    }
    _$AI(t, e = this, n, s) {
      const r = this.strings;
      let a = !1;
      if (r === void 0) t = Cs(this, t, e, 0), a = !vr(t) || t !== this._$AH && t !== Ss, a && (this._$AH = t);
      else {
        const o = t;
        let l, h;
        for (t = r[0], l = 0; l < r.length - 1; l++) h = Cs(this, o[n + l], e, l), h === Ss && (h = this._$AH[l]), a || (a = !vr(h) || h !== this._$AH[l]), h === qt ? t = qt : t !== qt && (t += (h ?? "") + r[l + 1]), this._$AH[l] = h;
      }
      a && !s && this.j(t);
    }
    j(t) {
      t === qt ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
    }
  }
  class u0 extends ao {
    constructor() {
      super(...arguments), this.type = 3;
    }
    j(t) {
      this.element[this.name] = t === qt ? void 0 : t;
    }
  }
  let d0 = class extends ao {
    constructor() {
      super(...arguments), this.type = 4;
    }
    j(t) {
      this.element.toggleAttribute(this.name, !!t && t !== qt);
    }
  };
  class f0 extends ao {
    constructor(t, e, n, s, r) {
      super(t, e, n, s, r), this.type = 5;
    }
    _$AI(t, e = this) {
      if ((t = Cs(this, t, e, 0) ?? qt) === Ss) return;
      const n = this._$AH, s = t === qt && n !== qt || t.capture !== n.capture || t.once !== n.once || t.passive !== n.passive, r = t !== qt && (n === qt || s);
      s && this.element.removeEventListener(this.name, this, n), r && this.element.addEventListener(this.name, this, t), this._$AH = t;
    }
    handleEvent(t) {
      var e;
      typeof this._$AH == "function" ? this._$AH.call(((e = this.options) == null ? void 0 : e.host) ?? this.element, t) : this._$AH.handleEvent(t);
    }
  }
  class g0 {
    constructor(t, e, n) {
      this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = n;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(t) {
      Cs(this, t);
    }
  }
  const Xo = ur.litHtmlPolyfillSupport;
  Xo == null || Xo(Er, Vl), (ur.litHtmlVersions ?? (ur.litHtmlVersions = [])).push("3.2.1");
  const m0 = (i, t, e) => {
    const n = (e == null ? void 0 : e.renderBefore) ?? t;
    let s = n._$litPart$;
    if (s === void 0) {
      const r = (e == null ? void 0 : e.renderBefore) ?? null;
      n._$litPart$ = s = new Vl(t.insertBefore(yr(), r), r, void 0, e ?? {});
    }
    return s._$AI(i), s;
  };
  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  class qi extends ss {
    constructor() {
      super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
    }
    createRenderRoot() {
      var e;
      const t = super.createRenderRoot();
      return (e = this.renderOptions).renderBefore ?? (e.renderBefore = t.firstChild), t;
    }
    update(t) {
      const e = this.render();
      this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = m0(e, this.renderRoot, this.renderOptions);
    }
    connectedCallback() {
      var t;
      super.connectedCallback(), (t = this._$Do) == null || t.setConnected(!0);
    }
    disconnectedCallback() {
      var t;
      super.disconnectedCallback(), (t = this._$Do) == null || t.setConnected(!1);
    }
    render() {
      return Ss;
    }
  }
  var td;
  qi._$litElement$ = !0, qi.finalized = !0, (td = globalThis.litElementHydrateSupport) == null || td.call(globalThis, { LitElement: qi });
  const Yo = globalThis.litElementPolyfillSupport;
  Yo == null || Yo({ LitElement: qi });
  (globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.1.1");
  const Ee = {
    /**
     * Triggered when an item is added to the collection.
     * @event module:ol/Collection.CollectionEvent#add
     * @api
     */
    ADD: "add",
    /**
     * Triggered when an item is removed from the collection.
     * @event module:ol/Collection.CollectionEvent#remove
     * @api
     */
    REMOVE: "remove"
  }, Rs = {
    /**
     * Triggered when a property is changed.
     * @event module:ol/Object.ObjectEvent#propertychange
     * @api
     */
    PROPERTYCHANGE: "propertychange"
  }, at = {
    /**
     * Generic change event. Triggered when the revision counter is increased.
     * @event module:ol/events/Event~BaseEvent#change
     * @api
     */
    CHANGE: "change",
    /**
     * Generic error event. Triggered when an error occurs.
     * @event module:ol/events/Event~BaseEvent#error
     * @api
     */
    ERROR: "error",
    BLUR: "blur",
    CLEAR: "clear",
    CONTEXTMENU: "contextmenu",
    CLICK: "click",
    DBLCLICK: "dblclick",
    DRAGENTER: "dragenter",
    DRAGOVER: "dragover",
    DROP: "drop",
    FOCUS: "focus",
    KEYDOWN: "keydown",
    KEYPRESS: "keypress",
    LOAD: "load",
    RESIZE: "resize",
    TOUCHMOVE: "touchmove",
    WHEEL: "wheel"
  };
  class oo {
    constructor() {
      this.disposed = !1;
    }
    /**
     * Clean up.
     */
    dispose() {
      this.disposed || (this.disposed = !0, this.disposeInternal());
    }
    /**
     * Extension point for disposable objects.
     * @protected
     */
    disposeInternal() {
    }
  }
  function _0(i, t, e) {
    let n, s;
    e = e || Ki;
    let r = 0, a = i.length, o = !1;
    for (; r < a; )
      n = r + (a - r >> 1), s = +e(i[n], t), s < 0 ? r = n + 1 : (a = n, o = !s);
    return o ? r : ~r;
  }
  function Ki(i, t) {
    return i > t ? 1 : i < t ? -1 : 0;
  }
  function p0(i, t) {
    return i < t ? 1 : i > t ? -1 : 0;
  }
  function jl(i, t, e) {
    if (i[0] <= t)
      return 0;
    const n = i.length;
    if (t <= i[n - 1])
      return n - 1;
    if (typeof e == "function") {
      for (let s = 1; s < n; ++s) {
        const r = i[s];
        if (r === t)
          return s;
        if (r < t)
          return e(t, i[s - 1], r) > 0 ? s - 1 : s;
      }
      return n - 1;
    }
    if (e > 0) {
      for (let s = 1; s < n; ++s)
        if (i[s] < t)
          return s - 1;
      return n - 1;
    }
    if (e < 0) {
      for (let s = 1; s < n; ++s)
        if (i[s] <= t)
          return s;
      return n - 1;
    }
    for (let s = 1; s < n; ++s) {
      if (i[s] == t)
        return s;
      if (i[s] < t)
        return i[s - 1] - t < t - i[s] ? s - 1 : s;
    }
    return n - 1;
  }
  function y0(i, t, e) {
    for (; t < e; ) {
      const n = i[t];
      i[t] = i[e], i[e] = n, ++t, --e;
    }
  }
  function pe(i, t) {
    const e = Array.isArray(t) ? t : [t], n = e.length;
    for (let s = 0; s < n; s++)
      i[i.length] = e[s];
  }
  function rn(i, t) {
    const e = i.length;
    if (e !== t.length)
      return !1;
    for (let n = 0; n < e; n++)
      if (i[n] !== t[n])
        return !1;
    return !0;
  }
  function v0(i, t, e) {
    const n = t;
    return i.every(function(s, r) {
      if (r === 0)
        return !0;
      const a = n(i[r - 1], s);
      return !(a > 0 || a === 0);
    });
  }
  function Mr() {
    return !0;
  }
  function lo() {
    return !1;
  }
  function Is() {
  }
  function ld(i) {
    let t, e, n;
    return function() {
      const s = Array.prototype.slice.call(arguments);
      return (!e || this !== n || !rn(s, e)) && (n = this, e = s, t = i.apply(this, arguments)), t;
    };
  }
  function E0(i) {
    function t() {
      let e;
      try {
        e = i();
      } catch (n) {
        return Promise.reject(n);
      }
      return e instanceof Promise ? e : Promise.resolve(e);
    }
    return t();
  }
  function Dr(i) {
    for (const t in i)
      delete i[t];
  }
  function Ts(i) {
    let t;
    for (t in i)
      return !1;
    return !t;
  }
  class Ri {
    /**
     * @param {string} type Type.
     */
    constructor(t) {
      this.propagationStopped, this.defaultPrevented, this.type = t, this.target = null;
    }
    /**
     * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
     * will be fired.
     * @api
     */
    preventDefault() {
      this.defaultPrevented = !0;
    }
    /**
     * Stop event propagation.
     * @api
     */
    stopPropagation() {
      this.propagationStopped = !0;
    }
  }
  class ho extends oo {
    /**
     * @param {*} [target] Default event target for dispatched events.
     */
    constructor(t) {
      super(), this.eventTarget_ = t, this.pendingRemovals_ = null, this.dispatching_ = null, this.listeners_ = null;
    }
    /**
     * @param {string} type Type.
     * @param {import("../events.js").Listener} listener Listener.
     */
    addEventListener(t, e) {
      if (!t || !e)
        return;
      const n = this.listeners_ || (this.listeners_ = {}), s = n[t] || (n[t] = []);
      s.includes(e) || s.push(e);
    }
    /**
     * Dispatches an event and calls all listeners listening for events
     * of this type. The event parameter can either be a string or an
     * Object with a `type` property.
     *
     * @param {import("./Event.js").default|string} event Event object.
     * @return {boolean|undefined} `false` if anyone called preventDefault on the
     *     event object or if any of the listeners returned false.
     * @api
     */
    dispatchEvent(t) {
      const e = typeof t == "string", n = e ? t : t.type, s = this.listeners_ && this.listeners_[n];
      if (!s)
        return;
      const r = e ? new Ri(t) : (
        /** @type {Event} */
        t
      );
      r.target || (r.target = this.eventTarget_ || this);
      const a = this.dispatching_ || (this.dispatching_ = {}), o = this.pendingRemovals_ || (this.pendingRemovals_ = {});
      n in a || (a[n] = 0, o[n] = 0), ++a[n];
      let l;
      for (let h = 0, c = s.length; h < c; ++h)
        if ("handleEvent" in s[h] ? l = /** @type {import("../events.js").ListenerObject} */
        s[h].handleEvent(r) : l = /** @type {import("../events.js").ListenerFunction} */
        s[h].call(this, r), l === !1 || r.propagationStopped) {
          l = !1;
          break;
        }
      if (--a[n] === 0) {
        let h = o[n];
        for (delete o[n]; h--; )
          this.removeEventListener(n, Is);
        delete a[n];
      }
      return l;
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.listeners_ && Dr(this.listeners_);
    }
    /**
     * Get the listeners for a specified event type. Listeners are returned in the
     * order that they will be called in.
     *
     * @param {string} type Type.
     * @return {Array<import("../events.js").Listener>|undefined} Listeners.
     */
    getListeners(t) {
      return this.listeners_ && this.listeners_[t] || void 0;
    }
    /**
     * @param {string} [type] Type. If not provided,
     *     `true` will be returned if this event target has any listeners.
     * @return {boolean} Has listeners.
     */
    hasListener(t) {
      return this.listeners_ ? t ? t in this.listeners_ : Object.keys(this.listeners_).length > 0 : !1;
    }
    /**
     * @param {string} type Type.
     * @param {import("../events.js").Listener} listener Listener.
     */
    removeEventListener(t, e) {
      if (!this.listeners_)
        return;
      const n = this.listeners_[t];
      if (!n)
        return;
      const s = n.indexOf(e);
      s !== -1 && (this.pendingRemovals_ && t in this.pendingRemovals_ ? (n[s] = Is, ++this.pendingRemovals_[t]) : (n.splice(s, 1), n.length === 0 && delete this.listeners_[t]));
    }
  }
  function vt(i, t, e, n, s) {
    if (s) {
      const a = e;
      e = function(o) {
        return i.removeEventListener(t, e), a.call(n ?? this, o);
      };
    } else n && n !== i && (e = e.bind(n));
    const r = {
      target: i,
      type: t,
      listener: e
    };
    return i.addEventListener(t, e), r;
  }
  function Da(i, t, e, n) {
    return vt(i, t, e, n, !0);
  }
  function Pt(i) {
    i && i.target && (i.target.removeEventListener(i.type, i.listener), Dr(i));
  }
  class kr extends ho {
    constructor() {
      super(), this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
      this.onInternal, this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
      this.onceInternal, this.un = /** @type {ObservableOnSignature<void>} */
      this.unInternal, this.revision_ = 0;
    }
    /**
     * Increases the revision counter and dispatches a 'change' event.
     * @api
     */
    changed() {
      ++this.revision_, this.dispatchEvent(at.CHANGE);
    }
    /**
     * Get the version number for this object.  Each time the object is modified,
     * its version number will be incremented.
     * @return {number} Revision.
     * @api
     */
    getRevision() {
      return this.revision_;
    }
    /**
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
     * @protected
     */
    onInternal(t, e) {
      if (Array.isArray(t)) {
        const n = t.length, s = new Array(n);
        for (let r = 0; r < n; ++r)
          s[r] = vt(this, t[r], e);
        return s;
      }
      return vt(
        this,
        /** @type {string} */
        t,
        e
      );
    }
    /**
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
     * @protected
     */
    onceInternal(t, e) {
      let n;
      if (Array.isArray(t)) {
        const s = t.length;
        n = new Array(s);
        for (let r = 0; r < s; ++r)
          n[r] = Da(this, t[r], e);
      } else
        n = Da(
          this,
          /** @type {string} */
          t,
          e
        );
      return e.ol_key = n, n;
    }
    /**
     * Unlisten for a certain type of event.
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @protected
     */
    unInternal(t, e) {
      const n = (
        /** @type {Object} */
        e.ol_key
      );
      if (n)
        M0(n);
      else if (Array.isArray(t))
        for (let s = 0, r = t.length; s < r; ++s)
          this.removeEventListener(t[s], e);
      else
        this.removeEventListener(t, e);
    }
  }
  kr.prototype.on;
  kr.prototype.once;
  kr.prototype.un;
  function M0(i) {
    if (Array.isArray(i))
      for (let t = 0, e = i.length; t < e; ++t)
        Pt(i[t]);
    else
      Pt(
        /** @type {import("./events.js").EventsKey} */
        i
      );
  }
  function ct() {
    throw new Error("Unimplemented abstract method.");
  }
  let x0 = 0;
  function Ct(i) {
    return i.ol_uid || (i.ol_uid = String(++x0));
  }
  class Ac extends Ri {
    /**
     * @param {string} type The event type.
     * @param {string} key The property name.
     * @param {*} oldValue The old value for `key`.
     */
    constructor(t, e, n) {
      super(t), this.key = e, this.oldValue = n;
    }
  }
  class Qe extends kr {
    /**
     * @param {Object<string, *>} [values] An object with key-value pairs.
     */
    constructor(t) {
      super(), this.on, this.once, this.un, Ct(this), this.values_ = null, t !== void 0 && this.setProperties(t);
    }
    /**
     * Gets a value.
     * @param {string} key Key name.
     * @return {*} Value.
     * @api
     */
    get(t) {
      let e;
      return this.values_ && this.values_.hasOwnProperty(t) && (e = this.values_[t]), e;
    }
    /**
     * Get a list of object property names.
     * @return {Array<string>} List of property names.
     * @api
     */
    getKeys() {
      return this.values_ && Object.keys(this.values_) || [];
    }
    /**
     * Get an object of all property names and values.
     * @return {Object<string, *>} Object.
     * @api
     */
    getProperties() {
      return this.values_ && Object.assign({}, this.values_) || {};
    }
    /**
     * Get an object of all property names and values.
     * @return {Object<string, *>?} Object.
     */
    getPropertiesInternal() {
      return this.values_;
    }
    /**
     * @return {boolean} The object has properties.
     */
    hasProperties() {
      return !!this.values_;
    }
    /**
     * @param {string} key Key name.
     * @param {*} oldValue Old value.
     */
    notify(t, e) {
      let n;
      n = `change:${t}`, this.hasListener(n) && this.dispatchEvent(new Ac(n, t, e)), n = Rs.PROPERTYCHANGE, this.hasListener(n) && this.dispatchEvent(new Ac(n, t, e));
    }
    /**
     * @param {string} key Key name.
     * @param {import("./events.js").Listener} listener Listener.
     */
    addChangeListener(t, e) {
      this.addEventListener(`change:${t}`, e);
    }
    /**
     * @param {string} key Key name.
     * @param {import("./events.js").Listener} listener Listener.
     */
    removeChangeListener(t, e) {
      this.removeEventListener(`change:${t}`, e);
    }
    /**
     * Sets a value.
     * @param {string} key Key name.
     * @param {*} value Value.
     * @param {boolean} [silent] Update without triggering an event.
     * @api
     */
    set(t, e, n) {
      const s = this.values_ || (this.values_ = {});
      if (n)
        s[t] = e;
      else {
        const r = s[t];
        s[t] = e, r !== e && this.notify(t, r);
      }
    }
    /**
     * Sets a collection of key-value pairs.  Note that this changes any existing
     * properties and adds new ones (it does not remove any existing properties).
     * @param {Object<string, *>} values Values.
     * @param {boolean} [silent] Update without triggering an event.
     * @api
     */
    setProperties(t, e) {
      for (const n in t)
        this.set(n, t[n], e);
    }
    /**
     * Apply any properties from another object without triggering events.
     * @param {BaseObject} source The source object.
     * @protected
     */
    applyProperties(t) {
      t.values_ && Object.assign(this.values_ || (this.values_ = {}), t.values_);
    }
    /**
     * Unsets a property.
     * @param {string} key Key name.
     * @param {boolean} [silent] Unset without triggering an event.
     * @api
     */
    unset(t, e) {
      if (this.values_ && t in this.values_) {
        const n = this.values_[t];
        delete this.values_[t], Ts(this.values_) && (this.values_ = null), e || this.notify(t, n);
      }
    }
  }
  const bc = {
    LENGTH: "length"
  };
  class ua extends Ri {
    /**
     * @param {import("./CollectionEventType.js").default} type Type.
     * @param {T} element Element.
     * @param {number} index The index of the added or removed element.
     */
    constructor(t, e, n) {
      super(t), this.element = e, this.index = n;
    }
  }
  class ni extends Qe {
    /**
     * @param {Array<T>} [array] Array.
     * @param {Options} [options] Collection options.
     */
    constructor(t, e) {
      if (super(), this.on, this.once, this.un, e = e || {}, this.unique_ = !!e.unique, this.array_ = t || [], this.unique_)
        for (let n = 0, s = this.array_.length; n < s; ++n)
          this.assertUnique_(this.array_[n], n);
      this.updateLength_();
    }
    /**
     * Remove all elements from the collection.
     * @api
     */
    clear() {
      for (; this.getLength() > 0; )
        this.pop();
    }
    /**
     * Add elements to the collection.  This pushes each item in the provided array
     * to the end of the collection.
     * @param {!Array<T>} arr Array.
     * @return {Collection<T>} This collection.
     * @api
     */
    extend(t) {
      for (let e = 0, n = t.length; e < n; ++e)
        this.push(t[e]);
      return this;
    }
    /**
     * Iterate over each element, calling the provided callback.
     * @param {function(T, number, Array<T>): *} f The function to call
     *     for every element. This function takes 3 arguments (the element, the
     *     index and the array). The return value is ignored.
     * @api
     */
    forEach(t) {
      const e = this.array_;
      for (let n = 0, s = e.length; n < s; ++n)
        t(e[n], n, e);
    }
    /**
     * Get a reference to the underlying Array object. Warning: if the array
     * is mutated, no events will be dispatched by the collection, and the
     * collection's "length" property won't be in sync with the actual length
     * of the array.
     * @return {!Array<T>} Array.
     * @api
     */
    getArray() {
      return this.array_;
    }
    /**
     * Get the element at the provided index.
     * @param {number} index Index.
     * @return {T} Element.
     * @api
     */
    item(t) {
      return this.array_[t];
    }
    /**
     * Get the length of this collection.
     * @return {number} The length of the array.
     * @observable
     * @api
     */
    getLength() {
      return this.get(bc.LENGTH);
    }
    /**
     * Insert an element at the provided index.
     * @param {number} index Index.
     * @param {T} elem Element.
     * @api
     */
    insertAt(t, e) {
      if (t < 0 || t > this.getLength())
        throw new Error("Index out of bounds: " + t);
      this.unique_ && this.assertUnique_(e), this.array_.splice(t, 0, e), this.updateLength_(), this.dispatchEvent(
        new ua(Ee.ADD, e, t)
      );
    }
    /**
     * Remove the last element of the collection and return it.
     * Return `undefined` if the collection is empty.
     * @return {T|undefined} Element.
     * @api
     */
    pop() {
      return this.removeAt(this.getLength() - 1);
    }
    /**
     * Insert the provided element at the end of the collection.
     * @param {T} elem Element.
     * @return {number} New length of the collection.
     * @api
     */
    push(t) {
      this.unique_ && this.assertUnique_(t);
      const e = this.getLength();
      return this.insertAt(e, t), this.getLength();
    }
    /**
     * Remove the first occurrence of an element from the collection.
     * @param {T} elem Element.
     * @return {T|undefined} The removed element or undefined if none found.
     * @api
     */
    remove(t) {
      const e = this.array_;
      for (let n = 0, s = e.length; n < s; ++n)
        if (e[n] === t)
          return this.removeAt(n);
    }
    /**
     * Remove the element at the provided index and return it.
     * Return `undefined` if the collection does not contain this index.
     * @param {number} index Index.
     * @return {T|undefined} Value.
     * @api
     */
    removeAt(t) {
      if (t < 0 || t >= this.getLength())
        return;
      const e = this.array_[t];
      return this.array_.splice(t, 1), this.updateLength_(), this.dispatchEvent(
        /** @type {CollectionEvent<T>} */
        new ua(Ee.REMOVE, e, t)
      ), e;
    }
    /**
     * Set the element at the provided index.
     * @param {number} index Index.
     * @param {T} elem Element.
     * @api
     */
    setAt(t, e) {
      const n = this.getLength();
      if (t >= n) {
        this.insertAt(t, e);
        return;
      }
      if (t < 0)
        throw new Error("Index out of bounds: " + t);
      this.unique_ && this.assertUnique_(e, t);
      const s = this.array_[t];
      this.array_[t] = e, this.dispatchEvent(
        /** @type {CollectionEvent<T>} */
        new ua(Ee.REMOVE, s, t)
      ), this.dispatchEvent(
        /** @type {CollectionEvent<T>} */
        new ua(Ee.ADD, e, t)
      );
    }
    /**
     * @private
     */
    updateLength_() {
      this.set(bc.LENGTH, this.array_.length);
    }
    /**
     * @private
     * @param {T} elem Element.
     * @param {number} [except] Optional index to ignore.
     */
    assertUnique_(t, e) {
      for (let n = 0, s = this.array_.length; n < s; ++n)
        if (this.array_[n] === t && n !== e)
          throw new Error("Duplicate item added to a unique collection");
    }
  }
  class rs extends Ri {
    /**
     * @param {string} type Event type.
     * @param {import("./Map.js").default} map Map.
     * @param {?import("./Map.js").FrameState} [frameState] Frame state.
     */
    constructor(t, e, n) {
      super(t), this.map = e, this.frameState = n !== void 0 ? n : null;
    }
  }
  class $i extends rs {
    /**
     * @param {string} type Event type.
     * @param {import("./Map.js").default} map Map.
     * @param {EVENT} originalEvent Original event.
     * @param {boolean} [dragging] Is the map currently being dragged?
     * @param {import("./Map.js").FrameState} [frameState] Frame state.
     * @param {Array<PointerEvent>} [activePointers] Active pointers.
     */
    constructor(t, e, n, s, r, a) {
      super(t, e, r), this.originalEvent = n, this.pixel_ = null, this.coordinate_ = null, this.dragging = s !== void 0 ? s : !1, this.activePointers = a;
    }
    /**
     * The map pixel relative to the viewport corresponding to the original event.
     * @type {import("./pixel.js").Pixel}
     * @api
     */
    get pixel() {
      return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)), this.pixel_;
    }
    set pixel(t) {
      this.pixel_ = t;
    }
    /**
     * The coordinate corresponding to the original browser event.  This will be in the user
     * projection if one is set.  Otherwise it will be in the view projection.
     * @type {import("./coordinate.js").Coordinate}
     * @api
     */
    get coordinate() {
      return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)), this.coordinate_;
    }
    set coordinate(t) {
      this.coordinate_ = t;
    }
    /**
     * Prevents the default browser action.
     * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
     * @api
     * @override
     */
    preventDefault() {
      super.preventDefault(), "preventDefault" in this.originalEvent && this.originalEvent.preventDefault();
    }
    /**
     * Prevents further propagation of the current event.
     * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
     * @api
     * @override
     */
    stopPropagation() {
      super.stopPropagation(), "stopPropagation" in this.originalEvent && this.originalEvent.stopPropagation();
    }
  }
  const Gt = {
    /**
     * A true single click with no dragging and no double click. Note that this
     * event is delayed by 250 ms to ensure that it is not a double click.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
     * @api
     */
    SINGLECLICK: "singleclick",
    /**
     * A click with no dragging. A double click will fire two of this.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
     * @api
     */
    CLICK: at.CLICK,
    /**
     * A true double click, with no dragging.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
     * @api
     */
    DBLCLICK: at.DBLCLICK,
    /**
     * Triggered when a pointer is dragged.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
     * @api
     */
    POINTERDRAG: "pointerdrag",
    /**
     * Triggered when a pointer is moved. Note that on touch devices this is
     * triggered when the map is panned, so is not the same as mousemove.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
     * @api
     */
    POINTERMOVE: "pointermove",
    POINTERDOWN: "pointerdown",
    POINTERUP: "pointerup",
    POINTEROVER: "pointerover",
    POINTEROUT: "pointerout",
    POINTERENTER: "pointerenter",
    POINTERLEAVE: "pointerleave",
    POINTERCANCEL: "pointercancel"
  }, Qi = typeof navigator < "u" && typeof navigator.userAgent < "u" ? navigator.userAgent.toLowerCase() : "", hd = Qi.includes("firefox"), cd = Qi.includes("safari") && !Qi.includes("chrom"), w0 = cd && (Qi.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(Qi)), ud = Qi.includes("webkit") && !Qi.includes("edge"), Hl = Qi.includes("macintosh"), co = typeof devicePixelRatio < "u" ? devicePixelRatio : 1, Jl = typeof WorkerGlobalScope < "u" && typeof OffscreenCanvas < "u" && self instanceof WorkerGlobalScope, Ql = typeof Image < "u" && Image.prototype.decode, S0 = typeof createImageBitmap == "function", th = function() {
    let i = !1;
    try {
      const t = Object.defineProperty({}, "passive", {
        get: function() {
          i = !0;
        }
      });
      window.addEventListener("_", null, t), window.removeEventListener("_", null, t);
    } catch {
    }
    return i;
  }(), C0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    CREATE_IMAGE_BITMAP: S0,
    DEVICE_PIXEL_RATIO: co,
    FIREFOX: hd,
    IMAGE_DECODE: Ql,
    MAC: Hl,
    PASSIVE_EVENT_LISTENERS: th,
    SAFARI: cd,
    SAFARI_BUG_237906: w0,
    WEBKIT: ud,
    WORKER_OFFSCREEN_CANVAS: Jl
  }, Symbol.toStringTag, { value: "Module" })), El = {
    POINTERMOVE: "pointermove",
    POINTERDOWN: "pointerdown",
    POINTERUP: "pointerup",
    POINTEROVER: "pointerover",
    POINTEROUT: "pointerout",
    POINTERENTER: "pointerenter",
    POINTERLEAVE: "pointerleave",
    POINTERCANCEL: "pointercancel"
  };
  class R0 extends ho {
    /**
     * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
     * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
     */
    constructor(t, e) {
      super(t), this.map_ = t, this.clickTimeoutId_, this.emulateClicks_ = !1, this.dragging_ = !1, this.dragListenerKeys_ = [], this.moveTolerance_ = e === void 0 ? 1 : e, this.down_ = null;
      const n = this.map_.getViewport();
      this.activePointers_ = [], this.trackedTouches_ = {}, this.element_ = n, this.pointerdownListenerKey_ = vt(
        n,
        El.POINTERDOWN,
        this.handlePointerDown_,
        this
      ), this.originalPointerMoveEvent_, this.relayedListenerKey_ = vt(
        n,
        El.POINTERMOVE,
        this.relayMoveEvent_,
        this
      ), this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this), this.element_.addEventListener(
        at.TOUCHMOVE,
        this.boundHandleTouchMove_,
        th ? { passive: !1 } : !1
      );
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    emulateClick_(t) {
      let e = new $i(
        Gt.CLICK,
        this.map_,
        t
      );
      this.dispatchEvent(e), this.clickTimeoutId_ !== void 0 ? (clearTimeout(this.clickTimeoutId_), this.clickTimeoutId_ = void 0, e = new $i(
        Gt.DBLCLICK,
        this.map_,
        t
      ), this.dispatchEvent(e)) : this.clickTimeoutId_ = setTimeout(() => {
        this.clickTimeoutId_ = void 0;
        const n = new $i(
          Gt.SINGLECLICK,
          this.map_,
          t
        );
        this.dispatchEvent(n);
      }, 250);
    }
    /**
     * Keeps track on how many pointers are currently active.
     *
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    updateActivePointers_(t) {
      const e = t, n = e.pointerId;
      if (e.type == Gt.POINTERUP || e.type == Gt.POINTERCANCEL) {
        delete this.trackedTouches_[n];
        for (const s in this.trackedTouches_)
          if (this.trackedTouches_[s].target !== e.target) {
            delete this.trackedTouches_[s];
            break;
          }
      } else (e.type == Gt.POINTERDOWN || e.type == Gt.POINTERMOVE) && (this.trackedTouches_[n] = e);
      this.activePointers_ = Object.values(this.trackedTouches_);
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    handlePointerUp_(t) {
      this.updateActivePointers_(t);
      const e = new $i(
        Gt.POINTERUP,
        this.map_,
        t,
        void 0,
        void 0,
        this.activePointers_
      );
      this.dispatchEvent(e), this.emulateClicks_ && !e.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(t) && this.emulateClick_(this.down_), this.activePointers_.length === 0 && (this.dragListenerKeys_.forEach(Pt), this.dragListenerKeys_.length = 0, this.dragging_ = !1, this.down_ = null);
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @return {boolean} If the left mouse button was pressed.
     * @private
     */
    isMouseActionButton_(t) {
      return t.button === 0;
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    handlePointerDown_(t) {
      this.emulateClicks_ = this.activePointers_.length === 0, this.updateActivePointers_(t);
      const e = new $i(
        Gt.POINTERDOWN,
        this.map_,
        t,
        void 0,
        void 0,
        this.activePointers_
      );
      if (this.dispatchEvent(e), this.down_ = new PointerEvent(t.type, t), Object.defineProperty(this.down_, "target", {
        writable: !1,
        value: t.target
      }), this.dragListenerKeys_.length === 0) {
        const n = this.map_.getOwnerDocument();
        this.dragListenerKeys_.push(
          vt(
            n,
            Gt.POINTERMOVE,
            this.handlePointerMove_,
            this
          ),
          vt(n, Gt.POINTERUP, this.handlePointerUp_, this),
          /* Note that the listener for `pointercancel is set up on
           * `pointerEventHandler_` and not `documentPointerEventHandler_` like
           * the `pointerup` and `pointermove` listeners.
           *
           * The reason for this is the following: `TouchSource.vacuumTouches_()`
           * issues `pointercancel` events, when there was no `touchend` for a
           * `touchstart`. Now, let's say a first `touchstart` is registered on
           * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
           * But `documentPointerEventHandler_` doesn't know about the first
           * `touchstart`. If there is no `touchend` for the `touchstart`, we can
           * only receive a `touchcancel` from `pointerEventHandler_`, because it is
           * only registered there.
           */
          vt(
            this.element_,
            Gt.POINTERCANCEL,
            this.handlePointerUp_,
            this
          )
        ), this.element_.getRootNode && this.element_.getRootNode() !== n && this.dragListenerKeys_.push(
          vt(
            this.element_.getRootNode(),
            Gt.POINTERUP,
            this.handlePointerUp_,
            this
          )
        );
      }
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    handlePointerMove_(t) {
      if (this.isMoving_(t)) {
        this.updateActivePointers_(t), this.dragging_ = !0;
        const e = new $i(
          Gt.POINTERDRAG,
          this.map_,
          t,
          this.dragging_,
          void 0,
          this.activePointers_
        );
        this.dispatchEvent(e);
      }
    }
    /**
     * Wrap and relay a pointermove event.
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    relayMoveEvent_(t) {
      this.originalPointerMoveEvent_ = t;
      const e = !!(this.down_ && this.isMoving_(t));
      this.dispatchEvent(
        new $i(
          Gt.POINTERMOVE,
          this.map_,
          t,
          e
        )
      );
    }
    /**
     * Flexible handling of a `touch-action: none` css equivalent: because calling
     * `preventDefault()` on a `pointermove` event does not stop native page scrolling
     * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
     * when an interaction (currently `DragPan` handles the event.
     * @param {TouchEvent} event Event.
     * @private
     */
    handleTouchMove_(t) {
      const e = this.originalPointerMoveEvent_;
      (!e || e.defaultPrevented) && (typeof t.cancelable != "boolean" || t.cancelable === !0) && t.preventDefault();
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @return {boolean} Is moving.
     * @private
     */
    isMoving_(t) {
      return this.dragging_ || Math.abs(t.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(t.clientY - this.down_.clientY) > this.moveTolerance_;
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.relayedListenerKey_ && (Pt(this.relayedListenerKey_), this.relayedListenerKey_ = null), this.element_.removeEventListener(
        at.TOUCHMOVE,
        this.boundHandleTouchMove_
      ), this.pointerdownListenerKey_ && (Pt(this.pointerdownListenerKey_), this.pointerdownListenerKey_ = null), this.dragListenerKeys_.forEach(Pt), this.dragListenerKeys_.length = 0, this.element_ = null, super.disposeInternal();
    }
  }
  const vi = {
    /**
     * Triggered after a map frame is rendered.
     * @event module:ol/MapEvent~MapEvent#postrender
     * @api
     */
    POSTRENDER: "postrender",
    /**
     * Triggered when the map starts moving.
     * @event module:ol/MapEvent~MapEvent#movestart
     * @api
     */
    MOVESTART: "movestart",
    /**
     * Triggered after the map is moved.
     * @event module:ol/MapEvent~MapEvent#moveend
     * @api
     */
    MOVEEND: "moveend",
    /**
     * Triggered when loading of additional map data (tiles, images, features) starts.
     * @event module:ol/MapEvent~MapEvent#loadstart
     * @api
     */
    LOADSTART: "loadstart",
    /**
     * Triggered when loading of additional map data has completed.
     * @event module:ol/MapEvent~MapEvent#loadend
     * @api
     */
    LOADEND: "loadend"
  }, ae = {
    LAYERGROUP: "layergroup",
    SIZE: "size",
    TARGET: "target",
    VIEW: "view"
  }, j = {
    IDLE: 0,
    LOADING: 1,
    LOADED: 2,
    /**
     * Indicates that tile loading failed
     * @type {number}
     */
    ERROR: 3,
    EMPTY: 4
  };
  function xt(i, t) {
    if (!i)
      throw new Error(t);
  }
  const ka = 1 / 0;
  class I0 {
    /**
     * @param {function(T): number} priorityFunction Priority function.
     * @param {function(T): string} keyFunction Key function.
     */
    constructor(t, e) {
      this.priorityFunction_ = t, this.keyFunction_ = e, this.elements_ = [], this.priorities_ = [], this.queuedElements_ = {};
    }
    /**
     * FIXME empty description for jsdoc
     */
    clear() {
      this.elements_.length = 0, this.priorities_.length = 0, Dr(this.queuedElements_);
    }
    /**
     * Remove and return the highest-priority element. O(log N).
     * @return {T} Element.
     */
    dequeue() {
      const t = this.elements_, e = this.priorities_, n = t[0];
      t.length == 1 ? (t.length = 0, e.length = 0) : (t[0] = /** @type {T} */
      t.pop(), e[0] = /** @type {number} */
      e.pop(), this.siftUp_(0));
      const s = this.keyFunction_(n);
      return delete this.queuedElements_[s], n;
    }
    /**
     * Enqueue an element. O(log N).
     * @param {T} element Element.
     * @return {boolean} The element was added to the queue.
     */
    enqueue(t) {
      xt(
        !(this.keyFunction_(t) in this.queuedElements_),
        "Tried to enqueue an `element` that was already added to the queue"
      );
      const e = this.priorityFunction_(t);
      return e != ka ? (this.elements_.push(t), this.priorities_.push(e), this.queuedElements_[this.keyFunction_(t)] = !0, this.siftDown_(0, this.elements_.length - 1), !0) : !1;
    }
    /**
     * @return {number} Count.
     */
    getCount() {
      return this.elements_.length;
    }
    /**
     * Gets the index of the left child of the node at the given index.
     * @param {number} index The index of the node to get the left child for.
     * @return {number} The index of the left child.
     * @private
     */
    getLeftChildIndex_(t) {
      return t * 2 + 1;
    }
    /**
     * Gets the index of the right child of the node at the given index.
     * @param {number} index The index of the node to get the right child for.
     * @return {number} The index of the right child.
     * @private
     */
    getRightChildIndex_(t) {
      return t * 2 + 2;
    }
    /**
     * Gets the index of the parent of the node at the given index.
     * @param {number} index The index of the node to get the parent for.
     * @return {number} The index of the parent.
     * @private
     */
    getParentIndex_(t) {
      return t - 1 >> 1;
    }
    /**
     * Make this a heap. O(N).
     * @private
     */
    heapify_() {
      let t;
      for (t = (this.elements_.length >> 1) - 1; t >= 0; t--)
        this.siftUp_(t);
    }
    /**
     * @return {boolean} Is empty.
     */
    isEmpty() {
      return this.elements_.length === 0;
    }
    /**
     * @param {string} key Key.
     * @return {boolean} Is key queued.
     */
    isKeyQueued(t) {
      return t in this.queuedElements_;
    }
    /**
     * @param {T} element Element.
     * @return {boolean} Is queued.
     */
    isQueued(t) {
      return this.isKeyQueued(this.keyFunction_(t));
    }
    /**
     * @param {number} index The index of the node to move down.
     * @private
     */
    siftUp_(t) {
      const e = this.elements_, n = this.priorities_, s = e.length, r = e[t], a = n[t], o = t;
      for (; t < s >> 1; ) {
        const l = this.getLeftChildIndex_(t), h = this.getRightChildIndex_(t), c = h < s && n[h] < n[l] ? h : l;
        e[t] = e[c], n[t] = n[c], t = c;
      }
      e[t] = r, n[t] = a, this.siftDown_(o, t);
    }
    /**
     * @param {number} startIndex The index of the root.
     * @param {number} index The index of the node to move up.
     * @private
     */
    siftDown_(t, e) {
      const n = this.elements_, s = this.priorities_, r = n[e], a = s[e];
      for (; e > t; ) {
        const o = this.getParentIndex_(e);
        if (s[o] > a)
          n[e] = n[o], s[e] = s[o], e = o;
        else
          break;
      }
      n[e] = r, s[e] = a;
    }
    /**
     * FIXME empty description for jsdoc
     */
    reprioritize() {
      const t = this.priorityFunction_, e = this.elements_, n = this.priorities_;
      let s = 0;
      const r = e.length;
      let a, o, l;
      for (o = 0; o < r; ++o)
        a = e[o], l = t(a), l == ka ? delete this.queuedElements_[this.keyFunction_(a)] : (n[s] = l, e[s++] = a);
      e.length = s, n.length = s, this.heapify_();
    }
  }
  class T0 extends I0 {
    /**
     * @param {PriorityFunction} tilePriorityFunction Tile priority function.
     * @param {function(): ?} tileChangeCallback Function called on each tile change event.
     */
    constructor(t, e) {
      super(
        (n) => t.apply(null, n),
        (n) => n[0].getKey()
      ), this.boundHandleTileChange_ = this.handleTileChange.bind(this), this.tileChangeCallback_ = e, this.tilesLoading_ = 0, this.tilesLoadingKeys_ = {};
    }
    /**
     * @param {TileQueueElement} element Element.
     * @return {boolean} The element was added to the queue.
     * @override
     */
    enqueue(t) {
      const e = super.enqueue(t);
      return e && t[0].addEventListener(at.CHANGE, this.boundHandleTileChange_), e;
    }
    /**
     * @return {number} Number of tiles loading.
     */
    getTilesLoading() {
      return this.tilesLoading_;
    }
    /**
     * @param {import("./events/Event.js").default} event Event.
     * @protected
     */
    handleTileChange(t) {
      const e = (
        /** @type {import("./Tile.js").default} */
        t.target
      ), n = e.getState();
      if (n === j.LOADED || n === j.ERROR || n === j.EMPTY) {
        n !== j.ERROR && e.removeEventListener(at.CHANGE, this.boundHandleTileChange_);
        const s = e.getKey();
        s in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[s], --this.tilesLoading_), this.tileChangeCallback_();
      }
    }
    /**
     * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
     * @param {number} maxNewLoads Maximum number of new tiles to load.
     */
    loadMoreTiles(t, e) {
      let n = 0;
      for (; this.tilesLoading_ < t && n < e && this.getCount() > 0; ) {
        const s = this.dequeue()[0], r = s.getKey();
        s.getState() === j.IDLE && !(r in this.tilesLoadingKeys_) && (this.tilesLoadingKeys_[r] = !0, ++this.tilesLoading_, ++n, s.load());
      }
    }
  }
  function A0(i, t, e, n, s) {
    if (!i || !(e in i.wantedTiles) || !i.wantedTiles[e][t.getKey()])
      return ka;
    const r = i.viewState.center, a = n[0] - r[0], o = n[1] - r[1];
    return 65536 * Math.log(s) + Math.sqrt(a * a + o * o) / s;
  }
  const oe = {
    ANIMATING: 0,
    INTERACTING: 1
  }, Ze = {
    CENTER: "center",
    RESOLUTION: "resolution",
    ROTATION: "rotation"
  };
  function zt(i, t, e) {
    return Math.min(Math.max(i, t), e);
  }
  function b0(i, t, e, n, s, r) {
    const a = s - e, o = r - n;
    if (a !== 0 || o !== 0) {
      const l = ((i - e) * a + (t - n) * o) / (a * a + o * o);
      l > 1 ? (e = s, n = r) : l > 0 && (e += a * l, n += o * l);
    }
    return Ln(i, t, e, n);
  }
  function Ln(i, t, e, n) {
    const s = e - i, r = n - t;
    return s * s + r * r;
  }
  function P0(i) {
    const t = i.length;
    for (let n = 0; n < t; n++) {
      let s = n, r = Math.abs(i[n][n]);
      for (let o = n + 1; o < t; o++) {
        const l = Math.abs(i[o][n]);
        l > r && (r = l, s = o);
      }
      if (r === 0)
        return null;
      const a = i[s];
      i[s] = i[n], i[n] = a;
      for (let o = n + 1; o < t; o++) {
        const l = -i[o][n] / i[n][n];
        for (let h = n; h < t + 1; h++)
          n == h ? i[o][h] = 0 : i[o][h] += l * i[n][h];
      }
    }
    const e = new Array(t);
    for (let n = t - 1; n >= 0; n--) {
      e[n] = i[n][t] / i[n][n];
      for (let s = n - 1; s >= 0; s--)
        i[s][t] -= i[s][n] * e[n];
    }
    return e;
  }
  function Pc(i) {
    return i * 180 / Math.PI;
  }
  function Vi(i) {
    return i * Math.PI / 180;
  }
  function _s(i, t) {
    const e = i % t;
    return e * t < 0 ? e + t : e;
  }
  function be(i, t, e) {
    return i + e * (t - i);
  }
  function eh(i, t) {
    const e = Math.pow(10, t);
    return Math.round(i * e) / e;
  }
  function da(i, t) {
    return Math.floor(eh(i, t));
  }
  function fa(i, t) {
    return Math.ceil(eh(i, t));
  }
  function Ml(i, t, e) {
    if (i >= t && i < e)
      return i;
    const n = e - t;
    return ((i - t) % n + n) % n + t;
  }
  function Lc(i, t, e) {
    return (
      /**
       * @param {import("./coordinate.js").Coordinate|undefined} center Center.
       * @param {number|undefined} resolution Resolution.
       * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
       * @param {boolean} [isMoving] True if an interaction or animation is in progress.
       * @param {Array<number>} [centerShift] Shift between map center and viewport center.
       * @return {import("./coordinate.js").Coordinate|undefined} Center.
       */
      function(n, s, r, a, o) {
        if (!n)
          return;
        if (!s && !t)
          return n;
        const l = t ? 0 : r[0] * s, h = t ? 0 : r[1] * s, c = o ? o[0] : 0, u = o ? o[1] : 0;
        let d = i[0] + l / 2 + c, g = i[2] - l / 2 + c, _ = i[1] + h / 2 + u, y = i[3] - h / 2 + u;
        d > g && (d = (g + d) / 2, g = d), _ > y && (_ = (y + _) / 2, y = _);
        let E = zt(n[0], d, g), M = zt(n[1], _, y);
        if (a && e && s) {
          const w = 30 * s;
          E += -w * Math.log(1 + Math.max(0, d - n[0]) / w) + w * Math.log(1 + Math.max(0, n[0] - g) / w), M += -w * Math.log(1 + Math.max(0, _ - n[1]) / w) + w * Math.log(1 + Math.max(0, n[1] - y) / w);
        }
        return [E, M];
      }
    );
  }
  function L0(i) {
    return i;
  }
  const Zt = {
    UNKNOWN: 0,
    INTERSECTING: 1,
    ABOVE: 2,
    RIGHT: 4,
    BELOW: 8,
    LEFT: 16
  };
  function xl(i) {
    const t = Pe();
    for (let e = 0, n = i.length; e < n; ++e)
      On(t, i[e]);
    return t;
  }
  function O0(i, t, e) {
    const n = Math.min.apply(null, i), s = Math.min.apply(null, t), r = Math.max.apply(null, i), a = Math.max.apply(null, t);
    return Le(n, s, r, a, e);
  }
  function uo(i, t, e) {
    return e ? (e[0] = i[0] - t, e[1] = i[1] - t, e[2] = i[2] + t, e[3] = i[3] + t, e) : [
      i[0] - t,
      i[1] - t,
      i[2] + t,
      i[3] + t
    ];
  }
  function ih(i, t) {
    return t ? (t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t) : i.slice();
  }
  function an(i, t, e) {
    let n, s;
    return t < i[0] ? n = i[0] - t : i[2] < t ? n = t - i[2] : n = 0, e < i[1] ? s = i[1] - e : i[3] < e ? s = e - i[3] : s = 0, n * n + s * s;
  }
  function Fn(i, t) {
    return fo(i, t[0], t[1]);
  }
  function Rn(i, t) {
    return i[0] <= t[0] && t[2] <= i[2] && i[1] <= t[1] && t[3] <= i[3];
  }
  function fo(i, t, e) {
    return i[0] <= t && t <= i[2] && i[1] <= e && e <= i[3];
  }
  function Ga(i, t) {
    const e = i[0], n = i[1], s = i[2], r = i[3], a = t[0], o = t[1];
    let l = Zt.UNKNOWN;
    return a < e ? l = l | Zt.LEFT : a > s && (l = l | Zt.RIGHT), o < n ? l = l | Zt.BELOW : o > r && (l = l | Zt.ABOVE), l === Zt.UNKNOWN && (l = Zt.INTERSECTING), l;
  }
  function Pe() {
    return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  }
  function Le(i, t, e, n, s) {
    return s ? (s[0] = i, s[1] = t, s[2] = e, s[3] = n, s) : [i, t, e, n];
  }
  function Ii(i) {
    return Le(1 / 0, 1 / 0, -1 / 0, -1 / 0, i);
  }
  function nh(i, t) {
    const e = i[0], n = i[1];
    return Le(e, n, e, n, t);
  }
  function N0(i, t) {
    const e = Ii(t);
    return sh(e, i);
  }
  function go(i, t, e, n, s) {
    const r = Ii(s);
    return rh(r, i, t, e, n);
  }
  function F0(i, t) {
    const e = Ii(t);
    return dd(e, i);
  }
  function As(i, t) {
    return i[0] == t[0] && i[2] == t[2] && i[1] == t[1] && i[3] == t[3];
  }
  function D0(i, t, e) {
    return Math.abs(i[0] - t[0]) < e && Math.abs(i[2] - t[2]) < e && Math.abs(i[1] - t[1]) < e && Math.abs(i[3] - t[3]) < e;
  }
  function mo(i, t) {
    return t[0] < i[0] && (i[0] = t[0]), t[2] > i[2] && (i[2] = t[2]), t[1] < i[1] && (i[1] = t[1]), t[3] > i[3] && (i[3] = t[3]), i;
  }
  function On(i, t) {
    t[0] < i[0] && (i[0] = t[0]), t[0] > i[2] && (i[2] = t[0]), t[1] < i[1] && (i[1] = t[1]), t[1] > i[3] && (i[3] = t[1]);
  }
  function sh(i, t) {
    for (let e = 0, n = t.length; e < n; ++e)
      On(i, t[e]);
    return i;
  }
  function rh(i, t, e, n, s) {
    for (; e < n; e += s)
      fd(i, t[e], t[e + 1]);
    return i;
  }
  function dd(i, t) {
    for (let e = 0, n = t.length; e < n; ++e)
      sh(i, t[e]);
    return i;
  }
  function fd(i, t, e) {
    i[0] = Math.min(i[0], t), i[1] = Math.min(i[1], e), i[2] = Math.max(i[2], t), i[3] = Math.max(i[3], e);
  }
  function _o(i, t) {
    let e;
    return e = t(Gr(i)), e || (e = t(zr(i)), e) || (e = t($r(i)), e) || (e = t(on(i)), e) ? e : !1;
  }
  function xr(i) {
    let t = 0;
    return zs(i) || (t = Mt(i) * te(i)), t;
  }
  function Gr(i) {
    return [i[0], i[1]];
  }
  function zr(i) {
    return [i[2], i[1]];
  }
  function Si(i) {
    return [(i[0] + i[2]) / 2, (i[1] + i[3]) / 2];
  }
  function gd(i, t) {
    let e;
    if (t === "bottom-left")
      e = Gr(i);
    else if (t === "bottom-right")
      e = zr(i);
    else if (t === "top-left")
      e = on(i);
    else if (t === "top-right")
      e = $r(i);
    else
      throw new Error("Invalid corner");
    return e;
  }
  function k0(i, t) {
    const e = Math.min(i[0], t[0]), n = Math.min(i[1], t[1]), s = Math.max(i[2], t[2]), r = Math.max(i[3], t[3]);
    return (s - e) * (r - n);
  }
  function za(i, t, e, n, s) {
    const [r, a, o, l, h, c, u, d] = ah(
      i,
      t,
      e,
      n
    );
    return Le(
      Math.min(r, o, h, u),
      Math.min(a, l, c, d),
      Math.max(r, o, h, u),
      Math.max(a, l, c, d),
      s
    );
  }
  function ah(i, t, e, n) {
    const s = t * n[0] / 2, r = t * n[1] / 2, a = Math.cos(e), o = Math.sin(e), l = s * a, h = s * o, c = r * a, u = r * o, d = i[0], g = i[1];
    return [
      d - l + u,
      g - h - c,
      d - l - u,
      g - h + c,
      d + l - u,
      g + h + c,
      d + l + u,
      g + h - c,
      d - l + u,
      g - h - c
    ];
  }
  function te(i) {
    return i[3] - i[1];
  }
  function G0(i, t) {
    const e = Mi(i, t);
    return xr(e);
  }
  function Mi(i, t, e) {
    const n = e || Pe();
    return he(i, t) ? (i[0] > t[0] ? n[0] = i[0] : n[0] = t[0], i[1] > t[1] ? n[1] = i[1] : n[1] = t[1], i[2] < t[2] ? n[2] = i[2] : n[2] = t[2], i[3] < t[3] ? n[3] = i[3] : n[3] = t[3]) : Ii(n), n;
  }
  function z0(i) {
    return Mt(i) + te(i);
  }
  function $0(i) {
    return [i[2] - i[0], i[3] - i[1]];
  }
  function on(i) {
    return [i[0], i[3]];
  }
  function $r(i) {
    return [i[2], i[3]];
  }
  function Mt(i) {
    return i[2] - i[0];
  }
  function he(i, t) {
    return i[0] <= t[2] && i[2] >= t[0] && i[1] <= t[3] && i[3] >= t[1];
  }
  function zs(i) {
    return i[2] < i[0] || i[3] < i[1];
  }
  function md(i, t) {
    return t ? (t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t) : i;
  }
  function U0(i, t) {
    const e = (i[2] - i[0]) / 2 * (t - 1), n = (i[3] - i[1]) / 2 * (t - 1);
    i[0] -= e, i[2] += e, i[1] -= n, i[3] += n;
  }
  function _d(i, t, e) {
    let n = !1;
    const s = Ga(i, t), r = Ga(i, e);
    if (s === Zt.INTERSECTING || r === Zt.INTERSECTING)
      n = !0;
    else {
      const a = i[0], o = i[1], l = i[2], h = i[3], c = t[0], u = t[1], d = e[0], g = e[1], _ = (g - u) / (d - c);
      let y, E;
      r & Zt.ABOVE && !(s & Zt.ABOVE) && (y = d - (g - h) / _, n = y >= a && y <= l), !n && r & Zt.RIGHT && !(s & Zt.RIGHT) && (E = g - (d - l) * _, n = E >= o && E <= h), !n && r & Zt.BELOW && !(s & Zt.BELOW) && (y = d - (g - o) / _, n = y >= a && y <= l), !n && r & Zt.LEFT && !(s & Zt.LEFT) && (E = g - (d - a) * _, n = E >= o && E <= h);
    }
    return n;
  }
  function pd(i, t, e, n) {
    if (zs(i))
      return Ii(e);
    let s = [];
    if (n > 1) {
      const o = i[2] - i[0], l = i[3] - i[1];
      for (let h = 0; h < n; ++h)
        s.push(
          i[0] + o * h / n,
          i[1],
          i[2],
          i[1] + l * h / n,
          i[2] - o * h / n,
          i[3],
          i[0],
          i[3] - l * h / n
        );
    } else
      s = [
        i[0],
        i[1],
        i[2],
        i[1],
        i[2],
        i[3],
        i[0],
        i[3]
      ];
    t(s, s, 2);
    const r = [], a = [];
    for (let o = 0, l = s.length; o < l; o += 2)
      r.push(s[o]), a.push(s[o + 1]);
    return O0(r, a, e);
  }
  function oh(i, t) {
    const e = t.getExtent(), n = Si(i);
    if (t.canWrapX() && (n[0] < e[0] || n[0] >= e[2])) {
      const s = Mt(e), a = Math.floor(
        (n[0] - e[0]) / s
      ) * s;
      i[0] -= a, i[2] -= a;
    }
    return i;
  }
  function lh(i, t, e) {
    if (t.canWrapX()) {
      const n = t.getExtent();
      if (!isFinite(i[0]) || !isFinite(i[2]))
        return [[n[0], i[1], n[2], i[3]]];
      oh(i, t);
      const s = Mt(n);
      if (Mt(i) > s && !e)
        return [[n[0], i[1], n[2], i[3]]];
      if (i[0] < n[0])
        return [
          [i[0] + s, i[1], n[2], i[3]],
          [n[0], i[1], i[2], i[3]]
        ];
      if (i[2] > n[2])
        return [
          [i[0], i[1], n[2], i[3]],
          [n[0], i[1], i[2] - s, i[3]]
        ];
    }
    return [i];
  }
  const B0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    applyTransform: pd,
    approximatelyEquals: D0,
    boundingExtent: xl,
    buffer: uo,
    clone: ih,
    closestSquaredDistanceXY: an,
    containsCoordinate: Fn,
    containsExtent: Rn,
    containsXY: fo,
    coordinateRelationship: Ga,
    createEmpty: Pe,
    createOrUpdate: Le,
    createOrUpdateEmpty: Ii,
    createOrUpdateFromCoordinate: nh,
    createOrUpdateFromCoordinates: N0,
    createOrUpdateFromFlatCoordinates: go,
    createOrUpdateFromRings: F0,
    equals: As,
    extend: mo,
    extendCoordinate: On,
    extendCoordinates: sh,
    extendFlatCoordinates: rh,
    extendRings: dd,
    extendXY: fd,
    forEachCorner: _o,
    getArea: xr,
    getBottomLeft: Gr,
    getBottomRight: zr,
    getCenter: Si,
    getCorner: gd,
    getEnlargedArea: k0,
    getForViewAndSize: za,
    getHeight: te,
    getIntersection: Mi,
    getIntersectionArea: G0,
    getMargin: z0,
    getRotatedViewport: ah,
    getSize: $0,
    getTopLeft: on,
    getTopRight: $r,
    getWidth: Mt,
    intersects: he,
    intersectsSegment: _d,
    isEmpty: zs,
    returnOrUpdate: md,
    scaleFromCenter: U0,
    wrapAndSliceX: lh,
    wrapX: oh
  }, Symbol.toStringTag, { value: "Module" }));
  function W0(i, t) {
    return i[0] += +t[0], i[1] += +t[1], i;
  }
  function $a(i, t) {
    let e = !0;
    for (let n = i.length - 1; n >= 0; --n)
      if (i[n] != t[n]) {
        e = !1;
        break;
      }
    return e;
  }
  function hh(i, t) {
    const e = Math.cos(t), n = Math.sin(t), s = i[0] * e - i[1] * n, r = i[1] * e + i[0] * n;
    return i[0] = s, i[1] = r, i;
  }
  function X0(i, t) {
    return i[0] *= t, i[1] *= t, i;
  }
  function yd(i, t) {
    if (t.canWrapX()) {
      const e = Mt(t.getExtent()), n = vd(i, t, e);
      n && (i[0] -= n * e);
    }
    return i;
  }
  function vd(i, t, e) {
    const n = t.getExtent();
    let s = 0;
    return t.canWrapX() && (i[0] < n[0] || i[0] > n[2]) && (e = e || Mt(n), s = Math.floor(
      (i[0] - n[0]) / e
    )), s;
  }
  function Ed(i) {
    return Math.pow(i, 3);
  }
  function $s(i) {
    return 1 - Ed(1 - i);
  }
  function Y0(i) {
    return 3 * i * i - 2 * i * i * i;
  }
  function Z0(i) {
    return i;
  }
  const q0 = 63710088e-1;
  function Oc(i, t, e) {
    e = e || q0;
    const n = Vi(i[1]), s = Vi(t[1]), r = (s - n) / 2, a = Vi(t[0] - i[0]) / 2, o = Math.sin(r) * Math.sin(r) + Math.sin(a) * Math.sin(a) * Math.cos(n) * Math.cos(s);
    return 2 * e * Math.atan2(Math.sqrt(o), Math.sqrt(1 - o));
  }
  function Md(...i) {
    console.warn(...i);
  }
  const ch = {
    // use the radius of the Normal sphere
    radians: 6370997 / (2 * Math.PI),
    degrees: 2 * Math.PI * 6370997 / 360,
    ft: 0.3048,
    m: 1,
    "us-ft": 1200 / 3937
  };
  let po = class {
    /**
     * @param {Options} options Projection options.
     */
    constructor(t) {
      this.code_ = t.code, this.units_ = /** @type {import("./Units.js").Units} */
      t.units, this.extent_ = t.extent !== void 0 ? t.extent : null, this.worldExtent_ = t.worldExtent !== void 0 ? t.worldExtent : null, this.axisOrientation_ = t.axisOrientation !== void 0 ? t.axisOrientation : "enu", this.global_ = t.global !== void 0 ? t.global : !1, this.canWrapX_ = !!(this.global_ && this.extent_), this.getPointResolutionFunc_ = t.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = t.metersPerUnit;
    }
    /**
     * @return {boolean} The projection is suitable for wrapping the x-axis
     */
    canWrapX() {
      return this.canWrapX_;
    }
    /**
     * Get the code for this projection, e.g. 'EPSG:4326'.
     * @return {string} Code.
     * @api
     */
    getCode() {
      return this.code_;
    }
    /**
     * Get the validity extent for this projection.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getExtent() {
      return this.extent_;
    }
    /**
     * Get the units of this projection.
     * @return {import("./Units.js").Units} Units.
     * @api
     */
    getUnits() {
      return this.units_;
    }
    /**
     * Get the amount of meters per unit of this projection.  If the projection is
     * not configured with `metersPerUnit` or a units identifier, the return is
     * `undefined`.
     * @return {number|undefined} Meters.
     * @api
     */
    getMetersPerUnit() {
      return this.metersPerUnit_ || ch[this.units_];
    }
    /**
     * Get the world extent for this projection.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getWorldExtent() {
      return this.worldExtent_;
    }
    /**
     * Get the axis orientation of this projection.
     * Example values are:
     * enu - the default easting, northing, elevation.
     * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
     *     or south orientated transverse mercator.
     * wnu - westing, northing, up - some planetary coordinate systems have
     *     "west positive" coordinate systems
     * @return {string} Axis orientation.
     * @api
     */
    getAxisOrientation() {
      return this.axisOrientation_;
    }
    /**
     * Is this projection a global projection which spans the whole world?
     * @return {boolean} Whether the projection is global.
     * @api
     */
    isGlobal() {
      return this.global_;
    }
    /**
     * Set if the projection is a global projection which spans the whole world
     * @param {boolean} global Whether the projection is global.
     * @api
     */
    setGlobal(t) {
      this.global_ = t, this.canWrapX_ = !!(t && this.extent_);
    }
    /**
     * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
     */
    getDefaultTileGrid() {
      return this.defaultTileGrid_;
    }
    /**
     * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
     */
    setDefaultTileGrid(t) {
      this.defaultTileGrid_ = t;
    }
    /**
     * Set the validity extent for this projection.
     * @param {import("../extent.js").Extent} extent Extent.
     * @api
     */
    setExtent(t) {
      this.extent_ = t, this.canWrapX_ = !!(this.global_ && t);
    }
    /**
     * Set the world extent for this projection.
     * @param {import("../extent.js").Extent} worldExtent World extent
     *     [minlon, minlat, maxlon, maxlat].
     * @api
     */
    setWorldExtent(t) {
      this.worldExtent_ = t;
    }
    /**
     * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
     * for this projection.
     * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
     * @api
     */
    setGetPointResolution(t) {
      this.getPointResolutionFunc_ = t;
    }
    /**
     * Get the custom point resolution function for this projection (if set).
     * @return {GetPointResolution|undefined} The custom point
     * resolution function (if set).
     */
    getPointResolutionFunc() {
      return this.getPointResolutionFunc_;
    }
  };
  const Ur = 6378137, cs = Math.PI * Ur, K0 = [-cs, -cs, cs, cs], V0 = [-180, -85, 180, 85], ga = Ur * Math.log(Math.tan(Math.PI / 2));
  class Hn extends po {
    /**
     * @param {string} code Code.
     */
    constructor(t) {
      super({
        code: t,
        units: "m",
        extent: K0,
        global: !0,
        worldExtent: V0,
        getPointResolution: function(e, n) {
          return e / Math.cosh(n[1] / Ur);
        }
      });
    }
  }
  const Nc = [
    new Hn("EPSG:3857"),
    new Hn("EPSG:102100"),
    new Hn("EPSG:102113"),
    new Hn("EPSG:900913"),
    new Hn("http://www.opengis.net/def/crs/EPSG/0/3857"),
    new Hn("http://www.opengis.net/gml/srs/epsg.xml#3857")
  ];
  function j0(i, t, e, n) {
    const s = i.length;
    e = e > 1 ? e : 2, n = n ?? e, t === void 0 && (e > 2 ? t = i.slice() : t = new Array(s));
    for (let r = 0; r < s; r += n) {
      t[r] = cs * i[r] / 180;
      let a = Ur * Math.log(Math.tan(Math.PI * (+i[r + 1] + 90) / 360));
      a > ga ? a = ga : a < -ga && (a = -ga), t[r + 1] = a;
    }
    return t;
  }
  function H0(i, t, e, n) {
    const s = i.length;
    e = e > 1 ? e : 2, n = n ?? e, t === void 0 && (e > 2 ? t = i.slice() : t = new Array(s));
    for (let r = 0; r < s; r += n)
      t[r] = 180 * i[r] / cs, t[r + 1] = 360 * Math.atan(Math.exp(i[r + 1] / Ur)) / Math.PI - 90;
    return t;
  }
  const J0 = 6378137, Fc = [-180, -90, 180, 90], Q0 = Math.PI * J0 / 180;
  class xn extends po {
    /**
     * @param {string} code Code.
     * @param {string} [axisOrientation] Axis orientation.
     */
    constructor(t, e) {
      super({
        code: t,
        units: "degrees",
        extent: Fc,
        axisOrientation: e,
        global: !0,
        metersPerUnit: Q0,
        worldExtent: Fc
      });
    }
  }
  const Dc = [
    new xn("CRS:84"),
    new xn("EPSG:4326", "neu"),
    new xn("urn:ogc:def:crs:OGC:1.3:CRS84"),
    new xn("urn:ogc:def:crs:OGC:2:84"),
    new xn("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
    new xn("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
    new xn("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
  ];
  let wl = {};
  function Aa(i) {
    return wl[i] || wl[i.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
  }
  function tm(i, t) {
    wl[i] = t;
  }
  let ps = {};
  function Dn(i, t, e) {
    const n = i.getCode(), s = t.getCode();
    n in ps || (ps[n] = {}), ps[n][s] = e;
  }
  function ba(i, t) {
    return i in ps && t in ps[i] ? ps[i][t] : null;
  }
  const Ua = 0.9996, ze = 669438e-8, yo = ze * ze, vo = yo * ze, In = ze / (1 - ze), kc = Math.sqrt(1 - ze), bs = (1 - kc) / (1 + kc), xd = bs * bs, uh = xd * bs, dh = uh * bs, wd = dh * bs, Sd = 1 - ze / 4 - 3 * yo / 64 - 5 * vo / 256, em = 3 * ze / 8 + 3 * yo / 32 + 45 * vo / 1024, im = 15 * yo / 256 + 45 * vo / 1024, nm = 35 * vo / 3072, sm = 3 / 2 * bs - 27 / 32 * uh + 269 / 512 * wd, rm = 21 / 16 * xd - 55 / 32 * dh, am = 151 / 96 * uh - 417 / 128 * wd, om = 1097 / 512 * dh, Ba = 6378137;
  function lm(i, t, e) {
    const n = i - 5e5, a = (e.north ? t : t - 1e7) / Ua / (Ba * Sd), o = a + sm * Math.sin(2 * a) + rm * Math.sin(4 * a) + am * Math.sin(6 * a) + om * Math.sin(8 * a), l = Math.sin(o), h = l * l, c = Math.cos(o), u = l / c, d = u * u, g = d * d, _ = 1 - ze * h, y = Math.sqrt(1 - ze * h), E = Ba / y, M = (1 - ze) / _, w = In * c ** 2, R = w * w, S = n / (E * Ua), C = S * S, T = C * S, L = T * S, A = L * S, O = A * S, $ = o - u / M * (C / 2 - L / 24 * (5 + 3 * d + 10 * w - 4 * R - 9 * In)) + O / 720 * (61 + 90 * d + 298 * w + 45 * g - 252 * In - 3 * R);
    let q = (S - T / 6 * (1 + 2 * d + w) + A / 120 * (5 - 2 * w + 28 * d - 3 * R + 8 * In + 24 * g)) / c;
    return q = Ml(
      q + Vi(Cd(e.number)),
      -Math.PI,
      Math.PI
    ), [Pc(q), Pc($)];
  }
  const Gc = -80, zc = 84, hm = -180, cm = 180;
  function um(i, t, e) {
    i = Ml(i, hm, cm), t < Gc ? t = Gc : t > zc && (t = zc);
    const n = Vi(t), s = Math.sin(n), r = Math.cos(n), a = s / r, o = a * a, l = o * o, h = Vi(i), c = Cd(e.number), u = Vi(c), d = Ba / Math.sqrt(1 - ze * s ** 2), g = In * r ** 2, _ = r * Ml(h - u, -Math.PI, Math.PI), y = _ * _, E = y * _, M = E * _, w = M * _, R = w * _, S = Ba * (Sd * n - em * Math.sin(2 * n) + im * Math.sin(4 * n) - nm * Math.sin(6 * n)), C = Ua * d * (_ + E / 6 * (1 - o + g) + w / 120 * (5 - 18 * o + l + 72 * g - 58 * In)) + 5e5;
    let T = Ua * (S + d * a * (y / 2 + M / 24 * (5 - o + 9 * g + 4 * g ** 2) + R / 720 * (61 - 58 * o + l + 600 * g - 330 * In)));
    return e.north || (T += 1e7), [C, T];
  }
  function Cd(i) {
    return (i - 1) * 6 - 180 + 3;
  }
  const dm = [
    /^EPSG:(\d+)$/,
    /^urn:ogc:def:crs:EPSG::(\d+)$/,
    /^http:\/\/www\.opengis\.net\/def\/crs\/EPSG\/0\/(\d+)$/
  ];
  function Rd(i) {
    let t = 0;
    for (const s of dm) {
      const r = i.match(s);
      if (r) {
        t = parseInt(r[1]);
        break;
      }
    }
    if (!t)
      return null;
    let e = 0, n = !1;
    return t > 32700 && t < 32761 ? e = t - 32700 : t > 32600 && t < 32661 && (n = !0, e = t - 32600), e ? { number: e, north: n } : null;
  }
  function $c(i, t) {
    return function(e, n, s, r) {
      const a = e.length;
      s = s > 1 ? s : 2, r = r ?? s, n || (s > 2 ? n = e.slice() : n = new Array(a));
      for (let o = 0; o < a; o += r) {
        const l = e[o], h = e[o + 1], c = i(l, h, t);
        n[o] = c[0], n[o + 1] = c[1];
      }
      return n;
    };
  }
  function fm(i) {
    return Rd(i) ? new po({ code: i, units: "m" }) : null;
  }
  function gm(i) {
    const t = Rd(i.getCode());
    return t ? {
      forward: $c(um, t),
      inverse: $c(lm, t)
    } : null;
  }
  const mm = [gm], _m = [fm];
  let Sl = !0;
  function pm(i) {
    Sl = !1;
  }
  function fh(i, t) {
    if (t !== void 0) {
      for (let e = 0, n = i.length; e < n; ++e)
        t[e] = i[e];
      t = t;
    } else
      t = i.slice();
    return t;
  }
  function Wa(i) {
    tm(i.getCode(), i), Dn(i, i, fh);
  }
  function ym(i) {
    i.forEach(Wa);
  }
  function At(i) {
    if (typeof i != "string")
      return i;
    const t = Aa(i);
    if (t)
      return t;
    for (const e of _m) {
      const n = e(i);
      if (n)
        return n;
    }
    return null;
  }
  function Cl(i, t, e, n) {
    i = At(i);
    let s;
    const r = i.getPointResolutionFunc();
    if (r)
      s = r(t, e);
    else {
      const a = i.getUnits();
      if (a == "degrees" || n == "degrees")
        s = t;
      else {
        const o = mh(
          i,
          At("EPSG:4326")
        );
        if (!o && a !== "degrees")
          s = t * i.getMetersPerUnit();
        else {
          let h = [
            e[0] - t / 2,
            e[1],
            e[0] + t / 2,
            e[1],
            e[0],
            e[1] - t / 2,
            e[0],
            e[1] + t / 2
          ];
          h = o(h, h, 2);
          const c = Oc(h.slice(0, 2), h.slice(2, 4)), u = Oc(h.slice(4, 6), h.slice(6, 8));
          s = (c + u) / 2;
        }
        const l = i.getMetersPerUnit();
        l !== void 0 && (s /= l);
      }
    }
    return s;
  }
  function Rl(i) {
    ym(i), i.forEach(function(t) {
      i.forEach(function(e) {
        t !== e && Dn(t, e, fh);
      });
    });
  }
  function vm(i, t, e, n) {
    i.forEach(function(s) {
      t.forEach(function(r) {
        Dn(s, r, e), Dn(r, s, n);
      });
    });
  }
  function gh(i, t) {
    return i ? typeof i == "string" ? At(i) : (
      /** @type {Projection} */
      i
    ) : At(t);
  }
  function Il(i) {
    return (
      /**
       * @param {Array<number>} input Input.
       * @param {Array<number>} [output] Output.
       * @param {number} [dimension] Dimensions that should be transformed.
       * @param {number} [stride] Stride.
       * @return {Array<number>} Output.
       */
      function(t, e, n, s) {
        const r = t.length;
        n = n !== void 0 ? n : 2, s = s ?? n, e = e !== void 0 ? e : new Array(r);
        for (let a = 0; a < r; a += s) {
          const o = i(t.slice(a, a + n)), l = o.length;
          for (let h = 0, c = s; h < c; ++h)
            e[a + h] = h >= l ? t[a + h] : o[h];
        }
        return e;
      }
    );
  }
  function Em(i, t, e, n) {
    const s = At(i), r = At(t);
    Dn(
      s,
      r,
      Il(e)
    ), Dn(
      r,
      s,
      Il(n)
    );
  }
  function dr(i, t) {
    if (i === t)
      return !0;
    const e = i.getUnits() === t.getUnits();
    return (i.getCode() === t.getCode() || mh(i, t) === fh) && e;
  }
  function mh(i, t) {
    const e = i.getCode(), n = t.getCode();
    let s = ba(e, n);
    if (s)
      return s;
    let r = null, a = null;
    for (const l of mm)
      r || (r = l(i)), a || (a = l(t));
    if (!r && !a)
      return null;
    const o = "EPSG:4326";
    if (a)
      if (r)
        s = Zo(
          r.inverse,
          a.forward
        );
      else {
        const l = ba(e, o);
        l && (s = Zo(
          l,
          a.forward
        ));
      }
    else {
      const l = ba(o, n);
      l && (s = Zo(
        r.inverse,
        l
      ));
    }
    return s && (Wa(i), Wa(t), Dn(i, t, s)), s;
  }
  function Zo(i, t) {
    return function(e, n, s, r) {
      return n = i(e, n, s, r), t(n, n, s, r);
    };
  }
  function Ps(i, t) {
    const e = At(i), n = At(t);
    return mh(e, n);
  }
  function Id(i, t, e) {
    const n = Ps(t, e);
    if (!n) {
      const s = At(t).getCode(), r = At(e).getCode();
      throw new Error(
        `No transform available between ${s} and ${r}`
      );
    }
    return n(i, void 0, i.length);
  }
  function Mm(i, t, e, n) {
    const s = Ps(t, e);
    return pd(i, s, void 0, n);
  }
  function Tl(i, t) {
    return i;
  }
  function pi(i, t) {
    return Sl && !$a(i, [0, 0]) && i[0] >= -180 && i[0] <= 180 && i[1] >= -90 && i[1] <= 90 && (Sl = !1, Md(
      "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
    )), i;
  }
  function Td(i, t) {
    return i;
  }
  function Wi(i, t) {
    return i;
  }
  function Uc(i, t, e) {
    return function(n) {
      let s, r;
      if (i.canWrapX()) {
        const a = i.getExtent(), o = Mt(a);
        n = n.slice(0), r = vd(n, i, o), r && (n[0] = n[0] - r * o), n[0] = zt(n[0], a[0], a[2]), n[1] = zt(n[1], a[1], a[3]), s = e(n);
      } else
        s = e(n);
      return r && t.canWrapX() && (s[0] += r * Mt(t.getExtent())), s;
    };
  }
  function xm() {
    Rl(Nc), Rl(Dc), vm(
      Dc,
      Nc,
      j0,
      H0
    );
  }
  xm();
  const wm = new Array(6);
  function $e() {
    return [1, 0, 0, 1, 0, 0];
  }
  function Ad(i, t) {
    const e = i[0], n = i[1], s = i[2], r = i[3], a = i[4], o = i[5], l = t[0], h = t[1], c = t[2], u = t[3], d = t[4], g = t[5];
    return i[0] = e * l + s * h, i[1] = n * l + r * h, i[2] = e * c + s * u, i[3] = n * c + r * u, i[4] = e * d + s * g + a, i[5] = n * d + r * g + o, i;
  }
  function Sm(i, t, e, n, s, r, a) {
    return i[0] = t, i[1] = e, i[2] = n, i[3] = s, i[4] = r, i[5] = a, i;
  }
  function Cm(i, t) {
    return i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[4] = t[4], i[5] = t[5], i;
  }
  function Xt(i, t) {
    const e = t[0], n = t[1];
    return t[0] = i[0] * e + i[2] * n + i[4], t[1] = i[1] * e + i[3] * n + i[5], t;
  }
  function Rm(i, t, e) {
    return Ad(i, Sm(wm, t, 0, 0, e, 0, 0));
  }
  function Ci(i, t, e, n, s, r, a, o) {
    const l = Math.sin(r), h = Math.cos(r);
    return i[0] = n * h, i[1] = s * l, i[2] = -n * l, i[3] = s * h, i[4] = a * n * h - o * n * l + t, i[5] = a * s * l + o * s * h + e, i;
  }
  function bd(i, t) {
    const e = Im(t);
    xt(e !== 0, "Transformation matrix cannot be inverted");
    const n = t[0], s = t[1], r = t[2], a = t[3], o = t[4], l = t[5];
    return i[0] = a / e, i[1] = -s / e, i[2] = -r / e, i[3] = n / e, i[4] = (r * l - a * o) / e, i[5] = -(n * l - s * o) / e, i;
  }
  function Im(i) {
    return i[0] * i[3] - i[1] * i[2];
  }
  const Bc = [1e6, 1e6, 1e6, 1e6, 2, 2];
  function Tm(i) {
    return "matrix(" + i.map(
      (e, n) => Math.round(e * Bc[n]) / Bc[n]
    ).join(", ") + ")";
  }
  function ji(i, t, e, n, s, r, a) {
    r = r || [], a = a || 2;
    let o = 0;
    for (let l = t; l < e; l += n) {
      const h = i[l], c = i[l + 1];
      r[o++] = s[0] * h + s[2] * c + s[4], r[o++] = s[1] * h + s[3] * c + s[5];
      for (let u = 2; u < a; u++)
        r[o++] = i[l + u];
    }
    return r && r.length != o && (r.length = o), r;
  }
  function _h(i, t, e, n, s, r, a) {
    a = a || [];
    const o = Math.cos(s), l = Math.sin(s), h = r[0], c = r[1];
    let u = 0;
    for (let d = t; d < e; d += n) {
      const g = i[d] - h, _ = i[d + 1] - c;
      a[u++] = h + g * o - _ * l, a[u++] = c + g * l + _ * o;
      for (let y = d + 2; y < d + n; ++y)
        a[u++] = i[y];
    }
    return a && a.length != u && (a.length = u), a;
  }
  function Am(i, t, e, n, s, r, a, o) {
    o = o || [];
    const l = a[0], h = a[1];
    let c = 0;
    for (let u = t; u < e; u += n) {
      const d = i[u] - l, g = i[u + 1] - h;
      o[c++] = l + s * d, o[c++] = h + r * g;
      for (let _ = u + 2; _ < u + n; ++_)
        o[c++] = i[_];
    }
    return o && o.length != c && (o.length = c), o;
  }
  function bm(i, t, e, n, s, r, a) {
    a = a || [];
    let o = 0;
    for (let l = t; l < e; l += n) {
      a[o++] = i[l] + s, a[o++] = i[l + 1] + r;
      for (let h = l + 2; h < l + n; ++h)
        a[o++] = i[h];
    }
    return a && a.length != o && (a.length = o), a;
  }
  const Wc = $e(), Pm = [NaN, NaN];
  class Eo extends Qe {
    constructor() {
      super(), this.extent_ = Pe(), this.extentRevision_ = -1, this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = 0, this.simplifyTransformedInternal = ld(
        (t, e, n) => {
          if (!n)
            return this.getSimplifiedGeometry(e);
          const s = this.clone();
          return s.applyTransform(n), s.getSimplifiedGeometry(e);
        }
      );
    }
    /**
     * Get a transformed and simplified version of the geometry.
     * @abstract
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
     * @return {Geometry} Simplified geometry.
     */
    simplifyTransformed(t, e) {
      return this.simplifyTransformedInternal(
        this.getRevision(),
        t,
        e
      );
    }
    /**
     * Make a complete copy of the geometry.
     * @abstract
     * @return {!Geometry} Clone.
     */
    clone() {
      return ct();
    }
    /**
     * @abstract
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
    closestPointXY(t, e, n, s) {
      return ct();
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
    containsXY(t, e) {
      return this.closestPointXY(t, e, Pm, Number.MIN_VALUE) === 0;
    }
    /**
     * Return the closest point of the geometry to the passed point as
     * {@link module:ol/coordinate~Coordinate coordinate}.
     * @param {import("../coordinate.js").Coordinate} point Point.
     * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
     * @return {import("../coordinate.js").Coordinate} Closest point.
     * @api
     */
    getClosestPoint(t, e) {
      return e = e || [NaN, NaN], this.closestPointXY(t[0], t[1], e, 1 / 0), e;
    }
    /**
     * Returns true if this geometry includes the specified coordinate. If the
     * coordinate is on the boundary of the geometry, returns false.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains coordinate.
     * @api
     */
    intersectsCoordinate(t) {
      return this.containsXY(t[0], t[1]);
    }
    /**
     * @abstract
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     */
    computeExtent(t) {
      return ct();
    }
    /**
     * Get the extent of the geometry.
     * @param {import("../extent.js").Extent} [extent] Extent.
     * @return {import("../extent.js").Extent} extent Extent.
     * @api
     */
    getExtent(t) {
      if (this.extentRevision_ != this.getRevision()) {
        const e = this.computeExtent(this.extent_);
        (isNaN(e[0]) || isNaN(e[1])) && Ii(e), this.extentRevision_ = this.getRevision();
      }
      return md(this.extent_, t);
    }
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @abstract
     * @param {number} angle Rotation angle in radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     */
    rotate(t, e) {
      ct();
    }
    /**
     * Scale the geometry (with an optional origin).  This modifies the geometry
     * coordinates in place.
     * @abstract
     * @param {number} sx The scaling factor in the x-direction.
     * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
     * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
     *     of the geometry extent).
     * @api
     */
    scale(t, e, n) {
      ct();
    }
    /**
     * Create a simplified version of this geometry.  For linestrings, this uses
     * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
     * algorithm.  For polygons, a quantization-based
     * simplification is used to preserve topology.
     * @param {number} tolerance The tolerance distance for simplification.
     * @return {Geometry} A new, simplified version of the original geometry.
     * @api
     */
    simplify(t) {
      return this.getSimplifiedGeometry(t * t);
    }
    /**
     * Create a simplified version of this geometry using the Douglas Peucker
     * algorithm.
     * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
     * @abstract
     * @param {number} squaredTolerance Squared tolerance.
     * @return {Geometry} Simplified geometry.
     */
    getSimplifiedGeometry(t) {
      return ct();
    }
    /**
     * Get the type of this geometry.
     * @abstract
     * @return {Type} Geometry type.
     */
    getType() {
      return ct();
    }
    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @abstract
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     * Called with a flat array of geometry coordinates.
     */
    applyTransform(t) {
      ct();
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @abstract
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     */
    intersectsExtent(t) {
      return ct();
    }
    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @abstract
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     */
    translate(t, e) {
      ct();
    }
    /**
     * Transform each coordinate of the geometry from one coordinate reference
     * system to another. The geometry is modified in place.
     * For example, a line will be transformed to a line and a circle to a circle.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     *
     * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
     * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
     * @return {this} This geometry.  Note that original geometry is
     *     modified in place.
     * @api
     */
    transform(t, e) {
      const n = At(t), s = n.getUnits() == "tile-pixels" ? function(r, a, o) {
        const l = n.getExtent(), h = n.getWorldExtent(), c = te(h) / te(l);
        Ci(
          Wc,
          h[0],
          h[3],
          c,
          -c,
          0,
          0,
          0
        );
        const u = ji(
          r,
          0,
          r.length,
          o,
          Wc,
          a
        ), d = Ps(n, e);
        return d ? d(u, u, o) : u;
      } : Ps(n, e);
      return this.applyTransform(s), this;
    }
  }
  class Ti extends Eo {
    constructor() {
      super(), this.layout = "XY", this.stride = 2, this.flatCoordinates;
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     * @override
     */
    computeExtent(t) {
      return go(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        t
      );
    }
    /**
     * @abstract
     * @return {Array<*> | null} Coordinates.
     */
    getCoordinates() {
      return ct();
    }
    /**
     * Return the first coordinate of the geometry.
     * @return {import("../coordinate.js").Coordinate} First coordinate.
     * @api
     */
    getFirstCoordinate() {
      return this.flatCoordinates.slice(0, this.stride);
    }
    /**
     * @return {Array<number>} Flat coordinates.
     */
    getFlatCoordinates() {
      return this.flatCoordinates;
    }
    /**
     * Return the last coordinate of the geometry.
     * @return {import("../coordinate.js").Coordinate} Last point.
     * @api
     */
    getLastCoordinate() {
      return this.flatCoordinates.slice(
        this.flatCoordinates.length - this.stride
      );
    }
    /**
     * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
     * @return {import("./Geometry.js").GeometryLayout} Layout.
     * @api
     */
    getLayout() {
      return this.layout;
    }
    /**
     * Create a simplified version of this geometry using the Douglas Peucker algorithm.
     * @param {number} squaredTolerance Squared tolerance.
     * @return {SimpleGeometry} Simplified geometry.
     * @override
     */
    getSimplifiedGeometry(t) {
      if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && t <= this.simplifiedGeometryMaxMinSquaredTolerance)
        return this;
      const e = this.getSimplifiedGeometryInternal(t);
      return e.getFlatCoordinates().length < this.flatCoordinates.length ? e : (this.simplifiedGeometryMaxMinSquaredTolerance = t, this);
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {SimpleGeometry} Simplified geometry.
     * @protected
     */
    getSimplifiedGeometryInternal(t) {
      return this;
    }
    /**
     * @return {number} Stride.
     */
    getStride() {
      return this.stride;
    }
    /**
     * @param {import("./Geometry.js").GeometryLayout} layout Layout.
     * @param {Array<number>} flatCoordinates Flat coordinates.
     */
    setFlatCoordinates(t, e) {
      this.stride = Xc(t), this.layout = t, this.flatCoordinates = e;
    }
    /**
     * @abstract
     * @param {!Array<*>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    setCoordinates(t, e) {
      ct();
    }
    /**
     * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
     * @param {Array<*>} coordinates Coordinates.
     * @param {number} nesting Nesting.
     * @protected
     */
    setLayout(t, e, n) {
      let s;
      if (t)
        s = Xc(t);
      else {
        for (let r = 0; r < n; ++r) {
          if (e.length === 0) {
            this.layout = "XY", this.stride = 2;
            return;
          }
          e = /** @type {Array<unknown>} */
          e[0];
        }
        s = e.length, t = Lm(s);
      }
      this.layout = t, this.stride = s;
    }
    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     * Called with a flat array of geometry coordinates.
     * @api
     * @override
     */
    applyTransform(t) {
      this.flatCoordinates && (t(
        this.flatCoordinates,
        this.flatCoordinates,
        this.layout.startsWith("XYZ") ? 3 : 2,
        this.stride
      ), this.changed());
    }
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @param {number} angle Rotation angle in counter-clockwise radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     * @override
     */
    rotate(t, e) {
      const n = this.getFlatCoordinates();
      if (n) {
        const s = this.getStride();
        _h(
          n,
          0,
          n.length,
          s,
          t,
          e,
          n
        ), this.changed();
      }
    }
    /**
     * Scale the geometry (with an optional origin).  This modifies the geometry
     * coordinates in place.
     * @param {number} sx The scaling factor in the x-direction.
     * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
     * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
     *     of the geometry extent).
     * @api
     * @override
     */
    scale(t, e, n) {
      e === void 0 && (e = t), n || (n = Si(this.getExtent()));
      const s = this.getFlatCoordinates();
      if (s) {
        const r = this.getStride();
        Am(
          s,
          0,
          s.length,
          r,
          t,
          e,
          n,
          s
        ), this.changed();
      }
    }
    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     * @override
     */
    translate(t, e) {
      const n = this.getFlatCoordinates();
      if (n) {
        const s = this.getStride();
        bm(
          n,
          0,
          n.length,
          s,
          t,
          e,
          n
        ), this.changed();
      }
    }
  }
  function Lm(i) {
    let t;
    return i == 2 ? t = "XY" : i == 3 ? t = "XYZ" : i == 4 && (t = "XYZM"), /** @type {import("./Geometry.js").GeometryLayout} */
    t;
  }
  function Xc(i) {
    let t;
    return i == "XY" ? t = 2 : i == "XYZ" || i == "XYM" ? t = 3 : i == "XYZM" && (t = 4), /** @type {number} */
    t;
  }
  function Om(i, t, e) {
    const n = i.getFlatCoordinates();
    if (!n)
      return null;
    const s = i.getStride();
    return ji(
      n,
      0,
      n.length,
      s,
      t,
      e
    );
  }
  function Pd(i, t, e, n) {
    let s = 0;
    const r = i[e - n], a = i[e - n + 1];
    let o = 0, l = 0;
    for (; t < e; t += n) {
      const h = i[t] - r, c = i[t + 1] - a;
      s += l * h - o * c, o = h, l = c;
    }
    return s / 2;
  }
  function Ld(i, t, e, n) {
    let s = 0;
    for (let r = 0, a = e.length; r < a; ++r) {
      const o = e[r];
      s += Pd(i, t, o, n), t = o;
    }
    return s;
  }
  function Nm(i, t, e, n) {
    let s = 0;
    for (let r = 0, a = e.length; r < a; ++r) {
      const o = e[r];
      s += Ld(i, t, o, n), t = o[o.length - 1];
    }
    return s;
  }
  function Yc(i, t, e, n, s, r, a) {
    const o = i[t], l = i[t + 1], h = i[e] - o, c = i[e + 1] - l;
    let u;
    if (h === 0 && c === 0)
      u = t;
    else {
      const d = ((s - o) * h + (r - l) * c) / (h * h + c * c);
      if (d > 1)
        u = e;
      else if (d > 0) {
        for (let g = 0; g < n; ++g)
          a[g] = be(
            i[t + g],
            i[e + g],
            d
          );
        a.length = n;
        return;
      } else
        u = t;
    }
    for (let d = 0; d < n; ++d)
      a[d] = i[u + d];
    a.length = n;
  }
  function ph(i, t, e, n, s) {
    let r = i[t], a = i[t + 1];
    for (t += n; t < e; t += n) {
      const o = i[t], l = i[t + 1], h = Ln(r, a, o, l);
      h > s && (s = h), r = o, a = l;
    }
    return s;
  }
  function yh(i, t, e, n, s) {
    for (let r = 0, a = e.length; r < a; ++r) {
      const o = e[r];
      s = ph(i, t, o, n, s), t = o;
    }
    return s;
  }
  function Fm(i, t, e, n, s) {
    for (let r = 0, a = e.length; r < a; ++r) {
      const o = e[r];
      s = yh(i, t, o, n, s), t = o[o.length - 1];
    }
    return s;
  }
  function vh(i, t, e, n, s, r, a, o, l, h, c) {
    if (t == e)
      return h;
    let u, d;
    if (s === 0) {
      if (d = Ln(
        a,
        o,
        i[t],
        i[t + 1]
      ), d < h) {
        for (u = 0; u < n; ++u)
          l[u] = i[t + u];
        return l.length = n, d;
      }
      return h;
    }
    c = c || [NaN, NaN];
    let g = t + n;
    for (; g < e; )
      if (Yc(
        i,
        g - n,
        g,
        n,
        a,
        o,
        c
      ), d = Ln(a, o, c[0], c[1]), d < h) {
        for (h = d, u = 0; u < n; ++u)
          l[u] = c[u];
        l.length = n, g += n;
      } else
        g += n * Math.max(
          (Math.sqrt(d) - Math.sqrt(h)) / s | 0,
          1
        );
    if (r && (Yc(
      i,
      e - n,
      t,
      n,
      a,
      o,
      c
    ), d = Ln(a, o, c[0], c[1]), d < h)) {
      for (h = d, u = 0; u < n; ++u)
        l[u] = c[u];
      l.length = n;
    }
    return h;
  }
  function Eh(i, t, e, n, s, r, a, o, l, h, c) {
    c = c || [NaN, NaN];
    for (let u = 0, d = e.length; u < d; ++u) {
      const g = e[u];
      h = vh(
        i,
        t,
        g,
        n,
        s,
        r,
        a,
        o,
        l,
        h,
        c
      ), t = g;
    }
    return h;
  }
  function Dm(i, t, e, n, s, r, a, o, l, h, c) {
    c = c || [NaN, NaN];
    for (let u = 0, d = e.length; u < d; ++u) {
      const g = e[u];
      h = Eh(
        i,
        t,
        g,
        n,
        s,
        r,
        a,
        o,
        l,
        h,
        c
      ), t = g[g.length - 1];
    }
    return h;
  }
  function Od(i, t, e, n) {
    for (let s = 0, r = e.length; s < r; ++s)
      i[t++] = e[s];
    return t;
  }
  function Mo(i, t, e, n) {
    for (let s = 0, r = e.length; s < r; ++s) {
      const a = e[s];
      for (let o = 0; o < n; ++o)
        i[t++] = a[o];
    }
    return t;
  }
  function Mh(i, t, e, n, s) {
    s = s || [];
    let r = 0;
    for (let a = 0, o = e.length; a < o; ++a) {
      const l = Mo(
        i,
        t,
        e[a],
        n
      );
      s[r++] = l, t = l;
    }
    return s.length = r, s;
  }
  function km(i, t, e, n, s) {
    s = s || [];
    let r = 0;
    for (let a = 0, o = e.length; a < o; ++a) {
      const l = Mh(
        i,
        t,
        e[a],
        n,
        s[r]
      );
      l.length === 0 && (l[0] = t), s[r++] = l, t = l[l.length - 1];
    }
    return s.length = r, s;
  }
  function Xi(i, t, e, n, s) {
    s = s !== void 0 ? s : [];
    let r = 0;
    for (let a = t; a < e; a += n)
      s[r++] = i.slice(a, a + n);
    return s.length = r, s;
  }
  function wr(i, t, e, n, s) {
    s = s !== void 0 ? s : [];
    let r = 0;
    for (let a = 0, o = e.length; a < o; ++a) {
      const l = e[a];
      s[r++] = Xi(
        i,
        t,
        l,
        n,
        s[r]
      ), t = l;
    }
    return s.length = r, s;
  }
  function Al(i, t, e, n, s) {
    s = s !== void 0 ? s : [];
    let r = 0;
    for (let a = 0, o = e.length; a < o; ++a) {
      const l = e[a];
      s[r++] = l.length === 1 && l[0] === t ? [] : wr(
        i,
        t,
        l,
        n,
        s[r]
      ), t = l[l.length - 1];
    }
    return s.length = r, s;
  }
  function xo(i, t, e, n, s, r, a) {
    const o = (e - t) / n;
    if (o < 3) {
      for (; t < e; t += n)
        r[a++] = i[t], r[a++] = i[t + 1];
      return a;
    }
    const l = new Array(o);
    l[0] = 1, l[o - 1] = 1;
    const h = [t, e - n];
    let c = 0;
    for (; h.length > 0; ) {
      const u = h.pop(), d = h.pop();
      let g = 0;
      const _ = i[d], y = i[d + 1], E = i[u], M = i[u + 1];
      for (let w = d + n; w < u; w += n) {
        const R = i[w], S = i[w + 1], C = b0(R, S, _, y, E, M);
        C > g && (c = w, g = C);
      }
      g > s && (l[(c - t) / n] = 1, d + n < c && h.push(d, c), c + n < u && h.push(c, u));
    }
    for (let u = 0; u < o; ++u)
      l[u] && (r[a++] = i[t + u * n], r[a++] = i[t + u * n + 1]);
    return a;
  }
  function Nd(i, t, e, n, s, r, a, o) {
    for (let l = 0, h = e.length; l < h; ++l) {
      const c = e[l];
      a = xo(
        i,
        t,
        c,
        n,
        s,
        r,
        a
      ), o.push(a), t = c;
    }
    return a;
  }
  function Sn(i, t) {
    return t * Math.round(i / t);
  }
  function Gm(i, t, e, n, s, r, a) {
    if (t == e)
      return a;
    let o = Sn(i[t], s), l = Sn(i[t + 1], s);
    t += n, r[a++] = o, r[a++] = l;
    let h, c;
    do
      if (h = Sn(i[t], s), c = Sn(i[t + 1], s), t += n, t == e)
        return r[a++] = h, r[a++] = c, a;
    while (h == o && c == l);
    for (; t < e; ) {
      const u = Sn(i[t], s), d = Sn(i[t + 1], s);
      if (t += n, u == h && d == c)
        continue;
      const g = h - o, _ = c - l, y = u - o, E = d - l;
      if (g * E == _ * y && (g < 0 && y < g || g == y || g > 0 && y > g) && (_ < 0 && E < _ || _ == E || _ > 0 && E > _)) {
        h = u, c = d;
        continue;
      }
      r[a++] = h, r[a++] = c, o = h, l = c, h = u, c = d;
    }
    return r[a++] = h, r[a++] = c, a;
  }
  function xh(i, t, e, n, s, r, a, o) {
    for (let l = 0, h = e.length; l < h; ++l) {
      const c = e[l];
      a = Gm(
        i,
        t,
        c,
        n,
        s,
        r,
        a
      ), o.push(a), t = c;
    }
    return a;
  }
  function zm(i, t, e, n, s, r, a, o) {
    for (let l = 0, h = e.length; l < h; ++l) {
      const c = e[l], u = [];
      a = xh(
        i,
        t,
        c,
        n,
        s,
        r,
        a,
        u
      ), o.push(u), t = c[c.length - 1];
    }
    return a;
  }
  class kn extends Ti {
    /**
     * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `layout` are also accepted.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    constructor(t, e) {
      super(), this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, e !== void 0 && !Array.isArray(t[0]) ? this.setFlatCoordinates(
        e,
        /** @type {Array<number>} */
        t
      ) : this.setCoordinates(
        /** @type {Array<import("../coordinate.js").Coordinate>} */
        t,
        e
      );
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!LinearRing} Clone.
     * @api
     * @override
     */
    clone() {
      return new kn(this.flatCoordinates.slice(), this.layout);
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(t, e, n, s) {
      return s < an(this.getExtent(), t, e) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
        ph(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          0
        )
      ), this.maxDeltaRevision_ = this.getRevision()), vh(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        this.maxDelta_,
        !0,
        t,
        e,
        n,
        s
      ));
    }
    /**
     * Return the area of the linear ring on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */
    getArea() {
      return Pd(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    /**
     * Return the coordinates of the linear ring.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     * @override
     */
    getCoordinates() {
      return Xi(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {LinearRing} Simplified LinearRing.
     * @protected
     * @override
     */
    getSimplifiedGeometryInternal(t) {
      const e = [];
      return e.length = xo(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        t,
        e,
        0
      ), new kn(e, "XY");
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "LinearRing";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(t) {
      return !1;
    }
    /**
     * Set the coordinates of the linear ring.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    setCoordinates(t, e) {
      this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Mo(
        this.flatCoordinates,
        0,
        t,
        this.stride
      ), this.changed();
    }
  }
  let Sr = class Fd extends Ti {
    /**
     * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    constructor(t, e) {
      super(), this.setCoordinates(t, e);
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!Point} Clone.
     * @api
     * @override
     */
    clone() {
      const t = new Fd(this.flatCoordinates.slice(), this.layout);
      return t.applyProperties(this), t;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(t, e, n, s) {
      const r = this.flatCoordinates, a = Ln(
        t,
        e,
        r[0],
        r[1]
      );
      if (a < s) {
        const o = this.stride;
        for (let l = 0; l < o; ++l)
          n[l] = r[l];
        return n.length = o, a;
      }
      return s;
    }
    /**
     * Return the coordinate of the point.
     * @return {import("../coordinate.js").Coordinate} Coordinates.
     * @api
     * @override
     */
    getCoordinates() {
      return this.flatCoordinates.slice();
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     * @override
     */
    computeExtent(t) {
      return nh(this.flatCoordinates, t);
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "Point";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(t) {
      return fo(t, this.flatCoordinates[0], this.flatCoordinates[1]);
    }
    /**
     * @param {!Array<*>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    setCoordinates(t, e) {
      this.setLayout(e, t, 0), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Od(
        this.flatCoordinates,
        0,
        t,
        this.stride
      ), this.changed();
    }
  };
  function $m(i, t, e, n, s) {
    return !_o(
      s,
      /**
       * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
       * @return {boolean} Contains (x, y).
       */
      function(a) {
        return !Tn(
          i,
          t,
          e,
          n,
          a[0],
          a[1]
        );
      }
    );
  }
  function Tn(i, t, e, n, s, r) {
    let a = 0, o = i[e - n], l = i[e - n + 1];
    for (; t < e; t += n) {
      const h = i[t], c = i[t + 1];
      l <= r ? c > r && (h - o) * (r - l) - (s - o) * (c - l) > 0 && a++ : c <= r && (h - o) * (r - l) - (s - o) * (c - l) < 0 && a--, o = h, l = c;
    }
    return a !== 0;
  }
  function wh(i, t, e, n, s, r) {
    if (e.length === 0 || !Tn(i, t, e[0], n, s, r))
      return !1;
    for (let a = 1, o = e.length; a < o; ++a)
      if (Tn(i, e[a - 1], e[a], n, s, r))
        return !1;
    return !0;
  }
  function Um(i, t, e, n, s, r) {
    if (e.length === 0)
      return !1;
    for (let a = 0, o = e.length; a < o; ++a) {
      const l = e[a];
      if (wh(i, t, l, n, s, r))
        return !0;
      t = l[l.length - 1];
    }
    return !1;
  }
  function Sh(i, t, e, n, s, r, a) {
    let o, l, h, c, u, d, g;
    const _ = s[r + 1], y = [];
    for (let w = 0, R = e.length; w < R; ++w) {
      const S = e[w];
      for (c = i[S - n], d = i[S - n + 1], o = t; o < S; o += n)
        u = i[o], g = i[o + 1], (_ <= d && g <= _ || d <= _ && _ <= g) && (h = (_ - d) / (g - d) * (u - c) + c, y.push(h)), c = u, d = g;
    }
    let E = NaN, M = -1 / 0;
    for (y.sort(Ki), c = y[0], o = 1, l = y.length; o < l; ++o) {
      u = y[o];
      const w = Math.abs(u - c);
      w > M && (h = (c + u) / 2, wh(i, t, e, n, h, _) && (E = h, M = w)), c = u;
    }
    return isNaN(E) && (E = s[r]), a ? (a.push(E, _, M), a) : [E, _, M];
  }
  function Dd(i, t, e, n, s) {
    let r = [];
    for (let a = 0, o = e.length; a < o; ++a) {
      const l = e[a];
      r = Sh(
        i,
        t,
        l,
        n,
        s,
        2 * a,
        r
      ), t = l[l.length - 1];
    }
    return r;
  }
  function kd(i, t, e, n, s) {
    let r;
    for (t += n; t < e; t += n)
      if (r = s(
        i.slice(t - n, t),
        i.slice(t, t + n)
      ), r)
        return r;
    return !1;
  }
  function wo(i, t, e, n, s, r) {
    return r = r ?? rh(Pe(), i, t, e, n), he(s, r) ? r[0] >= s[0] && r[2] <= s[2] || r[1] >= s[1] && r[3] <= s[3] ? !0 : kd(
      i,
      t,
      e,
      n,
      /**
       * @param {import("../../coordinate.js").Coordinate} point1 Start point.
       * @param {import("../../coordinate.js").Coordinate} point2 End point.
       * @return {boolean} `true` if the segment and the extent intersect,
       *     `false` otherwise.
       */
      function(a, o) {
        return _d(s, a, o);
      }
    ) : !1;
  }
  function Bm(i, t, e, n, s) {
    for (let r = 0, a = e.length; r < a; ++r) {
      if (wo(i, t, e[r], n, s))
        return !0;
      t = e[r];
    }
    return !1;
  }
  function Gd(i, t, e, n, s) {
    return !!(wo(i, t, e, n, s) || Tn(
      i,
      t,
      e,
      n,
      s[0],
      s[1]
    ) || Tn(
      i,
      t,
      e,
      n,
      s[0],
      s[3]
    ) || Tn(
      i,
      t,
      e,
      n,
      s[2],
      s[1]
    ) || Tn(
      i,
      t,
      e,
      n,
      s[2],
      s[3]
    ));
  }
  function zd(i, t, e, n, s) {
    if (!Gd(i, t, e[0], n, s))
      return !1;
    if (e.length === 1)
      return !0;
    for (let r = 1, a = e.length; r < a; ++r)
      if ($m(
        i,
        e[r - 1],
        e[r],
        n,
        s
      ) && !wo(
        i,
        e[r - 1],
        e[r],
        n,
        s
      ))
        return !1;
    return !0;
  }
  function Wm(i, t, e, n, s) {
    for (let r = 0, a = e.length; r < a; ++r) {
      const o = e[r];
      if (zd(i, t, o, n, s))
        return !0;
      t = o[o.length - 1];
    }
    return !1;
  }
  function Xm(i, t, e, n) {
    for (; t < e - n; ) {
      for (let s = 0; s < n; ++s) {
        const r = i[t + s];
        i[t + s] = i[e - n + s], i[e - n + s] = r;
      }
      t += n, e -= n;
    }
  }
  function Ch(i, t, e, n) {
    let s = 0, r = i[e - n], a = i[e - n + 1];
    for (; t < e; t += n) {
      const o = i[t], l = i[t + 1];
      s += (o - r) * (l + a), r = o, a = l;
    }
    return s === 0 ? void 0 : s > 0;
  }
  function $d(i, t, e, n, s) {
    s = s !== void 0 ? s : !1;
    for (let r = 0, a = e.length; r < a; ++r) {
      const o = e[r], l = Ch(
        i,
        t,
        o,
        n
      );
      if (r === 0) {
        if (s && l || !s && !l)
          return !1;
      } else if (s && !l || !s && l)
        return !1;
      t = o;
    }
    return !0;
  }
  function Ym(i, t, e, n, s) {
    for (let r = 0, a = e.length; r < a; ++r) {
      const o = e[r];
      if (!$d(i, t, o, n, s))
        return !1;
      o.length && (t = o[o.length - 1]);
    }
    return !0;
  }
  function bl(i, t, e, n, s) {
    s = s !== void 0 ? s : !1;
    for (let r = 0, a = e.length; r < a; ++r) {
      const o = e[r], l = Ch(
        i,
        t,
        o,
        n
      );
      (r === 0 ? s && l || !s && !l : s && !l || !s && l) && Xm(i, t, o, n), t = o;
    }
    return t;
  }
  function Zc(i, t, e, n, s) {
    for (let r = 0, a = e.length; r < a; ++r)
      t = bl(
        i,
        t,
        e[r],
        n,
        s
      );
    return t;
  }
  function Zm(i, t) {
    const e = [];
    let n = 0, s = 0, r;
    for (let a = 0, o = t.length; a < o; ++a) {
      const l = t[a], h = Ch(i, n, l, 2);
      if (r === void 0 && (r = h), h === r)
        e.push(t.slice(s, a + 1));
      else {
        if (e.length === 0)
          continue;
        e[e.length - 1].push(t[s]);
      }
      s = a + 1, n = l;
    }
    return e;
  }
  class oi extends Ti {
    /**
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
     *     Array of linear rings that define the polygon. The first linear ring of the
     *     array defines the outer-boundary or surface of the polygon. Each subsequent
     *     linear ring defines a hole in the surface of the polygon. A linear ring is
     *     an array of vertices' coordinates where the first coordinate and the last are
     *     equivalent. (For internal use, flat coordinates in combination with
     *     `layout` and `ends` are also accepted.)
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
     */
    constructor(t, e, n) {
      super(), this.ends_ = [], this.flatInteriorPointRevision_ = -1, this.flatInteriorPoint_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, e !== void 0 && n ? (this.setFlatCoordinates(
        e,
        /** @type {Array<number>} */
        t
      ), this.ends_ = n) : this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
        t,
        e
      );
    }
    /**
     * Append the passed linear ring to this polygon.
     * @param {LinearRing} linearRing Linear ring.
     * @api
     */
    appendLinearRing(t) {
      this.flatCoordinates ? pe(this.flatCoordinates, t.getFlatCoordinates()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!Polygon} Clone.
     * @api
     * @override
     */
    clone() {
      const t = new oi(
        this.flatCoordinates.slice(),
        this.layout,
        this.ends_.slice()
      );
      return t.applyProperties(this), t;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(t, e, n, s) {
      return s < an(this.getExtent(), t, e) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
        yh(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          0
        )
      ), this.maxDeltaRevision_ = this.getRevision()), Eh(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        this.maxDelta_,
        !0,
        t,
        e,
        n,
        s
      ));
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     * @override
     */
    containsXY(t, e) {
      return wh(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        t,
        e
      );
    }
    /**
     * Return the area of the polygon on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */
    getArea() {
      return Ld(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride
      );
    }
    /**
     * Get the coordinate array for this geometry.  This array has the structure
     * of a GeoJSON coordinate array for polygons.
     *
     * @param {boolean} [right] Orient coordinates according to the right-hand
     *     rule (counter-clockwise for exterior and clockwise for interior rings).
     *     If `false`, coordinates will be oriented according to the left-hand rule
     *     (clockwise for exterior and counter-clockwise for interior rings).
     *     By default, coordinate orientation will depend on how the geometry was
     *     constructed.
     * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
     * @api
     * @override
     */
    getCoordinates(t) {
      let e;
      return t !== void 0 ? (e = this.getOrientedFlatCoordinates().slice(), bl(e, 0, this.ends_, this.stride, t)) : e = this.flatCoordinates, wr(e, 0, this.ends_, this.stride);
    }
    /**
     * @return {Array<number>} Ends.
     */
    getEnds() {
      return this.ends_;
    }
    /**
     * @return {Array<number>} Interior point.
     */
    getFlatInteriorPoint() {
      if (this.flatInteriorPointRevision_ != this.getRevision()) {
        const t = Si(this.getExtent());
        this.flatInteriorPoint_ = Sh(
          this.getOrientedFlatCoordinates(),
          0,
          this.ends_,
          this.stride,
          t,
          0
        ), this.flatInteriorPointRevision_ = this.getRevision();
      }
      return (
        /** @type {import("../coordinate.js").Coordinate} */
        this.flatInteriorPoint_
      );
    }
    /**
     * Return an interior point of the polygon.
     * @return {Point} Interior point as XYM coordinate, where M is the
     * length of the horizontal intersection that the point belongs to.
     * @api
     */
    getInteriorPoint() {
      return new Sr(this.getFlatInteriorPoint(), "XYM");
    }
    /**
     * Return the number of rings of the polygon,  this includes the exterior
     * ring and any interior rings.
     *
     * @return {number} Number of rings.
     * @api
     */
    getLinearRingCount() {
      return this.ends_.length;
    }
    /**
     * Return the Nth linear ring of the polygon geometry. Return `null` if the
     * given index is out of range.
     * The exterior linear ring is available at index `0` and the interior rings
     * at index `1` and beyond.
     *
     * @param {number} index Index.
     * @return {LinearRing|null} Linear ring.
     * @api
     */
    getLinearRing(t) {
      return t < 0 || this.ends_.length <= t ? null : new kn(
        this.flatCoordinates.slice(
          t === 0 ? 0 : this.ends_[t - 1],
          this.ends_[t]
        ),
        this.layout
      );
    }
    /**
     * Return the linear rings of the polygon.
     * @return {Array<LinearRing>} Linear rings.
     * @api
     */
    getLinearRings() {
      const t = this.layout, e = this.flatCoordinates, n = this.ends_, s = [];
      let r = 0;
      for (let a = 0, o = n.length; a < o; ++a) {
        const l = n[a], h = new kn(
          e.slice(r, l),
          t
        );
        s.push(h), r = l;
      }
      return s;
    }
    /**
     * @return {Array<number>} Oriented flat coordinates.
     */
    getOrientedFlatCoordinates() {
      if (this.orientedRevision_ != this.getRevision()) {
        const t = this.flatCoordinates;
        $d(t, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = bl(
          this.orientedFlatCoordinates_,
          0,
          this.ends_,
          this.stride
        )), this.orientedRevision_ = this.getRevision();
      }
      return (
        /** @type {Array<number>} */
        this.orientedFlatCoordinates_
      );
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {Polygon} Simplified Polygon.
     * @protected
     * @override
     */
    getSimplifiedGeometryInternal(t) {
      const e = [], n = [];
      return e.length = xh(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        Math.sqrt(t),
        e,
        0,
        n
      ), new oi(e, "XY", n);
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "Polygon";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(t) {
      return zd(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        t
      );
    }
    /**
     * Set the coordinates of the polygon.
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    setCoordinates(t, e) {
      this.setLayout(e, t, 2), this.flatCoordinates || (this.flatCoordinates = []);
      const n = Mh(
        this.flatCoordinates,
        0,
        t,
        this.stride,
        this.ends_
      );
      this.flatCoordinates.length = n.length === 0 ? 0 : n[n.length - 1], this.changed();
    }
  }
  function qc(i) {
    if (zs(i))
      throw new Error("Cannot create polygon from empty extent");
    const t = i[0], e = i[1], n = i[2], s = i[3], r = [
      t,
      e,
      t,
      s,
      n,
      s,
      n,
      e,
      t,
      e
    ];
    return new oi(r, "XY", [r.length]);
  }
  function Rh(i, t, e, n) {
    const s = Mt(t) / e[0], r = te(t) / e[1];
    return n ? Math.min(i, Math.max(s, r)) : Math.min(i, Math.min(s, r));
  }
  function Ih(i, t, e) {
    let n = Math.min(i, t);
    const s = 50;
    return n *= Math.log(1 + s * Math.max(0, i / t - 1)) / s + 1, e && (n = Math.max(n, e), n /= Math.log(1 + s * Math.max(0, e / i - 1)) / s + 1), zt(n, e / 2, t * 2);
  }
  function qm(i, t, e, n) {
    return t = t !== void 0 ? t : !0, /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(s, r, a, o) {
      if (s !== void 0) {
        const l = i[0], h = i[i.length - 1], c = e ? Rh(
          l,
          e,
          a,
          n
        ) : l;
        if (o)
          return t ? Ih(
            s,
            c,
            h
          ) : zt(s, h, c);
        const u = Math.min(c, s), d = Math.floor(jl(i, u, r));
        return i[d] > c && d < i.length - 1 ? i[d + 1] : i[d];
      }
    };
  }
  function Km(i, t, e, n, s, r) {
    return n = n !== void 0 ? n : !0, e = e !== void 0 ? e : 0, /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(a, o, l, h) {
      if (a !== void 0) {
        const c = s ? Rh(
          t,
          s,
          l,
          r
        ) : t;
        if (h)
          return n ? Ih(
            a,
            c,
            e
          ) : zt(a, e, c);
        const u = 1e-9, d = Math.ceil(
          Math.log(t / c) / Math.log(i) - u
        ), g = -o * (0.5 - u) + 0.5, _ = Math.min(c, a), y = Math.floor(
          Math.log(t / _) / Math.log(i) + g
        ), E = Math.max(d, y), M = t / Math.pow(i, E);
        return zt(M, e, c);
      }
    };
  }
  function Kc(i, t, e, n, s) {
    return e = e !== void 0 ? e : !0, /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(r, a, o, l) {
      if (r !== void 0) {
        const h = n ? Rh(
          i,
          n,
          o,
          s
        ) : i;
        return !e || !l ? zt(r, t, h) : Ih(
          r,
          h,
          t
        );
      }
    };
  }
  function Th(i) {
    if (i !== void 0)
      return 0;
  }
  function Vc(i) {
    if (i !== void 0)
      return i;
  }
  function Vm(i) {
    const t = 2 * Math.PI / i;
    return (
      /**
       * @param {number|undefined} rotation Rotation.
       * @param {boolean} [isMoving] True if an interaction or animation is in progress.
       * @return {number|undefined} Rotation.
       */
      function(e, n) {
        if (n)
          return e;
        if (e !== void 0)
          return e = Math.floor(e / t + 0.5) * t, e;
      }
    );
  }
  function jm(i) {
    const t = Vi(5);
    return (
      /**
       * @param {number|undefined} rotation Rotation.
       * @param {boolean} [isMoving] True if an interaction or animation is in progress.
       * @return {number|undefined} Rotation.
       */
      function(e, n) {
        return n || e === void 0 ? e : Math.abs(e) <= t ? 0 : e;
      }
    );
  }
  const Hm = 42, Ah = 256, qo = 0;
  class Ke extends Qe {
    /**
     * @param {ViewOptions} [options] View options.
     */
    constructor(t) {
      super(), this.on, this.once, this.un, t = Object.assign({}, t), this.hints_ = [0, 0], this.animations_ = [], this.updateAnimationKey_, this.projection_ = gh(t.projection, "EPSG:3857"), this.viewportSize_ = [100, 100], this.targetCenter_ = null, this.targetResolution_, this.targetRotation_, this.nextCenter_ = null, this.nextResolution_, this.nextRotation_, this.cancelAnchor_ = void 0, t.projection && pm(), t.center && (t.center = pi(t.center, this.projection_)), t.extent && (t.extent = Wi(t.extent, this.projection_)), this.applyOptions_(t);
    }
    /**
     * Set up the view with the given options.
     * @param {ViewOptions} options View options.
     */
    applyOptions_(t) {
      const e = Object.assign({}, t);
      for (const o in Ze)
        delete e[o];
      this.setProperties(e, !0);
      const n = Qm(t);
      this.maxResolution_ = n.maxResolution, this.minResolution_ = n.minResolution, this.zoomFactor_ = n.zoomFactor, this.resolutions_ = t.resolutions, this.padding_ = t.padding, this.minZoom_ = n.minZoom;
      const s = Jm(t), r = n.constraint, a = t_(t);
      this.constraints_ = {
        center: s,
        resolution: r,
        rotation: a
      }, this.setRotation(t.rotation !== void 0 ? t.rotation : 0), this.setCenterInternal(
        t.center !== void 0 ? t.center : null
      ), t.resolution !== void 0 ? this.setResolution(t.resolution) : t.zoom !== void 0 && this.setZoom(t.zoom);
    }
    /**
     * Padding (in css pixels).
     * If the map viewport is partially covered with other content (overlays) along
     * its edges, this setting allows to shift the center of the viewport away from that
     * content. The order of the values in the array is top, right, bottom, left.
     * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
     * @type {Array<number>|undefined}
     * @api
     */
    get padding() {
      return this.padding_;
    }
    set padding(t) {
      let e = this.padding_;
      this.padding_ = t;
      const n = this.getCenterInternal();
      if (n) {
        const s = t || [0, 0, 0, 0];
        e = e || [0, 0, 0, 0];
        const r = this.getResolution(), a = r / 2 * (s[3] - e[3] + e[1] - s[1]), o = r / 2 * (s[0] - e[0] + e[2] - s[2]);
        this.setCenterInternal([n[0] + a, n[1] - o]);
      }
    }
    /**
     * Get an updated version of the view options used to construct the view.  The
     * current resolution (or zoom), center, and rotation are applied to any stored
     * options.  The provided options can be used to apply new min/max zoom or
     * resolution limits.
     * @param {ViewOptions} newOptions New options to be applied.
     * @return {ViewOptions} New options updated with the current view state.
     */
    getUpdatedOptions_(t) {
      const e = this.getProperties();
      return e.resolution !== void 0 ? e.resolution = this.getResolution() : e.zoom = this.getZoom(), e.center = this.getCenterInternal(), e.rotation = this.getRotation(), Object.assign({}, e, t);
    }
    /**
     * Animate the view.  The view's center, zoom (or resolution), and rotation
     * can be animated for smooth transitions between view states.  For example,
     * to animate the view to a new zoom level:
     *
     *     view.animate({zoom: view.getZoom() + 1});
     *
     * By default, the animation lasts one second and uses in-and-out easing.  You
     * can customize this behavior by including `duration` (in milliseconds) and
     * `easing` options (see {@link module:ol/easing}).
     *
     * To chain together multiple animations, call the method with multiple
     * animation objects.  For example, to first zoom and then pan:
     *
     *     view.animate({zoom: 10}, {center: [0, 0]});
     *
     * If you provide a function as the last argument to the animate method, it
     * will get called at the end of an animation series.  The callback will be
     * called with `true` if the animation series completed on its own or `false`
     * if it was cancelled.
     *
     * Animations are cancelled by user interactions (e.g. dragging the map) or by
     * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
     * (or another method that calls one of these).
     *
     * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
     *     options.  Multiple animations can be run in series by passing multiple
     *     options objects.  To run multiple animations in parallel, call the method
     *     multiple times.  An optional callback can be provided as a final
     *     argument.  The callback will be called with a boolean indicating whether
     *     the animation completed without being cancelled.
     * @api
     */
    animate(t) {
      this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
      const e = new Array(arguments.length);
      for (let n = 0; n < e.length; ++n) {
        let s = arguments[n];
        s.center && (s = Object.assign({}, s), s.center = pi(
          s.center,
          this.getProjection()
        )), s.anchor && (s = Object.assign({}, s), s.anchor = pi(
          s.anchor,
          this.getProjection()
        )), e[n] = s;
      }
      this.animateInternal.apply(this, e);
    }
    /**
     * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
     */
    animateInternal(t) {
      let e = arguments.length, n;
      e > 1 && typeof arguments[e - 1] == "function" && (n = arguments[e - 1], --e);
      let s = 0;
      for (; s < e && !this.isDef(); ++s) {
        const c = arguments[s];
        c.center && this.setCenterInternal(c.center), c.zoom !== void 0 ? this.setZoom(c.zoom) : c.resolution && this.setResolution(c.resolution), c.rotation !== void 0 && this.setRotation(c.rotation);
      }
      if (s === e) {
        n && ma(n, !0);
        return;
      }
      let r = Date.now(), a = this.targetCenter_.slice(), o = this.targetResolution_, l = this.targetRotation_;
      const h = [];
      for (; s < e; ++s) {
        const c = (
          /** @type {AnimationOptions} */
          arguments[s]
        ), u = {
          start: r,
          complete: !1,
          anchor: c.anchor,
          duration: c.duration !== void 0 ? c.duration : 1e3,
          easing: c.easing || Y0,
          callback: n
        };
        if (c.center && (u.sourceCenter = a, u.targetCenter = c.center.slice(), a = u.targetCenter), c.zoom !== void 0 ? (u.sourceResolution = o, u.targetResolution = this.getResolutionForZoom(c.zoom), o = u.targetResolution) : c.resolution && (u.sourceResolution = o, u.targetResolution = c.resolution, o = u.targetResolution), c.rotation !== void 0) {
          u.sourceRotation = l;
          const d = _s(c.rotation - l + Math.PI, 2 * Math.PI) - Math.PI;
          u.targetRotation = l + d, l = u.targetRotation;
        }
        e_(u) ? u.complete = !0 : r += u.duration, h.push(u);
      }
      this.animations_.push(h), this.setHint(oe.ANIMATING, 1), this.updateAnimations_();
    }
    /**
     * Determine if the view is being animated.
     * @return {boolean} The view is being animated.
     * @api
     */
    getAnimating() {
      return this.hints_[oe.ANIMATING] > 0;
    }
    /**
     * Determine if the user is interacting with the view, such as panning or zooming.
     * @return {boolean} The view is being interacted with.
     * @api
     */
    getInteracting() {
      return this.hints_[oe.INTERACTING] > 0;
    }
    /**
     * Cancel any ongoing animations.
     * @api
     */
    cancelAnimations() {
      this.setHint(oe.ANIMATING, -this.hints_[oe.ANIMATING]);
      let t;
      for (let e = 0, n = this.animations_.length; e < n; ++e) {
        const s = this.animations_[e];
        if (s[0].callback && ma(s[0].callback, !1), !t)
          for (let r = 0, a = s.length; r < a; ++r) {
            const o = s[r];
            if (!o.complete) {
              t = o.anchor;
              break;
            }
          }
      }
      this.animations_.length = 0, this.cancelAnchor_ = t, this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
    }
    /**
     * Update all animations.
     */
    updateAnimations_() {
      if (this.updateAnimationKey_ !== void 0 && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0), !this.getAnimating())
        return;
      const t = Date.now();
      let e = !1;
      for (let n = this.animations_.length - 1; n >= 0; --n) {
        const s = this.animations_[n];
        let r = !0;
        for (let a = 0, o = s.length; a < o; ++a) {
          const l = s[a];
          if (l.complete)
            continue;
          const h = t - l.start;
          let c = l.duration > 0 ? h / l.duration : 1;
          c >= 1 ? (l.complete = !0, c = 1) : r = !1;
          const u = l.easing(c);
          if (l.sourceCenter) {
            const d = l.sourceCenter[0], g = l.sourceCenter[1], _ = l.targetCenter[0], y = l.targetCenter[1];
            this.nextCenter_ = l.targetCenter;
            const E = d + u * (_ - d), M = g + u * (y - g);
            this.targetCenter_ = [E, M];
          }
          if (l.sourceResolution && l.targetResolution) {
            const d = u === 1 ? l.targetResolution : l.sourceResolution + u * (l.targetResolution - l.sourceResolution);
            if (l.anchor) {
              const g = this.getViewportSize_(this.getRotation()), _ = this.constraints_.resolution(
                d,
                0,
                g,
                !0
              );
              this.targetCenter_ = this.calculateCenterZoom(
                _,
                l.anchor
              );
            }
            this.nextResolution_ = l.targetResolution, this.targetResolution_ = d, this.applyTargetState_(!0);
          }
          if (l.sourceRotation !== void 0 && l.targetRotation !== void 0) {
            const d = u === 1 ? _s(l.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : l.sourceRotation + u * (l.targetRotation - l.sourceRotation);
            if (l.anchor) {
              const g = this.constraints_.rotation(
                d,
                !0
              );
              this.targetCenter_ = this.calculateCenterRotate(
                g,
                l.anchor
              );
            }
            this.nextRotation_ = l.targetRotation, this.targetRotation_ = d;
          }
          if (this.applyTargetState_(!0), e = !0, !l.complete)
            break;
        }
        if (r) {
          this.animations_[n] = null, this.setHint(oe.ANIMATING, -1), this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
          const a = s[0].callback;
          a && ma(a, !0);
        }
      }
      this.animations_ = this.animations_.filter(Boolean), e && this.updateAnimationKey_ === void 0 && (this.updateAnimationKey_ = requestAnimationFrame(
        this.updateAnimations_.bind(this)
      ));
    }
    /**
     * @param {number} rotation Target rotation.
     * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
     * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
     */
    calculateCenterRotate(t, e) {
      let n;
      const s = this.getCenterInternal();
      return s !== void 0 && (n = [s[0] - e[0], s[1] - e[1]], hh(n, t - this.getRotation()), W0(n, e)), n;
    }
    /**
     * @param {number} resolution Target resolution.
     * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
     * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
     */
    calculateCenterZoom(t, e) {
      let n;
      const s = this.getCenterInternal(), r = this.getResolution();
      if (s !== void 0 && r !== void 0) {
        const a = e[0] - t * (e[0] - s[0]) / r, o = e[1] - t * (e[1] - s[1]) / r;
        n = [a, o];
      }
      return n;
    }
    /**
     * Returns the current viewport size.
     * @private
     * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
     * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
     */
    getViewportSize_(t) {
      const e = this.viewportSize_;
      if (t) {
        const n = e[0], s = e[1];
        return [
          Math.abs(n * Math.cos(t)) + Math.abs(s * Math.sin(t)),
          Math.abs(n * Math.sin(t)) + Math.abs(s * Math.cos(t))
        ];
      }
      return e;
    }
    /**
     * Stores the viewport size on the view. The viewport size is not read every time from the DOM
     * to avoid performance hit and layout reflow.
     * This should be done on map size change.
     * Note: the constraints are not resolved during an animation to avoid stopping it
     * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
     */
    setViewportSize(t) {
      this.viewportSize_ = Array.isArray(t) ? t.slice() : [100, 100], this.getAnimating() || this.resolveConstraints(0);
    }
    /**
     * Get the view center.
     * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
     * @observable
     * @api
     */
    getCenter() {
      const t = this.getCenterInternal();
      return t && Tl(t, this.getProjection());
    }
    /**
     * Get the view center without transforming to user projection.
     * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
     */
    getCenterInternal() {
      return (
        /** @type {import("./coordinate.js").Coordinate|undefined} */
        this.get(Ze.CENTER)
      );
    }
    /**
     * @return {Constraints} Constraints.
     */
    getConstraints() {
      return this.constraints_;
    }
    /**
     * @return {boolean} Resolution constraint is set
     */
    getConstrainResolution() {
      return this.get("constrainResolution");
    }
    /**
     * @param {Array<number>} [hints] Destination array.
     * @return {Array<number>} Hint.
     */
    getHints(t) {
      return t !== void 0 ? (t[0] = this.hints_[0], t[1] = this.hints_[1], t) : this.hints_.slice();
    }
    /**
     * Calculate the extent for the current view state and the passed box size.
     * @param {import("./size.js").Size} [size] The pixel dimensions of the box
     * into which the calculated extent should fit. Defaults to the size of the
     * map the view is associated with.
     * If no map or multiple maps are connected to the view, provide the desired
     * box size (e.g. `map.getSize()`).
     * @return {import("./extent.js").Extent} Extent.
     * @api
     */
    calculateExtent(t) {
      const e = this.calculateExtentInternal(t);
      return Td(e, this.getProjection());
    }
    /**
     * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
     * the map's last known viewport size will be used.
     * @return {import("./extent.js").Extent} Extent.
     */
    calculateExtentInternal(t) {
      t = t || this.getViewportSizeMinusPadding_();
      const e = (
        /** @type {!import("./coordinate.js").Coordinate} */
        this.getCenterInternal()
      );
      xt(e, "The view center is not defined");
      const n = (
        /** @type {!number} */
        this.getResolution()
      );
      xt(n !== void 0, "The view resolution is not defined");
      const s = (
        /** @type {!number} */
        this.getRotation()
      );
      return xt(s !== void 0, "The view rotation is not defined"), za(e, n, s, t);
    }
    /**
     * Get the maximum resolution of the view.
     * @return {number} The maximum resolution of the view.
     * @api
     */
    getMaxResolution() {
      return this.maxResolution_;
    }
    /**
     * Get the minimum resolution of the view.
     * @return {number} The minimum resolution of the view.
     * @api
     */
    getMinResolution() {
      return this.minResolution_;
    }
    /**
     * Get the maximum zoom level for the view.
     * @return {number} The maximum zoom level.
     * @api
     */
    getMaxZoom() {
      return (
        /** @type {number} */
        this.getZoomForResolution(this.minResolution_)
      );
    }
    /**
     * Set a new maximum zoom level for the view.
     * @param {number} zoom The maximum zoom level.
     * @api
     */
    setMaxZoom(t) {
      this.applyOptions_(this.getUpdatedOptions_({ maxZoom: t }));
    }
    /**
     * Get the minimum zoom level for the view.
     * @return {number} The minimum zoom level.
     * @api
     */
    getMinZoom() {
      return (
        /** @type {number} */
        this.getZoomForResolution(this.maxResolution_)
      );
    }
    /**
     * Set a new minimum zoom level for the view.
     * @param {number} zoom The minimum zoom level.
     * @api
     */
    setMinZoom(t) {
      this.applyOptions_(this.getUpdatedOptions_({ minZoom: t }));
    }
    /**
     * Set whether the view should allow intermediary zoom levels.
     * @param {boolean} enabled Whether the resolution is constrained.
     * @api
     */
    setConstrainResolution(t) {
      this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: t }));
    }
    /**
     * Get the view projection.
     * @return {import("./proj/Projection.js").default} The projection of the view.
     * @api
     */
    getProjection() {
      return this.projection_;
    }
    /**
     * Get the view resolution.
     * @return {number|undefined} The resolution of the view.
     * @observable
     * @api
     */
    getResolution() {
      return (
        /** @type {number|undefined} */
        this.get(Ze.RESOLUTION)
      );
    }
    /**
     * Get the resolutions for the view. This returns the array of resolutions
     * passed to the constructor of the View, or undefined if none were given.
     * @return {Array<number>|undefined} The resolutions of the view.
     * @api
     */
    getResolutions() {
      return this.resolutions_;
    }
    /**
     * Get the resolution for a provided extent (in map units) and size (in pixels).
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {import("./size.js").Size} [size] Box pixel size.
     * @return {number} The resolution at which the provided extent will render at
     *     the given size.
     * @api
     */
    getResolutionForExtent(t, e) {
      return this.getResolutionForExtentInternal(
        Wi(t, this.getProjection()),
        e
      );
    }
    /**
     * Get the resolution for a provided extent (in map units) and size (in pixels).
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {import("./size.js").Size} [size] Box pixel size.
     * @return {number} The resolution at which the provided extent will render at
     *     the given size.
     */
    getResolutionForExtentInternal(t, e) {
      e = e || this.getViewportSizeMinusPadding_();
      const n = Mt(t) / e[0], s = te(t) / e[1];
      return Math.max(n, s);
    }
    /**
     * Return a function that returns a value between 0 and 1 for a
     * resolution. Exponential scaling is assumed.
     * @param {number} [power] Power.
     * @return {function(number): number} Resolution for value function.
     */
    getResolutionForValueFunction(t) {
      t = t || 2;
      const e = this.getConstrainedResolution(this.maxResolution_), n = this.minResolution_, s = Math.log(e / n) / Math.log(t);
      return (
        /**
         * @param {number} value Value.
         * @return {number} Resolution.
         */
        function(r) {
          return e / Math.pow(t, r * s);
        }
      );
    }
    /**
     * Get the view rotation.
     * @return {number} The rotation of the view in radians.
     * @observable
     * @api
     */
    getRotation() {
      return (
        /** @type {number} */
        this.get(Ze.ROTATION)
      );
    }
    /**
     * Return a function that returns a resolution for a value between
     * 0 and 1. Exponential scaling is assumed.
     * @param {number} [power] Power.
     * @return {function(number): number} Value for resolution function.
     */
    getValueForResolutionFunction(t) {
      const e = Math.log(t || 2), n = this.getConstrainedResolution(this.maxResolution_), s = this.minResolution_, r = Math.log(n / s) / e;
      return (
        /**
         * @param {number} resolution Resolution.
         * @return {number} Value.
         */
        function(a) {
          return Math.log(n / a) / e / r;
        }
      );
    }
    /**
     * Returns the size of the viewport minus padding.
     * @private
     * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
     * @return {import("./size.js").Size} Viewport size reduced by the padding.
     */
    getViewportSizeMinusPadding_(t) {
      let e = this.getViewportSize_(t);
      const n = this.padding_;
      return n && (e = [
        e[0] - n[1] - n[3],
        e[1] - n[0] - n[2]
      ]), e;
    }
    /**
     * @return {State} View state.
     */
    getState() {
      const t = this.getProjection(), e = this.getResolution(), n = this.getRotation();
      let s = (
        /** @type {import("./coordinate.js").Coordinate} */
        this.getCenterInternal()
      );
      const r = this.padding_;
      if (r) {
        const a = this.getViewportSizeMinusPadding_();
        s = Ko(
          s,
          this.getViewportSize_(),
          [a[0] / 2 + r[3], a[1] / 2 + r[0]],
          e,
          n
        );
      }
      return {
        center: s.slice(0),
        projection: t !== void 0 ? t : null,
        resolution: e,
        nextCenter: this.nextCenter_,
        nextResolution: this.nextResolution_,
        nextRotation: this.nextRotation_,
        rotation: n,
        zoom: this.getZoom()
      };
    }
    /**
     * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
     */
    getViewStateAndExtent() {
      return {
        viewState: this.getState(),
        extent: this.calculateExtent()
      };
    }
    /**
     * Get the current zoom level. This method may return non-integer zoom levels
     * if the view does not constrain the resolution, or if an interaction or
     * animation is underway.
     * @return {number|undefined} Zoom.
     * @api
     */
    getZoom() {
      let t;
      const e = this.getResolution();
      return e !== void 0 && (t = this.getZoomForResolution(e)), t;
    }
    /**
     * Get the zoom level for a resolution.
     * @param {number} resolution The resolution.
     * @return {number|undefined} The zoom level for the provided resolution.
     * @api
     */
    getZoomForResolution(t) {
      let e = this.minZoom_ || 0, n, s;
      if (this.resolutions_) {
        const r = jl(this.resolutions_, t, 1);
        e = r, n = this.resolutions_[r], r == this.resolutions_.length - 1 ? s = 2 : s = n / this.resolutions_[r + 1];
      } else
        n = this.maxResolution_, s = this.zoomFactor_;
      return e + Math.log(n / t) / Math.log(s);
    }
    /**
     * Get the resolution for a zoom level.
     * @param {number} zoom Zoom level.
     * @return {number} The view resolution for the provided zoom level.
     * @api
     */
    getResolutionForZoom(t) {
      var e;
      if ((e = this.resolutions_) != null && e.length) {
        if (this.resolutions_.length === 1)
          return this.resolutions_[0];
        const n = zt(
          Math.floor(t),
          0,
          this.resolutions_.length - 2
        ), s = this.resolutions_[n] / this.resolutions_[n + 1];
        return this.resolutions_[n] / Math.pow(s, zt(t - n, 0, 1));
      }
      return this.maxResolution_ / Math.pow(this.zoomFactor_, t - this.minZoom_);
    }
    /**
     * Fit the given geometry or extent based on the given map size and border.
     * The size is pixel dimensions of the box to fit the extent into.
     * In most cases you will want to use the map size, that is `map.getSize()`.
     * Takes care of the map angle.
     * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
     *     extent to fit the view to.
     * @param {FitOptions} [options] Options.
     * @api
     */
    fit(t, e) {
      let n;
      if (xt(
        Array.isArray(t) || typeof /** @type {?} */
        t.getSimplifiedGeometry == "function",
        "Invalid extent or geometry provided as `geometry`"
      ), Array.isArray(t)) {
        xt(
          !zs(t),
          "Cannot fit empty extent provided as `geometry`"
        );
        const s = Wi(t, this.getProjection());
        n = qc(s);
      } else if (t.getType() === "Circle") {
        const s = Wi(
          t.getExtent(),
          this.getProjection()
        );
        n = qc(s), n.rotate(this.getRotation(), Si(s));
      } else
        n = t;
      this.fitInternal(n, e);
    }
    /**
     * Calculate rotated extent
     * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
     * @return {import("./extent").Extent} The rotated extent for the geometry.
     */
    rotatedExtentForGeometry(t) {
      const e = this.getRotation(), n = Math.cos(e), s = Math.sin(-e), r = t.getFlatCoordinates(), a = t.getStride();
      let o = 1 / 0, l = 1 / 0, h = -1 / 0, c = -1 / 0;
      for (let u = 0, d = r.length; u < d; u += a) {
        const g = r[u] * n - r[u + 1] * s, _ = r[u] * s + r[u + 1] * n;
        o = Math.min(o, g), l = Math.min(l, _), h = Math.max(h, g), c = Math.max(c, _);
      }
      return [o, l, h, c];
    }
    /**
     * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
     * @param {FitOptions} [options] Options.
     */
    fitInternal(t, e) {
      e = e || {};
      let n = e.size;
      n || (n = this.getViewportSizeMinusPadding_());
      const s = e.padding !== void 0 ? e.padding : [0, 0, 0, 0], r = e.nearest !== void 0 ? e.nearest : !1;
      let a;
      e.minResolution !== void 0 ? a = e.minResolution : e.maxZoom !== void 0 ? a = this.getResolutionForZoom(e.maxZoom) : a = 0;
      const o = this.rotatedExtentForGeometry(t);
      let l = this.getResolutionForExtentInternal(o, [
        n[0] - s[1] - s[3],
        n[1] - s[0] - s[2]
      ]);
      l = isNaN(l) ? a : Math.max(l, a), l = this.getConstrainedResolution(l, r ? 0 : 1);
      const h = this.getRotation(), c = Math.sin(h), u = Math.cos(h), d = Si(o);
      d[0] += (s[1] - s[3]) / 2 * l, d[1] += (s[0] - s[2]) / 2 * l;
      const g = d[0] * u - d[1] * c, _ = d[1] * u + d[0] * c, y = this.getConstrainedCenter([g, _], l), E = e.callback ? e.callback : Is;
      e.duration !== void 0 ? this.animateInternal(
        {
          resolution: l,
          center: y,
          duration: e.duration,
          easing: e.easing
        },
        E
      ) : (this.targetResolution_ = l, this.targetCenter_ = y, this.applyTargetState_(!1, !0), ma(E, !0));
    }
    /**
     * Center on coordinate and view position.
     * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("./size.js").Size} size Box pixel size.
     * @param {import("./pixel.js").Pixel} position Position on the view to center on.
     * @api
     */
    centerOn(t, e, n) {
      this.centerOnInternal(
        pi(t, this.getProjection()),
        e,
        n
      );
    }
    /**
     * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("./size.js").Size} size Box pixel size.
     * @param {import("./pixel.js").Pixel} position Position on the view to center on.
     */
    centerOnInternal(t, e, n) {
      this.setCenterInternal(
        Ko(
          t,
          e,
          n,
          this.getResolution(),
          this.getRotation()
        )
      );
    }
    /**
     * Calculates the shift between map and viewport center.
     * @param {import("./coordinate.js").Coordinate} center Center.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {import("./size.js").Size} size Size.
     * @return {Array<number>|undefined} Center shift.
     */
    calculateCenterShift(t, e, n, s) {
      let r;
      const a = this.padding_;
      if (a && t) {
        const o = this.getViewportSizeMinusPadding_(-n), l = Ko(
          t,
          s,
          [o[0] / 2 + a[3], o[1] / 2 + a[0]],
          e,
          n
        );
        r = [
          t[0] - l[0],
          t[1] - l[1]
        ];
      }
      return r;
    }
    /**
     * @return {boolean} Is defined.
     */
    isDef() {
      return !!this.getCenterInternal() && this.getResolution() !== void 0;
    }
    /**
     * Adds relative coordinates to the center of the view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
     * @api
     */
    adjustCenter(t) {
      const e = Tl(this.targetCenter_, this.getProjection());
      this.setCenter([
        e[0] + t[0],
        e[1] + t[1]
      ]);
    }
    /**
     * Adds relative coordinates to the center of the view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
     */
    adjustCenterInternal(t) {
      const e = this.targetCenter_;
      this.setCenterInternal([
        e[0] + t[0],
        e[1] + t[1]
      ]);
    }
    /**
     * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} ratio The ratio to apply on the view resolution.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     * @api
     */
    adjustResolution(t, e) {
      e = e && pi(e, this.getProjection()), this.adjustResolutionInternal(t, e);
    }
    /**
     * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} ratio The ratio to apply on the view resolution.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     */
    adjustResolutionInternal(t, e) {
      const n = this.getAnimating() || this.getInteracting(), s = this.getViewportSize_(this.getRotation()), r = this.constraints_.resolution(
        this.targetResolution_ * t,
        0,
        s,
        n
      );
      e && (this.targetCenter_ = this.calculateCenterZoom(r, e)), this.targetResolution_ *= t, this.applyTargetState_();
    }
    /**
     * Adds a value to the view zoom level, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} delta Relative value to add to the zoom level.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     * @api
     */
    adjustZoom(t, e) {
      this.adjustResolution(Math.pow(this.zoomFactor_, -t), e);
    }
    /**
     * Adds a value to the view rotation, optionally using an anchor. Any rotation
     * constraint will apply.
     * @param {number} delta Relative value to add to the zoom rotation, in radians.
     * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
     * @api
     */
    adjustRotation(t, e) {
      e && (e = pi(e, this.getProjection())), this.adjustRotationInternal(t, e);
    }
    /**
     * @param {number} delta Relative value to add to the zoom rotation, in radians.
     * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
     */
    adjustRotationInternal(t, e) {
      const n = this.getAnimating() || this.getInteracting(), s = this.constraints_.rotation(
        this.targetRotation_ + t,
        n
      );
      e && (this.targetCenter_ = this.calculateCenterRotate(s, e)), this.targetRotation_ += t, this.applyTargetState_();
    }
    /**
     * Set the center of the current view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
     * @observable
     * @api
     */
    setCenter(t) {
      this.setCenterInternal(
        t && pi(t, this.getProjection())
      );
    }
    /**
     * Set the center using the view projection (not the user projection).
     * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
     */
    setCenterInternal(t) {
      this.targetCenter_ = t, this.applyTargetState_();
    }
    /**
     * @param {import("./ViewHint.js").default} hint Hint.
     * @param {number} delta Delta.
     * @return {number} New value.
     */
    setHint(t, e) {
      return this.hints_[t] += e, this.changed(), this.hints_[t];
    }
    /**
     * Set the resolution for this view. Any resolution constraint will apply.
     * @param {number|undefined} resolution The resolution of the view.
     * @observable
     * @api
     */
    setResolution(t) {
      this.targetResolution_ = t, this.applyTargetState_();
    }
    /**
     * Set the rotation for this view. Any rotation constraint will apply.
     * @param {number} rotation The rotation of the view in radians.
     * @observable
     * @api
     */
    setRotation(t) {
      this.targetRotation_ = t, this.applyTargetState_();
    }
    /**
     * Zoom to a specific zoom level. Any resolution constrain will apply.
     * @param {number} zoom Zoom level.
     * @api
     */
    setZoom(t) {
      this.setResolution(this.getResolutionForZoom(t));
    }
    /**
     * Recompute rotation/resolution/center based on target values.
     * Note: we have to compute rotation first, then resolution and center considering that
     * parameters can influence one another in case a view extent constraint is present.
     * @param {boolean} [doNotCancelAnims] Do not cancel animations.
     * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
     * @private
     */
    applyTargetState_(t, e) {
      const n = this.getAnimating() || this.getInteracting() || e, s = this.constraints_.rotation(
        this.targetRotation_,
        n
      ), r = this.getViewportSize_(s), a = this.constraints_.resolution(
        this.targetResolution_,
        0,
        r,
        n
      ), o = this.constraints_.center(
        this.targetCenter_,
        a,
        r,
        n,
        this.calculateCenterShift(
          this.targetCenter_,
          a,
          s,
          r
        )
      );
      this.get(Ze.ROTATION) !== s && this.set(Ze.ROTATION, s), this.get(Ze.RESOLUTION) !== a && (this.set(Ze.RESOLUTION, a), this.set("zoom", this.getZoom(), !0)), (!o || !this.get(Ze.CENTER) || !$a(this.get(Ze.CENTER), o)) && this.set(Ze.CENTER, o), this.getAnimating() && !t && this.cancelAnimations(), this.cancelAnchor_ = void 0;
    }
    /**
     * If any constraints need to be applied, an animation will be triggered.
     * This is typically done on interaction end.
     * Note: calling this with a duration of 0 will apply the constrained values straight away,
     * without animation.
     * @param {number} [duration] The animation duration in ms.
     * @param {number} [resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     */
    resolveConstraints(t, e, n) {
      t = t !== void 0 ? t : 200;
      const s = e || 0, r = this.constraints_.rotation(this.targetRotation_), a = this.getViewportSize_(r), o = this.constraints_.resolution(
        this.targetResolution_,
        s,
        a
      ), l = this.constraints_.center(
        this.targetCenter_,
        o,
        a,
        !1,
        this.calculateCenterShift(
          this.targetCenter_,
          o,
          r,
          a
        )
      );
      if (t === 0 && !this.cancelAnchor_) {
        this.targetResolution_ = o, this.targetRotation_ = r, this.targetCenter_ = l, this.applyTargetState_();
        return;
      }
      n = n || (t === 0 ? this.cancelAnchor_ : void 0), this.cancelAnchor_ = void 0, (this.getResolution() !== o || this.getRotation() !== r || !this.getCenterInternal() || !$a(this.getCenterInternal(), l)) && (this.getAnimating() && this.cancelAnimations(), this.animateInternal({
        rotation: r,
        center: l,
        resolution: o,
        duration: t,
        easing: $s,
        anchor: n
      }));
    }
    /**
     * Notify the View that an interaction has started.
     * The view state will be resolved to a stable one if needed
     * (depending on its constraints).
     * @api
     */
    beginInteraction() {
      this.resolveConstraints(0), this.setHint(oe.INTERACTING, 1);
    }
    /**
     * Notify the View that an interaction has ended. The view state will be resolved
     * to a stable one if needed (depending on its constraints).
     * @param {number} [duration] Animation duration in ms.
     * @param {number} [resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     * @api
     */
    endInteraction(t, e, n) {
      n = n && pi(n, this.getProjection()), this.endInteractionInternal(t, e, n);
    }
    /**
     * Notify the View that an interaction has ended. The view state will be resolved
     * to a stable one if needed (depending on its constraints).
     * @param {number} [duration] Animation duration in ms.
     * @param {number} [resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     */
    endInteractionInternal(t, e, n) {
      this.getInteracting() && (this.setHint(oe.INTERACTING, -1), this.resolveConstraints(t, e, n));
    }
    /**
     * Get a valid position for the view center according to the current constraints.
     * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
     * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
     * This is useful to guess a valid center position at a different zoom level.
     * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
     */
    getConstrainedCenter(t, e) {
      const n = this.getViewportSize_(this.getRotation());
      return this.constraints_.center(
        t,
        e || this.getResolution(),
        n
      );
    }
    /**
     * Get a valid zoom level according to the current view constraints.
     * @param {number|undefined} targetZoom Target zoom.
     * @param {number} [direction] Indicate which resolution should be used
     * by a renderer if the view resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @return {number|undefined} Valid zoom level.
     */
    getConstrainedZoom(t, e) {
      const n = this.getResolutionForZoom(t);
      return this.getZoomForResolution(
        this.getConstrainedResolution(n, e)
      );
    }
    /**
     * Get a valid resolution according to the current view constraints.
     * @param {number|undefined} targetResolution Target resolution.
     * @param {number} [direction] Indicate which resolution should be used
     * by a renderer if the view resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @return {number|undefined} Valid resolution.
     */
    getConstrainedResolution(t, e) {
      e = e || 0;
      const n = this.getViewportSize_(this.getRotation());
      return this.constraints_.resolution(t, e, n);
    }
  }
  function ma(i, t) {
    setTimeout(function() {
      i(t);
    }, 0);
  }
  function Jm(i) {
    if (i.extent !== void 0) {
      const e = i.smoothExtentConstraint !== void 0 ? i.smoothExtentConstraint : !0;
      return Lc(i.extent, i.constrainOnlyCenter, e);
    }
    const t = gh(i.projection, "EPSG:3857");
    if (i.multiWorld !== !0 && t.isGlobal()) {
      const e = t.getExtent().slice();
      return e[0] = -1 / 0, e[2] = 1 / 0, Lc(e, !1, !1);
    }
    return L0;
  }
  function Qm(i) {
    let t, e, n, a = i.minZoom !== void 0 ? i.minZoom : qo, o = i.maxZoom !== void 0 ? i.maxZoom : 28;
    const l = i.zoomFactor !== void 0 ? i.zoomFactor : 2, h = i.multiWorld !== void 0 ? i.multiWorld : !1, c = i.smoothResolutionConstraint !== void 0 ? i.smoothResolutionConstraint : !0, u = i.showFullExtent !== void 0 ? i.showFullExtent : !1, d = gh(i.projection, "EPSG:3857"), g = d.getExtent();
    let _ = i.constrainOnlyCenter, y = i.extent;
    if (!h && !y && d.isGlobal() && (_ = !1, y = g), i.resolutions !== void 0) {
      const E = i.resolutions;
      e = E[a], n = E[o] !== void 0 ? E[o] : E[E.length - 1], i.constrainResolution ? t = qm(
        E,
        c,
        !_ && y,
        u
      ) : t = Kc(
        e,
        n,
        c,
        !_ && y,
        u
      );
    } else {
      const M = (g ? Math.max(Mt(g), te(g)) : (
        // use an extent that can fit the whole world if need be
        360 * ch.degrees / d.getMetersPerUnit()
      )) / Ah / Math.pow(2, qo), w = M / Math.pow(2, 28 - qo);
      e = i.maxResolution, e !== void 0 ? a = 0 : e = M / Math.pow(l, a), n = i.minResolution, n === void 0 && (i.maxZoom !== void 0 ? i.maxResolution !== void 0 ? n = e / Math.pow(l, o) : n = M / Math.pow(l, o) : n = w), o = a + Math.floor(
        Math.log(e / n) / Math.log(l)
      ), n = e / Math.pow(l, o - a), i.constrainResolution ? t = Km(
        l,
        e,
        n,
        c,
        !_ && y,
        u
      ) : t = Kc(
        e,
        n,
        c,
        !_ && y,
        u
      );
    }
    return {
      constraint: t,
      maxResolution: e,
      minResolution: n,
      minZoom: a,
      zoomFactor: l
    };
  }
  function t_(i) {
    if (i.enableRotation !== void 0 ? i.enableRotation : !0) {
      const e = i.constrainRotation;
      return e === void 0 || e === !0 ? jm() : e === !1 ? Vc : typeof e == "number" ? Vm(e) : Vc;
    }
    return Th;
  }
  function e_(i) {
    return !(i.sourceCenter && i.targetCenter && !$a(i.sourceCenter, i.targetCenter) || i.sourceResolution !== i.targetResolution || i.sourceRotation !== i.targetRotation);
  }
  function Ko(i, t, e, n, s) {
    const r = Math.cos(-s);
    let a = Math.sin(-s), o = i[0] * r - i[1] * a, l = i[1] * r + i[0] * a;
    o += (t[0] / 2 - e[0]) * n, l += (e[1] - t[1] / 2) * n, a = -a;
    const h = o * r - l * a, c = l * r + o * a;
    return [h, c];
  }
  const _a = "ol-hidden", i_ = "ol-selectable", So = "ol-unselectable", bh = "ol-control", jc = "ol-collapsed", n_ = new RegExp(
    [
      "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
      "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
      "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
      "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
      "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
      "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
      `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
    ].join(""),
    "i"
  ), Hc = [
    "style",
    "variant",
    "weight",
    "size",
    "lineHeight",
    "family"
  ], Ud = function(i) {
    const t = i.match(n_);
    if (!t)
      return null;
    const e = (
      /** @type {FontParameters} */
      {
        lineHeight: "normal",
        size: "1.2em",
        style: "normal",
        weight: "normal",
        variant: "normal"
      }
    );
    for (let n = 0, s = Hc.length; n < s; ++n) {
      const r = t[n + 1];
      r !== void 0 && (e[Hc[n]] = r);
    }
    return e.families = e.family.split(/,\s?/), e;
  };
  function Kt(i, t, e, n) {
    let s;
    return e && e.length ? s = /** @type {HTMLCanvasElement} */
    e.shift() : Jl ? s = new OffscreenCanvas(i || 300, t || 300) : s = document.createElement("canvas"), i && (s.width = i), t && (s.height = t), /** @type {CanvasRenderingContext2D} */
    s.getContext("2d", n);
  }
  let Vo;
  function Xa() {
    return Vo || (Vo = Kt(1, 1)), Vo;
  }
  function Co(i) {
    const t = i.canvas;
    t.width = 1, t.height = 1, i.clearRect(0, 0, 1, 1);
  }
  function s_(i) {
    let t = i.offsetWidth;
    const e = getComputedStyle(i);
    return t += parseInt(e.marginLeft, 10) + parseInt(e.marginRight, 10), t;
  }
  function r_(i) {
    let t = i.offsetHeight;
    const e = getComputedStyle(i);
    return t += parseInt(e.marginTop, 10) + parseInt(e.marginBottom, 10), t;
  }
  function Jc(i, t) {
    const e = t.parentNode;
    e && e.replaceChild(i, t);
  }
  function Bd(i) {
    for (; i.lastChild; )
      i.lastChild.remove();
  }
  function a_(i, t) {
    const e = i.childNodes;
    for (let n = 0; ; ++n) {
      const s = e[n], r = t[n];
      if (!s && !r)
        break;
      if (s !== r) {
        if (!s) {
          i.appendChild(r);
          continue;
        }
        if (!r) {
          i.removeChild(s), --n;
          continue;
        }
        i.insertBefore(r, s);
      }
    }
  }
  class Ph extends Qe {
    /**
     * @param {Options} options Control options.
     */
    constructor(t) {
      super();
      const e = t.element;
      e && !t.target && !e.style.pointerEvents && (e.style.pointerEvents = "auto"), this.element = e || null, this.target_ = null, this.map_ = null, this.listenerKeys = [], t.render && (this.render = t.render), t.target && this.setTarget(t.target);
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      var t;
      (t = this.element) == null || t.remove(), super.disposeInternal();
    }
    /**
     * Get the map associated with this control.
     * @return {import("../Map.js").default|null} Map.
     * @api
     */
    getMap() {
      return this.map_;
    }
    /**
     * Remove the control from its current map and attach it to the new map.
     * Pass `null` to just remove the control from the current map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../Map.js").default|null} map Map.
     * @api
     */
    setMap(t) {
      var e;
      this.map_ && ((e = this.element) == null || e.remove());
      for (let n = 0, s = this.listenerKeys.length; n < s; ++n)
        Pt(this.listenerKeys[n]);
      if (this.listenerKeys.length = 0, this.map_ = t, t) {
        const n = this.target_ ?? t.getOverlayContainerStopEvent();
        this.element && n.appendChild(this.element), this.render !== Is && this.listenerKeys.push(
          vt(t, vi.POSTRENDER, this.render, this)
        ), t.render();
      }
    }
    /**
     * Renders the control.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @api
     */
    render(t) {
    }
    /**
     * This function is used to set a target element for the control. It has no
     * effect if it is called after the control has been added to the map (i.e.
     * after `setMap` is called on the control). If no `target` is set in the
     * options passed to the control constructor and if `setTarget` is not called
     * then the control is added to the map's overlay container.
     * @param {HTMLElement|string} target Target.
     * @api
     */
    setTarget(t) {
      this.target_ = typeof t == "string" ? document.getElementById(t) : t;
    }
  }
  class o_ extends Ph {
    /**
     * @param {Options} [options] Attribution options.
     */
    constructor(t) {
      t = t || {}, super({
        element: document.createElement("div"),
        render: t.render,
        target: t.target
      }), this.ulElement_ = document.createElement("ul"), this.collapsed_ = t.collapsed !== void 0 ? t.collapsed : !0, this.userCollapsed_ = this.collapsed_, this.overrideCollapsible_ = t.collapsible !== void 0, this.collapsible_ = t.collapsible !== void 0 ? t.collapsible : !0, this.collapsible_ || (this.collapsed_ = !1), this.attributions_ = t.attributions;
      const e = t.className !== void 0 ? t.className : "ol-attribution", n = t.tipLabel !== void 0 ? t.tipLabel : "Attributions", s = t.expandClassName !== void 0 ? t.expandClassName : e + "-expand", r = t.collapseLabel !== void 0 ? t.collapseLabel : "", a = t.collapseClassName !== void 0 ? t.collapseClassName : e + "-collapse";
      typeof r == "string" ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = r, this.collapseLabel_.className = a) : this.collapseLabel_ = r;
      const o = t.label !== void 0 ? t.label : "i";
      typeof o == "string" ? (this.label_ = document.createElement("span"), this.label_.textContent = o, this.label_.className = s) : this.label_ = o;
      const l = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
      this.toggleButton_ = document.createElement("button"), this.toggleButton_.setAttribute("type", "button"), this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_)), this.toggleButton_.title = n, this.toggleButton_.appendChild(l), this.toggleButton_.addEventListener(
        at.CLICK,
        this.handleClick_.bind(this),
        !1
      );
      const h = e + " " + So + " " + bh + (this.collapsed_ && this.collapsible_ ? " " + jc : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), c = this.element;
      c.className = h, c.appendChild(this.toggleButton_), c.appendChild(this.ulElement_), this.renderedAttributions_ = [], this.renderedVisible_ = !0;
    }
    /**
     * Collect a list of visible attributions and set the collapsible state.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @return {Array<string>} Attributions.
     * @private
     */
    collectSourceAttributions_(t) {
      const e = this.getMap().getAllLayers(), n = new Set(
        e.flatMap((s) => s.getAttributions(t))
      );
      if (this.attributions_ !== void 0 && (Array.isArray(this.attributions_) ? this.attributions_.forEach((s) => n.add(s)) : n.add(this.attributions_)), !this.overrideCollapsible_) {
        const s = !e.some(
          (r) => {
            var a;
            return ((a = r.getSource()) == null ? void 0 : a.getAttributionsCollapsible()) === !1;
          }
        );
        this.setCollapsible(s);
      }
      return Array.from(n);
    }
    /**
     * @private
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     */
    async updateElement_(t) {
      if (!t) {
        this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1);
        return;
      }
      const e = await Promise.all(
        this.collectSourceAttributions_(t).map(
          (s) => E0(() => s)
        )
      ), n = e.length > 0;
      if (this.renderedVisible_ != n && (this.element.style.display = n ? "" : "none", this.renderedVisible_ = n), !rn(e, this.renderedAttributions_)) {
        Bd(this.ulElement_);
        for (let s = 0, r = e.length; s < r; ++s) {
          const a = document.createElement("li");
          a.innerHTML = e[s], this.ulElement_.appendChild(a);
        }
        this.renderedAttributions_ = e;
      }
    }
    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */
    handleClick_(t) {
      t.preventDefault(), this.handleToggle_(), this.userCollapsed_ = this.collapsed_;
    }
    /**
     * @private
     */
    handleToggle_() {
      this.element.classList.toggle(jc), this.collapsed_ ? Jc(this.collapseLabel_, this.label_) : Jc(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_, this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
    }
    /**
     * Return `true` if the attribution is collapsible, `false` otherwise.
     * @return {boolean} True if the widget is collapsible.
     * @api
     */
    getCollapsible() {
      return this.collapsible_;
    }
    /**
     * Set whether the attribution should be collapsible.
     * @param {boolean} collapsible True if the widget is collapsible.
     * @api
     */
    setCollapsible(t) {
      this.collapsible_ !== t && (this.collapsible_ = t, this.element.classList.toggle("ol-uncollapsible"), this.userCollapsed_ && this.handleToggle_());
    }
    /**
     * Collapse or expand the attribution according to the passed parameter. Will
     * not do anything if the attribution isn't collapsible or if the current
     * collapsed state is already the one requested.
     * @param {boolean} collapsed True if the widget is collapsed.
     * @api
     */
    setCollapsed(t) {
      this.userCollapsed_ = t, !(!this.collapsible_ || this.collapsed_ === t) && this.handleToggle_();
    }
    /**
     * Return `true` when the attribution is currently collapsed or `false`
     * otherwise.
     * @return {boolean} True if the widget is collapsed.
     * @api
     */
    getCollapsed() {
      return this.collapsed_;
    }
    /**
     * Update the attribution element.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @override
     */
    render(t) {
      this.updateElement_(t.frameState);
    }
  }
  class l_ extends Ph {
    /**
     * @param {Options} [options] Rotate options.
     */
    constructor(t) {
      t = t || {}, super({
        element: document.createElement("div"),
        render: t.render,
        target: t.target
      });
      const e = t.className !== void 0 ? t.className : "ol-rotate", n = t.label !== void 0 ? t.label : "", s = t.compassClassName !== void 0 ? t.compassClassName : "ol-compass";
      this.label_ = null, typeof n == "string" ? (this.label_ = document.createElement("span"), this.label_.className = s, this.label_.textContent = n) : (this.label_ = n, this.label_.classList.add(s));
      const r = t.tipLabel ? t.tipLabel : "Reset rotation", a = document.createElement("button");
      a.className = e + "-reset", a.setAttribute("type", "button"), a.title = r, a.appendChild(this.label_), a.addEventListener(
        at.CLICK,
        this.handleClick_.bind(this),
        !1
      );
      const o = e + " " + So + " " + bh, l = this.element;
      l.className = o, l.appendChild(a), this.callResetNorth_ = t.resetNorth ? t.resetNorth : void 0, this.duration_ = t.duration !== void 0 ? t.duration : 250, this.autoHide_ = t.autoHide !== void 0 ? t.autoHide : !0, this.rotation_ = void 0, this.autoHide_ && this.element.classList.add(_a);
    }
    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */
    handleClick_(t) {
      t.preventDefault(), this.callResetNorth_ !== void 0 ? this.callResetNorth_() : this.resetNorth_();
    }
    /**
     * @private
     */
    resetNorth_() {
      const e = this.getMap().getView();
      if (!e)
        return;
      const n = e.getRotation();
      n !== void 0 && (this.duration_ > 0 && n % (2 * Math.PI) !== 0 ? e.animate({
        rotation: 0,
        duration: this.duration_,
        easing: $s
      }) : e.setRotation(0));
    }
    /**
     * Update the rotate control element.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @override
     */
    render(t) {
      const e = t.frameState;
      if (!e)
        return;
      const n = e.viewState.rotation;
      if (n != this.rotation_) {
        const s = "rotate(" + n + "rad)";
        if (this.autoHide_) {
          const r = this.element.classList.contains(_a);
          !r && n === 0 ? this.element.classList.add(_a) : r && n !== 0 && this.element.classList.remove(_a);
        }
        this.label_.style.transform = s;
      }
      this.rotation_ = n;
    }
  }
  class h_ extends Ph {
    /**
     * @param {Options} [options] Zoom options.
     */
    constructor(t) {
      t = t || {}, super({
        element: document.createElement("div"),
        target: t.target
      });
      const e = t.className !== void 0 ? t.className : "ol-zoom", n = t.delta !== void 0 ? t.delta : 1, s = t.zoomInClassName !== void 0 ? t.zoomInClassName : e + "-in", r = t.zoomOutClassName !== void 0 ? t.zoomOutClassName : e + "-out", a = t.zoomInLabel !== void 0 ? t.zoomInLabel : "+", o = t.zoomOutLabel !== void 0 ? t.zoomOutLabel : "", l = t.zoomInTipLabel !== void 0 ? t.zoomInTipLabel : "Zoom in", h = t.zoomOutTipLabel !== void 0 ? t.zoomOutTipLabel : "Zoom out", c = document.createElement("button");
      c.className = s, c.setAttribute("type", "button"), c.title = l, c.appendChild(
        typeof a == "string" ? document.createTextNode(a) : a
      ), c.addEventListener(
        at.CLICK,
        this.handleClick_.bind(this, n),
        !1
      );
      const u = document.createElement("button");
      u.className = r, u.setAttribute("type", "button"), u.title = h, u.appendChild(
        typeof o == "string" ? document.createTextNode(o) : o
      ), u.addEventListener(
        at.CLICK,
        this.handleClick_.bind(this, -n),
        !1
      );
      const d = e + " " + So + " " + bh, g = this.element;
      g.className = d, g.appendChild(c), g.appendChild(u), this.duration_ = t.duration !== void 0 ? t.duration : 250;
    }
    /**
     * @param {number} delta Zoom delta.
     * @param {MouseEvent} event The event to handle
     * @private
     */
    handleClick_(t, e) {
      e.preventDefault(), this.zoomByDelta_(t);
    }
    /**
     * @param {number} delta Zoom delta.
     * @private
     */
    zoomByDelta_(t) {
      const n = this.getMap().getView();
      if (!n)
        return;
      const s = n.getZoom();
      if (s !== void 0) {
        const r = n.getConstrainedZoom(s + t);
        this.duration_ > 0 ? (n.getAnimating() && n.cancelAnimations(), n.animate({
          zoom: r,
          duration: this.duration_,
          easing: $s
        })) : n.setZoom(r);
      }
    }
  }
  function c_(i) {
    i = i || {};
    const t = new ni();
    return (i.zoom !== void 0 ? i.zoom : !0) && t.push(new h_(i.zoomOptions)), (i.rotate !== void 0 ? i.rotate : !0) && t.push(new l_(i.rotateOptions)), (i.attribution !== void 0 ? i.attribution : !0) && t.push(new o_(i.attributionOptions)), t;
  }
  class u_ {
    /**
     * @param {number} decay Rate of decay (must be negative).
     * @param {number} minVelocity Minimum velocity (pixels/millisecond).
     * @param {number} delay Delay to consider to calculate the kinetic
     *     initial values (milliseconds).
     */
    constructor(t, e, n) {
      this.decay_ = t, this.minVelocity_ = e, this.delay_ = n, this.points_ = [], this.angle_ = 0, this.initialVelocity_ = 0;
    }
    /**
     * FIXME empty description for jsdoc
     */
    begin() {
      this.points_.length = 0, this.angle_ = 0, this.initialVelocity_ = 0;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     */
    update(t, e) {
      this.points_.push(t, e, Date.now());
    }
    /**
     * @return {boolean} Whether we should do kinetic animation.
     */
    end() {
      if (this.points_.length < 6)
        return !1;
      const t = Date.now() - this.delay_, e = this.points_.length - 3;
      if (this.points_[e + 2] < t)
        return !1;
      let n = e - 3;
      for (; n > 0 && this.points_[n + 2] > t; )
        n -= 3;
      const s = this.points_[e + 2] - this.points_[n + 2];
      if (s < 1e3 / 60)
        return !1;
      const r = this.points_[e] - this.points_[n], a = this.points_[e + 1] - this.points_[n + 1];
      return this.angle_ = Math.atan2(a, r), this.initialVelocity_ = Math.sqrt(r * r + a * a) / s, this.initialVelocity_ > this.minVelocity_;
    }
    /**
     * @return {number} Total distance travelled (pixels).
     */
    getDistance() {
      return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
    }
    /**
     * @return {number} Angle of the kinetic panning animation (radians).
     */
    getAngle() {
      return this.angle_;
    }
  }
  const Qc = {
    ACTIVE: "active"
  };
  class Br extends Qe {
    /**
     * @param {InteractionOptions} [options] Options.
     */
    constructor(t) {
      super(), this.on, this.once, this.un, t && t.handleEvent && (this.handleEvent = t.handleEvent), this.map_ = null, this.setActive(!0);
    }
    /**
     * Return whether the interaction is currently active.
     * @return {boolean} `true` if the interaction is active, `false` otherwise.
     * @observable
     * @api
     */
    getActive() {
      return (
        /** @type {boolean} */
        this.get(Qc.ACTIVE)
      );
    }
    /**
     * Get the map associated with this interaction.
     * @return {import("../Map.js").default|null} Map.
     * @api
     */
    getMap() {
      return this.map_;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @api
     */
    handleEvent(t) {
      return !0;
    }
    /**
     * Activate or deactivate the interaction.
     * @param {boolean} active Active.
     * @observable
     * @api
     */
    setActive(t) {
      this.set(Qc.ACTIVE, t);
    }
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../Map.js").default|null} map Map.
     */
    setMap(t) {
      this.map_ = t;
    }
  }
  function d_(i, t, e) {
    const n = i.getCenterInternal();
    if (n) {
      const s = [n[0] + t[0], n[1] + t[1]];
      i.animateInternal({
        duration: e !== void 0 ? e : 250,
        easing: Z0,
        center: i.getConstrainedCenter(s)
      });
    }
  }
  function Lh(i, t, e, n) {
    const s = i.getZoom();
    if (s === void 0)
      return;
    const r = i.getConstrainedZoom(s + t), a = i.getResolutionForZoom(r);
    i.getAnimating() && i.cancelAnimations(), i.animate({
      resolution: a,
      anchor: e,
      duration: n !== void 0 ? n : 250,
      easing: $s
    });
  }
  class f_ extends Br {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      super(), t = t || {}, this.delta_ = t.delta ? t.delta : 1, this.duration_ = t.duration !== void 0 ? t.duration : 250;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
     * doubleclick) and eventually zooms the map.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @override
     */
    handleEvent(t) {
      let e = !1;
      if (t.type == Gt.DBLCLICK) {
        const n = (
          /** @type {MouseEvent} */
          t.originalEvent
        ), s = t.map, r = t.coordinate, a = n.shiftKey ? -this.delta_ : this.delta_, o = s.getView();
        Lh(o, a, r, this.duration_), n.preventDefault(), e = !0;
      }
      return !e;
    }
  }
  function Pl(i) {
    const t = arguments;
    return function(e) {
      let n = !0;
      for (let s = 0, r = t.length; s < r && (n = n && t[s](e), !!n); ++s)
        ;
      return n;
    };
  }
  const g_ = function(i) {
    const t = (
      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
      i.originalEvent
    );
    return t.altKey && !(t.metaKey || t.ctrlKey) && t.shiftKey;
  }, m_ = function(i) {
    const t = i.map.getTargetElement(), e = t.getRootNode(), n = i.map.getOwnerDocument().activeElement;
    return e instanceof ShadowRoot ? e.host.contains(n) : t.contains(n);
  }, Wd = function(i) {
    const t = i.map.getTargetElement(), e = t.getRootNode();
    return (e instanceof ShadowRoot ? e.host : t).hasAttribute("tabindex") ? m_(i) : !0;
  }, __ = Mr, Xd = function(i) {
    const t = (
      /** @type {MouseEvent} */
      i.originalEvent
    );
    return t.button == 0 && !(ud && Hl && t.ctrlKey);
  }, Yd = function(i) {
    const t = (
      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
      i.originalEvent
    );
    return !t.altKey && !(t.metaKey || t.ctrlKey) && !t.shiftKey;
  }, p_ = function(i) {
    const t = (
      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
      i.originalEvent
    );
    return Hl ? t.metaKey : t.ctrlKey;
  }, y_ = function(i) {
    const t = (
      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
      i.originalEvent
    );
    return !t.altKey && !(t.metaKey || t.ctrlKey) && t.shiftKey;
  }, Zd = function(i) {
    const t = (
      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
      i.originalEvent
    ), e = (
      /** @type {Element} */
      t.target.tagName
    );
    return e !== "INPUT" && e !== "SELECT" && e !== "TEXTAREA" && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
    // different type like `SVGElement`.
    // @ts-ignore
    !t.target.isContentEditable;
  }, jo = function(i) {
    const t = (
      /** @type {import("../MapBrowserEvent").default} */
      i.originalEvent
    );
    return xt(
      t !== void 0,
      "mapBrowserEvent must originate from a pointer event"
    ), t.pointerType == "mouse";
  }, v_ = function(i) {
    const t = (
      /** @type {import("../MapBrowserEvent").default} */
      i.originalEvent
    );
    return xt(
      t !== void 0,
      "mapBrowserEvent must originate from a pointer event"
    ), t.isPrimary && t.button === 0;
  };
  class Wr extends Br {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      t = t || {}, super(
        /** @type {import("./Interaction.js").InteractionOptions} */
        t
      ), t.handleDownEvent && (this.handleDownEvent = t.handleDownEvent), t.handleDragEvent && (this.handleDragEvent = t.handleDragEvent), t.handleMoveEvent && (this.handleMoveEvent = t.handleMoveEvent), t.handleUpEvent && (this.handleUpEvent = t.handleUpEvent), t.stopDown && (this.stopDown = t.stopDown), this.handlingDownUpSequence = !1, this.targetPointers = [];
    }
    /**
     * Returns the current number of pointers involved in the interaction,
     * e.g. `2` when two fingers are used.
     * @return {number} The number of pointers.
     * @api
     */
    getPointerCount() {
      return this.targetPointers.length;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @protected
     */
    handleDownEvent(t) {
      return !1;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @protected
     */
    handleDragEvent(t) {
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
     * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
     * detected.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @api
     * @override
     */
    handleEvent(t) {
      if (!t.originalEvent)
        return !0;
      let e = !1;
      if (this.updateTrackedPointers_(t), this.handlingDownUpSequence) {
        if (t.type == Gt.POINTERDRAG)
          this.handleDragEvent(t), t.originalEvent.preventDefault();
        else if (t.type == Gt.POINTERUP) {
          const n = this.handleUpEvent(t);
          this.handlingDownUpSequence = n && this.targetPointers.length > 0;
        }
      } else if (t.type == Gt.POINTERDOWN) {
        const n = this.handleDownEvent(t);
        this.handlingDownUpSequence = n, e = this.stopDown(n);
      } else t.type == Gt.POINTERMOVE && this.handleMoveEvent(t);
      return !e;
    }
    /**
     * Handle pointer move events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @protected
     */
    handleMoveEvent(t) {
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @protected
     */
    handleUpEvent(t) {
      return !1;
    }
    /**
     * This function is used to determine if "down" events should be propagated
     * to other interactions or should be stopped.
     * @param {boolean} handled Was the event handled by the interaction?
     * @return {boolean} Should the `down` event be stopped?
     */
    stopDown(t) {
      return t;
    }
    /**
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @private
     */
    updateTrackedPointers_(t) {
      t.activePointers && (this.targetPointers = t.activePointers);
    }
  }
  function Oh(i) {
    const t = i.length;
    let e = 0, n = 0;
    for (let s = 0; s < t; s++)
      e += i[s].clientX, n += i[s].clientY;
    return { clientX: e / t, clientY: n / t };
  }
  class E_ extends Wr {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      super({
        stopDown: lo
      }), t = t || {}, this.kinetic_ = t.kinetic, this.lastCentroid = null, this.lastPointersCount_, this.panning_ = !1;
      const e = t.condition ? t.condition : Pl(Yd, v_);
      this.condition_ = t.onFocusOnly ? Pl(Wd, e) : e, this.noKinetic_ = !1;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @override
     */
    handleDragEvent(t) {
      const e = t.map;
      this.panning_ || (this.panning_ = !0, e.getView().beginInteraction());
      const n = this.targetPointers, s = e.getEventPixel(Oh(n));
      if (n.length == this.lastPointersCount_) {
        if (this.kinetic_ && this.kinetic_.update(s[0], s[1]), this.lastCentroid) {
          const r = [
            this.lastCentroid[0] - s[0],
            s[1] - this.lastCentroid[1]
          ], o = t.map.getView();
          X0(r, o.getResolution()), hh(r, o.getRotation()), o.adjustCenterInternal(r);
        }
      } else this.kinetic_ && this.kinetic_.begin();
      this.lastCentroid = s, this.lastPointersCount_ = n.length, t.originalEvent.preventDefault();
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleUpEvent(t) {
      const e = t.map, n = e.getView();
      if (this.targetPointers.length === 0) {
        if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
          const s = this.kinetic_.getDistance(), r = this.kinetic_.getAngle(), a = n.getCenterInternal(), o = e.getPixelFromCoordinateInternal(a), l = e.getCoordinateFromPixelInternal([
            o[0] - s * Math.cos(r),
            o[1] - s * Math.sin(r)
          ]);
          n.animateInternal({
            center: n.getConstrainedCenter(l),
            duration: 500,
            easing: $s
          });
        }
        return this.panning_ && (this.panning_ = !1, n.endInteraction()), !1;
      }
      return this.kinetic_ && this.kinetic_.begin(), this.lastCentroid = null, !0;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleDownEvent(t) {
      if (this.targetPointers.length > 0 && this.condition_(t)) {
        const n = t.map.getView();
        return this.lastCentroid = null, n.getAnimating() && n.cancelAnimations(), this.kinetic_ && this.kinetic_.begin(), this.noKinetic_ = this.targetPointers.length > 1, !0;
      }
      return !1;
    }
  }
  class M_ extends Wr {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      t = t || {}, super({
        stopDown: lo
      }), this.condition_ = t.condition ? t.condition : g_, this.lastAngle_ = void 0, this.duration_ = t.duration !== void 0 ? t.duration : 250;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @override
     */
    handleDragEvent(t) {
      if (!jo(t))
        return;
      const e = t.map, n = e.getView();
      if (n.getConstraints().rotation === Th)
        return;
      const s = e.getSize(), r = t.pixel, a = Math.atan2(s[1] / 2 - r[1], r[0] - s[0] / 2);
      if (this.lastAngle_ !== void 0) {
        const o = a - this.lastAngle_;
        n.adjustRotationInternal(-o);
      }
      this.lastAngle_ = a;
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleUpEvent(t) {
      return jo(t) ? (t.map.getView().endInteraction(this.duration_), !1) : !0;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleDownEvent(t) {
      return jo(t) && Xd(t) && this.condition_(t) ? (t.map.getView().beginInteraction(), this.lastAngle_ = void 0, !0) : !1;
    }
  }
  class x_ extends oo {
    /**
     * @param {string} className CSS class name.
     */
    constructor(t) {
      super(), this.geometry_ = null, this.element_ = document.createElement("div"), this.element_.style.position = "absolute", this.element_.style.pointerEvents = "auto", this.element_.className = "ol-box " + t, this.map_ = null, this.startPixel_ = null, this.endPixel_ = null;
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.setMap(null);
    }
    /**
     * @private
     */
    render_() {
      const t = this.startPixel_, e = this.endPixel_, n = "px", s = this.element_.style;
      s.left = Math.min(t[0], e[0]) + n, s.top = Math.min(t[1], e[1]) + n, s.width = Math.abs(e[0] - t[0]) + n, s.height = Math.abs(e[1] - t[1]) + n;
    }
    /**
     * @param {import("../Map.js").default|null} map Map.
     */
    setMap(t) {
      if (this.map_) {
        this.map_.getOverlayContainer().removeChild(this.element_);
        const e = this.element_.style;
        e.left = "inherit", e.top = "inherit", e.width = "inherit", e.height = "inherit";
      }
      this.map_ = t, this.map_ && this.map_.getOverlayContainer().appendChild(this.element_);
    }
    /**
     * @param {import("../pixel.js").Pixel} startPixel Start pixel.
     * @param {import("../pixel.js").Pixel} endPixel End pixel.
     */
    setPixels(t, e) {
      this.startPixel_ = t, this.endPixel_ = e, this.createOrUpdateGeometry(), this.render_();
    }
    /**
     * Creates or updates the cached geometry.
     */
    createOrUpdateGeometry() {
      if (!this.map_)
        return;
      const t = this.startPixel_, e = this.endPixel_, s = [
        t,
        [t[0], e[1]],
        e,
        [e[0], t[1]]
      ].map(
        this.map_.getCoordinateFromPixelInternal,
        this.map_
      );
      s[4] = s[0].slice(), this.geometry_ ? this.geometry_.setCoordinates([s]) : this.geometry_ = new oi([s]);
    }
    /**
     * @return {import("../geom/Polygon.js").default} Geometry.
     */
    getGeometry() {
      return this.geometry_;
    }
  }
  const Jn = {
    /**
     * Triggered upon drag box start.
     * @event DragBoxEvent#boxstart
     * @api
     */
    BOXSTART: "boxstart",
    /**
     * Triggered on drag when box is active.
     * @event DragBoxEvent#boxdrag
     * @api
     */
    BOXDRAG: "boxdrag",
    /**
     * Triggered upon drag box end.
     * @event DragBoxEvent#boxend
     * @api
     */
    BOXEND: "boxend",
    /**
     * Triggered upon drag box canceled.
     * @event DragBoxEvent#boxcancel
     * @api
     */
    BOXCANCEL: "boxcancel"
  };
  class Vs extends Ri {
    /**
     * @param {string} type The event type.
     * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
     */
    constructor(t, e, n) {
      super(t), this.coordinate = e, this.mapBrowserEvent = n;
    }
  }
  class w_ extends Wr {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      super(), this.on, this.once, this.un, t = t ?? {}, this.box_ = new x_(t.className || "ol-dragbox"), this.minArea_ = t.minArea ?? 64, t.onBoxEnd && (this.onBoxEnd = t.onBoxEnd), this.startPixel_ = null, this.condition_ = t.condition ?? Xd, this.boxEndCondition_ = t.boxEndCondition ?? this.defaultBoxEndCondition;
    }
    /**
     * The default condition for determining whether the boxend event
     * should fire.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
     *     leading to the box end.
     * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
     * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
     * @return {boolean} Whether or not the boxend condition should be fired.
     */
    defaultBoxEndCondition(t, e, n) {
      const s = n[0] - e[0], r = n[1] - e[1];
      return s * s + r * r >= this.minArea_;
    }
    /**
     * Returns geometry of last drawn box.
     * @return {import("../geom/Polygon.js").default} Geometry.
     * @api
     */
    getGeometry() {
      return this.box_.getGeometry();
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @override
     */
    handleDragEvent(t) {
      this.startPixel_ && (this.box_.setPixels(this.startPixel_, t.pixel), this.dispatchEvent(
        new Vs(
          Jn.BOXDRAG,
          t.coordinate,
          t
        )
      ));
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleUpEvent(t) {
      if (!this.startPixel_)
        return !1;
      const e = this.boxEndCondition_(
        t,
        this.startPixel_,
        t.pixel
      );
      return e && this.onBoxEnd(t), this.dispatchEvent(
        new Vs(
          e ? Jn.BOXEND : Jn.BOXCANCEL,
          t.coordinate,
          t
        )
      ), this.box_.setMap(null), this.startPixel_ = null, !1;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleDownEvent(t) {
      return this.condition_(t) ? (this.startPixel_ = t.pixel, this.box_.setMap(t.map), this.box_.setPixels(this.startPixel_, this.startPixel_), this.dispatchEvent(
        new Vs(
          Jn.BOXSTART,
          t.coordinate,
          t
        )
      ), !0) : !1;
    }
    /**
     * Function to execute just before `onboxend` is fired
     * @param {import("../MapBrowserEvent.js").default} event Event.
     */
    onBoxEnd(t) {
    }
    /**
     * Activate or deactivate the interaction.
     * @param {boolean} active Active.
     * @observable
     * @api
     * @override
     */
    setActive(t) {
      t || (this.box_.setMap(null), this.startPixel_ && (this.dispatchEvent(
        new Vs(Jn.BOXCANCEL, this.startPixel_, null)
      ), this.startPixel_ = null)), super.setActive(t);
    }
    /**
     * @param {import("../Map.js").default|null} map Map.
     * @override
     */
    setMap(t) {
      this.getMap() && (this.box_.setMap(null), this.startPixel_ && (this.dispatchEvent(
        new Vs(Jn.BOXCANCEL, this.startPixel_, null)
      ), this.startPixel_ = null)), super.setMap(t);
    }
  }
  class S_ extends w_ {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      t = t || {};
      const e = t.condition ? t.condition : y_;
      super({
        condition: e,
        className: t.className || "ol-dragzoom",
        minArea: t.minArea
      }), this.duration_ = t.duration !== void 0 ? t.duration : 200, this.out_ = t.out !== void 0 ? t.out : !1;
    }
    /**
     * Function to execute just before `onboxend` is fired
     * @param {import("../MapBrowserEvent.js").default} event Event.
     * @override
     */
    onBoxEnd(t) {
      const n = (
        /** @type {!import("../View.js").default} */
        this.getMap().getView()
      );
      let s = this.getGeometry();
      if (this.out_) {
        const r = n.rotatedExtentForGeometry(s), a = n.getResolutionForExtentInternal(r), o = n.getResolution() / a;
        s = s.clone(), s.scale(o * o);
      }
      n.fitInternal(s, {
        duration: this.duration_,
        easing: $s
      });
    }
  }
  const wn = {
    LEFT: "ArrowLeft",
    UP: "ArrowUp",
    RIGHT: "ArrowRight",
    DOWN: "ArrowDown"
  };
  class C_ extends Br {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      super(), t = t || {}, this.defaultCondition_ = function(e) {
        return Yd(e) && Zd(e);
      }, this.condition_ = t.condition !== void 0 ? t.condition : this.defaultCondition_, this.duration_ = t.duration !== void 0 ? t.duration : 100, this.pixelDelta_ = t.pixelDelta !== void 0 ? t.pixelDelta : 128;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
     * `KeyEvent`, and decides the direction to pan to (if an arrow key was
     * pressed).
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @override
     */
    handleEvent(t) {
      let e = !1;
      if (t.type == at.KEYDOWN) {
        const n = (
          /** @type {KeyboardEvent} */
          t.originalEvent
        ), s = n.key;
        if (this.condition_(t) && (s == wn.DOWN || s == wn.LEFT || s == wn.RIGHT || s == wn.UP)) {
          const a = t.map.getView(), o = a.getResolution() * this.pixelDelta_;
          let l = 0, h = 0;
          s == wn.DOWN ? h = -o : s == wn.LEFT ? l = -o : s == wn.RIGHT ? l = o : h = o;
          const c = [l, h];
          hh(c, a.getRotation()), d_(a, c, this.duration_), n.preventDefault(), e = !0;
        }
      }
      return !e;
    }
  }
  class R_ extends Br {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      super(), t = t || {}, this.condition_ = t.condition ? t.condition : function(e) {
        return !p_(e) && Zd(e);
      }, this.delta_ = t.delta ? t.delta : 1, this.duration_ = t.duration !== void 0 ? t.duration : 100;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
     * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
     * key pressed was '+' or '-').
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @override
     */
    handleEvent(t) {
      let e = !1;
      if (t.type == at.KEYDOWN || t.type == at.KEYPRESS) {
        const n = (
          /** @type {KeyboardEvent} */
          t.originalEvent
        ), s = n.key;
        if (this.condition_(t) && (s === "+" || s === "-")) {
          const r = t.map, a = s === "+" ? this.delta_ : -this.delta_, o = r.getView();
          Lh(o, a, void 0, this.duration_), n.preventDefault(), e = !0;
        }
      }
      return !e;
    }
  }
  class I_ extends Br {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      t = t || {}, super(
        /** @type {import("./Interaction.js").InteractionOptions} */
        t
      ), this.totalDelta_ = 0, this.lastDelta_ = 0, this.maxDelta_ = t.maxDelta !== void 0 ? t.maxDelta : 1, this.duration_ = t.duration !== void 0 ? t.duration : 250, this.timeout_ = t.timeout !== void 0 ? t.timeout : 80, this.useAnchor_ = t.useAnchor !== void 0 ? t.useAnchor : !0, this.constrainResolution_ = t.constrainResolution !== void 0 ? t.constrainResolution : !1;
      const e = t.condition ? t.condition : __;
      this.condition_ = t.onFocusOnly ? Pl(Wd, e) : e, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_, this.mode_ = void 0, this.trackpadEventGap_ = 400, this.trackpadTimeoutId_, this.deltaPerZoom_ = 300;
    }
    /**
     * @private
     */
    endInteraction_() {
      this.trackpadTimeoutId_ = void 0;
      const t = this.getMap();
      if (!t)
        return;
      t.getView().endInteraction(
        void 0,
        this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0,
        this.lastAnchor_ ? t.getCoordinateFromPixel(this.lastAnchor_) : null
      );
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
     * zooms the map.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @override
     */
    handleEvent(t) {
      if (!this.condition_(t) || t.type !== at.WHEEL)
        return !0;
      const n = t.map, s = (
        /** @type {WheelEvent} */
        t.originalEvent
      );
      s.preventDefault(), this.useAnchor_ && (this.lastAnchor_ = t.pixel);
      let r;
      if (t.type == at.WHEEL && (r = s.deltaY, hd && s.deltaMode === WheelEvent.DOM_DELTA_PIXEL && (r /= co), s.deltaMode === WheelEvent.DOM_DELTA_LINE && (r *= 40)), r === 0)
        return !1;
      this.lastDelta_ = r;
      const a = Date.now();
      this.startTime_ === void 0 && (this.startTime_ = a), (!this.mode_ || a - this.startTime_ > this.trackpadEventGap_) && (this.mode_ = Math.abs(r) < 4 ? "trackpad" : "wheel");
      const o = n.getView();
      if (this.mode_ === "trackpad" && !(o.getConstrainResolution() || this.constrainResolution_))
        return this.trackpadTimeoutId_ ? clearTimeout(this.trackpadTimeoutId_) : (o.getAnimating() && o.cancelAnimations(), o.beginInteraction()), this.trackpadTimeoutId_ = setTimeout(
          this.endInteraction_.bind(this),
          this.timeout_
        ), o.adjustZoom(
          -r / this.deltaPerZoom_,
          this.lastAnchor_ ? n.getCoordinateFromPixel(this.lastAnchor_) : null
        ), this.startTime_ = a, !1;
      this.totalDelta_ += r;
      const l = Math.max(this.timeout_ - (a - this.startTime_), 0);
      return clearTimeout(this.timeoutId_), this.timeoutId_ = setTimeout(
        this.handleWheelZoom_.bind(this, n),
        l
      ), !1;
    }
    /**
     * @private
     * @param {import("../Map.js").default} map Map.
     */
    handleWheelZoom_(t) {
      const e = t.getView();
      e.getAnimating() && e.cancelAnimations();
      let n = -zt(
        this.totalDelta_,
        -this.maxDelta_ * this.deltaPerZoom_,
        this.maxDelta_ * this.deltaPerZoom_
      ) / this.deltaPerZoom_;
      (e.getConstrainResolution() || this.constrainResolution_) && (n = n ? n > 0 ? 1 : -1 : 0), Lh(
        e,
        n,
        this.lastAnchor_ ? t.getCoordinateFromPixel(this.lastAnchor_) : null,
        this.duration_
      ), this.mode_ = void 0, this.totalDelta_ = 0, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_ = void 0;
    }
    /**
     * Enable or disable using the mouse's location as an anchor when zooming
     * @param {boolean} useAnchor true to zoom to the mouse's location, false
     * to zoom to the center of the map
     * @api
     */
    setMouseAnchor(t) {
      this.useAnchor_ = t, t || (this.lastAnchor_ = null);
    }
  }
  class T_ extends Wr {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      t = t || {};
      const e = (
        /** @type {import("./Pointer.js").Options} */
        t
      );
      e.stopDown || (e.stopDown = lo), super(e), this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.threshold_ = t.threshold !== void 0 ? t.threshold : 0.3, this.duration_ = t.duration !== void 0 ? t.duration : 250;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @override
     */
    handleDragEvent(t) {
      let e = 0;
      const n = this.targetPointers[0], s = this.targetPointers[1], r = Math.atan2(
        s.clientY - n.clientY,
        s.clientX - n.clientX
      );
      if (this.lastAngle_ !== void 0) {
        const l = r - this.lastAngle_;
        this.rotationDelta_ += l, !this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_ && (this.rotating_ = !0), e = l;
      }
      this.lastAngle_ = r;
      const a = t.map, o = a.getView();
      o.getConstraints().rotation !== Th && (this.anchor_ = a.getCoordinateFromPixelInternal(
        a.getEventPixel(Oh(this.targetPointers))
      ), this.rotating_ && (a.render(), o.adjustRotationInternal(e, this.anchor_)));
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleUpEvent(t) {
      return this.targetPointers.length < 2 ? (t.map.getView().endInteraction(this.duration_), !1) : !0;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleDownEvent(t) {
      if (this.targetPointers.length >= 2) {
        const e = t.map;
        return this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.handlingDownUpSequence || e.getView().beginInteraction(), !0;
      }
      return !1;
    }
  }
  class A_ extends Wr {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      t = t || {};
      const e = (
        /** @type {import("./Pointer.js").Options} */
        t
      );
      e.stopDown || (e.stopDown = lo), super(e), this.anchor_ = null, this.duration_ = t.duration !== void 0 ? t.duration : 400, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @override
     */
    handleDragEvent(t) {
      let e = 1;
      const n = this.targetPointers[0], s = this.targetPointers[1], r = n.clientX - s.clientX, a = n.clientY - s.clientY, o = Math.sqrt(r * r + a * a);
      this.lastDistance_ !== void 0 && (e = this.lastDistance_ / o), this.lastDistance_ = o;
      const l = t.map, h = l.getView();
      e != 1 && (this.lastScaleDelta_ = e), this.anchor_ = l.getCoordinateFromPixelInternal(
        l.getEventPixel(Oh(this.targetPointers))
      ), l.render(), h.adjustResolutionInternal(e, this.anchor_);
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleUpEvent(t) {
      if (this.targetPointers.length < 2) {
        const n = t.map.getView(), s = this.lastScaleDelta_ > 1 ? 1 : -1;
        return n.endInteraction(this.duration_, s), !1;
      }
      return !0;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleDownEvent(t) {
      if (this.targetPointers.length >= 2) {
        const e = t.map;
        return this.anchor_ = null, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1, this.handlingDownUpSequence || e.getView().beginInteraction(), !0;
      }
      return !1;
    }
  }
  function b_(i) {
    i = i || {};
    const t = new ni(), e = new u_(-5e-3, 0.05, 100);
    return (i.altShiftDragRotate !== void 0 ? i.altShiftDragRotate : !0) && t.push(new M_()), (i.doubleClickZoom !== void 0 ? i.doubleClickZoom : !0) && t.push(
      new f_({
        delta: i.zoomDelta,
        duration: i.zoomDuration
      })
    ), (i.dragPan !== void 0 ? i.dragPan : !0) && t.push(
      new E_({
        onFocusOnly: i.onFocusOnly,
        kinetic: e
      })
    ), (i.pinchRotate !== void 0 ? i.pinchRotate : !0) && t.push(new T_()), (i.pinchZoom !== void 0 ? i.pinchZoom : !0) && t.push(
      new A_({
        duration: i.zoomDuration
      })
    ), (i.keyboard !== void 0 ? i.keyboard : !0) && (t.push(new C_()), t.push(
      new R_({
        delta: i.zoomDelta,
        duration: i.zoomDuration
      })
    )), (i.mouseWheelZoom !== void 0 ? i.mouseWheelZoom : !0) && t.push(
      new I_({
        onFocusOnly: i.onFocusOnly,
        duration: i.zoomDuration
      })
    ), (i.shiftDragZoom !== void 0 ? i.shiftDragZoom : !0) && t.push(
      new S_({
        duration: i.zoomDuration
      })
    ), t;
  }
  const Tt = {
    OPACITY: "opacity",
    VISIBLE: "visible",
    EXTENT: "extent",
    Z_INDEX: "zIndex",
    MAX_RESOLUTION: "maxResolution",
    MIN_RESOLUTION: "minResolution",
    MAX_ZOOM: "maxZoom",
    MIN_ZOOM: "minZoom",
    SOURCE: "source",
    MAP: "map"
  };
  class qd extends Qe {
    /**
     * @param {Options} options Layer options.
     */
    constructor(t) {
      super(), this.on, this.once, this.un, this.background_ = t.background;
      const e = Object.assign({}, t);
      typeof t.properties == "object" && (delete e.properties, Object.assign(e, t.properties)), e[Tt.OPACITY] = t.opacity !== void 0 ? t.opacity : 1, xt(
        typeof e[Tt.OPACITY] == "number",
        "Layer opacity must be a number"
      ), e[Tt.VISIBLE] = t.visible !== void 0 ? t.visible : !0, e[Tt.Z_INDEX] = t.zIndex, e[Tt.MAX_RESOLUTION] = t.maxResolution !== void 0 ? t.maxResolution : 1 / 0, e[Tt.MIN_RESOLUTION] = t.minResolution !== void 0 ? t.minResolution : 0, e[Tt.MIN_ZOOM] = t.minZoom !== void 0 ? t.minZoom : -1 / 0, e[Tt.MAX_ZOOM] = t.maxZoom !== void 0 ? t.maxZoom : 1 / 0, this.className_ = e.className !== void 0 ? e.className : "ol-layer", delete e.className, this.setProperties(e), this.state_ = null;
    }
    /**
     * Get the background for this layer.
     * @return {BackgroundColor|false} Layer background.
     */
    getBackground() {
      return this.background_;
    }
    /**
     * @return {string} CSS class name.
     */
    getClassName() {
      return this.className_;
    }
    /**
     * This method is not meant to be called by layers or layer renderers because the state
     * is incorrect if the layer is included in a layer group.
     *
     * @param {boolean} [managed] Layer is managed.
     * @return {import("./Layer.js").State} Layer state.
     */
    getLayerState(t) {
      const e = this.state_ || /** @type {?} */
      {
        layer: this,
        managed: t === void 0 ? !0 : t
      }, n = this.getZIndex();
      return e.opacity = zt(Math.round(this.getOpacity() * 100) / 100, 0, 1), e.visible = this.getVisible(), e.extent = this.getExtent(), e.zIndex = n === void 0 && !e.managed ? 1 / 0 : n, e.maxResolution = this.getMaxResolution(), e.minResolution = Math.max(this.getMinResolution(), 0), e.minZoom = this.getMinZoom(), e.maxZoom = this.getMaxZoom(), this.state_ = e, e;
    }
    /**
     * @abstract
     * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
     *     modified in place).
     * @return {Array<import("./Layer.js").default>} Array of layers.
     */
    getLayersArray(t) {
      return ct();
    }
    /**
     * @abstract
     * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
     *     states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     */
    getLayerStatesArray(t) {
      return ct();
    }
    /**
     * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
     * will be visible regardless of extent.
     * @return {import("../extent.js").Extent|undefined} The layer extent.
     * @observable
     * @api
     */
    getExtent() {
      return (
        /** @type {import("../extent.js").Extent|undefined} */
        this.get(Tt.EXTENT)
      );
    }
    /**
     * Return the maximum resolution of the layer. Returns Infinity if
     * the layer has no maximum resolution set.
     * @return {number} The maximum resolution of the layer.
     * @observable
     * @api
     */
    getMaxResolution() {
      return (
        /** @type {number} */
        this.get(Tt.MAX_RESOLUTION)
      );
    }
    /**
     * Return the minimum resolution of the layer. Returns 0 if
     * the layer has no minimum resolution set.
     * @return {number} The minimum resolution of the layer.
     * @observable
     * @api
     */
    getMinResolution() {
      return (
        /** @type {number} */
        this.get(Tt.MIN_RESOLUTION)
      );
    }
    /**
     * Return the minimum zoom level of the layer. Returns -Infinity if
     * the layer has no minimum zoom set.
     * @return {number} The minimum zoom level of the layer.
     * @observable
     * @api
     */
    getMinZoom() {
      return (
        /** @type {number} */
        this.get(Tt.MIN_ZOOM)
      );
    }
    /**
     * Return the maximum zoom level of the layer. Returns Infinity if
     * the layer has no maximum zoom set.
     * @return {number} The maximum zoom level of the layer.
     * @observable
     * @api
     */
    getMaxZoom() {
      return (
        /** @type {number} */
        this.get(Tt.MAX_ZOOM)
      );
    }
    /**
     * Return the opacity of the layer (between 0 and 1).
     * @return {number} The opacity of the layer.
     * @observable
     * @api
     */
    getOpacity() {
      return (
        /** @type {number} */
        this.get(Tt.OPACITY)
      );
    }
    /**
     * @abstract
     * @return {import("../source/Source.js").State} Source state.
     */
    getSourceState() {
      return ct();
    }
    /**
     * Return the value of this layer's `visible` property. To find out whether the layer
     * is visible on a map, use `isVisible()` instead.
     * @return {boolean} The value of the `visible` property of the layer.
     * @observable
     * @api
     */
    getVisible() {
      return (
        /** @type {boolean} */
        this.get(Tt.VISIBLE)
      );
    }
    /**
     * Return the Z-index of the layer, which is used to order layers before
     * rendering. Returns undefined if the layer is unmanaged.
     * @return {number|undefined} The Z-index of the layer.
     * @observable
     * @api
     */
    getZIndex() {
      return (
        /** @type {number|undefined} */
        this.get(Tt.Z_INDEX)
      );
    }
    /**
     * Sets the background color.
     * @param {BackgroundColor} [background] Background color.
     */
    setBackground(t) {
      this.background_ = t, this.changed();
    }
    /**
     * Set the extent at which the layer is visible.  If `undefined`, the layer
     * will be visible at all extents.
     * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
     * @observable
     * @api
     */
    setExtent(t) {
      this.set(Tt.EXTENT, t);
    }
    /**
     * Set the maximum resolution at which the layer is visible.
     * @param {number} maxResolution The maximum resolution of the layer.
     * @observable
     * @api
     */
    setMaxResolution(t) {
      this.set(Tt.MAX_RESOLUTION, t);
    }
    /**
     * Set the minimum resolution at which the layer is visible.
     * @param {number} minResolution The minimum resolution of the layer.
     * @observable
     * @api
     */
    setMinResolution(t) {
      this.set(Tt.MIN_RESOLUTION, t);
    }
    /**
     * Set the maximum zoom (exclusive) at which the layer is visible.
     * Note that the zoom levels for layer visibility are based on the
     * view zoom level, which may be different from a tile source zoom level.
     * @param {number} maxZoom The maximum zoom of the layer.
     * @observable
     * @api
     */
    setMaxZoom(t) {
      this.set(Tt.MAX_ZOOM, t);
    }
    /**
     * Set the minimum zoom (inclusive) at which the layer is visible.
     * Note that the zoom levels for layer visibility are based on the
     * view zoom level, which may be different from a tile source zoom level.
     * @param {number} minZoom The minimum zoom of the layer.
     * @observable
     * @api
     */
    setMinZoom(t) {
      this.set(Tt.MIN_ZOOM, t);
    }
    /**
     * Set the opacity of the layer, allowed values range from 0 to 1.
     * @param {number} opacity The opacity of the layer.
     * @observable
     * @api
     */
    setOpacity(t) {
      xt(typeof t == "number", "Layer opacity must be a number"), this.set(Tt.OPACITY, t);
    }
    /**
     * Set the visibility of the layer (`true` or `false`).
     * @param {boolean} visible The visibility of the layer.
     * @observable
     * @api
     */
    setVisible(t) {
      this.set(Tt.VISIBLE, t);
    }
    /**
     * Set Z-index of the layer, which is used to order layers before rendering.
     * The default Z-index is 0.
     * @param {number} zindex The z-index of the layer.
     * @observable
     * @api
     */
    setZIndex(t) {
      this.set(Tt.Z_INDEX, t);
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.state_ && (this.state_.layer = null, this.state_ = null), super.disposeInternal();
    }
  }
  class Ui extends Ri {
    /**
     * @param {GroupEventType} type The event type.
     * @param {BaseLayer} layer The layer.
     */
    constructor(t, e) {
      super(t), this.layer = e;
    }
  }
  const Ho = {
    LAYERS: "layers"
  };
  class Us extends qd {
    /**
     * @param {Options} [options] Layer options.
     */
    constructor(t) {
      t = t || {};
      const e = (
        /** @type {Options} */
        Object.assign({}, t)
      );
      delete e.layers;
      let n = t.layers;
      super(e), this.on, this.once, this.un, this.layersListenerKeys_ = [], this.listenerKeys_ = {}, this.addChangeListener(Ho.LAYERS, this.handleLayersChanged_), n ? Array.isArray(n) ? n = new ni(n.slice(), { unique: !0 }) : xt(
        typeof /** @type {?} */
        n.getArray == "function",
        "Expected `layers` to be an array or a `Collection`"
      ) : n = new ni(void 0, { unique: !0 }), this.setLayers(n);
    }
    /**
     * @private
     */
    handleLayerChange_() {
      this.changed();
    }
    /**
     * @private
     */
    handleLayersChanged_() {
      this.layersListenerKeys_.forEach(Pt), this.layersListenerKeys_.length = 0;
      const t = this.getLayers();
      this.layersListenerKeys_.push(
        vt(t, Ee.ADD, this.handleLayersAdd_, this),
        vt(
          t,
          Ee.REMOVE,
          this.handleLayersRemove_,
          this
        )
      );
      for (const n in this.listenerKeys_)
        this.listenerKeys_[n].forEach(Pt);
      Dr(this.listenerKeys_);
      const e = t.getArray();
      for (let n = 0, s = e.length; n < s; n++) {
        const r = e[n];
        this.registerLayerListeners_(r), this.dispatchEvent(new Ui("addlayer", r));
      }
      this.changed();
    }
    /**
     * @param {BaseLayer} layer The layer.
     */
    registerLayerListeners_(t) {
      const e = [
        vt(
          t,
          Rs.PROPERTYCHANGE,
          this.handleLayerChange_,
          this
        ),
        vt(t, at.CHANGE, this.handleLayerChange_, this)
      ];
      t instanceof Us && e.push(
        vt(t, "addlayer", this.handleLayerGroupAdd_, this),
        vt(t, "removelayer", this.handleLayerGroupRemove_, this)
      ), this.listenerKeys_[Ct(t)] = e;
    }
    /**
     * @param {GroupEvent} event The layer group event.
     */
    handleLayerGroupAdd_(t) {
      this.dispatchEvent(new Ui("addlayer", t.layer));
    }
    /**
     * @param {GroupEvent} event The layer group event.
     */
    handleLayerGroupRemove_(t) {
      this.dispatchEvent(new Ui("removelayer", t.layer));
    }
    /**
     * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
     * @private
     */
    handleLayersAdd_(t) {
      const e = t.element;
      this.registerLayerListeners_(e), this.dispatchEvent(new Ui("addlayer", e)), this.changed();
    }
    /**
     * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
     * @private
     */
    handleLayersRemove_(t) {
      const e = t.element, n = Ct(e);
      this.listenerKeys_[n].forEach(Pt), delete this.listenerKeys_[n], this.dispatchEvent(new Ui("removelayer", e)), this.changed();
    }
    /**
     * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
     * in this group.
     * @return {!Collection<import("./Base.js").default>} Collection of
     *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
     * @observable
     * @api
     */
    getLayers() {
      return (
        /** @type {!Collection<import("./Base.js").default>} */
        this.get(Ho.LAYERS)
      );
    }
    /**
     * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
     * in this group.
     * @param {!Collection<import("./Base.js").default>} layers Collection of
     *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
     * @observable
     * @api
     */
    setLayers(t) {
      const e = this.getLayers();
      if (e) {
        const n = e.getArray();
        for (let s = 0, r = n.length; s < r; ++s)
          this.dispatchEvent(new Ui("removelayer", n[s]));
      }
      this.set(Ho.LAYERS, t);
    }
    /**
     * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
     * @return {Array<import("./Layer.js").default>} Array of layers.
     * @override
     */
    getLayersArray(t) {
      return t = t !== void 0 ? t : [], this.getLayers().forEach(function(e) {
        e.getLayersArray(t);
      }), t;
    }
    /**
     * Get the layer states list and use this groups z-index as the default
     * for all layers in this and nested groups, if it is unset at this point.
     * If dest is not provided and this group's z-index is undefined
     * 0 is used a the default z-index.
     * @param {Array<import("./Layer.js").State>} [dest] Optional list
     * of layer states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     * @override
     */
    getLayerStatesArray(t) {
      const e = t !== void 0 ? t : [], n = e.length;
      this.getLayers().forEach(function(a) {
        a.getLayerStatesArray(e);
      });
      const s = this.getLayerState();
      let r = s.zIndex;
      !t && s.zIndex === void 0 && (r = 0);
      for (let a = n, o = e.length; a < o; a++) {
        const l = e[a];
        l.opacity *= s.opacity, l.visible = l.visible && s.visible, l.maxResolution = Math.min(
          l.maxResolution,
          s.maxResolution
        ), l.minResolution = Math.max(
          l.minResolution,
          s.minResolution
        ), l.minZoom = Math.max(l.minZoom, s.minZoom), l.maxZoom = Math.min(l.maxZoom, s.maxZoom), s.extent !== void 0 && (l.extent !== void 0 ? l.extent = Mi(
          l.extent,
          s.extent
        ) : l.extent = s.extent), l.zIndex === void 0 && (l.zIndex = r);
      }
      return e;
    }
    /**
     * @return {import("../source/Source.js").State} Source state.
     * @override
     */
    getSourceState() {
      return "ready";
    }
  }
  const ke = {
    /**
     * Triggered before a layer is rendered.
     * @event module:ol/render/Event~RenderEvent#prerender
     * @api
     */
    PRERENDER: "prerender",
    /**
     * Triggered after a layer is rendered.
     * @event module:ol/render/Event~RenderEvent#postrender
     * @api
     */
    POSTRENDER: "postrender",
    /**
     * Triggered before layers are composed.  When dispatched by the map, the event object will not have
     * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
     * WebGL layers currently dispatch this event.
     * @event module:ol/render/Event~RenderEvent#precompose
     * @api
     */
    PRECOMPOSE: "precompose",
    /**
     * Triggered after layers are composed.  When dispatched by the map, the event object will not have
     * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
     * WebGL layers currently dispatch this event.
     * @event module:ol/render/Event~RenderEvent#postcompose
     * @api
     */
    POSTCOMPOSE: "postcompose",
    /**
     * Triggered when rendering is complete, i.e. all sources and tiles have
     * finished loading for the current viewport, and all tiles are faded in.
     * The event object will not have a `context` set.
     * @event module:ol/render/Event~RenderEvent#rendercomplete
     * @api
     */
    RENDERCOMPLETE: "rendercomplete"
  };
  class Ro extends qd {
    /**
     * @param {Options<SourceType>} options Layer options.
     */
    constructor(t) {
      const e = Object.assign({}, t);
      delete e.source, super(e), this.on, this.once, this.un, this.mapPrecomposeKey_ = null, this.mapRenderKey_ = null, this.sourceChangeKey_ = null, this.renderer_ = null, this.sourceReady_ = !1, this.rendered = !1, t.render && (this.render = t.render), t.map && this.setMap(t.map), this.addChangeListener(
        Tt.SOURCE,
        this.handleSourcePropertyChange_
      );
      const n = t.source ? (
        /** @type {SourceType} */
        t.source
      ) : null;
      this.setSource(n);
    }
    /**
     * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
     * @return {Array<import("./Layer.js").default>} Array of layers.
     * @override
     */
    getLayersArray(t) {
      return t = t || [], t.push(this), t;
    }
    /**
     * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     * @override
     */
    getLayerStatesArray(t) {
      return t = t || [], t.push(this.getLayerState()), t;
    }
    /**
     * Get the layer source.
     * @return {SourceType|null} The layer source (or `null` if not yet set).
     * @observable
     * @api
     */
    getSource() {
      return (
        /** @type {SourceType} */
        this.get(Tt.SOURCE) || null
      );
    }
    /**
     * @return {SourceType|null} The source being rendered.
     */
    getRenderSource() {
      return this.getSource();
    }
    /**
     * @return {import("../source/Source.js").State} Source state.
     * @override
     */
    getSourceState() {
      const t = this.getSource();
      return t ? t.getState() : "undefined";
    }
    /**
     * @private
     */
    handleSourceChange_() {
      this.changed(), !(this.sourceReady_ || this.getSource().getState() !== "ready") && (this.sourceReady_ = !0, this.dispatchEvent("sourceready"));
    }
    /**
     * @private
     */
    handleSourcePropertyChange_() {
      this.sourceChangeKey_ && (Pt(this.sourceChangeKey_), this.sourceChangeKey_ = null), this.sourceReady_ = !1;
      const t = this.getSource();
      t && (this.sourceChangeKey_ = vt(
        t,
        at.CHANGE,
        this.handleSourceChange_,
        this
      ), t.getState() === "ready" && (this.sourceReady_ = !0, setTimeout(() => {
        this.dispatchEvent("sourceready");
      }, 0)), this.clearRenderer()), this.changed();
    }
    /**
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
     * an array of features.
     */
    getFeatures(t) {
      return this.renderer_ ? this.renderer_.getFeatures(t) : Promise.resolve([]);
    }
    /**
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     */
    getData(t) {
      return !this.renderer_ || !this.rendered ? null : this.renderer_.getData(t);
    }
    /**
     * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
     * extent, not set to `visible: false`, and not inside a layer group that is set
     * to `visible: false`.
     * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
     * Only required when the layer is not added to a map.
     * @return {boolean} The layer is visible in the map view.
     * @api
     */
    isVisible(t) {
      let e;
      const n = this.getMapInternal();
      !t && n && (t = n.getView()), t instanceof Ke ? e = {
        viewState: t.getState(),
        extent: t.calculateExtent()
      } : e = t, !e.layerStatesArray && n && (e.layerStatesArray = n.getLayerGroup().getLayerStatesArray());
      let s;
      if (e.layerStatesArray) {
        if (s = e.layerStatesArray.find(
          (a) => a.layer === this
        ), !s)
          return !1;
      } else
        s = this.getLayerState();
      const r = this.getExtent();
      return Nh(s, e.viewState) && (!r || he(r, e.extent));
    }
    /**
     * Get the attributions of the source of this layer for the given view.
     * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
     * Only required when the layer is not added to a map.
     * @return {Array<string>} Attributions for this layer at the given view.
     * @api
     */
    getAttributions(t) {
      var r;
      if (!this.isVisible(t))
        return [];
      const e = (r = this.getSource()) == null ? void 0 : r.getAttributions();
      if (!e)
        return [];
      const n = t instanceof Ke ? t.getViewStateAndExtent() : t;
      let s = e(n);
      return Array.isArray(s) || (s = [s]), s;
    }
    /**
     * In charge to manage the rendering of the layer. One layer type is
     * bounded with one layer renderer.
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target which the renderer may (but need not) use
     * for rendering its content.
     * @return {HTMLElement|null} The rendered element.
     */
    render(t, e) {
      const n = this.getRenderer();
      return n.prepareFrame(t) ? (this.rendered = !0, n.renderFrame(t, e)) : null;
    }
    /**
     * Called when a layer is not visible during a map render.
     */
    unrender() {
      this.rendered = !1;
    }
    /** @return {string} Declutter */
    getDeclutter() {
    }
    /**
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {import("../layer/Layer.js").State} layerState Layer state.
     */
    renderDeclutter(t, e) {
    }
    /**
     * When the renderer follows a layout -> render approach, do the final rendering here.
     * @param {import('../Map.js').FrameState} frameState Frame state
     */
    renderDeferred(t) {
      const e = this.getRenderer();
      e && e.renderDeferred(t);
    }
    /**
     * For use inside the library only.
     * @param {import("../Map.js").default|null} map Map.
     */
    setMapInternal(t) {
      t || this.unrender(), this.set(Tt.MAP, t);
    }
    /**
     * For use inside the library only.
     * @return {import("../Map.js").default|null} Map.
     */
    getMapInternal() {
      return this.get(Tt.MAP);
    }
    /**
     * Sets the layer to be rendered on top of other layers on a map. The map will
     * not manage this layer in its layers collection. This
     * is useful for temporary layers. To remove an unmanaged layer from the map,
     * use `#setMap(null)`.
     *
     * To add the layer to a map and have it managed by the map, use
     * {@link module:ol/Map~Map#addLayer} instead.
     * @param {import("../Map.js").default|null} map Map.
     * @api
     */
    setMap(t) {
      this.mapPrecomposeKey_ && (Pt(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null), t || this.changed(), this.mapRenderKey_ && (Pt(this.mapRenderKey_), this.mapRenderKey_ = null), t && (this.mapPrecomposeKey_ = vt(
        t,
        ke.PRECOMPOSE,
        this.handlePrecompose_,
        this
      ), this.mapRenderKey_ = vt(this, at.CHANGE, t.render, t), this.changed());
    }
    /**
     * @param {import("../events/Event.js").default} renderEvent Render event
     * @private
     */
    handlePrecompose_(t) {
      const e = (
        /** @type {import("../render/Event.js").default} */
        t.frameState.layerStatesArray
      ), n = this.getLayerState(!1);
      xt(
        !e.some(
          (s) => s.layer === n.layer
        ),
        "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
      ), e.push(n);
    }
    /**
     * Set the layer source.
     * @param {SourceType|null} source The layer source.
     * @observable
     * @api
     */
    setSource(t) {
      this.set(Tt.SOURCE, t);
    }
    /**
     * Get the renderer for this layer.
     * @return {RendererType|null} The layer renderer.
     */
    getRenderer() {
      return this.renderer_ || (this.renderer_ = this.createRenderer()), this.renderer_;
    }
    /**
     * @return {boolean} The layer has a renderer.
     */
    hasRenderer() {
      return !!this.renderer_;
    }
    /**
     * Create a renderer for this layer.
     * @return {RendererType} A layer renderer.
     * @protected
     */
    createRenderer() {
      return null;
    }
    /**
     * This will clear the renderer so that a new one can be created next time it is needed
     */
    clearRenderer() {
      this.renderer_ && (this.renderer_.dispose(), delete this.renderer_);
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.clearRenderer(), this.setSource(null), super.disposeInternal();
    }
  }
  function Nh(i, t) {
    if (!i.visible)
      return !1;
    const e = t.resolution;
    if (e < i.minResolution || e >= i.maxResolution)
      return !1;
    const n = t.zoom;
    return n > i.minZoom && n <= i.maxZoom;
  }
  function Kd(i, t, e = 0, n = i.length - 1, s = P_) {
    for (; n > e; ) {
      if (n - e > 600) {
        const l = n - e + 1, h = t - e + 1, c = Math.log(l), u = 0.5 * Math.exp(2 * c / 3), d = 0.5 * Math.sqrt(c * u * (l - u) / l) * (h - l / 2 < 0 ? -1 : 1), g = Math.max(e, Math.floor(t - h * u / l + d)), _ = Math.min(n, Math.floor(t + (l - h) * u / l + d));
        Kd(i, t, g, _, s);
      }
      const r = i[t];
      let a = e, o = n;
      for (js(i, e, t), s(i[n], r) > 0 && js(i, e, n); a < o; ) {
        for (js(i, a, o), a++, o--; s(i[a], r) < 0; ) a++;
        for (; s(i[o], r) > 0; ) o--;
      }
      s(i[e], r) === 0 ? js(i, e, o) : (o++, js(i, o, n)), o <= t && (e = o + 1), t <= o && (n = o - 1);
    }
  }
  function js(i, t, e) {
    const n = i[t];
    i[t] = i[e], i[e] = n;
  }
  function P_(i, t) {
    return i < t ? -1 : i > t ? 1 : 0;
  }
  let Vd = class {
    constructor(t = 9) {
      this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
    }
    all() {
      return this._all(this.data, []);
    }
    search(t) {
      let e = this.data;
      const n = [];
      if (!ya(t, e)) return n;
      const s = this.toBBox, r = [];
      for (; e; ) {
        for (let a = 0; a < e.children.length; a++) {
          const o = e.children[a], l = e.leaf ? s(o) : o;
          ya(t, l) && (e.leaf ? n.push(o) : Qo(t, l) ? this._all(o, n) : r.push(o));
        }
        e = r.pop();
      }
      return n;
    }
    collides(t) {
      let e = this.data;
      if (!ya(t, e)) return !1;
      const n = [];
      for (; e; ) {
        for (let s = 0; s < e.children.length; s++) {
          const r = e.children[s], a = e.leaf ? this.toBBox(r) : r;
          if (ya(t, a)) {
            if (e.leaf || Qo(t, a)) return !0;
            n.push(r);
          }
        }
        e = n.pop();
      }
      return !1;
    }
    load(t) {
      if (!(t && t.length)) return this;
      if (t.length < this._minEntries) {
        for (let n = 0; n < t.length; n++)
          this.insert(t[n]);
        return this;
      }
      let e = this._build(t.slice(), 0, t.length - 1, 0);
      if (!this.data.children.length)
        this.data = e;
      else if (this.data.height === e.height)
        this._splitRoot(this.data, e);
      else {
        if (this.data.height < e.height) {
          const n = this.data;
          this.data = e, e = n;
        }
        this._insert(e, this.data.height - e.height - 1, !0);
      }
      return this;
    }
    insert(t) {
      return t && this._insert(t, this.data.height - 1), this;
    }
    clear() {
      return this.data = as([]), this;
    }
    remove(t, e) {
      if (!t) return this;
      let n = this.data;
      const s = this.toBBox(t), r = [], a = [];
      let o, l, h;
      for (; n || r.length; ) {
        if (n || (n = r.pop(), l = r[r.length - 1], o = a.pop(), h = !0), n.leaf) {
          const c = L_(t, n.children, e);
          if (c !== -1)
            return n.children.splice(c, 1), r.push(n), this._condense(r), this;
        }
        !h && !n.leaf && Qo(n, s) ? (r.push(n), a.push(o), o = 0, l = n, n = n.children[0]) : l ? (o++, n = l.children[o], h = !1) : n = null;
      }
      return this;
    }
    toBBox(t) {
      return t;
    }
    compareMinX(t, e) {
      return t.minX - e.minX;
    }
    compareMinY(t, e) {
      return t.minY - e.minY;
    }
    toJSON() {
      return this.data;
    }
    fromJSON(t) {
      return this.data = t, this;
    }
    _all(t, e) {
      const n = [];
      for (; t; )
        t.leaf ? e.push(...t.children) : n.push(...t.children), t = n.pop();
      return e;
    }
    _build(t, e, n, s) {
      const r = n - e + 1;
      let a = this._maxEntries, o;
      if (r <= a)
        return o = as(t.slice(e, n + 1)), Qn(o, this.toBBox), o;
      s || (s = Math.ceil(Math.log(r) / Math.log(a)), a = Math.ceil(r / Math.pow(a, s - 1))), o = as([]), o.leaf = !1, o.height = s;
      const l = Math.ceil(r / a), h = l * Math.ceil(Math.sqrt(a));
      tu(t, e, n, h, this.compareMinX);
      for (let c = e; c <= n; c += h) {
        const u = Math.min(c + h - 1, n);
        tu(t, c, u, l, this.compareMinY);
        for (let d = c; d <= u; d += l) {
          const g = Math.min(d + l - 1, u);
          o.children.push(this._build(t, d, g, s - 1));
        }
      }
      return Qn(o, this.toBBox), o;
    }
    _chooseSubtree(t, e, n, s) {
      for (; s.push(e), !(e.leaf || s.length - 1 === n); ) {
        let r = 1 / 0, a = 1 / 0, o;
        for (let l = 0; l < e.children.length; l++) {
          const h = e.children[l], c = Jo(h), u = F_(t, h) - c;
          u < a ? (a = u, r = c < r ? c : r, o = h) : u === a && c < r && (r = c, o = h);
        }
        e = o || e.children[0];
      }
      return e;
    }
    _insert(t, e, n) {
      const s = n ? t : this.toBBox(t), r = [], a = this._chooseSubtree(s, this.data, e, r);
      for (a.children.push(t), er(a, s); e >= 0 && r[e].children.length > this._maxEntries; )
        this._split(r, e), e--;
      this._adjustParentBBoxes(s, r, e);
    }
    // split overflowed node into two
    _split(t, e) {
      const n = t[e], s = n.children.length, r = this._minEntries;
      this._chooseSplitAxis(n, r, s);
      const a = this._chooseSplitIndex(n, r, s), o = as(n.children.splice(a, n.children.length - a));
      o.height = n.height, o.leaf = n.leaf, Qn(n, this.toBBox), Qn(o, this.toBBox), e ? t[e - 1].children.push(o) : this._splitRoot(n, o);
    }
    _splitRoot(t, e) {
      this.data = as([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, Qn(this.data, this.toBBox);
    }
    _chooseSplitIndex(t, e, n) {
      let s, r = 1 / 0, a = 1 / 0;
      for (let o = e; o <= n - e; o++) {
        const l = tr(t, 0, o, this.toBBox), h = tr(t, o, n, this.toBBox), c = D_(l, h), u = Jo(l) + Jo(h);
        c < r ? (r = c, s = o, a = u < a ? u : a) : c === r && u < a && (a = u, s = o);
      }
      return s || n - e;
    }
    // sorts node children by the best axis for split
    _chooseSplitAxis(t, e, n) {
      const s = t.leaf ? this.compareMinX : O_, r = t.leaf ? this.compareMinY : N_, a = this._allDistMargin(t, e, n, s), o = this._allDistMargin(t, e, n, r);
      a < o && t.children.sort(s);
    }
    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin(t, e, n, s) {
      t.children.sort(s);
      const r = this.toBBox, a = tr(t, 0, e, r), o = tr(t, n - e, n, r);
      let l = pa(a) + pa(o);
      for (let h = e; h < n - e; h++) {
        const c = t.children[h];
        er(a, t.leaf ? r(c) : c), l += pa(a);
      }
      for (let h = n - e - 1; h >= e; h--) {
        const c = t.children[h];
        er(o, t.leaf ? r(c) : c), l += pa(o);
      }
      return l;
    }
    _adjustParentBBoxes(t, e, n) {
      for (let s = n; s >= 0; s--)
        er(e[s], t);
    }
    _condense(t) {
      for (let e = t.length - 1, n; e >= 0; e--)
        t[e].children.length === 0 ? e > 0 ? (n = t[e - 1].children, n.splice(n.indexOf(t[e]), 1)) : this.clear() : Qn(t[e], this.toBBox);
    }
  };
  function L_(i, t, e) {
    if (!e) return t.indexOf(i);
    for (let n = 0; n < t.length; n++)
      if (e(i, t[n])) return n;
    return -1;
  }
  function Qn(i, t) {
    tr(i, 0, i.children.length, t, i);
  }
  function tr(i, t, e, n, s) {
    s || (s = as(null)), s.minX = 1 / 0, s.minY = 1 / 0, s.maxX = -1 / 0, s.maxY = -1 / 0;
    for (let r = t; r < e; r++) {
      const a = i.children[r];
      er(s, i.leaf ? n(a) : a);
    }
    return s;
  }
  function er(i, t) {
    return i.minX = Math.min(i.minX, t.minX), i.minY = Math.min(i.minY, t.minY), i.maxX = Math.max(i.maxX, t.maxX), i.maxY = Math.max(i.maxY, t.maxY), i;
  }
  function O_(i, t) {
    return i.minX - t.minX;
  }
  function N_(i, t) {
    return i.minY - t.minY;
  }
  function Jo(i) {
    return (i.maxX - i.minX) * (i.maxY - i.minY);
  }
  function pa(i) {
    return i.maxX - i.minX + (i.maxY - i.minY);
  }
  function F_(i, t) {
    return (Math.max(t.maxX, i.maxX) - Math.min(t.minX, i.minX)) * (Math.max(t.maxY, i.maxY) - Math.min(t.minY, i.minY));
  }
  function D_(i, t) {
    const e = Math.max(i.minX, t.minX), n = Math.max(i.minY, t.minY), s = Math.min(i.maxX, t.maxX), r = Math.min(i.maxY, t.maxY);
    return Math.max(0, s - e) * Math.max(0, r - n);
  }
  function Qo(i, t) {
    return i.minX <= t.minX && i.minY <= t.minY && t.maxX <= i.maxX && t.maxY <= i.maxY;
  }
  function ya(i, t) {
    return t.minX <= i.maxX && t.minY <= i.maxY && t.maxX >= i.minX && t.maxY >= i.minY;
  }
  function as(i) {
    return {
      children: i,
      height: 1,
      leaf: !0,
      minX: 1 / 0,
      minY: 1 / 0,
      maxX: -1 / 0,
      maxY: -1 / 0
    };
  }
  function tu(i, t, e, n, s) {
    const r = [t, e];
    for (; r.length; ) {
      if (e = r.pop(), t = r.pop(), e - t <= n) continue;
      const a = t + Math.ceil((e - t) / n / 2) * n;
      Kd(i, a, t, e, s), r.push(t, a, a, e);
    }
  }
  const eu = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
  var iu = {
    red: 0,
    orange: 60,
    yellow: 120,
    green: 180,
    blue: 240,
    purple: 300
  };
  function k_(i) {
    var c, u;
    var t, e = [], n = 1, s;
    if (typeof i == "number")
      return { space: "rgb", values: [i >>> 16, (i & 65280) >>> 8, i & 255], alpha: 1 };
    if (typeof i == "number") return { space: "rgb", values: [i >>> 16, (i & 65280) >>> 8, i & 255], alpha: 1 };
    if (i = String(i).toLowerCase(), eu[i])
      e = eu[i].slice(), s = "rgb";
    else if (i === "transparent")
      n = 0, s = "rgb", e = [0, 0, 0];
    else if (i[0] === "#") {
      var r = i.slice(1), a = r.length, o = a <= 4;
      n = 1, o ? (e = [
        parseInt(r[0] + r[0], 16),
        parseInt(r[1] + r[1], 16),
        parseInt(r[2] + r[2], 16)
      ], a === 4 && (n = parseInt(r[3] + r[3], 16) / 255)) : (e = [
        parseInt(r[0] + r[1], 16),
        parseInt(r[2] + r[3], 16),
        parseInt(r[4] + r[5], 16)
      ], a === 8 && (n = parseInt(r[6] + r[7], 16) / 255)), e[0] || (e[0] = 0), e[1] || (e[1] = 0), e[2] || (e[2] = 0), s = "rgb";
    } else if (t = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(i)) {
      var l = t[1];
      s = l.replace(/a$/, "");
      var h = s === "cmyk" ? 4 : s === "gray" ? 1 : 3;
      e = t[2].trim().split(/\s*[,\/]\s*|\s+/), s === "color" && (s = e.shift()), e = e.map(function(d, g) {
        if (d[d.length - 1] === "%")
          return d = parseFloat(d) / 100, g === 3 ? d : s === "rgb" ? d * 255 : s[0] === "h" || s[0] === "l" && !g ? d * 100 : s === "lab" ? d * 125 : s === "lch" ? g < 2 ? d * 150 : d * 360 : s[0] === "o" && !g ? d : s === "oklab" ? d * 0.4 : s === "oklch" ? g < 2 ? d * 0.4 : d * 360 : d;
        if (s[g] === "h" || g === 2 && s[s.length - 1] === "h") {
          if (iu[d] !== void 0) return iu[d];
          if (d.endsWith("deg")) return parseFloat(d);
          if (d.endsWith("turn")) return parseFloat(d) * 360;
          if (d.endsWith("grad")) return parseFloat(d) * 360 / 400;
          if (d.endsWith("rad")) return parseFloat(d) * 180 / Math.PI;
        }
        return d === "none" ? 0 : parseFloat(d);
      }), n = e.length > h ? e.pop() : 1;
    } else /[0-9](?:\s|\/|,)/.test(i) && (e = i.match(/([0-9]+)/g).map(function(d) {
      return parseFloat(d);
    }), s = ((u = (c = i.match(/([a-z])/ig)) == null ? void 0 : c.join("")) == null ? void 0 : u.toLowerCase()) || "rgb");
    return {
      space: s,
      values: e,
      alpha: n
    };
  }
  var Cr = {
    name: "rgb",
    min: [0, 0, 0],
    max: [255, 255, 255],
    channel: ["red", "green", "blue"],
    alias: ["RGB"]
  }, tl = {
    name: "hsl",
    min: [0, 0, 0],
    max: [360, 100, 100],
    channel: ["hue", "saturation", "lightness"],
    alias: ["HSL"],
    rgb: function(i) {
      var t = i[0] / 360, e = i[1] / 100, n = i[2] / 100, s, r, a, o, l, h = 0;
      if (e === 0) return l = n * 255, [l, l, l];
      for (r = n < 0.5 ? n * (1 + e) : n + e - n * e, s = 2 * n - r, o = [0, 0, 0]; h < 3; )
        a = t + 1 / 3 * -(h - 1), a < 0 ? a++ : a > 1 && a--, l = 6 * a < 1 ? s + (r - s) * 6 * a : 2 * a < 1 ? r : 3 * a < 2 ? s + (r - s) * (2 / 3 - a) * 6 : s, o[h++] = l * 255;
      return o;
    }
  };
  Cr.hsl = function(i) {
    var t = i[0] / 255, e = i[1] / 255, n = i[2] / 255, s = Math.min(t, e, n), r = Math.max(t, e, n), a = r - s, o, l, h;
    return r === s ? o = 0 : t === r ? o = (e - n) / a : e === r ? o = 2 + (n - t) / a : n === r && (o = 4 + (t - e) / a), o = Math.min(o * 60, 360), o < 0 && (o += 360), h = (s + r) / 2, r === s ? l = 0 : h <= 0.5 ? l = a / (r + s) : l = a / (2 - r - s), [o, l * 100, h * 100];
  };
  function G_(i) {
    Array.isArray(i) && i.raw && (i = String.raw(...arguments)), i instanceof Number && (i = +i);
    var t, e = k_(i);
    if (!e.space) return [];
    const n = e.space[0] === "h" ? tl.min : Cr.min, s = e.space[0] === "h" ? tl.max : Cr.max;
    return t = Array(3), t[0] = Math.min(Math.max(e.values[0], n[0]), s[0]), t[1] = Math.min(Math.max(e.values[1], n[1]), s[1]), t[2] = Math.min(Math.max(e.values[2], n[2]), s[2]), e.space[0] === "h" && (t = tl.rgb(t)), t.push(Math.min(Math.max(e.alpha, 0), 1)), t;
  }
  var ce = {
    name: "xyz",
    min: [0, 0, 0],
    channel: ["X", "Y", "Z"],
    alias: ["XYZ", "ciexyz", "cie1931"],
    /**
     * Whitepoint reference values with observer/illuminant
     *
     * http://en.wikipedia.org/wiki/Standard_illuminant
     */
    whitepoint: {
      //1931 2
      2: {
        //incadescent
        A: [109.85, 100, 35.585],
        // B:[],
        C: [98.074, 100, 118.232],
        D50: [96.422, 100, 82.521],
        D55: [95.682, 100, 92.149],
        //daylight
        D65: [95.045592705167, 100, 108.9057750759878],
        D75: [94.972, 100, 122.638],
        //flourescent
        // F1: [],
        F2: [99.187, 100, 67.395],
        // F3: [],
        // F4: [],
        // F5: [],
        // F6:[],
        F7: [95.044, 100, 108.755],
        // F8: [],
        // F9: [],
        // F10: [],
        F11: [100.966, 100, 64.37],
        // F12: [],
        E: [100, 100, 100]
      },
      //1964  10
      10: {
        //incadescent
        A: [111.144, 100, 35.2],
        C: [97.285, 100, 116.145],
        D50: [96.72, 100, 81.427],
        D55: [95.799, 100, 90.926],
        //daylight
        D65: [94.811, 100, 107.304],
        D75: [94.416, 100, 120.641],
        //flourescent
        F2: [103.28, 100, 69.026],
        F7: [95.792, 100, 107.687],
        F11: [103.866, 100, 65.627],
        E: [100, 100, 100]
      }
    }
  };
  ce.max = ce.whitepoint[2].D65;
  ce.rgb = function(i, t) {
    t = t || ce.whitepoint[2].E;
    var e = i[0] / t[0], n = i[1] / t[1], s = i[2] / t[2], r, a, o;
    return r = e * 3.240969941904521 + n * -1.537383177570093 + s * -0.498610760293, a = e * -0.96924363628087 + n * 1.87596750150772 + s * 0.041555057407175, o = e * 0.055630079696993 + n * -0.20397695888897 + s * 1.056971514242878, r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r = r * 12.92, a = a > 31308e-7 ? 1.055 * Math.pow(a, 1 / 2.4) - 0.055 : a = a * 12.92, o = o > 31308e-7 ? 1.055 * Math.pow(o, 1 / 2.4) - 0.055 : o = o * 12.92, r = Math.min(Math.max(0, r), 1), a = Math.min(Math.max(0, a), 1), o = Math.min(Math.max(0, o), 1), [r * 255, a * 255, o * 255];
  };
  Cr.xyz = function(i, t) {
    var e = i[0] / 255, n = i[1] / 255, s = i[2] / 255;
    e = e > 0.04045 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92, n = n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92, s = s > 0.04045 ? Math.pow((s + 0.055) / 1.055, 2.4) : s / 12.92;
    var r = e * 0.41239079926595 + n * 0.35758433938387 + s * 0.18048078840183, a = e * 0.21263900587151 + n * 0.71516867876775 + s * 0.072192315360733, o = e * 0.019330818715591 + n * 0.11919477979462 + s * 0.95053215224966;
    return t = t || ce.whitepoint[2].E, [r * t[0], a * t[1], o * t[2]];
  };
  var Fh = {
    name: "luv",
    //NOTE: luv has no rigidly defined limits
    //easyrgb fails to get proper coords
    //boronine states no rigid limits
    //colorMine refers this ones:
    min: [0, -134, -140],
    max: [100, 224, 122],
    channel: ["lightness", "u", "v"],
    alias: ["LUV", "cieluv", "cie1976"],
    xyz: function(i, t, e) {
      var n, s, r, a, o, l, h, c, u, d, g, _, y;
      if (r = i[0], a = i[1], o = i[2], r === 0) return [0, 0, 0];
      var E = 0.0011070564598794539;
      return t = t || "D65", e = e || 2, u = ce.whitepoint[e][t][0], d = ce.whitepoint[e][t][1], g = ce.whitepoint[e][t][2], _ = 4 * u / (u + 15 * d + 3 * g), y = 9 * d / (u + 15 * d + 3 * g), n = a / (13 * r) + _ || 0, s = o / (13 * r) + y || 0, h = r > 8 ? d * Math.pow((r + 16) / 116, 3) : d * r * E, l = h * 9 * n / (4 * s) || 0, c = h * (12 - 3 * n - 20 * s) / (4 * s) || 0, [l, h, c];
    }
  };
  ce.luv = function(i, t, e) {
    var n, s, r, a, o, l, h, c, u, d, g, _, y, E = 0.008856451679035631, M = 903.2962962962961;
    t = t || "D65", e = e || 2, u = ce.whitepoint[e][t][0], d = ce.whitepoint[e][t][1], g = ce.whitepoint[e][t][2], _ = 4 * u / (u + 15 * d + 3 * g), y = 9 * d / (u + 15 * d + 3 * g), l = i[0], h = i[1], c = i[2], n = 4 * l / (l + 15 * h + 3 * c) || 0, s = 9 * h / (l + 15 * h + 3 * c) || 0;
    var w = h / d;
    return r = w <= E ? M * w : 116 * Math.pow(w, 1 / 3) - 16, a = 13 * r * (n - _), o = 13 * r * (s - y), [r, a, o];
  };
  var jd = {
    name: "lchuv",
    channel: ["lightness", "chroma", "hue"],
    alias: ["LCHuv", "cielchuv"],
    min: [0, 0, 0],
    max: [100, 100, 360],
    luv: function(i) {
      var t = i[0], e = i[1], n = i[2], s, r, a;
      return a = n / 360 * 2 * Math.PI, s = e * Math.cos(a), r = e * Math.sin(a), [t, s, r];
    },
    xyz: function(i) {
      return Fh.xyz(jd.luv(i));
    }
  };
  Fh.lchuv = function(i) {
    var t = i[0], e = i[1], n = i[2], s = Math.sqrt(e * e + n * n), r = Math.atan2(n, e), a = r * 360 / 2 / Math.PI;
    return a < 0 && (a += 360), [t, s, a];
  };
  ce.lchuv = function(i) {
    return Fh.lchuv(ce.luv(i));
  };
  const Dh = [NaN, NaN, NaN, 0];
  function z_(i) {
    return typeof i == "string" ? i : Gh(i);
  }
  const $_ = 1024, Hs = {};
  let el = 0;
  function U_(i) {
    if (i.length === 4)
      return i;
    const t = i.slice();
    return t[3] = 1, t;
  }
  function nu(i) {
    const t = ce.lchuv(Cr.xyz(i));
    return t[3] = i[3], t;
  }
  function B_(i) {
    const t = ce.rgb(jd.xyz(i));
    return t[3] = i[3], t;
  }
  function kh(i) {
    if (i === "none")
      return Dh;
    if (Hs.hasOwnProperty(i))
      return Hs[i];
    if (el >= $_) {
      let e = 0;
      for (const n in Hs)
        e++ & 3 || (delete Hs[n], --el);
    }
    const t = G_(i);
    if (t.length !== 4)
      throw new Error('failed to parse "' + i + '" as color');
    for (const e of t)
      if (isNaN(e))
        throw new Error('failed to parse "' + i + '" as color');
    return Hd(t), Hs[i] = t, ++el, t;
  }
  function Ls(i) {
    return Array.isArray(i) ? i : kh(i);
  }
  function Hd(i) {
    return i[0] = zt(i[0] + 0.5 | 0, 0, 255), i[1] = zt(i[1] + 0.5 | 0, 0, 255), i[2] = zt(i[2] + 0.5 | 0, 0, 255), i[3] = zt(i[3], 0, 1), i;
  }
  function Gh(i) {
    let t = i[0];
    t != (t | 0) && (t = t + 0.5 | 0);
    let e = i[1];
    e != (e | 0) && (e = e + 0.5 | 0);
    let n = i[2];
    n != (n | 0) && (n = n + 0.5 | 0);
    const s = i[3] === void 0 ? 1 : Math.round(i[3] * 1e3) / 1e3;
    return "rgba(" + t + "," + e + "," + n + "," + s + ")";
  }
  function su(i) {
    return i[0] > 0 && i[1] > 0;
  }
  function W_(i, t, e) {
    return e === void 0 && (e = [0, 0]), e[0] = i[0] * t + 0.5 | 0, e[1] = i[1] * t + 0.5 | 0, e;
  }
  function Ce(i, t) {
    return Array.isArray(i) ? i : (t === void 0 ? t = [i, i] : (t[0] = i, t[1] = i), t);
  }
  let Bn = 0;
  const me = 1 << Bn++, yt = 1 << Bn++, Me = 1 << Bn++, Ve = 1 << Bn++, Gn = 1 << Bn++, ir = 1 << Bn++, va = Math.pow(2, Bn) - 1, zh = {
    [me]: "boolean",
    [yt]: "number",
    [Me]: "string",
    [Ve]: "color",
    [Gn]: "number[]",
    [ir]: "size"
  }, X_ = Object.keys(zh).map(Number).sort(Ki);
  function Y_(i) {
    return i in zh;
  }
  function nr(i) {
    const t = [];
    for (const e of X_)
      sr(i, e) && t.push(zh[e]);
    return t.length === 0 ? "untyped" : t.length < 3 ? t.join(" or ") : t.slice(0, -1).join(", ") + ", or " + t[t.length - 1];
  }
  function sr(i, t) {
    return (i & t) === t;
  }
  function Fi(i, t) {
    return i === t;
  }
  class Wt {
    /**
     * @param {number} type The value type.
     * @param {LiteralValue} value The literal value.
     */
    constructor(t, e) {
      if (!Y_(t))
        throw new Error(
          `literal expressions must have a specific type, got ${nr(t)}`
        );
      this.type = t, this.value = e;
    }
  }
  class Z_ {
    /**
     * @param {number} type The return type.
     * @param {string} operator The operator.
     * @param {...Expression} args The arguments.
     */
    constructor(t, e, ...n) {
      this.type = t, this.operator = e, this.args = n;
    }
  }
  function Jd() {
    return {
      variables: /* @__PURE__ */ new Set(),
      properties: /* @__PURE__ */ new Set(),
      featureId: !1,
      geometryType: !1,
      mapState: !1
    };
  }
  function ee(i, t, e) {
    switch (typeof i) {
      case "boolean": {
        if (Fi(t, Me))
          return new Wt(Me, i ? "true" : "false");
        if (!sr(t, me))
          throw new Error(
            `got a boolean, but expected ${nr(t)}`
          );
        return new Wt(me, i);
      }
      case "number": {
        if (Fi(t, ir))
          return new Wt(ir, Ce(i));
        if (Fi(t, me))
          return new Wt(me, !!i);
        if (Fi(t, Me))
          return new Wt(Me, i.toString());
        if (!sr(t, yt))
          throw new Error(`got a number, but expected ${nr(t)}`);
        return new Wt(yt, i);
      }
      case "string": {
        if (Fi(t, Ve))
          return new Wt(Ve, kh(i));
        if (Fi(t, me))
          return new Wt(me, !!i);
        if (!sr(t, Me))
          throw new Error(`got a string, but expected ${nr(t)}`);
        return new Wt(Me, i);
      }
    }
    if (!Array.isArray(i))
      throw new Error("expression must be an array or a primitive value");
    if (i.length === 0)
      throw new Error("empty expression");
    if (typeof i[0] == "string")
      return np(i, t, e);
    for (const n of i)
      if (typeof n != "number")
        throw new Error("expected an array of numbers");
    if (Fi(t, ir)) {
      if (i.length !== 2)
        throw new Error(
          `expected an array of two values for a size, got ${i.length}`
        );
      return new Wt(ir, i);
    }
    if (Fi(t, Ve)) {
      if (i.length === 3)
        return new Wt(Ve, [...i, 1]);
      if (i.length === 4)
        return new Wt(Ve, i);
      throw new Error(
        `expected an array of 3 or 4 values for a color, got ${i.length}`
      );
    }
    if (!sr(t, Gn))
      throw new Error(
        `got an array of numbers, but expected ${nr(t)}`
      );
    return new Wt(Gn, i);
  }
  const b = {
    Get: "get",
    Var: "var",
    Concat: "concat",
    GeometryType: "geometry-type",
    LineMetric: "line-metric",
    Any: "any",
    All: "all",
    Not: "!",
    Resolution: "resolution",
    Zoom: "zoom",
    Time: "time",
    Equal: "==",
    NotEqual: "!=",
    GreaterThan: ">",
    GreaterThanOrEqualTo: ">=",
    LessThan: "<",
    LessThanOrEqualTo: "<=",
    Multiply: "*",
    Divide: "/",
    Add: "+",
    Subtract: "-",
    Clamp: "clamp",
    Mod: "%",
    Pow: "^",
    Abs: "abs",
    Floor: "floor",
    Ceil: "ceil",
    Round: "round",
    Sin: "sin",
    Cos: "cos",
    Atan: "atan",
    Sqrt: "sqrt",
    Match: "match",
    Between: "between",
    Interpolate: "interpolate",
    Coalesce: "coalesce",
    Case: "case",
    In: "in",
    Number: "number",
    String: "string",
    Array: "array",
    Color: "color",
    Id: "id",
    Band: "band",
    Palette: "palette",
    ToString: "to-string",
    Has: "has"
  }, q_ = {
    [b.Get]: it(ht(1, 1 / 0), ru),
    [b.Var]: it(ht(1, 1), K_),
    [b.Has]: it(ht(1, 1 / 0), ru),
    [b.Id]: it(V_, ts),
    [b.Concat]: it(
      ht(2, 1 / 0),
      St(Me)
    ),
    [b.GeometryType]: it(j_, ts),
    [b.LineMetric]: it(ts),
    [b.Resolution]: it(il, ts),
    [b.Zoom]: it(il, ts),
    [b.Time]: it(il, ts),
    [b.Any]: it(
      ht(2, 1 / 0),
      St(me)
    ),
    [b.All]: it(
      ht(2, 1 / 0),
      St(me)
    ),
    [b.Not]: it(
      ht(1, 1),
      St(me)
    ),
    [b.Equal]: it(
      ht(2, 2),
      St(va)
    ),
    [b.NotEqual]: it(
      ht(2, 2),
      St(va)
    ),
    [b.GreaterThan]: it(
      ht(2, 2),
      St(yt)
    ),
    [b.GreaterThanOrEqualTo]: it(
      ht(2, 2),
      St(yt)
    ),
    [b.LessThan]: it(
      ht(2, 2),
      St(yt)
    ),
    [b.LessThanOrEqualTo]: it(
      ht(2, 2),
      St(yt)
    ),
    [b.Multiply]: it(
      ht(2, 1 / 0),
      au
    ),
    [b.Coalesce]: it(
      ht(2, 1 / 0),
      au
    ),
    [b.Divide]: it(
      ht(2, 2),
      St(yt)
    ),
    [b.Add]: it(
      ht(2, 1 / 0),
      St(yt)
    ),
    [b.Subtract]: it(
      ht(2, 2),
      St(yt)
    ),
    [b.Clamp]: it(
      ht(3, 3),
      St(yt)
    ),
    [b.Mod]: it(
      ht(2, 2),
      St(yt)
    ),
    [b.Pow]: it(
      ht(2, 2),
      St(yt)
    ),
    [b.Abs]: it(
      ht(1, 1),
      St(yt)
    ),
    [b.Floor]: it(
      ht(1, 1),
      St(yt)
    ),
    [b.Ceil]: it(
      ht(1, 1),
      St(yt)
    ),
    [b.Round]: it(
      ht(1, 1),
      St(yt)
    ),
    [b.Sin]: it(
      ht(1, 1),
      St(yt)
    ),
    [b.Cos]: it(
      ht(1, 1),
      St(yt)
    ),
    [b.Atan]: it(
      ht(1, 2),
      St(yt)
    ),
    [b.Sqrt]: it(
      ht(1, 1),
      St(yt)
    ),
    [b.Match]: it(
      ht(4, 1 / 0),
      ou,
      J_
    ),
    [b.Between]: it(
      ht(3, 3),
      St(yt)
    ),
    [b.Interpolate]: it(
      ht(6, 1 / 0),
      ou,
      Q_
    ),
    [b.Case]: it(
      ht(3, 1 / 0),
      H_,
      tp
    ),
    [b.In]: it(ht(2, 2), ep),
    [b.Number]: it(
      ht(1, 1 / 0),
      St(va)
    ),
    [b.String]: it(
      ht(1, 1 / 0),
      St(va)
    ),
    [b.Array]: it(
      ht(1, 1 / 0),
      St(yt)
    ),
    [b.Color]: it(
      ht(1, 4),
      St(yt)
    ),
    [b.Band]: it(
      ht(1, 3),
      St(yt)
    ),
    [b.Palette]: it(
      ht(2, 2),
      ip
    ),
    [b.ToString]: it(
      ht(1, 1),
      St(me | yt | Me | Ve)
    )
  };
  function ru(i, t, e) {
    const n = i.length - 1, s = new Array(n);
    for (let r = 0; r < n; ++r) {
      const a = i[r + 1];
      switch (typeof a) {
        case "number": {
          s[r] = new Wt(yt, a);
          break;
        }
        case "string": {
          s[r] = new Wt(Me, a);
          break;
        }
        default:
          throw new Error(
            `expected a string key or numeric array index for a get operation, got ${a}`
          );
      }
      r === 0 && e.properties.add(String(a));
    }
    return s;
  }
  function K_(i, t, e) {
    const n = i[1];
    if (typeof n != "string")
      throw new Error("expected a string argument for var operation");
    return e.variables.add(n), [new Wt(Me, n)];
  }
  function V_(i, t, e) {
    e.featureId = !0;
  }
  function j_(i, t, e) {
    e.geometryType = !0;
  }
  function il(i, t, e) {
    e.mapState = !0;
  }
  function ts(i, t, e) {
    const n = i[0];
    if (i.length !== 1)
      throw new Error(`expected no arguments for ${n} operation`);
    return [];
  }
  function ht(i, t) {
    return function(e, n, s) {
      const r = e[0], a = e.length - 1;
      if (i === t) {
        if (a !== i) {
          const o = i === 1 ? "" : "s";
          throw new Error(
            `expected ${i} argument${o} for ${r}, got ${a}`
          );
        }
      } else if (a < i || a > t) {
        const o = t === 1 / 0 ? `${i} or more` : `${i} to ${t}`;
        throw new Error(
          `expected ${o} arguments for ${r}, got ${a}`
        );
      }
    };
  }
  function au(i, t, e) {
    const n = i.length - 1, s = new Array(n);
    for (let r = 0; r < n; ++r) {
      const a = ee(i[r + 1], t, e);
      s[r] = a;
    }
    return s;
  }
  function St(i) {
    return function(t, e, n) {
      const s = t.length - 1, r = new Array(s);
      for (let a = 0; a < s; ++a) {
        const o = ee(t[a + 1], i, n);
        r[a] = o;
      }
      return r;
    };
  }
  function H_(i, t, e) {
    const n = i[0], s = i.length - 1;
    if (s % 2 === 0)
      throw new Error(
        `expected an odd number of arguments for ${n}, got ${s} instead`
      );
  }
  function ou(i, t, e) {
    const n = i[0], s = i.length - 1;
    if (s % 2 === 1)
      throw new Error(
        `expected an even number of arguments for operation ${n}, got ${s} instead`
      );
  }
  function J_(i, t, e) {
    const n = i.length - 1, s = Me | yt | me, r = ee(i[1], s, e), a = ee(i[i.length - 1], t, e), o = new Array(n - 2);
    for (let l = 0; l < n - 2; l += 2) {
      try {
        const h = ee(i[l + 2], r.type, e);
        o[l] = h;
      } catch (h) {
        throw new Error(
          `failed to parse argument ${l + 1} of match expression: ${h.message}`
        );
      }
      try {
        const h = ee(i[l + 3], a.type, e);
        o[l + 1] = h;
      } catch (h) {
        throw new Error(
          `failed to parse argument ${l + 2} of match expression: ${h.message}`
        );
      }
    }
    return [r, ...o, a];
  }
  function Q_(i, t, e) {
    const n = i[1];
    let s;
    switch (n[0]) {
      case "linear":
        s = 1;
        break;
      case "exponential":
        const l = n[1];
        if (typeof l != "number" || l <= 0)
          throw new Error(
            `expected a number base for exponential interpolation, got ${JSON.stringify(l)} instead`
          );
        s = l;
        break;
      default:
        throw new Error(
          `invalid interpolation type: ${JSON.stringify(n)}`
        );
    }
    const r = new Wt(yt, s);
    let a;
    try {
      a = ee(i[2], yt, e);
    } catch (l) {
      throw new Error(
        `failed to parse argument 1 in interpolate expression: ${l.message}`
      );
    }
    const o = new Array(i.length - 3);
    for (let l = 0; l < o.length; l += 2) {
      try {
        const h = ee(i[l + 3], yt, e);
        o[l] = h;
      } catch (h) {
        throw new Error(
          `failed to parse argument ${l + 2} for interpolate expression: ${h.message}`
        );
      }
      try {
        const h = ee(i[l + 4], t, e);
        o[l + 1] = h;
      } catch (h) {
        throw new Error(
          `failed to parse argument ${l + 3} for interpolate expression: ${h.message}`
        );
      }
    }
    return [r, a, ...o];
  }
  function tp(i, t, e) {
    const n = ee(i[i.length - 1], t, e), s = new Array(i.length - 1);
    for (let r = 0; r < s.length - 1; r += 2) {
      try {
        const a = ee(i[r + 1], me, e);
        s[r] = a;
      } catch (a) {
        throw new Error(
          `failed to parse argument ${r} of case expression: ${a.message}`
        );
      }
      try {
        const a = ee(i[r + 2], n.type, e);
        s[r + 1] = a;
      } catch (a) {
        throw new Error(
          `failed to parse argument ${r + 1} of case expression: ${a.message}`
        );
      }
    }
    return s[s.length - 1] = n, s;
  }
  function ep(i, t, e) {
    let n = i[2];
    if (!Array.isArray(n))
      throw new Error(
        'the second argument for the "in" operator must be an array'
      );
    let s;
    if (typeof n[0] == "string") {
      if (n[0] !== "literal")
        throw new Error(
          'for the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions'
        );
      if (!Array.isArray(n[1]))
        throw new Error(
          'failed to parse "in" expression: the literal operator must be followed by an array'
        );
      n = n[1], s = Me;
    } else
      s = yt;
    const r = new Array(n.length);
    for (let o = 0; o < r.length; o++)
      try {
        const l = ee(n[o], s, e);
        r[o] = l;
      } catch (l) {
        throw new Error(
          `failed to parse haystack item ${o} for "in" expression: ${l.message}`
        );
      }
    return [ee(i[1], s, e), ...r];
  }
  function ip(i, t, e) {
    let n;
    try {
      n = ee(i[1], yt, e);
    } catch (a) {
      throw new Error(
        `failed to parse first argument in palette expression: ${a.message}`
      );
    }
    const s = i[2];
    if (!Array.isArray(s))
      throw new Error("the second argument of palette must be an array");
    const r = new Array(s.length);
    for (let a = 0; a < r.length; a++) {
      let o;
      try {
        o = ee(s[a], Ve, e);
      } catch (l) {
        throw new Error(
          `failed to parse color at index ${a} in palette expression: ${l.message}`
        );
      }
      if (!(o instanceof Wt))
        throw new Error(
          `the palette color at index ${a} must be a literal value`
        );
      r[a] = o;
    }
    return [n, ...r];
  }
  function it(...i) {
    return function(t, e, n) {
      const s = t[0];
      let r;
      for (let a = 0; a < i.length; a++) {
        const o = i[a](t, e, n);
        if (a == i.length - 1) {
          if (!o)
            throw new Error(
              "expected last argument validator to return the parsed args"
            );
          r = o;
        }
      }
      return new Z_(e, s, ...r);
    };
  }
  function np(i, t, e) {
    const n = i[0], s = q_[n];
    if (!s)
      throw new Error(`unknown operator: ${n}`);
    return s(i, t, e);
  }
  function Qd(i) {
    if (!i)
      return "";
    const t = i.getType();
    switch (t) {
      case "Point":
      case "LineString":
      case "Polygon":
        return t;
      case "MultiPoint":
      case "MultiLineString":
      case "MultiPolygon":
        return (
          /** @type {'Point'|'LineString'|'Polygon'} */
          t.substring(5)
        );
      case "Circle":
        return "Polygon";
      case "GeometryCollection":
        return Qd(
          /** @type {import("../geom/GeometryCollection.js").default} */
          i.getGeometries()[0]
        );
      default:
        return "";
    }
  }
  function tf() {
    return {
      variables: {},
      properties: {},
      resolution: NaN,
      featureId: null,
      geometryType: ""
    };
  }
  function Ai(i, t, e) {
    const n = ee(i, t, e);
    return Je(n);
  }
  function Je(i, t) {
    if (i instanceof Wt) {
      if (i.type === Ve && typeof i.value == "string") {
        const n = kh(i.value);
        return function() {
          return n;
        };
      }
      return function() {
        return i.value;
      };
    }
    const e = i.operator;
    switch (e) {
      case b.Number:
      case b.String:
      case b.Coalesce:
        return sp(i);
      case b.Get:
      case b.Var:
      case b.Has:
        return rp(i);
      case b.Id:
        return (n) => n.featureId;
      case b.GeometryType:
        return (n) => n.geometryType;
      case b.Concat: {
        const n = i.args.map((s) => Je(s));
        return (s) => "".concat(...n.map((r) => r(s).toString()));
      }
      case b.Resolution:
        return (n) => n.resolution;
      case b.Any:
      case b.All:
      case b.Between:
      case b.In:
      case b.Not:
        return op(i);
      case b.Equal:
      case b.NotEqual:
      case b.LessThan:
      case b.LessThanOrEqualTo:
      case b.GreaterThan:
      case b.GreaterThanOrEqualTo:
        return ap(i);
      case b.Multiply:
      case b.Divide:
      case b.Add:
      case b.Subtract:
      case b.Clamp:
      case b.Mod:
      case b.Pow:
      case b.Abs:
      case b.Floor:
      case b.Ceil:
      case b.Round:
      case b.Sin:
      case b.Cos:
      case b.Atan:
      case b.Sqrt:
        return lp(i);
      case b.Case:
        return hp(i);
      case b.Match:
        return cp(i);
      case b.Interpolate:
        return up(i);
      case b.ToString:
        return dp(i);
      default:
        throw new Error(`Unsupported operator ${e}`);
    }
  }
  function sp(i, t) {
    const e = i.operator, n = i.args.length, s = new Array(n);
    for (let r = 0; r < n; ++r)
      s[r] = Je(i.args[r]);
    switch (e) {
      case b.Coalesce:
        return (r) => {
          for (let a = 0; a < n; ++a) {
            const o = s[a](r);
            if (typeof o < "u" && o !== null)
              return o;
          }
          throw new Error("Expected one of the values to be non-null");
        };
      case b.Number:
      case b.String:
        return (r) => {
          for (let a = 0; a < n; ++a) {
            const o = s[a](r);
            if (typeof o === e)
              return o;
          }
          throw new Error(`Expected one of the values to be a ${e}`);
        };
      default:
        throw new Error(`Unsupported assertion operator ${e}`);
    }
  }
  function rp(i, t) {
    const n = (
      /** @type {string} */
      /** @type {LiteralExpression} */
      i.args[0].value
    );
    switch (i.operator) {
      case b.Get:
        return (s) => {
          const r = i.args;
          let a = s.properties[n];
          for (let o = 1, l = r.length; o < l; ++o) {
            const c = (
              /** @type {string|number} */
              /** @type {LiteralExpression} */
              r[o].value
            );
            a = a[c];
          }
          return a;
        };
      case b.Var:
        return (s) => s.variables[n];
      case b.Has:
        return (s) => {
          const r = i.args;
          if (!(n in s.properties))
            return !1;
          let a = s.properties[n];
          for (let o = 1, l = r.length; o < l; ++o) {
            const c = (
              /** @type {string|number} */
              /** @type {LiteralExpression} */
              r[o].value
            );
            if (!a || !Object.hasOwn(a, c))
              return !1;
            a = a[c];
          }
          return !0;
        };
      default:
        throw new Error(`Unsupported accessor operator ${i.operator}`);
    }
  }
  function ap(i, t) {
    const e = i.operator, n = Je(i.args[0]), s = Je(i.args[1]);
    switch (e) {
      case b.Equal:
        return (r) => n(r) === s(r);
      case b.NotEqual:
        return (r) => n(r) !== s(r);
      case b.LessThan:
        return (r) => n(r) < s(r);
      case b.LessThanOrEqualTo:
        return (r) => n(r) <= s(r);
      case b.GreaterThan:
        return (r) => n(r) > s(r);
      case b.GreaterThanOrEqualTo:
        return (r) => n(r) >= s(r);
      default:
        throw new Error(`Unsupported comparison operator ${e}`);
    }
  }
  function op(i, t) {
    const e = i.operator, n = i.args.length, s = new Array(n);
    for (let r = 0; r < n; ++r)
      s[r] = Je(i.args[r]);
    switch (e) {
      case b.Any:
        return (r) => {
          for (let a = 0; a < n; ++a)
            if (s[a](r))
              return !0;
          return !1;
        };
      case b.All:
        return (r) => {
          for (let a = 0; a < n; ++a)
            if (!s[a](r))
              return !1;
          return !0;
        };
      case b.Between:
        return (r) => {
          const a = s[0](r), o = s[1](r), l = s[2](r);
          return a >= o && a <= l;
        };
      case b.In:
        return (r) => {
          const a = s[0](r);
          for (let o = 1; o < n; ++o)
            if (a === s[o](r))
              return !0;
          return !1;
        };
      case b.Not:
        return (r) => !s[0](r);
      default:
        throw new Error(`Unsupported logical operator ${e}`);
    }
  }
  function lp(i, t) {
    const e = i.operator, n = i.args.length, s = new Array(n);
    for (let r = 0; r < n; ++r)
      s[r] = Je(i.args[r]);
    switch (e) {
      case b.Multiply:
        return (r) => {
          let a = 1;
          for (let o = 0; o < n; ++o)
            a *= s[o](r);
          return a;
        };
      case b.Divide:
        return (r) => s[0](r) / s[1](r);
      case b.Add:
        return (r) => {
          let a = 0;
          for (let o = 0; o < n; ++o)
            a += s[o](r);
          return a;
        };
      case b.Subtract:
        return (r) => s[0](r) - s[1](r);
      case b.Clamp:
        return (r) => {
          const a = s[0](r), o = s[1](r);
          if (a < o)
            return o;
          const l = s[2](r);
          return a > l ? l : a;
        };
      case b.Mod:
        return (r) => s[0](r) % s[1](r);
      case b.Pow:
        return (r) => Math.pow(s[0](r), s[1](r));
      case b.Abs:
        return (r) => Math.abs(s[0](r));
      case b.Floor:
        return (r) => Math.floor(s[0](r));
      case b.Ceil:
        return (r) => Math.ceil(s[0](r));
      case b.Round:
        return (r) => Math.round(s[0](r));
      case b.Sin:
        return (r) => Math.sin(s[0](r));
      case b.Cos:
        return (r) => Math.cos(s[0](r));
      case b.Atan:
        return n === 2 ? (r) => Math.atan2(s[0](r), s[1](r)) : (r) => Math.atan(s[0](r));
      case b.Sqrt:
        return (r) => Math.sqrt(s[0](r));
      default:
        throw new Error(`Unsupported numeric operator ${e}`);
    }
  }
  function hp(i, t) {
    const e = i.args.length, n = new Array(e);
    for (let s = 0; s < e; ++s)
      n[s] = Je(i.args[s]);
    return (s) => {
      for (let r = 0; r < e - 1; r += 2)
        if (n[r](s))
          return n[r + 1](s);
      return n[e - 1](s);
    };
  }
  function cp(i, t) {
    const e = i.args.length, n = new Array(e);
    for (let s = 0; s < e; ++s)
      n[s] = Je(i.args[s]);
    return (s) => {
      const r = n[0](s);
      for (let a = 1; a < e; a += 2)
        if (r === n[a](s))
          return n[a + 1](s);
      return n[e - 1](s);
    };
  }
  function up(i, t) {
    const e = i.args.length, n = new Array(e);
    for (let s = 0; s < e; ++s)
      n[s] = Je(i.args[s]);
    return (s) => {
      const r = n[0](s), a = n[1](s);
      let o, l;
      for (let h = 2; h < e; h += 2) {
        const c = n[h](s);
        let u = n[h + 1](s);
        const d = Array.isArray(u);
        if (d && (u = U_(u)), c >= a)
          return h === 2 ? u : d ? fp(
            r,
            a,
            o,
            l,
            c,
            u
          ) : rr(
            r,
            a,
            o,
            l,
            c,
            u
          );
        o = c, l = u;
      }
      return l;
    };
  }
  function dp(i, t) {
    const e = i.operator, n = i.args.length, s = new Array(n);
    for (let r = 0; r < n; ++r)
      s[r] = Je(i.args[r]);
    switch (e) {
      case b.ToString:
        return (r) => {
          const a = s[0](r);
          return i.args[0].type === Ve ? Gh(a) : a.toString();
        };
      default:
        throw new Error(`Unsupported convert operator ${e}`);
    }
  }
  function rr(i, t, e, n, s, r) {
    const a = s - e;
    if (a === 0)
      return n;
    const o = t - e, l = i === 1 ? o / a : (Math.pow(i, o) - 1) / (Math.pow(i, a) - 1);
    return n + l * (r - n);
  }
  function fp(i, t, e, n, s, r) {
    if (s - e === 0)
      return n;
    const o = nu(n), l = nu(r);
    let h = l[2] - o[2];
    h > 180 ? h -= 360 : h < -180 && (h += 360);
    const c = [
      rr(i, t, e, o[0], s, l[0]),
      rr(i, t, e, o[1], s, l[1]),
      o[2] + rr(i, t, e, 0, s, h),
      rr(i, t, e, n[3], s, r[3])
    ];
    return Hd(B_(c));
  }
  const ut = {
    IDLE: 0,
    LOADING: 1,
    LOADED: 2,
    ERROR: 3,
    EMPTY: 4
  };
  function gp(i, t, e) {
    const n = (
      /** @type {HTMLImageElement} */
      i
    );
    let s = !0, r = !1, a = !1;
    const o = [
      Da(n, at.LOAD, function() {
        a = !0, r || t();
      })
    ];
    return n.src && Ql ? (r = !0, n.decode().then(function() {
      s && t();
    }).catch(function(l) {
      s && (a ? t() : e());
    })) : o.push(Da(n, at.ERROR, e)), function() {
      s = !1, o.forEach(Pt);
    };
  }
  function mp(i, t) {
    return new Promise((e, n) => {
      function s() {
        a(), e(i);
      }
      function r() {
        a(), n(new Error("Image load error"));
      }
      function a() {
        i.removeEventListener("load", s), i.removeEventListener("error", r);
      }
      i.addEventListener("load", s), i.addEventListener("error", r);
    });
  }
  function _p(i, t) {
    return t && (i.src = t), i.src && Ql ? new Promise(
      (e, n) => i.decode().then(() => e(i)).catch(
        (s) => i.complete && i.width ? e(i) : n(s)
      )
    ) : mp(i);
  }
  class pp {
    constructor() {
      this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0, this.maxCacheSize_ = 1024;
    }
    /**
     * FIXME empty description for jsdoc
     */
    clear() {
      this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0;
    }
    /**
     * @return {boolean} Can expire cache.
     */
    canExpireCache() {
      return this.cacheSize_ > this.maxCacheSize_;
    }
    /**
     * FIXME empty description for jsdoc
     */
    expire() {
      if (this.canExpireCache()) {
        let t = 0;
        for (const e in this.cache_) {
          const n = this.cache_[e];
          !(t++ & 3) && !n.hasListener() && (delete this.cache_[e], delete this.patternCache_[e], --this.cacheSize_);
        }
      }
    }
    /**
     * @param {string} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../color.js").Color|string|null} color Color.
     * @return {import("./IconImage.js").default} Icon image.
     */
    get(t, e, n) {
      const s = nl(t, e, n);
      return s in this.cache_ ? this.cache_[s] : null;
    }
    /**
     * @param {string} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../color.js").Color|string|null} color Color.
     * @return {CanvasPattern} Icon image.
     */
    getPattern(t, e, n) {
      const s = nl(t, e, n);
      return s in this.patternCache_ ? this.patternCache_[s] : null;
    }
    /**
     * @param {string} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../color.js").Color|string|null} color Color.
     * @param {import("./IconImage.js").default|null} iconImage Icon image.
     * @param {boolean} [pattern] Also cache a `'repeat'` pattern with this `iconImage`.
     */
    set(t, e, n, s, r) {
      const a = nl(t, e, n), o = a in this.cache_;
      this.cache_[a] = s, r && (s.getImageState() === ut.IDLE && s.load(), s.getImageState() === ut.LOADING ? s.ready().then(() => {
        this.patternCache_[a] = Xa().createPattern(
          s.getImage(1),
          "repeat"
        );
      }) : this.patternCache_[a] = Xa().createPattern(
        s.getImage(1),
        "repeat"
      )), o || ++this.cacheSize_;
    }
    /**
     * Set the cache size of the icon cache. Default is `1024`. Change this value when
     * your map uses more than 1024 different icon images and you are not caching icon
     * styles on the application level.
     * @param {number} maxCacheSize Cache max size.
     * @api
     */
    setSize(t) {
      this.maxCacheSize_ = t, this.expire();
    }
  }
  function nl(i, t, e) {
    const n = e ? Ls(e) : "null";
    return t + ":" + i + ":" + n;
  }
  const Ge = new pp();
  let Js = null;
  class $h extends ho {
    /**
     * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap|null} image Image.
     * @param {string|undefined} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../ImageState.js").default|undefined} imageState Image state.
     * @param {import("../color.js").Color|string|null} color Color.
     */
    constructor(t, e, n, s, r) {
      super(), this.hitDetectionImage_ = null, this.image_ = t, this.crossOrigin_ = n, this.canvas_ = {}, this.color_ = r, this.imageState_ = s === void 0 ? ut.IDLE : s, this.size_ = t && t.width && t.height ? [t.width, t.height] : null, this.src_ = e, this.tainted_, this.ready_ = null;
    }
    /**
     * @private
     */
    initializeImage_() {
      this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_);
    }
    /**
     * @private
     * @return {boolean} The image canvas is tainted.
     */
    isTainted_() {
      if (this.tainted_ === void 0 && this.imageState_ === ut.LOADED) {
        Js || (Js = Kt(1, 1, void 0, {
          willReadFrequently: !0
        })), Js.drawImage(this.image_, 0, 0);
        try {
          Js.getImageData(0, 0, 1, 1), this.tainted_ = !1;
        } catch {
          Js = null, this.tainted_ = !0;
        }
      }
      return this.tainted_ === !0;
    }
    /**
     * @private
     */
    dispatchChangeEvent_() {
      this.dispatchEvent(at.CHANGE);
    }
    /**
     * @private
     */
    handleImageError_() {
      this.imageState_ = ut.ERROR, this.dispatchChangeEvent_();
    }
    /**
     * @private
     */
    handleImageLoad_() {
      this.imageState_ = ut.LOADED, this.size_ = [this.image_.width, this.image_.height], this.dispatchChangeEvent_();
    }
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
     */
    getImage(t) {
      return this.image_ || this.initializeImage_(), this.replaceColor_(t), this.canvas_[t] ? this.canvas_[t] : this.image_;
    }
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Image or Canvas element.
     */
    getPixelRatio(t) {
      return this.replaceColor_(t), this.canvas_[t] ? t : 1;
    }
    /**
     * @return {import("../ImageState.js").default} Image state.
     */
    getImageState() {
      return this.imageState_;
    }
    /**
     * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
     */
    getHitDetectionImage() {
      if (this.image_ || this.initializeImage_(), !this.hitDetectionImage_)
        if (this.isTainted_()) {
          const t = this.size_[0], e = this.size_[1], n = Kt(t, e);
          n.fillRect(0, 0, t, e), this.hitDetectionImage_ = n.canvas;
        } else
          this.hitDetectionImage_ = this.image_;
      return this.hitDetectionImage_;
    }
    /**
     * Get the size of the icon (in pixels).
     * @return {import("../size.js").Size} Image size.
     */
    getSize() {
      return this.size_;
    }
    /**
     * @return {string|undefined} Image src.
     */
    getSrc() {
      return this.src_;
    }
    /**
     * Load not yet loaded URI.
     */
    load() {
      if (this.imageState_ === ut.IDLE) {
        this.image_ || this.initializeImage_(), this.imageState_ = ut.LOADING;
        try {
          this.src_ !== void 0 && (this.image_.src = this.src_);
        } catch {
          this.handleImageError_();
        }
        this.image_ instanceof HTMLImageElement && _p(this.image_, this.src_).then((t) => {
          this.image_ = t, this.handleImageLoad_();
        }).catch(this.handleImageError_.bind(this));
      }
    }
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @private
     */
    replaceColor_(t) {
      if (!this.color_ || this.canvas_[t] || this.imageState_ !== ut.LOADED)
        return;
      const e = this.image_, n = Kt(
        Math.ceil(e.width * t),
        Math.ceil(e.height * t)
      ), s = n.canvas;
      n.scale(t, t), n.drawImage(e, 0, 0), n.globalCompositeOperation = "multiply", n.fillStyle = z_(this.color_), n.fillRect(0, 0, s.width / t, s.height / t), n.globalCompositeOperation = "destination-in", n.drawImage(e, 0, 0), this.canvas_[t] = s;
    }
    /**
     * @return {Promise<void>} Promise that resolves when the image is loaded.
     */
    ready() {
      return this.ready_ || (this.ready_ = new Promise((t) => {
        if (this.imageState_ === ut.LOADED || this.imageState_ === ut.ERROR)
          t();
        else {
          const e = () => {
            (this.imageState_ === ut.LOADED || this.imageState_ === ut.ERROR) && (this.removeEventListener(at.CHANGE, e), t());
          };
          this.addEventListener(at.CHANGE, e);
        }
      })), this.ready_;
    }
  }
  function Uh(i, t, e, n, s, r) {
    let a = t === void 0 ? void 0 : Ge.get(t, e, s);
    return a || (a = new $h(
      i,
      i && "src" in i ? i.src || void 0 : t,
      e,
      n,
      s
    ), Ge.set(t, e, s, a, r)), r && a && !Ge.getPattern(t, e, s) && Ge.set(t, e, s, a, r), a;
  }
  function si(i) {
    return i ? Array.isArray(i) ? Gh(i) : typeof i == "object" && "src" in i ? yp(i) : i : null;
  }
  function yp(i) {
    if (!i.offset || !i.size)
      return Ge.getPattern(i.src, "anonymous", i.color);
    const t = i.src + ":" + i.offset, e = Ge.getPattern(
      t,
      void 0,
      i.color
    );
    if (e)
      return e;
    const n = Ge.get(i.src, "anonymous", null);
    if (n.getImageState() !== ut.LOADED)
      return null;
    const s = Kt(
      i.size[0],
      i.size[1]
    );
    return s.drawImage(
      n.getImage(1),
      i.offset[0],
      i.offset[1],
      i.size[0],
      i.size[1],
      0,
      0,
      i.size[0],
      i.size[1]
    ), Uh(
      s.canvas,
      t,
      void 0,
      ut.LOADED,
      i.color,
      !0
    ), Ge.getPattern(t, void 0, i.color);
  }
  const ef = "10px sans-serif", xe = "#000", Os = "round", xi = [], wi = 0, Ns = "round", Rr = 10, Ir = "#000", Tr = "center", Ya = "middle", An = [0, 0, 0, 0], Ar = 1, yi = new Qe();
  let os = null, Ll;
  const Ol = {}, vp = function() {
    const t = "32px ", e = ["monospace", "serif"], n = e.length, s = "wmytzilWMYTZIL@#/&?$%10";
    let r, a;
    function o(h, c, u) {
      let d = !0;
      for (let g = 0; g < n; ++g) {
        const _ = e[g];
        if (a = Za(
          h + " " + c + " " + t + _,
          s
        ), u != _) {
          const y = Za(
            h + " " + c + " " + t + u + "," + _,
            s
          );
          d = d && y != a;
        }
      }
      return !!d;
    }
    function l() {
      let h = !0;
      const c = yi.getKeys();
      for (let u = 0, d = c.length; u < d; ++u) {
        const g = c[u];
        if (yi.get(g) < 100) {
          const [_, y, E] = g.split(`
`);
          o(_, y, E) ? (Dr(Ol), os = null, Ll = void 0, yi.set(g, 100)) : (yi.set(g, yi.get(g) + 1, !0), h = !1);
        }
      }
      h && (clearInterval(r), r = void 0);
    }
    return function(h) {
      const c = Ud(h);
      if (!c)
        return;
      const u = c.families;
      for (let d = 0, g = u.length; d < g; ++d) {
        const _ = u[d], y = c.style + `
` + c.weight + `
` + _;
        yi.get(y) === void 0 && (yi.set(y, 100, !0), o(c.style, c.weight, _) || (yi.set(y, 0, !0), r === void 0 && (r = setInterval(l, 32))));
      }
    };
  }(), Ep = /* @__PURE__ */ function() {
    let i;
    return function(t) {
      let e = Ol[t];
      if (e == null) {
        if (Jl) {
          const n = Ud(t), s = nf(t, "g");
          e = (isNaN(Number(n.lineHeight)) ? 1.2 : Number(n.lineHeight)) * (s.actualBoundingBoxAscent + s.actualBoundingBoxDescent);
        } else
          i || (i = document.createElement("div"), i.innerHTML = "M", i.style.minHeight = "0", i.style.maxHeight = "none", i.style.height = "auto", i.style.padding = "0", i.style.border = "none", i.style.position = "absolute", i.style.display = "block", i.style.left = "-99999px"), i.style.font = t, document.body.appendChild(i), e = i.offsetHeight, document.body.removeChild(i);
        Ol[t] = e;
      }
      return e;
    };
  }();
  function nf(i, t) {
    return os || (os = Kt(1, 1)), i != Ll && (os.font = i, Ll = os.font), os.measureText(t);
  }
  function Za(i, t) {
    return nf(i, t).width;
  }
  function lu(i, t, e) {
    if (t in e)
      return e[t];
    const n = t.split(`
`).reduce((s, r) => Math.max(s, Za(i, r)), 0);
    return e[t] = n, n;
  }
  function Mp(i, t) {
    const e = [], n = [], s = [];
    let r = 0, a = 0, o = 0, l = 0;
    for (let h = 0, c = t.length; h <= c; h += 2) {
      const u = t[h];
      if (u === `
` || h === c) {
        r = Math.max(r, a), s.push(a), a = 0, o += l, l = 0;
        continue;
      }
      const d = t[h + 1] || i.font, g = Za(d, u);
      e.push(g), a += g;
      const _ = Ep(d);
      n.push(_), l = Math.max(l, _);
    }
    return { width: r, height: o, widths: e, heights: n, lineWidths: s };
  }
  function xp(i, t, e, n, s, r, a, o, l, h, c) {
    i.save(), e !== 1 && (i.globalAlpha === void 0 ? i.globalAlpha = (u) => u.globalAlpha *= e : i.globalAlpha *= e), t && i.transform.apply(i, t), /** @type {*} */
    n.contextInstructions ? (i.translate(l, h), i.scale(c[0], c[1]), wp(
      /** @type {Label} */
      n,
      i
    )) : c[0] < 0 || c[1] < 0 ? (i.translate(l, h), i.scale(c[0], c[1]), i.drawImage(
      /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
      n,
      s,
      r,
      a,
      o,
      0,
      0,
      a,
      o
    )) : i.drawImage(
      /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
      n,
      s,
      r,
      a,
      o,
      l,
      h,
      a * c[0],
      o * c[1]
    ), i.restore();
  }
  function wp(i, t) {
    const e = i.contextInstructions;
    for (let n = 0, s = e.length; n < s; n += 2)
      Array.isArray(e[n + 1]) ? t[e[n]].apply(
        t,
        e[n + 1]
      ) : t[e[n]] = e[n + 1];
  }
  class Xr {
    /**
     * @param {Options} options Options.
     */
    constructor(t) {
      this.opacity_ = t.opacity, this.rotateWithView_ = t.rotateWithView, this.rotation_ = t.rotation, this.scale_ = t.scale, this.scaleArray_ = Ce(t.scale), this.displacement_ = t.displacement, this.declutterMode_ = t.declutterMode;
    }
    /**
     * Clones the style.
     * @return {ImageStyle} The cloned style.
     * @api
     */
    clone() {
      const t = this.getScale();
      return new Xr({
        opacity: this.getOpacity(),
        scale: Array.isArray(t) ? t.slice() : t,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
    }
    /**
     * Get the symbolizer opacity.
     * @return {number} Opacity.
     * @api
     */
    getOpacity() {
      return this.opacity_;
    }
    /**
     * Determine whether the symbolizer rotates with the map.
     * @return {boolean} Rotate with map.
     * @api
     */
    getRotateWithView() {
      return this.rotateWithView_;
    }
    /**
     * Get the symoblizer rotation.
     * @return {number} Rotation.
     * @api
     */
    getRotation() {
      return this.rotation_;
    }
    /**
     * Get the symbolizer scale.
     * @return {number|import("../size.js").Size} Scale.
     * @api
     */
    getScale() {
      return this.scale_;
    }
    /**
     * Get the symbolizer scale array.
     * @return {import("../size.js").Size} Scale array.
     */
    getScaleArray() {
      return this.scaleArray_;
    }
    /**
     * Get the displacement of the shape
     * @return {Array<number>} Shape's center displacement
     * @api
     */
    getDisplacement() {
      return this.displacement_;
    }
    /**
     * Get the declutter mode of the shape
     * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
     * @api
     */
    getDeclutterMode() {
      return this.declutterMode_;
    }
    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @abstract
     * @return {Array<number>} Anchor.
     */
    getAnchor() {
      return ct();
    }
    /**
     * Get the image element for the symbolizer.
     * @abstract
     * @param {number} pixelRatio Pixel ratio.
     * @return {import('../DataTile.js').ImageLike} Image element.
     */
    getImage(t) {
      return ct();
    }
    /**
     * @abstract
     * @return {import('../DataTile.js').ImageLike} Image element.
     */
    getHitDetectionImage() {
      return ct();
    }
    /**
     * Get the image pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Pixel ratio.
     */
    getPixelRatio(t) {
      return 1;
    }
    /**
     * @abstract
     * @return {import("../ImageState.js").default} Image state.
     */
    getImageState() {
      return ct();
    }
    /**
     * @abstract
     * @return {import("../size.js").Size} Image size.
     */
    getImageSize() {
      return ct();
    }
    /**
     * Get the origin of the symbolizer.
     * @abstract
     * @return {Array<number>} Origin.
     */
    getOrigin() {
      return ct();
    }
    /**
     * Get the size of the symbolizer (in pixels).
     * @abstract
     * @return {import("../size.js").Size} Size.
     */
    getSize() {
      return ct();
    }
    /**
     * Set the displacement.
     *
     * @param {Array<number>} displacement Displacement.
     * @api
     */
    setDisplacement(t) {
      this.displacement_ = t;
    }
    /**
     * Set the opacity.
     *
     * @param {number} opacity Opacity.
     * @api
     */
    setOpacity(t) {
      this.opacity_ = t;
    }
    /**
     * Set whether to rotate the style with the view.
     *
     * @param {boolean} rotateWithView Rotate with map.
     * @api
     */
    setRotateWithView(t) {
      this.rotateWithView_ = t;
    }
    /**
     * Set the rotation.
     *
     * @param {number} rotation Rotation.
     * @api
     */
    setRotation(t) {
      this.rotation_ = t;
    }
    /**
     * Set the scale.
     *
     * @param {number|import("../size.js").Size} scale Scale.
     * @api
     */
    setScale(t) {
      this.scale_ = t, this.scaleArray_ = Ce(t);
    }
    /**
     * @abstract
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
    listenImageChange(t) {
      ct();
    }
    /**
     * Load not yet loaded URI.
     * @abstract
     */
    load() {
      ct();
    }
    /**
     * @abstract
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
    unlistenImageChange(t) {
      ct();
    }
    /**
     * @return {Promise<void>} `false` or Promise that resolves when the style is ready to use.
     */
    ready() {
      return Promise.resolve();
    }
  }
  class Yr extends Xr {
    /**
     * @param {Options} options Options.
     */
    constructor(t) {
      super({
        opacity: 1,
        rotateWithView: t.rotateWithView !== void 0 ? t.rotateWithView : !1,
        rotation: t.rotation !== void 0 ? t.rotation : 0,
        scale: t.scale !== void 0 ? t.scale : 1,
        displacement: t.displacement !== void 0 ? t.displacement : [0, 0],
        declutterMode: t.declutterMode
      }), this.hitDetectionCanvas_ = null, this.fill_ = t.fill !== void 0 ? t.fill : null, this.origin_ = [0, 0], this.points_ = t.points, this.radius = t.radius, this.radius2_ = t.radius2, this.angle_ = t.angle !== void 0 ? t.angle : 0, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.size_, this.renderOptions_, this.imageState_ = this.fill_ && this.fill_.loading() ? ut.LOADING : ut.LOADED, this.imageState_ === ut.LOADING && this.ready().then(() => this.imageState_ = ut.LOADED), this.render();
    }
    /**
     * Clones the style.
     * @return {RegularShape} The cloned style.
     * @api
     * @override
     */
    clone() {
      const t = this.getScale(), e = new Yr({
        fill: this.getFill() ? this.getFill().clone() : void 0,
        points: this.getPoints(),
        radius: this.getRadius(),
        radius2: this.getRadius2(),
        angle: this.getAngle(),
        stroke: this.getStroke() ? this.getStroke().clone() : void 0,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        scale: Array.isArray(t) ? t.slice() : t,
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
      return e.setOpacity(this.getOpacity()), e;
    }
    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @return {Array<number>} Anchor.
     * @api
     * @override
     */
    getAnchor() {
      const t = this.size_, e = this.getDisplacement(), n = this.getScaleArray();
      return [
        t[0] / 2 - e[0] / n[0],
        t[1] / 2 + e[1] / n[1]
      ];
    }
    /**
     * Get the angle used in generating the shape.
     * @return {number} Shape's rotation in radians.
     * @api
     */
    getAngle() {
      return this.angle_;
    }
    /**
     * Get the fill style for the shape.
     * @return {import("./Fill.js").default|null} Fill style.
     * @api
     */
    getFill() {
      return this.fill_;
    }
    /**
     * Set the fill style.
     * @param {import("./Fill.js").default|null} fill Fill style.
     * @api
     */
    setFill(t) {
      this.fill_ = t, this.render();
    }
    /**
     * @return {HTMLCanvasElement} Image element.
     * @override
     */
    getHitDetectionImage() {
      return this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(
        this.renderOptions_
      )), this.hitDetectionCanvas_;
    }
    /**
     * Get the image icon.
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLCanvasElement} Image or Canvas element.
     * @api
     * @override
     */
    getImage(t) {
      var r, a;
      const e = (r = this.fill_) == null ? void 0 : r.getKey(), n = `${t},${this.angle_},${this.radius},${this.radius2_},${this.points_},${e}` + Object.values(this.renderOptions_).join(",");
      let s = (
        /** @type {HTMLCanvasElement} */
        (a = Ge.get(n, null, null)) == null ? void 0 : a.getImage(1)
      );
      if (!s) {
        const o = this.renderOptions_, l = Math.ceil(o.size * t), h = Kt(l, l);
        this.draw_(o, h, t), s = h.canvas, Ge.set(
          n,
          null,
          null,
          new $h(s, void 0, null, ut.LOADED, null)
        );
      }
      return s;
    }
    /**
     * Get the image pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Pixel ratio.
     * @override
     */
    getPixelRatio(t) {
      return t;
    }
    /**
     * @return {import("../size.js").Size} Image size.
     * @override
     */
    getImageSize() {
      return this.size_;
    }
    /**
     * @return {import("../ImageState.js").default} Image state.
     * @override
     */
    getImageState() {
      return this.imageState_;
    }
    /**
     * Get the origin of the symbolizer.
     * @return {Array<number>} Origin.
     * @api
     * @override
     */
    getOrigin() {
      return this.origin_;
    }
    /**
     * Get the number of points for generating the shape.
     * @return {number} Number of points for stars and regular polygons.
     * @api
     */
    getPoints() {
      return this.points_;
    }
    /**
     * Get the (primary) radius for the shape.
     * @return {number} Radius.
     * @api
     */
    getRadius() {
      return this.radius;
    }
    /**
     * Get the secondary radius for the shape.
     * @return {number|undefined} Radius2.
     * @api
     */
    getRadius2() {
      return this.radius2_;
    }
    /**
     * Get the size of the symbolizer (in pixels).
     * @return {import("../size.js").Size} Size.
     * @api
     * @override
     */
    getSize() {
      return this.size_;
    }
    /**
     * Get the stroke style for the shape.
     * @return {import("./Stroke.js").default|null} Stroke style.
     * @api
     */
    getStroke() {
      return this.stroke_;
    }
    /**
     * Set the stroke style.
     * @param {import("./Stroke.js").default|null} stroke Stroke style.
     * @api
     */
    setStroke(t) {
      this.stroke_ = t, this.render();
    }
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     * @override
     */
    listenImageChange(t) {
    }
    /**
     * Load not yet loaded URI.
     * @override
     */
    load() {
    }
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     * @override
     */
    unlistenImageChange(t) {
    }
    /**
     * Calculate additional canvas size needed for the miter.
     * @param {string} lineJoin Line join
     * @param {number} strokeWidth Stroke width
     * @param {number} miterLimit Miter limit
     * @return {number} Additional canvas size needed
     * @private
     */
    calculateLineJoinSize_(t, e, n) {
      if (e === 0 || this.points_ === 1 / 0 || t !== "bevel" && t !== "miter")
        return e;
      let s = this.radius, r = this.radius2_ === void 0 ? s : this.radius2_;
      if (s < r) {
        const T = s;
        s = r, r = T;
      }
      const a = this.radius2_ === void 0 ? this.points_ : this.points_ * 2, o = 2 * Math.PI / a, l = r * Math.sin(o), h = Math.sqrt(r * r - l * l), c = s - h, u = Math.sqrt(l * l + c * c), d = u / l;
      if (t === "miter" && d <= n)
        return d * e;
      const g = e / 2 / d, _ = e / 2 * (c / u), E = Math.sqrt((s + g) * (s + g) + _ * _) - s;
      if (this.radius2_ === void 0 || t === "bevel")
        return E * 2;
      const M = s * Math.sin(o), w = Math.sqrt(s * s - M * M), R = r - w, C = Math.sqrt(M * M + R * R) / M;
      if (C <= n) {
        const T = C * e / 2 - r - s;
        return 2 * Math.max(E, T);
      }
      return E * 2;
    }
    /**
     * @return {RenderOptions}  The render options
     * @protected
     */
    createRenderOptions() {
      let t = Os, e = Ns, n = 0, s = null, r = 0, a, o = 0;
      this.stroke_ && (a = si(this.stroke_.getColor() ?? Ir), o = this.stroke_.getWidth() ?? Ar, s = this.stroke_.getLineDash(), r = this.stroke_.getLineDashOffset() ?? 0, e = this.stroke_.getLineJoin() ?? Ns, t = this.stroke_.getLineCap() ?? Os, n = this.stroke_.getMiterLimit() ?? Rr);
      const l = this.calculateLineJoinSize_(e, o, n), h = Math.max(this.radius, this.radius2_ || 0), c = Math.ceil(2 * h + l);
      return {
        strokeStyle: a,
        strokeWidth: o,
        size: c,
        lineCap: t,
        lineDash: s,
        lineDashOffset: r,
        lineJoin: e,
        miterLimit: n
      };
    }
    /**
     * @protected
     */
    render() {
      this.renderOptions_ = this.createRenderOptions();
      const t = this.renderOptions_.size;
      this.hitDetectionCanvas_ = null, this.size_ = [t, t];
    }
    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     * @param {CanvasRenderingContext2D} context The rendering context.
     * @param {number} pixelRatio The pixel ratio.
     */
    draw_(t, e, n) {
      if (e.scale(n, n), e.translate(t.size / 2, t.size / 2), this.createPath_(e), this.fill_) {
        let s = this.fill_.getColor();
        s === null && (s = xe), e.fillStyle = si(s), e.fill();
      }
      t.strokeStyle && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineCap = t.lineCap, e.lineJoin = t.lineJoin, e.miterLimit = t.miterLimit, e.stroke());
    }
    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     * @return {HTMLCanvasElement} Canvas containing the icon
     */
    createHitDetectionCanvas_(t) {
      let e;
      if (this.fill_) {
        let n = this.fill_.getColor(), s = 0;
        typeof n == "string" && (n = Ls(n)), n === null ? s = 1 : Array.isArray(n) && (s = n.length === 4 ? n[3] : 1), s === 0 && (e = Kt(t.size, t.size), this.drawHitDetectionCanvas_(t, e));
      }
      return e ? e.canvas : this.getImage(1);
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context The context to draw in.
     */
    createPath_(t) {
      let e = this.points_;
      const n = this.radius;
      if (e === 1 / 0)
        t.arc(0, 0, n, 0, 2 * Math.PI);
      else {
        const s = this.radius2_ === void 0 ? n : this.radius2_;
        this.radius2_ !== void 0 && (e *= 2);
        const r = this.angle_ - Math.PI / 2, a = 2 * Math.PI / e;
        for (let o = 0; o < e; o++) {
          const l = r + o * a, h = o % 2 === 0 ? n : s;
          t.lineTo(h * Math.cos(l), h * Math.sin(l));
        }
        t.closePath();
      }
    }
    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     * @param {CanvasRenderingContext2D} context The context.
     */
    drawHitDetectionCanvas_(t, e) {
      e.translate(t.size / 2, t.size / 2), this.createPath_(e), e.fillStyle = xe, e.fill(), t.strokeStyle && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineJoin = t.lineJoin, e.miterLimit = t.miterLimit, e.stroke());
    }
    /**
     * @override
     */
    ready() {
      return this.fill_ ? this.fill_.ready() : Promise.resolve();
    }
  }
  class zn extends Yr {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      t = t || { radius: 5 }, super({
        points: 1 / 0,
        fill: t.fill,
        radius: t.radius,
        stroke: t.stroke,
        scale: t.scale !== void 0 ? t.scale : 1,
        rotation: t.rotation !== void 0 ? t.rotation : 0,
        rotateWithView: t.rotateWithView !== void 0 ? t.rotateWithView : !1,
        displacement: t.displacement !== void 0 ? t.displacement : [0, 0],
        declutterMode: t.declutterMode
      });
    }
    /**
     * Clones the style.
     * @return {CircleStyle} The cloned style.
     * @api
     * @override
     */
    clone() {
      const t = this.getScale(), e = new zn({
        fill: this.getFill() ? this.getFill().clone() : void 0,
        stroke: this.getStroke() ? this.getStroke().clone() : void 0,
        radius: this.getRadius(),
        scale: Array.isArray(t) ? t.slice() : t,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
      return e.setOpacity(this.getOpacity()), e;
    }
    /**
     * Set the circle radius.
     *
     * @param {number} radius Circle radius.
     * @api
     */
    setRadius(t) {
      this.radius = t, this.render();
    }
  }
  class tn {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      t = t || {}, this.patternImage_ = null, this.color_ = null, t.color !== void 0 && this.setColor(t.color);
    }
    /**
     * Clones the style. The color is not cloned if it is a {@link module:ol/colorlike~ColorLike}.
     * @return {Fill} The cloned style.
     * @api
     */
    clone() {
      const t = this.getColor();
      return new tn({
        color: Array.isArray(t) ? t.slice() : t || void 0
      });
    }
    /**
     * Get the fill color.
     * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} Color.
     * @api
     */
    getColor() {
      return this.color_;
    }
    /**
     * Set the color.
     *
     * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} color Color.
     * @api
     */
    setColor(t) {
      if (t !== null && typeof t == "object" && "src" in t) {
        const e = Uh(
          null,
          t.src,
          "anonymous",
          void 0,
          t.offset ? null : t.color ? t.color : null,
          !(t.offset && t.size)
        );
        e.ready().then(() => {
          this.patternImage_ = null;
        }), e.getImageState() === ut.IDLE && e.load(), e.getImageState() === ut.LOADING && (this.patternImage_ = e);
      }
      this.color_ = t;
    }
    /**
     * @return {string} Key of the fill for cache lookup.
     */
    getKey() {
      const t = this.getColor();
      return t ? t instanceof CanvasPattern || t instanceof CanvasGradient ? Ct(t) : typeof t == "object" && "src" in t ? t.src + ":" + t.offset : Ls(t).toString() : "";
    }
    /**
     * @return {boolean} The fill style is loading an image pattern.
     */
    loading() {
      return !!this.patternImage_;
    }
    /**
     * @return {Promise<void>} `false` or a promise that resolves when the style is ready to use.
     */
    ready() {
      return this.patternImage_ ? this.patternImage_.ready() : Promise.resolve();
    }
  }
  function hu(i, t, e, n) {
    return e !== void 0 && n !== void 0 ? [e / i, n / t] : e !== void 0 ? e / i : n !== void 0 ? n / t : 1;
  }
  class Zr extends Xr {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      t = t || {};
      const e = t.opacity !== void 0 ? t.opacity : 1, n = t.rotation !== void 0 ? t.rotation : 0, s = t.scale !== void 0 ? t.scale : 1, r = t.rotateWithView !== void 0 ? t.rotateWithView : !1;
      super({
        opacity: e,
        rotation: n,
        scale: s,
        displacement: t.displacement !== void 0 ? t.displacement : [0, 0],
        rotateWithView: r,
        declutterMode: t.declutterMode
      }), this.anchor_ = t.anchor !== void 0 ? t.anchor : [0.5, 0.5], this.normalizedAnchor_ = null, this.anchorOrigin_ = t.anchorOrigin !== void 0 ? t.anchorOrigin : "top-left", this.anchorXUnits_ = t.anchorXUnits !== void 0 ? t.anchorXUnits : "fraction", this.anchorYUnits_ = t.anchorYUnits !== void 0 ? t.anchorYUnits : "fraction", this.crossOrigin_ = t.crossOrigin !== void 0 ? t.crossOrigin : null;
      const a = t.img !== void 0 ? t.img : null;
      let o = t.src;
      xt(
        !(o !== void 0 && a),
        "`image` and `src` cannot be provided at the same time"
      ), (o === void 0 || o.length === 0) && a && (o = /** @type {HTMLImageElement} */
      a.src || Ct(a)), xt(
        o !== void 0 && o.length > 0,
        "A defined and non-empty `src` or `image` must be provided"
      ), xt(
        !((t.width !== void 0 || t.height !== void 0) && t.scale !== void 0),
        "`width` or `height` cannot be provided together with `scale`"
      );
      let l;
      if (t.src !== void 0 ? l = ut.IDLE : a !== void 0 && ("complete" in a ? a.complete ? l = a.src ? ut.LOADED : ut.IDLE : l = ut.LOADING : l = ut.LOADED), this.color_ = t.color !== void 0 ? Ls(t.color) : null, this.iconImage_ = Uh(
        a,
        /** @type {string} */
        o,
        this.crossOrigin_,
        l,
        this.color_
      ), this.offset_ = t.offset !== void 0 ? t.offset : [0, 0], this.offsetOrigin_ = t.offsetOrigin !== void 0 ? t.offsetOrigin : "top-left", this.origin_ = null, this.size_ = t.size !== void 0 ? t.size : null, this.initialOptions_, t.width !== void 0 || t.height !== void 0) {
        let h, c;
        if (t.size)
          [h, c] = t.size;
        else {
          const u = this.getImage(1);
          if (u.width && u.height)
            h = u.width, c = u.height;
          else if (u instanceof HTMLImageElement) {
            this.initialOptions_ = t;
            const d = () => {
              if (this.unlistenImageChange(d), !this.initialOptions_)
                return;
              const g = this.iconImage_.getSize();
              this.setScale(
                hu(
                  g[0],
                  g[1],
                  t.width,
                  t.height
                )
              );
            };
            this.listenImageChange(d);
            return;
          }
        }
        h !== void 0 && this.setScale(
          hu(h, c, t.width, t.height)
        );
      }
    }
    /**
     * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
     * @return {Icon} The cloned style.
     * @api
     * @override
     */
    clone() {
      let t, e, n;
      return this.initialOptions_ ? (e = this.initialOptions_.width, n = this.initialOptions_.height) : (t = this.getScale(), t = Array.isArray(t) ? t.slice() : t), new Zr({
        anchor: this.anchor_.slice(),
        anchorOrigin: this.anchorOrigin_,
        anchorXUnits: this.anchorXUnits_,
        anchorYUnits: this.anchorYUnits_,
        color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
        crossOrigin: this.crossOrigin_,
        offset: this.offset_.slice(),
        offsetOrigin: this.offsetOrigin_,
        opacity: this.getOpacity(),
        rotateWithView: this.getRotateWithView(),
        rotation: this.getRotation(),
        scale: t,
        width: e,
        height: n,
        size: this.size_ !== null ? this.size_.slice() : void 0,
        src: this.getSrc(),
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
    }
    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @return {Array<number>} Anchor.
     * @api
     * @override
     */
    getAnchor() {
      let t = this.normalizedAnchor_;
      if (!t) {
        t = this.anchor_;
        const s = this.getSize();
        if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
          if (!s)
            return null;
          t = this.anchor_.slice(), this.anchorXUnits_ == "fraction" && (t[0] *= s[0]), this.anchorYUnits_ == "fraction" && (t[1] *= s[1]);
        }
        if (this.anchorOrigin_ != "top-left") {
          if (!s)
            return null;
          t === this.anchor_ && (t = this.anchor_.slice()), (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") && (t[0] = -t[0] + s[0]), (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") && (t[1] = -t[1] + s[1]);
        }
        this.normalizedAnchor_ = t;
      }
      const e = this.getDisplacement(), n = this.getScaleArray();
      return [
        t[0] - e[0] / n[0],
        t[1] + e[1] / n[1]
      ];
    }
    /**
     * Set the anchor point. The anchor determines the center point for the
     * symbolizer.
     *
     * @param {Array<number>} anchor Anchor.
     * @api
     */
    setAnchor(t) {
      this.anchor_ = t, this.normalizedAnchor_ = null;
    }
    /**
     * Get the icon color.
     * @return {import("../color.js").Color} Color.
     * @api
     */
    getColor() {
      return this.color_;
    }
    /**
     * Get the image icon.
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element. If the Icon
     * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
     * @api
     * @override
     */
    getImage(t) {
      return this.iconImage_.getImage(t);
    }
    /**
     * Get the pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} The pixel ratio of the image.
     * @api
     * @override
     */
    getPixelRatio(t) {
      return this.iconImage_.getPixelRatio(t);
    }
    /**
     * @return {import("../size.js").Size} Image size.
     * @override
     */
    getImageSize() {
      return this.iconImage_.getSize();
    }
    /**
     * @return {import("../ImageState.js").default} Image state.
     * @override
     */
    getImageState() {
      return this.iconImage_.getImageState();
    }
    /**
     * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
     * @override
     */
    getHitDetectionImage() {
      return this.iconImage_.getHitDetectionImage();
    }
    /**
     * Get the origin of the symbolizer.
     * @return {Array<number>} Origin.
     * @api
     * @override
     */
    getOrigin() {
      if (this.origin_)
        return this.origin_;
      let t = this.offset_;
      if (this.offsetOrigin_ != "top-left") {
        const e = this.getSize(), n = this.iconImage_.getSize();
        if (!e || !n)
          return null;
        t = t.slice(), (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") && (t[0] = n[0] - e[0] - t[0]), (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") && (t[1] = n[1] - e[1] - t[1]);
      }
      return this.origin_ = t, this.origin_;
    }
    /**
     * Get the image URL.
     * @return {string|undefined} Image src.
     * @api
     */
    getSrc() {
      return this.iconImage_.getSrc();
    }
    /**
     * Get the size of the icon (in pixels).
     * @return {import("../size.js").Size} Image size.
     * @api
     * @override
     */
    getSize() {
      return this.size_ ? this.size_ : this.iconImage_.getSize();
    }
    /**
     * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
     * @return {number} Icon width (in pixels).
     * @api
     */
    getWidth() {
      const t = this.getScaleArray();
      if (this.size_)
        return this.size_[0] * t[0];
      if (this.iconImage_.getImageState() == ut.LOADED)
        return this.iconImage_.getSize()[0] * t[0];
    }
    /**
     * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
     * @return {number} Icon height (in pixels).
     * @api
     */
    getHeight() {
      const t = this.getScaleArray();
      if (this.size_)
        return this.size_[1] * t[1];
      if (this.iconImage_.getImageState() == ut.LOADED)
        return this.iconImage_.getSize()[1] * t[1];
    }
    /**
     * Set the scale.
     *
     * @param {number|import("../size.js").Size} scale Scale.
     * @api
     * @override
     */
    setScale(t) {
      delete this.initialOptions_, super.setScale(t);
    }
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     * @override
     */
    listenImageChange(t) {
      this.iconImage_.addEventListener(at.CHANGE, t);
    }
    /**
     * Load not yet loaded URI.
     * When rendering a feature with an icon style, the vector renderer will
     * automatically call this method. However, you might want to call this
     * method yourself for preloading or other purposes.
     * @api
     * @override
     */
    load() {
      this.iconImage_.load();
    }
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     * @override
     */
    unlistenImageChange(t) {
      this.iconImage_.removeEventListener(at.CHANGE, t);
    }
    /**
     * @override
     */
    ready() {
      return this.iconImage_.ready();
    }
  }
  class Hi {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      t = t || {}, this.color_ = t.color !== void 0 ? t.color : null, this.lineCap_ = t.lineCap, this.lineDash_ = t.lineDash !== void 0 ? t.lineDash : null, this.lineDashOffset_ = t.lineDashOffset, this.lineJoin_ = t.lineJoin, this.miterLimit_ = t.miterLimit, this.width_ = t.width;
    }
    /**
     * Clones the style.
     * @return {Stroke} The cloned style.
     * @api
     */
    clone() {
      const t = this.getColor();
      return new Hi({
        color: Array.isArray(t) ? t.slice() : t || void 0,
        lineCap: this.getLineCap(),
        lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
        lineDashOffset: this.getLineDashOffset(),
        lineJoin: this.getLineJoin(),
        miterLimit: this.getMiterLimit(),
        width: this.getWidth()
      });
    }
    /**
     * Get the stroke color.
     * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
     * @api
     */
    getColor() {
      return this.color_;
    }
    /**
     * Get the line cap type for the stroke.
     * @return {CanvasLineCap|undefined} Line cap.
     * @api
     */
    getLineCap() {
      return this.lineCap_;
    }
    /**
     * Get the line dash style for the stroke.
     * @return {Array<number>|null} Line dash.
     * @api
     */
    getLineDash() {
      return this.lineDash_;
    }
    /**
     * Get the line dash offset for the stroke.
     * @return {number|undefined} Line dash offset.
     * @api
     */
    getLineDashOffset() {
      return this.lineDashOffset_;
    }
    /**
     * Get the line join type for the stroke.
     * @return {CanvasLineJoin|undefined} Line join.
     * @api
     */
    getLineJoin() {
      return this.lineJoin_;
    }
    /**
     * Get the miter limit for the stroke.
     * @return {number|undefined} Miter limit.
     * @api
     */
    getMiterLimit() {
      return this.miterLimit_;
    }
    /**
     * Get the stroke width.
     * @return {number|undefined} Width.
     * @api
     */
    getWidth() {
      return this.width_;
    }
    /**
     * Set the color.
     *
     * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
     * @api
     */
    setColor(t) {
      this.color_ = t;
    }
    /**
     * Set the line cap.
     *
     * @param {CanvasLineCap|undefined} lineCap Line cap.
     * @api
     */
    setLineCap(t) {
      this.lineCap_ = t;
    }
    /**
     * Set the line dash.
     *
     * @param {Array<number>|null} lineDash Line dash.
     * @api
     */
    setLineDash(t) {
      this.lineDash_ = t;
    }
    /**
     * Set the line dash offset.
     *
     * @param {number|undefined} lineDashOffset Line dash offset.
     * @api
     */
    setLineDashOffset(t) {
      this.lineDashOffset_ = t;
    }
    /**
     * Set the line join.
     *
     * @param {CanvasLineJoin|undefined} lineJoin Line join.
     * @api
     */
    setLineJoin(t) {
      this.lineJoin_ = t;
    }
    /**
     * Set the miter limit.
     *
     * @param {number|undefined} miterLimit Miter limit.
     * @api
     */
    setMiterLimit(t) {
      this.miterLimit_ = t;
    }
    /**
     * Set the width.
     *
     * @param {number|undefined} width Width.
     * @api
     */
    setWidth(t) {
      this.width_ = t;
    }
  }
  class je {
    /**
     * @param {Options} [options] Style options.
     */
    constructor(t) {
      t = t || {}, this.geometry_ = null, this.geometryFunction_ = cu, t.geometry !== void 0 && this.setGeometry(t.geometry), this.fill_ = t.fill !== void 0 ? t.fill : null, this.image_ = t.image !== void 0 ? t.image : null, this.renderer_ = t.renderer !== void 0 ? t.renderer : null, this.hitDetectionRenderer_ = t.hitDetectionRenderer !== void 0 ? t.hitDetectionRenderer : null, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.text_ = t.text !== void 0 ? t.text : null, this.zIndex_ = t.zIndex;
    }
    /**
     * Clones the style.
     * @return {Style} The cloned style.
     * @api
     */
    clone() {
      let t = this.getGeometry();
      return t && typeof t == "object" && (t = /** @type {import("../geom/Geometry.js").default} */
      t.clone()), new je({
        geometry: t ?? void 0,
        fill: this.getFill() ? this.getFill().clone() : void 0,
        image: this.getImage() ? this.getImage().clone() : void 0,
        renderer: this.getRenderer() ?? void 0,
        stroke: this.getStroke() ? this.getStroke().clone() : void 0,
        text: this.getText() ? this.getText().clone() : void 0,
        zIndex: this.getZIndex()
      });
    }
    /**
     * Get the custom renderer function that was configured with
     * {@link #setRenderer} or the `renderer` constructor option.
     * @return {RenderFunction|null} Custom renderer function.
     * @api
     */
    getRenderer() {
      return this.renderer_;
    }
    /**
     * Sets a custom renderer function for this style. When set, `fill`, `stroke`
     * and `image` options of the style will be ignored.
     * @param {RenderFunction|null} renderer Custom renderer function.
     * @api
     */
    setRenderer(t) {
      this.renderer_ = t;
    }
    /**
     * Sets a custom renderer function for this style used
     * in hit detection.
     * @param {RenderFunction|null} renderer Custom renderer function.
     * @api
     */
    setHitDetectionRenderer(t) {
      this.hitDetectionRenderer_ = t;
    }
    /**
     * Get the custom renderer function that was configured with
     * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
     * @return {RenderFunction|null} Custom renderer function.
     * @api
     */
    getHitDetectionRenderer() {
      return this.hitDetectionRenderer_;
    }
    /**
     * Get the geometry to be rendered.
     * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
     * Feature property or geometry or function that returns the geometry that will
     * be rendered with this style.
     * @api
     */
    getGeometry() {
      return this.geometry_;
    }
    /**
     * Get the function used to generate a geometry for rendering.
     * @return {!GeometryFunction} Function that is called with a feature
     * and returns the geometry to render instead of the feature's geometry.
     * @api
     */
    getGeometryFunction() {
      return this.geometryFunction_;
    }
    /**
     * Get the fill style.
     * @return {import("./Fill.js").default|null} Fill style.
     * @api
     */
    getFill() {
      return this.fill_;
    }
    /**
     * Set the fill style.
     * @param {import("./Fill.js").default|null} fill Fill style.
     * @api
     */
    setFill(t) {
      this.fill_ = t;
    }
    /**
     * Get the image style.
     * @return {import("./Image.js").default|null} Image style.
     * @api
     */
    getImage() {
      return this.image_;
    }
    /**
     * Set the image style.
     * @param {import("./Image.js").default} image Image style.
     * @api
     */
    setImage(t) {
      this.image_ = t;
    }
    /**
     * Get the stroke style.
     * @return {import("./Stroke.js").default|null} Stroke style.
     * @api
     */
    getStroke() {
      return this.stroke_;
    }
    /**
     * Set the stroke style.
     * @param {import("./Stroke.js").default|null} stroke Stroke style.
     * @api
     */
    setStroke(t) {
      this.stroke_ = t;
    }
    /**
     * Get the text style.
     * @return {import("./Text.js").default|null} Text style.
     * @api
     */
    getText() {
      return this.text_;
    }
    /**
     * Set the text style.
     * @param {import("./Text.js").default} text Text style.
     * @api
     */
    setText(t) {
      this.text_ = t;
    }
    /**
     * Get the z-index for the style.
     * @return {number|undefined} ZIndex.
     * @api
     */
    getZIndex() {
      return this.zIndex_;
    }
    /**
     * Set a geometry that is rendered instead of the feature's geometry.
     *
     * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
     *     Feature property or geometry or function returning a geometry to render
     *     for this style.
     * @api
     */
    setGeometry(t) {
      typeof t == "function" ? this.geometryFunction_ = t : typeof t == "string" ? this.geometryFunction_ = function(e) {
        return (
          /** @type {import("../geom/Geometry.js").default} */
          e.get(t)
        );
      } : t ? t !== void 0 && (this.geometryFunction_ = function() {
        return (
          /** @type {import("../geom/Geometry.js").default} */
          t
        );
      }) : this.geometryFunction_ = cu, this.geometry_ = t;
    }
    /**
     * Set the z-index.
     *
     * @param {number|undefined} zIndex ZIndex.
     * @api
     */
    setZIndex(t) {
      this.zIndex_ = t;
    }
  }
  function Sp(i) {
    let t;
    if (typeof i == "function")
      t = i;
    else {
      let e;
      Array.isArray(i) ? e = i : (xt(
        typeof /** @type {?} */
        i.getZIndex == "function",
        "Expected an `Style` or an array of `Style`"
      ), e = [
        /** @type {Style} */
        i
      ]), t = function() {
        return e;
      };
    }
    return t;
  }
  let sl = null;
  function sf(i, t) {
    if (!sl) {
      const e = new tn({
        color: "rgba(255,255,255,0.4)"
      }), n = new Hi({
        color: "#3399CC",
        width: 1.25
      });
      sl = [
        new je({
          image: new zn({
            fill: e,
            stroke: n,
            radius: 5
          }),
          fill: e,
          stroke: n
        })
      ];
    }
    return sl;
  }
  function cu(i) {
    return i.getGeometry();
  }
  const Cp = "#333";
  class Io {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      t = t || {}, this.font_ = t.font, this.rotation_ = t.rotation, this.rotateWithView_ = t.rotateWithView, this.keepUpright_ = t.keepUpright, this.scale_ = t.scale, this.scaleArray_ = Ce(t.scale !== void 0 ? t.scale : 1), this.text_ = t.text, this.textAlign_ = t.textAlign, this.justify_ = t.justify, this.repeat_ = t.repeat, this.textBaseline_ = t.textBaseline, this.fill_ = t.fill !== void 0 ? t.fill : new tn({ color: Cp }), this.maxAngle_ = t.maxAngle !== void 0 ? t.maxAngle : Math.PI / 4, this.placement_ = t.placement !== void 0 ? t.placement : "point", this.overflow_ = !!t.overflow, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.offsetX_ = t.offsetX !== void 0 ? t.offsetX : 0, this.offsetY_ = t.offsetY !== void 0 ? t.offsetY : 0, this.backgroundFill_ = t.backgroundFill ? t.backgroundFill : null, this.backgroundStroke_ = t.backgroundStroke ? t.backgroundStroke : null, this.padding_ = t.padding === void 0 ? null : t.padding, this.declutterMode_ = t.declutterMode;
    }
    /**
     * Clones the style.
     * @return {Text} The cloned style.
     * @api
     */
    clone() {
      const t = this.getScale();
      return new Io({
        font: this.getFont(),
        placement: this.getPlacement(),
        repeat: this.getRepeat(),
        maxAngle: this.getMaxAngle(),
        overflow: this.getOverflow(),
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        keepUpright: this.getKeepUpright(),
        scale: Array.isArray(t) ? t.slice() : t,
        text: this.getText(),
        textAlign: this.getTextAlign(),
        justify: this.getJustify(),
        textBaseline: this.getTextBaseline(),
        fill: this.getFill() ? this.getFill().clone() : void 0,
        stroke: this.getStroke() ? this.getStroke().clone() : void 0,
        offsetX: this.getOffsetX(),
        offsetY: this.getOffsetY(),
        backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
        backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
        padding: this.getPadding() || void 0,
        declutterMode: this.getDeclutterMode()
      });
    }
    /**
     * Get the `overflow` configuration.
     * @return {boolean} Let text overflow the length of the path they follow.
     * @api
     */
    getOverflow() {
      return this.overflow_;
    }
    /**
     * Get the font name.
     * @return {string|undefined} Font.
     * @api
     */
    getFont() {
      return this.font_;
    }
    /**
     * Get the maximum angle between adjacent characters.
     * @return {number} Angle in radians.
     * @api
     */
    getMaxAngle() {
      return this.maxAngle_;
    }
    /**
     * Get the label placement.
     * @return {TextPlacement} Text placement.
     * @api
     */
    getPlacement() {
      return this.placement_;
    }
    /**
     * Get the repeat interval of the text.
     * @return {number|undefined} Repeat interval in pixels.
     * @api
     */
    getRepeat() {
      return this.repeat_;
    }
    /**
     * Get the x-offset for the text.
     * @return {number} Horizontal text offset.
     * @api
     */
    getOffsetX() {
      return this.offsetX_;
    }
    /**
     * Get the y-offset for the text.
     * @return {number} Vertical text offset.
     * @api
     */
    getOffsetY() {
      return this.offsetY_;
    }
    /**
     * Get the fill style for the text.
     * @return {import("./Fill.js").default|null} Fill style.
     * @api
     */
    getFill() {
      return this.fill_;
    }
    /**
     * Determine whether the text rotates with the map.
     * @return {boolean|undefined} Rotate with map.
     * @api
     */
    getRotateWithView() {
      return this.rotateWithView_;
    }
    /**
     * Determine whether the text can be rendered upside down.
     * @return {boolean|undefined} Keep text upright.
     * @api
     */
    getKeepUpright() {
      return this.keepUpright_;
    }
    /**
     * Get the text rotation.
     * @return {number|undefined} Rotation.
     * @api
     */
    getRotation() {
      return this.rotation_;
    }
    /**
     * Get the text scale.
     * @return {number|import("../size.js").Size|undefined} Scale.
     * @api
     */
    getScale() {
      return this.scale_;
    }
    /**
     * Get the symbolizer scale array.
     * @return {import("../size.js").Size} Scale array.
     */
    getScaleArray() {
      return this.scaleArray_;
    }
    /**
     * Get the stroke style for the text.
     * @return {import("./Stroke.js").default|null} Stroke style.
     * @api
     */
    getStroke() {
      return this.stroke_;
    }
    /**
     * Get the text to be rendered.
     * @return {string|Array<string>|undefined} Text.
     * @api
     */
    getText() {
      return this.text_;
    }
    /**
     * Get the text alignment.
     * @return {CanvasTextAlign|undefined} Text align.
     * @api
     */
    getTextAlign() {
      return this.textAlign_;
    }
    /**
     * Get the justification.
     * @return {TextJustify|undefined} Justification.
     * @api
     */
    getJustify() {
      return this.justify_;
    }
    /**
     * Get the text baseline.
     * @return {CanvasTextBaseline|undefined} Text baseline.
     * @api
     */
    getTextBaseline() {
      return this.textBaseline_;
    }
    /**
     * Get the background fill style for the text.
     * @return {import("./Fill.js").default|null} Fill style.
     * @api
     */
    getBackgroundFill() {
      return this.backgroundFill_;
    }
    /**
     * Get the background stroke style for the text.
     * @return {import("./Stroke.js").default|null} Stroke style.
     * @api
     */
    getBackgroundStroke() {
      return this.backgroundStroke_;
    }
    /**
     * Get the padding for the text.
     * @return {Array<number>|null} Padding.
     * @api
     */
    getPadding() {
      return this.padding_;
    }
    /**
     * Get the declutter mode of the shape
     * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
     * @api
     */
    getDeclutterMode() {
      return this.declutterMode_;
    }
    /**
     * Set the `overflow` property.
     *
     * @param {boolean} overflow Let text overflow the path that it follows.
     * @api
     */
    setOverflow(t) {
      this.overflow_ = t;
    }
    /**
     * Set the font.
     *
     * @param {string|undefined} font Font.
     * @api
     */
    setFont(t) {
      this.font_ = t;
    }
    /**
     * Set the maximum angle between adjacent characters.
     *
     * @param {number} maxAngle Angle in radians.
     * @api
     */
    setMaxAngle(t) {
      this.maxAngle_ = t;
    }
    /**
     * Set the x offset.
     *
     * @param {number} offsetX Horizontal text offset.
     * @api
     */
    setOffsetX(t) {
      this.offsetX_ = t;
    }
    /**
     * Set the y offset.
     *
     * @param {number} offsetY Vertical text offset.
     * @api
     */
    setOffsetY(t) {
      this.offsetY_ = t;
    }
    /**
     * Set the text placement.
     *
     * @param {TextPlacement} placement Placement.
     * @api
     */
    setPlacement(t) {
      this.placement_ = t;
    }
    /**
     * Set the repeat interval of the text.
     * @param {number|undefined} [repeat] Repeat interval in pixels.
     * @api
     */
    setRepeat(t) {
      this.repeat_ = t;
    }
    /**
     * Set whether to rotate the text with the view.
     *
     * @param {boolean} rotateWithView Rotate with map.
     * @api
     */
    setRotateWithView(t) {
      this.rotateWithView_ = t;
    }
    /**
     * Set whether the text can be rendered upside down.
     *
     * @param {boolean} keepUpright Keep text upright.
     * @api
     */
    setKeepUpright(t) {
      this.keepUpright_ = t;
    }
    /**
     * Set the fill.
     *
     * @param {import("./Fill.js").default|null} fill Fill style.
     * @api
     */
    setFill(t) {
      this.fill_ = t;
    }
    /**
     * Set the rotation.
     *
     * @param {number|undefined} rotation Rotation.
     * @api
     */
    setRotation(t) {
      this.rotation_ = t;
    }
    /**
     * Set the scale.
     *
     * @param {number|import("../size.js").Size|undefined} scale Scale.
     * @api
     */
    setScale(t) {
      this.scale_ = t, this.scaleArray_ = Ce(t !== void 0 ? t : 1);
    }
    /**
     * Set the stroke.
     *
     * @param {import("./Stroke.js").default|null} stroke Stroke style.
     * @api
     */
    setStroke(t) {
      this.stroke_ = t;
    }
    /**
     * Set the text.
     *
     * @param {string|Array<string>|undefined} text Text.
     * @api
     */
    setText(t) {
      this.text_ = t;
    }
    /**
     * Set the text alignment.
     *
     * @param {CanvasTextAlign|undefined} textAlign Text align.
     * @api
     */
    setTextAlign(t) {
      this.textAlign_ = t;
    }
    /**
     * Set the justification.
     *
     * @param {TextJustify|undefined} justify Justification.
     * @api
     */
    setJustify(t) {
      this.justify_ = t;
    }
    /**
     * Set the text baseline.
     *
     * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
     * @api
     */
    setTextBaseline(t) {
      this.textBaseline_ = t;
    }
    /**
     * Set the background fill.
     *
     * @param {import("./Fill.js").default|null} fill Fill style.
     * @api
     */
    setBackgroundFill(t) {
      this.backgroundFill_ = t;
    }
    /**
     * Set the background stroke.
     *
     * @param {import("./Stroke.js").default|null} stroke Stroke style.
     * @api
     */
    setBackgroundStroke(t) {
      this.backgroundStroke_ = t;
    }
    /**
     * Set the padding (`[top, right, bottom, left]`).
     *
     * @param {Array<number>|null} padding Padding.
     * @api
     */
    setPadding(t) {
      this.padding_ = t;
    }
  }
  function Rp(i) {
    return !0;
  }
  function Ip(i) {
    const t = Jd(), e = Tp(i, t), n = tf();
    return function(s, r) {
      if (n.properties = s.getPropertiesInternal(), n.resolution = r, t.featureId) {
        const a = s.getId();
        a !== void 0 ? n.featureId = a : n.featureId = null;
      }
      return t.geometryType && (n.geometryType = Qd(
        s.getGeometry()
      )), e(n);
    };
  }
  function uu(i) {
    const t = Jd(), e = i.length, n = new Array(e);
    for (let a = 0; a < e; ++a)
      n[a] = Nl(i[a], t);
    const s = tf(), r = new Array(e);
    return function(a, o) {
      if (s.properties = a.getPropertiesInternal(), s.resolution = o, t.featureId) {
        const h = a.getId();
        h !== void 0 ? s.featureId = h : s.featureId = null;
      }
      let l = 0;
      for (let h = 0; h < e; ++h) {
        const c = n[h](s);
        c && (r[l] = c, l += 1);
      }
      return r.length = l, r;
    };
  }
  function Tp(i, t) {
    const e = i.length, n = new Array(e);
    for (let s = 0; s < e; ++s) {
      const r = i[s], a = "filter" in r ? Ai(r.filter, me, t) : Rp;
      let o;
      if (Array.isArray(r.style)) {
        const l = r.style.length;
        o = new Array(l);
        for (let h = 0; h < l; ++h)
          o[h] = Nl(r.style[h], t);
      } else
        o = [Nl(r.style, t)];
      n[s] = { filter: a, styles: o };
    }
    return function(s) {
      const r = [];
      let a = !1;
      for (let o = 0; o < e; ++o) {
        const l = n[o].filter;
        if (l(s) && !(i[o].else && a)) {
          a = !0;
          for (const h of n[o].styles) {
            const c = h(s);
            c && r.push(c);
          }
        }
      }
      return r;
    };
  }
  function Nl(i, t) {
    const e = br(i, "", t), n = Pr(i, "", t), s = Ap(i, t), r = bp(i, t), a = we(i, "z-index", t);
    if (!e && !n && !s && !r && !Ts(i))
      throw new Error(
        "No fill, stroke, point, or text symbolizer properties in style: " + JSON.stringify(i)
      );
    const o = new je();
    return function(l) {
      let h = !0;
      if (e) {
        const c = e(l);
        c && (h = !1), o.setFill(c);
      }
      if (n) {
        const c = n(l);
        c && (h = !1), o.setStroke(c);
      }
      if (s) {
        const c = s(l);
        c && (h = !1), o.setText(c);
      }
      if (r) {
        const c = r(l);
        c && (h = !1), o.setImage(c);
      }
      return a && o.setZIndex(a(l)), h ? null : o;
    };
  }
  function br(i, t, e) {
    let n;
    if (t + "fill-pattern-src" in i)
      n = Np(i, t + "fill-", e);
    else {
      if (i[t + "fill-color"] === "none")
        return (r) => null;
      n = Bh(
        i,
        t + "fill-color",
        e
      );
    }
    if (!n)
      return null;
    const s = new tn();
    return function(r) {
      const a = n(r);
      return a === Dh ? null : (s.setColor(a), s);
    };
  }
  function Pr(i, t, e) {
    const n = we(
      i,
      t + "stroke-width",
      e
    ), s = Bh(
      i,
      t + "stroke-color",
      e
    );
    if (!n && !s)
      return null;
    const r = Ei(
      i,
      t + "stroke-line-cap",
      e
    ), a = Ei(
      i,
      t + "stroke-line-join",
      e
    ), o = rf(
      i,
      t + "stroke-line-dash",
      e
    ), l = we(
      i,
      t + "stroke-line-dash-offset",
      e
    ), h = we(
      i,
      t + "stroke-miter-limit",
      e
    ), c = new Hi();
    return function(u) {
      if (s) {
        const d = s(u);
        if (d === Dh)
          return null;
        c.setColor(d);
      }
      if (n && c.setWidth(n(u)), r) {
        const d = r(u);
        if (d !== "butt" && d !== "round" && d !== "square")
          throw new Error("Expected butt, round, or square line cap");
        c.setLineCap(d);
      }
      if (a) {
        const d = a(u);
        if (d !== "bevel" && d !== "round" && d !== "miter")
          throw new Error("Expected bevel, round, or miter line join");
        c.setLineJoin(d);
      }
      return o && c.setLineDash(o(u)), l && c.setLineDashOffset(l(u)), h && c.setMiterLimit(h(u)), c;
    };
  }
  function Ap(i, t) {
    const e = "text-", n = Ei(i, e + "value", t);
    if (!n)
      return null;
    const s = br(i, e, t), r = br(
      i,
      e + "background-",
      t
    ), a = Pr(i, e, t), o = Pr(
      i,
      e + "background-",
      t
    ), l = Ei(i, e + "font", t), h = we(
      i,
      e + "max-angle",
      t
    ), c = we(
      i,
      e + "offset-x",
      t
    ), u = we(
      i,
      e + "offset-y",
      t
    ), d = ys(
      i,
      e + "overflow",
      t
    ), g = Ei(
      i,
      e + "placement",
      t
    ), _ = we(i, e + "repeat", t), y = To(i, e + "scale", t), E = ys(
      i,
      e + "rotate-with-view",
      t
    ), M = we(
      i,
      e + "rotation",
      t
    ), w = Ei(i, e + "align", t), R = Ei(
      i,
      e + "justify",
      t
    ), S = Ei(
      i,
      e + "baseline",
      t
    ), C = ys(
      i,
      e + "keep-upright",
      t
    ), T = rf(
      i,
      e + "padding",
      t
    ), L = Ao(
      i,
      e + "declutter-mode"
    ), A = new Io({ declutterMode: L });
    return function(O) {
      if (A.setText(n(O)), s && A.setFill(s(O)), r && A.setBackgroundFill(r(O)), a && A.setStroke(a(O)), o && A.setBackgroundStroke(o(O)), l && A.setFont(l(O)), h && A.setMaxAngle(h(O)), c && A.setOffsetX(c(O)), u && A.setOffsetY(u(O)), d && A.setOverflow(d(O)), g) {
        const $ = g(O);
        if ($ !== "point" && $ !== "line")
          throw new Error("Expected point or line for text-placement");
        A.setPlacement($);
      }
      if (_ && A.setRepeat(_(O)), y && A.setScale(y(O)), E && A.setRotateWithView(E(O)), M && A.setRotation(M(O)), w) {
        const $ = w(O);
        if ($ !== "left" && $ !== "center" && $ !== "right" && $ !== "end" && $ !== "start")
          throw new Error(
            "Expected left, right, center, start, or end for text-align"
          );
        A.setTextAlign($);
      }
      if (R) {
        const $ = R(O);
        if ($ !== "left" && $ !== "right" && $ !== "center")
          throw new Error("Expected left, right, or center for text-justify");
        A.setJustify($);
      }
      if (S) {
        const $ = S(O);
        if ($ !== "bottom" && $ !== "top" && $ !== "middle" && $ !== "alphabetic" && $ !== "hanging")
          throw new Error(
            "Expected bottom, top, middle, alphabetic, or hanging for text-baseline"
          );
        A.setTextBaseline($);
      }
      return T && A.setPadding(T(O)), C && A.setKeepUpright(C(O)), A;
    };
  }
  function bp(i, t) {
    return "icon-src" in i ? Pp(i, t) : "shape-points" in i ? Lp(i, t) : "circle-radius" in i ? Op(i, t) : null;
  }
  function Pp(i, t) {
    const e = "icon-", n = e + "src", s = af(i[n], n), r = qa(
      i,
      e + "anchor",
      t
    ), a = To(i, e + "scale", t), o = we(
      i,
      e + "opacity",
      t
    ), l = qa(
      i,
      e + "displacement",
      t
    ), h = we(
      i,
      e + "rotation",
      t
    ), c = ys(
      i,
      e + "rotate-with-view",
      t
    ), u = fu(i, e + "anchor-origin"), d = gu(
      i,
      e + "anchor-x-units"
    ), g = gu(
      i,
      e + "anchor-y-units"
    ), _ = Gp(i, e + "color"), y = Dp(i, e + "cross-origin"), E = kp(i, e + "offset"), M = fu(i, e + "offset-origin"), w = Ka(i, e + "width"), R = Ka(i, e + "height"), S = Fp(i, e + "size"), C = Ao(
      i,
      e + "declutter-mode"
    ), T = new Zr({
      src: s,
      anchorOrigin: u,
      anchorXUnits: d,
      anchorYUnits: g,
      color: _,
      crossOrigin: y,
      offset: E,
      offsetOrigin: M,
      height: R,
      width: w,
      size: S,
      declutterMode: C
    });
    return function(L) {
      return o && T.setOpacity(o(L)), l && T.setDisplacement(l(L)), h && T.setRotation(h(L)), c && T.setRotateWithView(c(L)), a && T.setScale(a(L)), r && T.setAnchor(r(L)), T;
    };
  }
  function Lp(i, t) {
    const e = "shape-", n = e + "points", s = e + "radius", r = Fl(i[n], n), a = Fl(i[s], s), o = br(i, e, t), l = Pr(i, e, t), h = To(i, e + "scale", t), c = qa(
      i,
      e + "displacement",
      t
    ), u = we(
      i,
      e + "rotation",
      t
    ), d = ys(
      i,
      e + "rotate-with-view",
      t
    ), g = Ka(i, e + "radius2"), _ = Ka(i, e + "angle"), y = Ao(
      i,
      e + "declutter-mode"
    ), E = new Yr({
      points: r,
      radius: a,
      radius2: g,
      angle: _,
      declutterMode: y
    });
    return function(M) {
      return o && E.setFill(o(M)), l && E.setStroke(l(M)), c && E.setDisplacement(c(M)), u && E.setRotation(u(M)), d && E.setRotateWithView(d(M)), h && E.setScale(h(M)), E;
    };
  }
  function Op(i, t) {
    const e = "circle-", n = br(i, e, t), s = Pr(i, e, t), r = we(i, e + "radius", t), a = To(i, e + "scale", t), o = qa(
      i,
      e + "displacement",
      t
    ), l = we(
      i,
      e + "rotation",
      t
    ), h = ys(
      i,
      e + "rotate-with-view",
      t
    ), c = Ao(
      i,
      e + "declutter-mode"
    ), u = new zn({
      radius: 5,
      // this is arbitrary, but required - the evaluated radius is used below
      declutterMode: c
    });
    return function(d) {
      return r && u.setRadius(r(d)), n && u.setFill(n(d)), s && u.setStroke(s(d)), o && u.setDisplacement(o(d)), l && u.setRotation(l(d)), h && u.setRotateWithView(h(d)), a && u.setScale(a(d)), u;
    };
  }
  function we(i, t, e) {
    if (!(t in i))
      return;
    const n = Ai(i[t], yt, e);
    return function(s) {
      return Fl(n(s), t);
    };
  }
  function Ei(i, t, e) {
    if (!(t in i))
      return null;
    const n = Ai(i[t], Me, e);
    return function(s) {
      return af(n(s), t);
    };
  }
  function Np(i, t, e) {
    const n = Ei(
      i,
      t + "pattern-src",
      e
    ), s = du(
      i,
      t + "pattern-offset",
      e
    ), r = du(
      i,
      t + "pattern-size",
      e
    ), a = Bh(
      i,
      t + "color",
      e
    );
    return function(o) {
      return {
        src: n(o),
        offset: s && s(o),
        size: r && r(o),
        color: a && a(o)
      };
    };
  }
  function ys(i, t, e) {
    if (!(t in i))
      return null;
    const n = Ai(i[t], me, e);
    return function(s) {
      const r = n(s);
      if (typeof r != "boolean")
        throw new Error(`Expected a boolean for ${t}`);
      return r;
    };
  }
  function Bh(i, t, e) {
    if (!(t in i))
      return null;
    const n = Ai(i[t], Ve, e);
    return function(s) {
      return of(n(s), t);
    };
  }
  function rf(i, t, e) {
    if (!(t in i))
      return null;
    const n = Ai(i[t], Gn, e);
    return function(s) {
      return qr(n(s), t);
    };
  }
  function qa(i, t, e) {
    if (!(t in i))
      return null;
    const n = Ai(i[t], Gn, e);
    return function(s) {
      const r = qr(n(s), t);
      if (r.length !== 2)
        throw new Error(`Expected two numbers for ${t}`);
      return r;
    };
  }
  function du(i, t, e) {
    if (!(t in i))
      return null;
    const n = Ai(i[t], Gn, e);
    return function(s) {
      return lf(n(s), t);
    };
  }
  function To(i, t, e) {
    if (!(t in i))
      return null;
    const n = Ai(
      i[t],
      Gn | yt,
      e
    );
    return function(s) {
      return zp(n(s), t);
    };
  }
  function Ka(i, t) {
    const e = i[t];
    if (e !== void 0) {
      if (typeof e != "number")
        throw new Error(`Expected a number for ${t}`);
      return e;
    }
  }
  function Fp(i, t) {
    const e = i[t];
    if (e !== void 0) {
      if (typeof e == "number")
        return Ce(e);
      if (!Array.isArray(e))
        throw new Error(`Expected a number or size array for ${t}`);
      if (e.length !== 2 || typeof e[0] != "number" || typeof e[1] != "number")
        throw new Error(`Expected a number or size array for ${t}`);
      return e;
    }
  }
  function Dp(i, t) {
    const e = i[t];
    if (e !== void 0) {
      if (typeof e != "string")
        throw new Error(`Expected a string for ${t}`);
      return e;
    }
  }
  function fu(i, t) {
    const e = i[t];
    if (e !== void 0) {
      if (e !== "bottom-left" && e !== "bottom-right" && e !== "top-left" && e !== "top-right")
        throw new Error(
          `Expected bottom-left, bottom-right, top-left, or top-right for ${t}`
        );
      return e;
    }
  }
  function gu(i, t) {
    const e = i[t];
    if (e !== void 0) {
      if (e !== "pixels" && e !== "fraction")
        throw new Error(`Expected pixels or fraction for ${t}`);
      return e;
    }
  }
  function kp(i, t) {
    const e = i[t];
    if (e !== void 0)
      return qr(e, t);
  }
  function Ao(i, t) {
    const e = i[t];
    if (e !== void 0) {
      if (typeof e != "string")
        throw new Error(`Expected a string for ${t}`);
      if (e !== "declutter" && e !== "obstacle" && e !== "none")
        throw new Error(`Expected declutter, obstacle, or none for ${t}`);
      return e;
    }
  }
  function Gp(i, t) {
    const e = i[t];
    if (e !== void 0)
      return of(e, t);
  }
  function qr(i, t) {
    if (!Array.isArray(i))
      throw new Error(`Expected an array for ${t}`);
    const e = i.length;
    for (let n = 0; n < e; ++n)
      if (typeof i[n] != "number")
        throw new Error(`Expected an array of numbers for ${t}`);
    return i;
  }
  function af(i, t) {
    if (typeof i != "string")
      throw new Error(`Expected a string for ${t}`);
    return i;
  }
  function Fl(i, t) {
    if (typeof i != "number")
      throw new Error(`Expected a number for ${t}`);
    return i;
  }
  function of(i, t) {
    if (typeof i == "string")
      return i;
    const e = qr(i, t), n = e.length;
    if (n < 3 || n > 4)
      throw new Error(`Expected a color with 3 or 4 values for ${t}`);
    return e;
  }
  function lf(i, t) {
    const e = qr(i, t);
    if (e.length !== 2)
      throw new Error(`Expected an array of two numbers for ${t}`);
    return e;
  }
  function zp(i, t) {
    return typeof i == "number" ? i : lf(i, t);
  }
  const mu = {
    RENDER_ORDER: "renderOrder"
  };
  class hf extends Ro {
    /**
     * @param {Options<FeatureType, VectorSourceType>} [options] Options.
     */
    constructor(t) {
      t = t || {};
      const e = Object.assign({}, t);
      delete e.style, delete e.renderBuffer, delete e.updateWhileAnimating, delete e.updateWhileInteracting, super(e), this.declutter_ = t.declutter ? String(t.declutter) : void 0, this.renderBuffer_ = t.renderBuffer !== void 0 ? t.renderBuffer : 100, this.style_ = null, this.styleFunction_ = void 0, this.setStyle(t.style), this.updateWhileAnimating_ = t.updateWhileAnimating !== void 0 ? t.updateWhileAnimating : !1, this.updateWhileInteracting_ = t.updateWhileInteracting !== void 0 ? t.updateWhileInteracting : !1;
    }
    /**
     * @return {string} Declutter group.
     * @override
     */
    getDeclutter() {
      return this.declutter_;
    }
    /**
     * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
     * that resolves with an array of features. The array will either contain the topmost feature
     * when a hit was detected, or it will be empty.
     *
     * The hit detection algorithm used for this method is optimized for performance, but is less
     * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
     * Text is not considered, and icons are only represented by their bounding box instead of the exact
     * image.
     *
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
     * @api
     * @override
     */
    getFeatures(t) {
      return super.getFeatures(t);
    }
    /**
     * @return {number|undefined} Render buffer.
     */
    getRenderBuffer() {
      return this.renderBuffer_;
    }
    /**
     * @return {import("../render.js").OrderFunction|null|undefined} Render order.
     */
    getRenderOrder() {
      return (
        /** @type {import("../render.js").OrderFunction|null|undefined} */
        this.get(mu.RENDER_ORDER)
      );
    }
    /**
     * Get the style for features.  This returns whatever was passed to the `style`
     * option at construction or to the `setStyle` method.
     * @return {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null|undefined} Layer style.
     * @api
     */
    getStyle() {
      return this.style_;
    }
    /**
     * Get the style function.
     * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
     * @api
     */
    getStyleFunction() {
      return this.styleFunction_;
    }
    /**
     * @return {boolean} Whether the rendered layer should be updated while
     *     animating.
     */
    getUpdateWhileAnimating() {
      return this.updateWhileAnimating_;
    }
    /**
     * @return {boolean} Whether the rendered layer should be updated while
     *     interacting.
     */
    getUpdateWhileInteracting() {
      return this.updateWhileInteracting_;
    }
    /**
     * Render declutter items for this layer
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {import("../layer/Layer.js").State} layerState Layer state.
     * @override
     */
    renderDeclutter(t, e) {
      const n = this.getDeclutter();
      n in t.declutter || (t.declutter[n] = new Vd(9)), this.getRenderer().renderDeclutter(t, e);
    }
    /**
     * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
     *     Render order.
     */
    setRenderOrder(t) {
      this.set(mu.RENDER_ORDER, t);
    }
    /**
     * Set the style for features.  This can be a single style object, an array
     * of styles, or a function that takes a feature and resolution and returns
     * an array of styles. If set to `null`, the layer has no style (a `null` style),
     * so only features that have their own styles will be rendered in the layer. Call
     * `setStyle()` without arguments to reset to the default style. See
     * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
     *
     * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
     * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
     * ```js
     * vectorLayer.setStyle({
     *   "fill-color": "yellow",
     *   "stroke-color": "black",
     *   "stroke-width": 4
     * })
     * ```
     *
     * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
     * @api
     */
    setStyle(t) {
      this.style_ = t === void 0 ? sf : t;
      const e = $p(t);
      this.styleFunction_ = t === null ? void 0 : Sp(e), this.changed();
    }
    /**
     * @param {boolean|string|number} declutter Declutter images and text.
     * @api
     */
    setDeclutter(t) {
      this.declutter_ = t ? String(t) : void 0, this.changed();
    }
  }
  function $p(i) {
    if (i === void 0)
      return sf;
    if (!i)
      return null;
    if (typeof i == "function" || i instanceof je)
      return i;
    if (!Array.isArray(i))
      return uu([i]);
    if (i.length === 0)
      return [];
    const t = i.length, e = i[0];
    if (e instanceof je) {
      const s = new Array(t);
      for (let r = 0; r < t; ++r) {
        const a = i[r];
        if (!(a instanceof je))
          throw new Error("Expected a list of style instances");
        s[r] = a;
      }
      return s;
    }
    if ("style" in e) {
      const s = new Array(t);
      for (let r = 0; r < t; ++r) {
        const a = i[r];
        if (!("style" in a))
          throw new Error("Expected a list of rules with a style property");
        s[r] = a;
      }
      return Ip(s);
    }
    return uu(
      /** @type {Array<import("../style/flat.js").FlatStyle>} */
      i
    );
  }
  class cf extends Ri {
    /**
     * @param {import("./EventType.js").default} type Type.
     * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
     *     CSS pixels to rendered pixels.
     * @param {import("../Map.js").FrameState} [frameState] Frame state.
     * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
     */
    constructor(t, e, n, s) {
      super(t), this.inversePixelTransform = e, this.frameState = n, this.context = s;
    }
  }
  class Up extends oo {
    /**
     * @param {import("../Map.js").default} map Map.
     */
    constructor(t) {
      super(), this.map_ = t;
    }
    /**
     * @abstract
     * @param {import("../render/EventType.js").default} type Event type.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */
    dispatchRenderEvent(t, e) {
      ct();
    }
    /**
     * @param {import("../Map.js").FrameState} frameState FrameState.
     * @protected
     */
    calculateMatrices2D(t) {
      const e = t.viewState, n = t.coordinateToPixelTransform, s = t.pixelToCoordinateTransform;
      Ci(
        n,
        t.size[0] / 2,
        t.size[1] / 2,
        1 / e.resolution,
        -1 / e.resolution,
        -e.rotation,
        -e.center[0],
        -e.center[1]
      ), bd(s, n);
    }
    /**
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../Map.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {boolean} checkWrapped Check for wrapped geometries.
     * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {S} thisArg Value to use as `this` when executing `callback`.
     * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
     *     function, only layers which are visible and for which this function
     *     returns `true` will be tested for features.  By default, all visible
     *     layers will be tested.
     * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
     * @return {T|undefined} Callback result.
     * @template S,T,U
     */
    forEachFeatureAtCoordinate(t, e, n, s, r, a, o, l) {
      let h;
      const c = e.viewState;
      function u(S, C, T, L) {
        return r.call(a, C, S ? T : null, L);
      }
      const d = c.projection, g = yd(t.slice(), d), _ = [[0, 0]];
      if (d.canWrapX() && s) {
        const S = d.getExtent(), C = Mt(S);
        _.push([-C, 0], [C, 0]);
      }
      const y = e.layerStatesArray, E = y.length, M = (
        /** @type {Array<HitMatch<T>>} */
        []
      ), w = [];
      for (let S = 0; S < _.length; S++)
        for (let C = E - 1; C >= 0; --C) {
          const T = y[C], L = T.layer;
          if (L.hasRenderer() && Nh(T, c) && o.call(l, L)) {
            const A = L.getRenderer(), O = L.getSource();
            if (A && O) {
              const $ = O.getWrapX() ? g : t, q = u.bind(
                null,
                T.managed
              );
              w[0] = $[0] + _[S][0], w[1] = $[1] + _[S][1], h = A.forEachFeatureAtCoordinate(
                w,
                e,
                n,
                q,
                M
              );
            }
            if (h)
              return h;
          }
        }
      if (M.length === 0)
        return;
      const R = 1 / M.length;
      return M.forEach((S, C) => S.distanceSq += C * R), M.sort((S, C) => S.distanceSq - C.distanceSq), M.some((S) => h = S.callback(S.feature, S.layer, S.geometry)), h;
    }
    /**
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../Map.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {boolean} checkWrapped Check for wrapped geometries.
     * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
     *     function, only layers which are visible and for which this function
     *     returns `true` will be tested for features.  By default, all visible
     *     layers will be tested.
     * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
     * @return {boolean} Is there a feature at the given coordinate?
     * @template U
     */
    hasFeatureAtCoordinate(t, e, n, s, r, a) {
      return this.forEachFeatureAtCoordinate(
        t,
        e,
        n,
        s,
        Mr,
        this,
        r,
        a
      ) !== void 0;
    }
    /**
     * @return {import("../Map.js").default} Map.
     */
    getMap() {
      return this.map_;
    }
    /**
     * Render.
     * @abstract
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     */
    renderFrame(t) {
      ct();
    }
    /**
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    scheduleExpireIconCache(t) {
      Ge.canExpireCache() && t.postRenderFunctions.push(Bp);
    }
  }
  function Bp(i, t) {
    Ge.expire();
  }
  class Wp extends Up {
    /**
     * @param {import("../Map.js").default} map Map.
     */
    constructor(t) {
      super(t), this.fontChangeListenerKey_ = vt(
        yi,
        Rs.PROPERTYCHANGE,
        t.redrawText,
        t
      ), this.element_ = document.createElement("div");
      const e = this.element_.style;
      e.position = "absolute", e.width = "100%", e.height = "100%", e.zIndex = "0", this.element_.className = So + " ol-layers";
      const n = t.getViewport();
      n.insertBefore(this.element_, n.firstChild || null), this.children_ = [], this.renderedVisible_ = !0;
    }
    /**
     * @param {import("../render/EventType.js").default} type Event type.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @override
     */
    dispatchRenderEvent(t, e) {
      const n = this.getMap();
      if (n.hasListener(t)) {
        const s = new cf(t, void 0, e);
        n.dispatchEvent(s);
      }
    }
    /**
     * @override
     */
    disposeInternal() {
      Pt(this.fontChangeListenerKey_), this.element_.remove(), super.disposeInternal();
    }
    /**
     * Render.
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     * @override
     */
    renderFrame(t) {
      if (!t) {
        this.renderedVisible_ && (this.element_.style.display = "none", this.renderedVisible_ = !1);
        return;
      }
      this.calculateMatrices2D(t), this.dispatchRenderEvent(ke.PRECOMPOSE, t);
      const e = t.layerStatesArray.sort(
        (o, l) => o.zIndex - l.zIndex
      );
      e.some(
        (o) => o.layer instanceof hf && o.layer.getDeclutter()
      ) && (t.declutter = {});
      const s = t.viewState;
      this.children_.length = 0;
      const r = [];
      let a = null;
      for (let o = 0, l = e.length; o < l; ++o) {
        const h = e[o];
        t.layerIndex = o;
        const c = h.layer, u = c.getSourceState();
        if (!Nh(h, s) || u != "ready" && u != "undefined") {
          c.unrender();
          continue;
        }
        const d = c.render(t, a);
        d && (d !== a && (this.children_.push(d), a = d), r.push(h));
      }
      this.declutter(t, r), a_(this.element_, this.children_), this.dispatchRenderEvent(ke.POSTCOMPOSE, t), this.renderedVisible_ || (this.element_.style.display = "", this.renderedVisible_ = !0), this.scheduleExpireIconCache(t);
    }
    /**
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {Array<import('../layer/Layer.js').State>} layerStates Layers.
     */
    declutter(t, e) {
      if (t.declutter) {
        for (let n = e.length - 1; n >= 0; --n) {
          const s = e[n], r = s.layer;
          r.getDeclutter() && r.renderDeclutter(t, s);
        }
        e.forEach(
          (n) => n.layer.renderDeferred(t)
        );
      }
    }
  }
  function uf(i) {
    if (i instanceof Ro) {
      i.setMapInternal(null);
      return;
    }
    i instanceof Us && i.getLayers().forEach(uf);
  }
  function df(i, t) {
    if (i instanceof Ro) {
      i.setMapInternal(t);
      return;
    }
    if (i instanceof Us) {
      const e = i.getLayers().getArray();
      for (let n = 0, s = e.length; n < s; ++n)
        df(e[n], t);
    }
  }
  let Xp = class extends Qe {
    /**
     * @param {MapOptions} [options] Map options.
     */
    constructor(t) {
      super(), t = t || {}, this.on, this.once, this.un;
      const e = Yp(t);
      this.renderComplete_ = !1, this.loaded_ = !0, this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this), this.maxTilesLoading_ = t.maxTilesLoading !== void 0 ? t.maxTilesLoading : 16, this.pixelRatio_ = t.pixelRatio !== void 0 ? t.pixelRatio : co, this.postRenderTimeoutHandle_, this.animationDelayKey_, this.animationDelay_ = this.animationDelay_.bind(this), this.coordinateToPixelTransform_ = $e(), this.pixelToCoordinateTransform_ = $e(), this.frameIndex_ = 0, this.frameState_ = null, this.previousExtent_ = null, this.viewPropertyListenerKey_ = null, this.viewChangeListenerKey_ = null, this.layerGroupPropertyListenerKeys_ = null, this.viewport_ = document.createElement("div"), this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : ""), this.viewport_.style.position = "relative", this.viewport_.style.overflow = "hidden", this.viewport_.style.width = "100%", this.viewport_.style.height = "100%", this.overlayContainer_ = document.createElement("div"), this.overlayContainer_.style.position = "absolute", this.overlayContainer_.style.zIndex = "0", this.overlayContainer_.style.width = "100%", this.overlayContainer_.style.height = "100%", this.overlayContainer_.style.pointerEvents = "none", this.overlayContainer_.className = "ol-overlaycontainer", this.viewport_.appendChild(this.overlayContainer_), this.overlayContainerStopEvent_ = document.createElement("div"), this.overlayContainerStopEvent_.style.position = "absolute", this.overlayContainerStopEvent_.style.zIndex = "0", this.overlayContainerStopEvent_.style.width = "100%", this.overlayContainerStopEvent_.style.height = "100%", this.overlayContainerStopEvent_.style.pointerEvents = "none", this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent", this.viewport_.appendChild(this.overlayContainerStopEvent_), this.mapBrowserEventHandler_ = null, this.moveTolerance_ = t.moveTolerance, this.keyboardEventTarget_ = e.keyboardEventTarget, this.targetChangeHandlerKeys_ = null, this.targetElement_ = null, this.resizeObserver_ = new ResizeObserver(() => this.updateSize()), this.controls = e.controls || c_(), this.interactions = e.interactions || b_({
        onFocusOnly: !0
      }), this.overlays_ = e.overlays, this.overlayIdIndex_ = {}, this.renderer_ = null, this.postRenderFunctions_ = [], this.tileQueue_ = new T0(
        this.getTilePriority.bind(this),
        this.handleTileChange_.bind(this)
      ), this.addChangeListener(
        ae.LAYERGROUP,
        this.handleLayerGroupChanged_
      ), this.addChangeListener(ae.VIEW, this.handleViewChanged_), this.addChangeListener(ae.SIZE, this.handleSizeChanged_), this.addChangeListener(ae.TARGET, this.handleTargetChanged_), this.setProperties(e.values);
      const n = this;
      t.view && !(t.view instanceof Ke) && t.view.then(function(s) {
        n.setView(new Ke(s));
      }), this.controls.addEventListener(
        Ee.ADD,
        /**
         * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
         */
        (s) => {
          s.element.setMap(this);
        }
      ), this.controls.addEventListener(
        Ee.REMOVE,
        /**
         * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
         */
        (s) => {
          s.element.setMap(null);
        }
      ), this.interactions.addEventListener(
        Ee.ADD,
        /**
         * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
         */
        (s) => {
          s.element.setMap(this);
        }
      ), this.interactions.addEventListener(
        Ee.REMOVE,
        /**
         * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
         */
        (s) => {
          s.element.setMap(null);
        }
      ), this.overlays_.addEventListener(
        Ee.ADD,
        /**
         * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
         */
        (s) => {
          this.addOverlayInternal_(s.element);
        }
      ), this.overlays_.addEventListener(
        Ee.REMOVE,
        /**
         * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
         */
        (s) => {
          const r = s.element.getId();
          r !== void 0 && delete this.overlayIdIndex_[r.toString()], s.element.setMap(null);
        }
      ), this.controls.forEach(
        /**
         * @param {import("./control/Control.js").default} control Control.
         */
        (s) => {
          s.setMap(this);
        }
      ), this.interactions.forEach(
        /**
         * @param {import("./interaction/Interaction.js").default} interaction Interaction.
         */
        (s) => {
          s.setMap(this);
        }
      ), this.overlays_.forEach(this.addOverlayInternal_.bind(this));
    }
    /**
     * Add the given control to the map.
     * @param {import("./control/Control.js").default} control Control.
     * @api
     */
    addControl(t) {
      this.getControls().push(t);
    }
    /**
     * Add the given interaction to the map. If you want to add an interaction
     * at another point of the collection use `getInteractions()` and the methods
     * available on {@link module:ol/Collection~Collection}. This can be used to
     * stop the event propagation from the handleEvent function. The interactions
     * get to handle the events in the reverse order of this collection.
     * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
     * @api
     */
    addInteraction(t) {
      this.getInteractions().push(t);
    }
    /**
     * Adds the given layer to the top of this map. If you want to add a layer
     * elsewhere in the stack, use `getLayers()` and the methods available on
     * {@link module:ol/Collection~Collection}.
     * @param {import("./layer/Base.js").default} layer Layer.
     * @api
     */
    addLayer(t) {
      this.getLayerGroup().getLayers().push(t);
    }
    /**
     * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
     * @private
     */
    handleLayerAdd_(t) {
      df(t.layer, this);
    }
    /**
     * Add the given overlay to the map.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @api
     */
    addOverlay(t) {
      this.getOverlays().push(t);
    }
    /**
     * This deals with map's overlay collection changes.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @private
     */
    addOverlayInternal_(t) {
      const e = t.getId();
      e !== void 0 && (this.overlayIdIndex_[e.toString()] = t), t.setMap(this);
    }
    /**
     *
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.controls.clear(), this.interactions.clear(), this.overlays_.clear(), this.resizeObserver_.disconnect(), this.setTarget(null), super.disposeInternal();
    }
    /**
     * Detect features that intersect a pixel on the viewport, and execute a
     * callback with each intersecting feature. Layers included in the detection can
     * be configured through the `layerFilter` option in `options`.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
     *     called with two arguments. The first argument is one
     *     {@link module:ol/Feature~Feature feature} or
     *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
     *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
     *     unmanaged layers. To stop detection, callback functions can return a
     *     truthy value.
     * @param {AtPixelOptions} [options] Optional options.
     * @return {T|undefined} Callback result, i.e. the return value of last
     * callback execution, or the first truthy callback return value.
     * @template T
     * @api
     */
    forEachFeatureAtPixel(t, e, n) {
      if (!this.frameState_ || !this.renderer_)
        return;
      const s = this.getCoordinateFromPixelInternal(t);
      n = n !== void 0 ? n : {};
      const r = n.hitTolerance !== void 0 ? n.hitTolerance : 0, a = n.layerFilter !== void 0 ? n.layerFilter : Mr, o = n.checkWrapped !== !1;
      return this.renderer_.forEachFeatureAtCoordinate(
        s,
        this.frameState_,
        r,
        o,
        e,
        null,
        a,
        null
      );
    }
    /**
     * Get all features that intersect a pixel on the viewport.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {AtPixelOptions} [options] Optional options.
     * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
     * an empty array if none were found.
     * @api
     */
    getFeaturesAtPixel(t, e) {
      const n = [];
      return this.forEachFeatureAtPixel(
        t,
        function(s) {
          n.push(s);
        },
        e
      ), n;
    }
    /**
     * Get all layers from all layer groups.
     * @return {Array<import("./layer/Layer.js").default>} Layers.
     * @api
     */
    getAllLayers() {
      const t = [];
      function e(n) {
        n.forEach(function(s) {
          s instanceof Us ? e(s.getLayers()) : t.push(s);
        });
      }
      return e(this.getLayers()), t;
    }
    /**
     * Detect if features intersect a pixel on the viewport. Layers included in the
     * detection can be configured through the `layerFilter` option.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {AtPixelOptions} [options] Optional options.
     * @return {boolean} Is there a feature at the given pixel?
     * @api
     */
    hasFeatureAtPixel(t, e) {
      if (!this.frameState_ || !this.renderer_)
        return !1;
      const n = this.getCoordinateFromPixelInternal(t);
      e = e !== void 0 ? e : {};
      const s = e.layerFilter !== void 0 ? e.layerFilter : Mr, r = e.hitTolerance !== void 0 ? e.hitTolerance : 0, a = e.checkWrapped !== !1;
      return this.renderer_.hasFeatureAtCoordinate(
        n,
        this.frameState_,
        r,
        a,
        s,
        null
      );
    }
    /**
     * Returns the coordinate in user projection for a browser event.
     * @param {MouseEvent} event Event.
     * @return {import("./coordinate.js").Coordinate} Coordinate.
     * @api
     */
    getEventCoordinate(t) {
      return this.getCoordinateFromPixel(this.getEventPixel(t));
    }
    /**
     * Returns the coordinate in view projection for a browser event.
     * @param {MouseEvent} event Event.
     * @return {import("./coordinate.js").Coordinate} Coordinate.
     */
    getEventCoordinateInternal(t) {
      return this.getCoordinateFromPixelInternal(this.getEventPixel(t));
    }
    /**
     * Returns the map pixel position for a browser event relative to the viewport.
     * @param {UIEvent|{clientX: number, clientY: number}} event Event.
     * @return {import("./pixel.js").Pixel} Pixel.
     * @api
     */
    getEventPixel(t) {
      const n = this.viewport_.getBoundingClientRect(), s = this.getSize(), r = n.width / s[0], a = n.height / s[1], o = (
        //FIXME Are we really calling this with a TouchEvent anywhere?
        "changedTouches" in t ? (
          /** @type {TouchEvent} */
          t.changedTouches[0]
        ) : (
          /** @type {MouseEvent} */
          t
        )
      );
      return [
        (o.clientX - n.left) / r,
        (o.clientY - n.top) / a
      ];
    }
    /**
     * Get the target in which this map is rendered.
     * Note that this returns what is entered as an option or in setTarget:
     * if that was an element, it returns an element; if a string, it returns that.
     * @return {HTMLElement|string|undefined} The Element or id of the Element that the
     *     map is rendered in.
     * @observable
     * @api
     */
    getTarget() {
      return (
        /** @type {HTMLElement|string|undefined} */
        this.get(ae.TARGET)
      );
    }
    /**
     * Get the DOM element into which this map is rendered. In contrast to
     * `getTarget` this method always return an `Element`, or `null` if the
     * map has no target.
     * @return {HTMLElement} The element that the map is rendered in.
     * @api
     */
    getTargetElement() {
      return this.targetElement_;
    }
    /**
     * Get the coordinate for a given pixel.  This returns a coordinate in the
     * user projection.
     * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
     * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
     * @api
     */
    getCoordinateFromPixel(t) {
      return Tl(
        this.getCoordinateFromPixelInternal(t),
        this.getView().getProjection()
      );
    }
    /**
     * Get the coordinate for a given pixel.  This returns a coordinate in the
     * map view projection.
     * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
     * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
     */
    getCoordinateFromPixelInternal(t) {
      const e = this.frameState_;
      return e ? Xt(e.pixelToCoordinateTransform, t.slice()) : null;
    }
    /**
     * Get the map controls. Modifying this collection changes the controls
     * associated with the map.
     * @return {Collection<import("./control/Control.js").default>} Controls.
     * @api
     */
    getControls() {
      return this.controls;
    }
    /**
     * Get the map overlays. Modifying this collection changes the overlays
     * associated with the map.
     * @return {Collection<import("./Overlay.js").default>} Overlays.
     * @api
     */
    getOverlays() {
      return this.overlays_;
    }
    /**
     * Get an overlay by its identifier (the value returned by overlay.getId()).
     * Note that the index treats string and numeric identifiers as the same. So
     * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
     * @param {string|number} id Overlay identifier.
     * @return {import("./Overlay.js").default|null} Overlay.
     * @api
     */
    getOverlayById(t) {
      const e = this.overlayIdIndex_[t.toString()];
      return e !== void 0 ? e : null;
    }
    /**
     * Get the map interactions. Modifying this collection changes the interactions
     * associated with the map.
     *
     * Interactions are used for e.g. pan, zoom and rotate.
     * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
     * @api
     */
    getInteractions() {
      return this.interactions;
    }
    /**
     * Get the layergroup associated with this map.
     * @return {LayerGroup} A layer group containing the layers in this map.
     * @observable
     * @api
     */
    getLayerGroup() {
      return (
        /** @type {LayerGroup} */
        this.get(ae.LAYERGROUP)
      );
    }
    /**
     * Clear any existing layers and add layers to the map.
     * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
     * @api
     */
    setLayers(t) {
      const e = this.getLayerGroup();
      if (t instanceof ni) {
        e.setLayers(t);
        return;
      }
      const n = e.getLayers();
      n.clear(), n.extend(t);
    }
    /**
     * Get the collection of layers associated with this map.
     * @return {!Collection<import("./layer/Base.js").default>} Layers.
     * @api
     */
    getLayers() {
      return this.getLayerGroup().getLayers();
    }
    /**
     * @return {boolean} Layers have sources that are still loading.
     */
    getLoadingOrNotReady() {
      const t = this.getLayerGroup().getLayerStatesArray();
      for (let e = 0, n = t.length; e < n; ++e) {
        const s = t[e];
        if (!s.visible)
          continue;
        const r = s.layer.getRenderer();
        if (r && !r.ready)
          return !0;
        const a = s.layer.getSource();
        if (a && a.loading)
          return !0;
      }
      return !1;
    }
    /**
     * Get the pixel for a coordinate.  This takes a coordinate in the user
     * projection and returns the corresponding pixel.
     * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
     * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
     * @api
     */
    getPixelFromCoordinate(t) {
      const e = pi(
        t,
        this.getView().getProjection()
      );
      return this.getPixelFromCoordinateInternal(e);
    }
    /**
     * Get the pixel for a coordinate.  This takes a coordinate in the map view
     * projection and returns the corresponding pixel.
     * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
     * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
     */
    getPixelFromCoordinateInternal(t) {
      const e = this.frameState_;
      return e ? Xt(
        e.coordinateToPixelTransform,
        t.slice(0, 2)
      ) : null;
    }
    /**
     * Get the map renderer.
     * @return {import("./renderer/Map.js").default|null} Renderer
     */
    getRenderer() {
      return this.renderer_;
    }
    /**
     * Get the size of this map.
     * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
     * @observable
     * @api
     */
    getSize() {
      return (
        /** @type {import("./size.js").Size|undefined} */
        this.get(ae.SIZE)
      );
    }
    /**
     * Get the view associated with this map. A view manages properties such as
     * center and resolution.
     * @return {View} The view that controls this map.
     * @observable
     * @api
     */
    getView() {
      return (
        /** @type {View} */
        this.get(ae.VIEW)
      );
    }
    /**
     * Get the element that serves as the map viewport.
     * @return {HTMLElement} Viewport.
     * @api
     */
    getViewport() {
      return this.viewport_;
    }
    /**
     * Get the element that serves as the container for overlays.  Elements added to
     * this container will let mousedown and touchstart events through to the map,
     * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
     * events.
     * @return {!HTMLElement} The map's overlay container.
     */
    getOverlayContainer() {
      return this.overlayContainer_;
    }
    /**
     * Get the element that serves as a container for overlays that don't allow
     * event propagation. Elements added to this container won't let mousedown and
     * touchstart events through to the map, so clicks and gestures on an overlay
     * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     * @return {!HTMLElement} The map's overlay container that stops events.
     */
    getOverlayContainerStopEvent() {
      return this.overlayContainerStopEvent_;
    }
    /**
     * @return {!Document} The document where the map is displayed.
     */
    getOwnerDocument() {
      const t = this.getTargetElement();
      return t ? t.ownerDocument : document;
    }
    /**
     * @param {import("./Tile.js").default} tile Tile.
     * @param {string} tileSourceKey Tile source key.
     * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
     * @param {number} tileResolution Tile resolution.
     * @return {number} Tile priority.
     */
    getTilePriority(t, e, n, s) {
      return A0(
        this.frameState_,
        t,
        e,
        n,
        s
      );
    }
    /**
     * @param {UIEvent} browserEvent Browser event.
     * @param {string} [type] Type.
     */
    handleBrowserEvent(t, e) {
      e = e || t.type;
      const n = new $i(e, this, t);
      this.handleMapBrowserEvent(n);
    }
    /**
     * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
     */
    handleMapBrowserEvent(t) {
      if (!this.frameState_)
        return;
      const e = (
        /** @type {PointerEvent} */
        t.originalEvent
      ), n = e.type;
      if (n === El.POINTERDOWN || n === at.WHEEL || n === at.KEYDOWN) {
        const s = this.getOwnerDocument(), r = this.viewport_.getRootNode ? this.viewport_.getRootNode() : s, a = (
          /** @type {Node} */
          e.target
        ), o = r instanceof ShadowRoot ? r.host === a ? r.host.ownerDocument : r : r === s ? s.documentElement : r;
        if (
          // Abort if the target is a child of the container for elements whose events are not meant
          // to be handled by map interactions.
          this.overlayContainerStopEvent_.contains(a) || // Abort if the event target is a child of the container that is no longer in the page.
          // It's possible for the target to no longer be in the page if it has been removed in an
          // event listener, this might happen in a Control that recreates it's content based on
          // user interaction either manually or via a render in something like https://reactjs.org/
          !o.contains(a)
        )
          return;
      }
      if (t.frameState = this.frameState_, this.dispatchEvent(t) !== !1) {
        const s = this.getInteractions().getArray().slice();
        for (let r = s.length - 1; r >= 0; r--) {
          const a = s[r];
          if (a.getMap() !== this || !a.getActive() || !this.getTargetElement())
            continue;
          if (!a.handleEvent(t) || t.propagationStopped)
            break;
        }
      }
    }
    /**
     * @protected
     */
    handlePostRender() {
      const t = this.frameState_, e = this.tileQueue_;
      if (!e.isEmpty()) {
        let s = this.maxTilesLoading_, r = s;
        if (t) {
          const a = t.viewHints;
          if (a[oe.ANIMATING] || a[oe.INTERACTING]) {
            const o = Date.now() - t.time > 8;
            s = o ? 0 : 8, r = o ? 0 : 2;
          }
        }
        e.getTilesLoading() < s && (e.reprioritize(), e.loadMoreTiles(s, r));
      }
      t && this.renderer_ && !t.animate && (this.renderComplete_ ? (this.hasListener(ke.RENDERCOMPLETE) && this.renderer_.dispatchRenderEvent(
        ke.RENDERCOMPLETE,
        t
      ), this.loaded_ === !1 && (this.loaded_ = !0, this.dispatchEvent(
        new rs(vi.LOADEND, this, t)
      ))) : this.loaded_ === !0 && (this.loaded_ = !1, this.dispatchEvent(
        new rs(vi.LOADSTART, this, t)
      )));
      const n = this.postRenderFunctions_;
      if (t)
        for (let s = 0, r = n.length; s < r; ++s)
          n[s](this, t);
      n.length = 0;
    }
    /**
     * @private
     */
    handleSizeChanged_() {
      this.getView() && !this.getView().getAnimating() && this.getView().resolveConstraints(0), this.render();
    }
    /**
     * @private
     */
    handleTargetChanged_() {
      if (this.mapBrowserEventHandler_) {
        for (let n = 0, s = this.targetChangeHandlerKeys_.length; n < s; ++n)
          Pt(this.targetChangeHandlerKeys_[n]);
        this.targetChangeHandlerKeys_ = null, this.viewport_.removeEventListener(
          at.CONTEXTMENU,
          this.boundHandleBrowserEvent_
        ), this.viewport_.removeEventListener(
          at.WHEEL,
          this.boundHandleBrowserEvent_
        ), this.mapBrowserEventHandler_.dispose(), this.mapBrowserEventHandler_ = null, this.viewport_.remove();
      }
      if (this.targetElement_) {
        this.resizeObserver_.unobserve(this.targetElement_);
        const n = this.targetElement_.getRootNode();
        n instanceof ShadowRoot && this.resizeObserver_.unobserve(n.host), this.setSize(void 0);
      }
      const t = this.getTarget(), e = typeof t == "string" ? document.getElementById(t) : t;
      if (this.targetElement_ = e, !e)
        this.renderer_ && (clearTimeout(this.postRenderTimeoutHandle_), this.postRenderTimeoutHandle_ = void 0, this.postRenderFunctions_.length = 0, this.renderer_.dispose(), this.renderer_ = null), this.animationDelayKey_ && (cancelAnimationFrame(this.animationDelayKey_), this.animationDelayKey_ = void 0);
      else {
        e.appendChild(this.viewport_), this.renderer_ || (this.renderer_ = new Wp(this)), this.mapBrowserEventHandler_ = new R0(
          this,
          this.moveTolerance_
        );
        for (const r in Gt)
          this.mapBrowserEventHandler_.addEventListener(
            Gt[r],
            this.handleMapBrowserEvent.bind(this)
          );
        this.viewport_.addEventListener(
          at.CONTEXTMENU,
          this.boundHandleBrowserEvent_,
          !1
        ), this.viewport_.addEventListener(
          at.WHEEL,
          this.boundHandleBrowserEvent_,
          th ? { passive: !1 } : !1
        );
        let n;
        if (this.keyboardEventTarget_)
          n = this.keyboardEventTarget_;
        else {
          const r = e.getRootNode();
          n = r instanceof ShadowRoot ? r.host : e;
        }
        this.targetChangeHandlerKeys_ = [
          vt(
            n,
            at.KEYDOWN,
            this.handleBrowserEvent,
            this
          ),
          vt(
            n,
            at.KEYPRESS,
            this.handleBrowserEvent,
            this
          )
        ];
        const s = e.getRootNode();
        s instanceof ShadowRoot && this.resizeObserver_.observe(s.host), this.resizeObserver_.observe(e);
      }
      this.updateSize();
    }
    /**
     * @private
     */
    handleTileChange_() {
      this.render();
    }
    /**
     * @private
     */
    handleViewPropertyChanged_() {
      this.render();
    }
    /**
     * @private
     */
    handleViewChanged_() {
      this.viewPropertyListenerKey_ && (Pt(this.viewPropertyListenerKey_), this.viewPropertyListenerKey_ = null), this.viewChangeListenerKey_ && (Pt(this.viewChangeListenerKey_), this.viewChangeListenerKey_ = null);
      const t = this.getView();
      t && (this.updateViewportSize_(this.getSize()), this.viewPropertyListenerKey_ = vt(
        t,
        Rs.PROPERTYCHANGE,
        this.handleViewPropertyChanged_,
        this
      ), this.viewChangeListenerKey_ = vt(
        t,
        at.CHANGE,
        this.handleViewPropertyChanged_,
        this
      ), t.resolveConstraints(0)), this.render();
    }
    /**
     * @private
     */
    handleLayerGroupChanged_() {
      this.layerGroupPropertyListenerKeys_ && (this.layerGroupPropertyListenerKeys_.forEach(Pt), this.layerGroupPropertyListenerKeys_ = null);
      const t = this.getLayerGroup();
      t && (this.handleLayerAdd_(new Ui("addlayer", t)), this.layerGroupPropertyListenerKeys_ = [
        vt(t, Rs.PROPERTYCHANGE, this.render, this),
        vt(t, at.CHANGE, this.render, this),
        vt(t, "addlayer", this.handleLayerAdd_, this),
        vt(t, "removelayer", this.handleLayerRemove_, this)
      ]), this.render();
    }
    /**
     * @return {boolean} Is rendered.
     */
    isRendered() {
      return !!this.frameState_;
    }
    /**
     * @private
     */
    animationDelay_() {
      this.animationDelayKey_ = void 0, this.renderFrame_(Date.now());
    }
    /**
     * Requests an immediate render in a synchronous manner.
     * @api
     */
    renderSync() {
      this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_), this.animationDelay_();
    }
    /**
     * Redraws all text after new fonts have loaded
     */
    redrawText() {
      const t = this.getLayerGroup().getLayerStatesArray();
      for (let e = 0, n = t.length; e < n; ++e) {
        const s = t[e].layer;
        s.hasRenderer() && s.getRenderer().handleFontsChanged();
      }
    }
    /**
     * Request a map rendering (at the next animation frame).
     * @api
     */
    render() {
      this.renderer_ && this.animationDelayKey_ === void 0 && (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_));
    }
    /**
     * Remove the given control from the map.
     * @param {import("./control/Control.js").default} control Control.
     * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
     *     if the control was not found).
     * @api
     */
    removeControl(t) {
      return this.getControls().remove(t);
    }
    /**
     * Remove the given interaction from the map.
     * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
     * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
     *     undefined if the interaction was not found).
     * @api
     */
    removeInteraction(t) {
      return this.getInteractions().remove(t);
    }
    /**
     * Removes the given layer from the map.
     * @param {import("./layer/Base.js").default} layer Layer.
     * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
     *     layer was not found).
     * @api
     */
    removeLayer(t) {
      return this.getLayerGroup().getLayers().remove(t);
    }
    /**
     * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
     * @private
     */
    handleLayerRemove_(t) {
      uf(t.layer);
    }
    /**
     * Remove the given overlay from the map.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
     *     if the overlay was not found).
     * @api
     */
    removeOverlay(t) {
      return this.getOverlays().remove(t);
    }
    /**
     * @param {number} time Time.
     * @private
     */
    renderFrame_(t) {
      const e = this.getSize(), n = this.getView(), s = this.frameState_;
      let r = null;
      if (e !== void 0 && su(e) && n && n.isDef()) {
        const a = n.getHints(
          this.frameState_ ? this.frameState_.viewHints : void 0
        ), o = n.getState();
        if (r = {
          animate: !1,
          coordinateToPixelTransform: this.coordinateToPixelTransform_,
          declutter: null,
          extent: za(
            o.center,
            o.resolution,
            o.rotation,
            e
          ),
          index: this.frameIndex_++,
          layerIndex: 0,
          layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
          pixelRatio: this.pixelRatio_,
          pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
          postRenderFunctions: [],
          size: e,
          tileQueue: this.tileQueue_,
          time: t,
          usedTiles: {},
          viewState: o,
          viewHints: a,
          wantedTiles: {},
          mapId: Ct(this),
          renderTargets: {}
        }, o.nextCenter && o.nextResolution) {
          const l = isNaN(o.nextRotation) ? o.rotation : o.nextRotation;
          r.nextExtent = za(
            o.nextCenter,
            o.nextResolution,
            l,
            e
          );
        }
      }
      this.frameState_ = r, this.renderer_.renderFrame(r), r && (r.animate && this.render(), Array.prototype.push.apply(
        this.postRenderFunctions_,
        r.postRenderFunctions
      ), s && (!this.previousExtent_ || !zs(this.previousExtent_) && !As(r.extent, this.previousExtent_)) && (this.dispatchEvent(
        new rs(vi.MOVESTART, this, s)
      ), this.previousExtent_ = Ii(this.previousExtent_)), this.previousExtent_ && !r.viewHints[oe.ANIMATING] && !r.viewHints[oe.INTERACTING] && !As(r.extent, this.previousExtent_) && (this.dispatchEvent(
        new rs(vi.MOVEEND, this, r)
      ), ih(r.extent, this.previousExtent_))), this.dispatchEvent(new rs(vi.POSTRENDER, this, r)), this.renderComplete_ = (this.hasListener(vi.LOADSTART) || this.hasListener(vi.LOADEND) || this.hasListener(ke.RENDERCOMPLETE)) && !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady(), this.postRenderTimeoutHandle_ || (this.postRenderTimeoutHandle_ = setTimeout(() => {
        this.postRenderTimeoutHandle_ = void 0, this.handlePostRender();
      }, 0));
    }
    /**
     * Sets the layergroup of this map.
     * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
     * @observable
     * @api
     */
    setLayerGroup(t) {
      const e = this.getLayerGroup();
      e && this.handleLayerRemove_(new Ui("removelayer", e)), this.set(ae.LAYERGROUP, t);
    }
    /**
     * Set the size of this map.
     * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
     * @observable
     * @api
     */
    setSize(t) {
      this.set(ae.SIZE, t);
    }
    /**
     * Set the target element to render this map into.
     * For accessibility (focus and keyboard events for map navigation), the `target` element must have a
     *  properly configured `tabindex` attribute. If the `target` element is inside a Shadow DOM, the
     *  `tabindex` atribute must be set on the custom element's host element.
     * @param {HTMLElement|string} [target] The Element or id of the Element
     *     that the map is rendered in.
     * @observable
     * @api
     */
    setTarget(t) {
      this.set(ae.TARGET, t);
    }
    /**
     * Set the view for this map.
     * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
     * It is also possible to pass a promise that resolves to options for constructing a view.  This
     * alternative allows view properties to be resolved by sources or other components that load
     * view-related metadata.
     * @observable
     * @api
     */
    setView(t) {
      if (!t || t instanceof Ke) {
        this.set(ae.VIEW, t);
        return;
      }
      this.set(ae.VIEW, new Ke());
      const e = this;
      t.then(function(n) {
        e.setView(new Ke(n));
      });
    }
    /**
     * Force a recalculation of the map viewport size.  This should be called when
     * third-party code changes the size of the map viewport.
     * @api
     */
    updateSize() {
      const t = this.getTargetElement();
      let e;
      if (t) {
        const s = getComputedStyle(t), r = t.offsetWidth - parseFloat(s.borderLeftWidth) - parseFloat(s.paddingLeft) - parseFloat(s.paddingRight) - parseFloat(s.borderRightWidth), a = t.offsetHeight - parseFloat(s.borderTopWidth) - parseFloat(s.paddingTop) - parseFloat(s.paddingBottom) - parseFloat(s.borderBottomWidth);
        !isNaN(r) && !isNaN(a) && (e = [Math.max(0, r), Math.max(0, a)], !su(e) && (t.offsetWidth || t.offsetHeight || t.getClientRects().length) && Md(
          "No map visible because the map container's width or height are 0."
        ));
      }
      const n = this.getSize();
      e && (!n || !rn(e, n)) && (this.setSize(e), this.updateViewportSize_(e));
    }
    /**
     * Recomputes the viewport size and save it on the view object (if any)
     * @param {import("./size.js").Size|undefined} size The size.
     * @private
     */
    updateViewportSize_(t) {
      const e = this.getView();
      e && e.setViewportSize(t);
    }
  };
  function Yp(i) {
    let t = null;
    i.keyboardEventTarget !== void 0 && (t = typeof i.keyboardEventTarget == "string" ? document.getElementById(i.keyboardEventTarget) : i.keyboardEventTarget);
    const e = {}, n = i.layers && typeof /** @type {?} */
    i.layers.getLayers == "function" ? (
      /** @type {LayerGroup} */
      i.layers
    ) : new Us({
      layers: (
        /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */
        i.layers
      )
    });
    e[ae.LAYERGROUP] = n, e[ae.TARGET] = i.target, e[ae.VIEW] = i.view instanceof Ke ? i.view : new Ke();
    let s;
    i.controls !== void 0 && (Array.isArray(i.controls) ? s = new ni(i.controls.slice()) : (xt(
      typeof /** @type {?} */
      i.controls.getArray == "function",
      "Expected `controls` to be an array or an `ol/Collection.js`"
    ), s = i.controls));
    let r;
    i.interactions !== void 0 && (Array.isArray(i.interactions) ? r = new ni(i.interactions.slice()) : (xt(
      typeof /** @type {?} */
      i.interactions.getArray == "function",
      "Expected `interactions` to be an array or an `ol/Collection.js`"
    ), r = i.interactions));
    let a;
    return i.overlays !== void 0 ? Array.isArray(i.overlays) ? a = new ni(i.overlays.slice()) : (xt(
      typeof /** @type {?} */
      i.overlays.getArray == "function",
      "Expected `overlays` to be an array or an `ol/Collection.js`"
    ), a = i.overlays) : a = new ni(), {
      controls: s,
      interactions: r,
      keyboardEventTarget: t,
      overlays: a,
      values: e
    };
  }
  class bo extends Qe {
    /**
     * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
     *     You may pass a Geometry object directly, or an object literal containing
     *     properties. If you pass an object literal, you may include a Geometry
     *     associated with a `geometry` key.
     */
    constructor(t) {
      if (super(), this.on, this.once, this.un, this.id_ = void 0, this.geometryName_ = "geometry", this.style_ = null, this.styleFunction_ = void 0, this.geometryChangeKey_ = null, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), t)
        if (typeof /** @type {?} */
        t.getSimplifiedGeometry == "function") {
          const e = (
            /** @type {Geometry} */
            t
          );
          this.setGeometry(e);
        } else {
          const e = t;
          this.setProperties(e);
        }
    }
    /**
     * Clone this feature. If the original feature has a geometry it
     * is also cloned. The feature id is not set in the clone.
     * @return {Feature<Geometry>} The clone.
     * @api
     */
    clone() {
      const t = (
        /** @type {Feature<Geometry>} */
        new bo(this.hasProperties() ? this.getProperties() : null)
      );
      t.setGeometryName(this.getGeometryName());
      const e = this.getGeometry();
      e && t.setGeometry(
        /** @type {Geometry} */
        e.clone()
      );
      const n = this.getStyle();
      return n && t.setStyle(n), t;
    }
    /**
     * Get the feature's default geometry.  A feature may have any number of named
     * geometries.  The "default" geometry (the one that is rendered by default) is
     * set when calling {@link module:ol/Feature~Feature#setGeometry}.
     * @return {Geometry|undefined} The default geometry for the feature.
     * @api
     * @observable
     */
    getGeometry() {
      return (
        /** @type {Geometry|undefined} */
        this.get(this.geometryName_)
      );
    }
    /**
     * Get the feature identifier.  This is a stable identifier for the feature and
     * is either set when reading data from a remote source or set explicitly by
     * calling {@link module:ol/Feature~Feature#setId}.
     * @return {number|string|undefined} Id.
     * @api
     */
    getId() {
      return this.id_;
    }
    /**
     * Get the name of the feature's default geometry.  By default, the default
     * geometry is named `geometry`.
     * @return {string} Get the property name associated with the default geometry
     *     for this feature.
     * @api
     */
    getGeometryName() {
      return this.geometryName_;
    }
    /**
     * Get the feature's style. Will return what was provided to the
     * {@link module:ol/Feature~Feature#setStyle} method.
     * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
     * @api
     */
    getStyle() {
      return this.style_;
    }
    /**
     * Get the feature's style function.
     * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
     * representing the current style of this feature.
     * @api
     */
    getStyleFunction() {
      return this.styleFunction_;
    }
    /**
     * @private
     */
    handleGeometryChange_() {
      this.changed();
    }
    /**
     * @private
     */
    handleGeometryChanged_() {
      this.geometryChangeKey_ && (Pt(this.geometryChangeKey_), this.geometryChangeKey_ = null);
      const t = this.getGeometry();
      t && (this.geometryChangeKey_ = vt(
        t,
        at.CHANGE,
        this.handleGeometryChange_,
        this
      )), this.changed();
    }
    /**
     * Set the default geometry for the feature.  This will update the property
     * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
     * @param {Geometry|undefined} geometry The new geometry.
     * @api
     * @observable
     */
    setGeometry(t) {
      this.set(this.geometryName_, t);
    }
    /**
     * Set the style for the feature to override the layer style.  This can be a
     * single style object, an array of styles, or a function that takes a
     * resolution and returns an array of styles. To unset the feature style, call
     * `setStyle()` without arguments or a falsey value.
     * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
     * @api
     * @fires module:ol/events/Event~BaseEvent#event:change
     */
    setStyle(t) {
      this.style_ = t, this.styleFunction_ = t ? Zp(t) : void 0, this.changed();
    }
    /**
     * Set the feature id.  The feature id is considered stable and may be used when
     * requesting features or comparing identifiers returned from a remote source.
     * The feature id can be used with the
     * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
     * @param {number|string|undefined} id The feature id.
     * @api
     * @fires module:ol/events/Event~BaseEvent#event:change
     */
    setId(t) {
      this.id_ = t, this.changed();
    }
    /**
     * Set the property name to be used when getting the feature's default geometry.
     * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
     * this name will be returned.
     * @param {string} name The property name of the default geometry.
     * @api
     */
    setGeometryName(t) {
      this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_), this.geometryName_ = t, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), this.handleGeometryChanged_();
    }
  }
  function Zp(i) {
    if (typeof i == "function")
      return i;
    let t;
    return Array.isArray(i) ? t = i : (xt(
      typeof /** @type {?} */
      i.getZIndex == "function",
      "Expected an `ol/style/Style` or an array of `ol/style/Style.js`"
    ), t = [
      /** @type {import("./style/Style.js").default} */
      i
    ]), function() {
      return t;
    };
  }
  function Va(i, t, e, n, s, r, a) {
    let o, l;
    const h = (e - t) / n;
    if (h === 1)
      o = t;
    else if (h === 2)
      o = t, l = s;
    else if (h !== 0) {
      let c = i[t], u = i[t + 1], d = 0;
      const g = [0];
      for (let E = t + n; E < e; E += n) {
        const M = i[E], w = i[E + 1];
        d += Math.sqrt((M - c) * (M - c) + (w - u) * (w - u)), g.push(d), c = M, u = w;
      }
      const _ = s * d, y = _0(g, _);
      y < 0 ? (l = (_ - g[-y - 2]) / (g[-y - 1] - g[-y - 2]), o = t + (-y - 2) * n) : o = t + y * n;
    }
    a = a > 1 ? a : 2, r = r || new Array(a);
    for (let c = 0; c < a; ++c)
      r[c] = o === void 0 ? NaN : l === void 0 ? i[o + c] : be(i[o + c], i[o + n + c], l);
    return r;
  }
  function Dl(i, t, e, n, s, r) {
    if (e == t)
      return null;
    let a;
    if (s < i[t + n - 1])
      return r ? (a = i.slice(t, t + n), a[n - 1] = s, a) : null;
    if (i[e - 1] < s)
      return r ? (a = i.slice(e - n, e), a[n - 1] = s, a) : null;
    if (s == i[t + n - 1])
      return i.slice(t, t + n);
    let o = t / n, l = e / n;
    for (; o < l; ) {
      const d = o + l >> 1;
      s < i[(d + 1) * n - 1] ? l = d : o = d + 1;
    }
    const h = i[o * n - 1];
    if (s == h)
      return i.slice((o - 1) * n, (o - 1) * n + n);
    const c = i[(o + 1) * n - 1], u = (s - h) / (c - h);
    a = [];
    for (let d = 0; d < n - 1; ++d)
      a.push(
        be(
          i[(o - 1) * n + d],
          i[o * n + d],
          u
        )
      );
    return a.push(s), a;
  }
  function qp(i, t, e, n, s, r, a) {
    if (a)
      return Dl(
        i,
        t,
        e[e.length - 1],
        n,
        s,
        r
      );
    let o;
    if (s < i[n - 1])
      return r ? (o = i.slice(0, n), o[n - 1] = s, o) : null;
    if (i[i.length - 1] < s)
      return r ? (o = i.slice(i.length - n), o[n - 1] = s, o) : null;
    for (let l = 0, h = e.length; l < h; ++l) {
      const c = e[l];
      if (t != c) {
        if (s < i[t + n - 1])
          return null;
        if (s <= i[c - 1])
          return Dl(
            i,
            t,
            c,
            n,
            s,
            !1
          );
        t = c;
      }
    }
    return null;
  }
  function ff(i, t, e, n) {
    let s = i[t], r = i[t + 1], a = 0;
    for (let o = t + n; o < e; o += n) {
      const l = i[o], h = i[o + 1];
      a += Math.sqrt((l - s) * (l - s) + (h - r) * (h - r)), s = l, r = h;
    }
    return a;
  }
  class en extends Ti {
    /**
     * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `layout` are also accepted.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    constructor(t, e) {
      super(), this.flatMidpoint_ = null, this.flatMidpointRevision_ = -1, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, e !== void 0 && !Array.isArray(t[0]) ? this.setFlatCoordinates(
        e,
        /** @type {Array<number>} */
        t
      ) : this.setCoordinates(
        /** @type {Array<import("../coordinate.js").Coordinate>} */
        t,
        e
      );
    }
    /**
     * Append the passed coordinate to the coordinates of the linestring.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @api
     */
    appendCoordinate(t) {
      pe(this.flatCoordinates, t), this.changed();
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!LineString} Clone.
     * @api
     * @override
     */
    clone() {
      const t = new en(
        this.flatCoordinates.slice(),
        this.layout
      );
      return t.applyProperties(this), t;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(t, e, n, s) {
      return s < an(this.getExtent(), t, e) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
        ph(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          0
        )
      ), this.maxDeltaRevision_ = this.getRevision()), vh(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        this.maxDelta_,
        !1,
        t,
        e,
        n,
        s
      ));
    }
    /**
     * Iterate over each segment, calling the provided callback.
     * If the callback returns a truthy value the function returns that
     * value immediately. Otherwise the function returns `false`.
     *
     * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
     *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
     * @return {T|boolean} Value.
     * @template T,S
     * @api
     */
    forEachSegment(t) {
      return kd(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        t
      );
    }
    /**
     * Returns the coordinate at `m` using linear interpolation, or `null` if no
     * such coordinate exists.
     *
     * `extrapolate` controls extrapolation beyond the range of Ms in the
     * MultiLineString. If `extrapolate` is `true` then Ms less than the first
     * M will return the first coordinate and Ms greater than the last M will
     * return the last coordinate.
     *
     * @param {number} m M.
     * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
     * @return {import("../coordinate.js").Coordinate|null} Coordinate.
     * @api
     */
    getCoordinateAtM(t, e) {
      return this.layout != "XYM" && this.layout != "XYZM" ? null : (e = e !== void 0 ? e : !1, Dl(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        t,
        e
      ));
    }
    /**
     * Return the coordinates of the linestring.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     * @override
     */
    getCoordinates() {
      return Xi(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    /**
     * Return the coordinate at the provided fraction along the linestring.
     * The `fraction` is a number between 0 and 1, where 0 is the start of the
     * linestring and 1 is the end.
     * @param {number} fraction Fraction.
     * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
     *     be modified. If not provided, a new coordinate will be returned.
     * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
     * @api
     */
    getCoordinateAt(t, e) {
      return Va(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        t,
        e,
        this.stride
      );
    }
    /**
     * Return the length of the linestring on projected plane.
     * @return {number} Length (on projected plane).
     * @api
     */
    getLength() {
      return ff(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    /**
     * @return {Array<number>} Flat midpoint.
     */
    getFlatMidpoint() {
      return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(
        0.5,
        this.flatMidpoint_ ?? void 0
      ), this.flatMidpointRevision_ = this.getRevision()), /** @type {Array<number>} */
      this.flatMidpoint_;
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {LineString} Simplified LineString.
     * @protected
     * @override
     */
    getSimplifiedGeometryInternal(t) {
      const e = [];
      return e.length = xo(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        t,
        e,
        0
      ), new en(e, "XY");
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "LineString";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(t) {
      return wo(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        t,
        this.getExtent()
      );
    }
    /**
     * Set the coordinates of the linestring.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    setCoordinates(t, e) {
      this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Mo(
        this.flatCoordinates,
        0,
        t,
        this.stride
      ), this.changed();
    }
  }
  class gf {
    /**
     * Render a geometry with a custom renderer.
     *
     * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {Function} renderer Renderer.
     * @param {Function} hitDetectionRenderer Renderer.
     * @param {number} [index] Render order index.
     */
    drawCustom(t, e, n, s, r) {
    }
    /**
     * Render a geometry.
     *
     * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
     */
    drawGeometry(t) {
    }
    /**
     * Set the rendering style.
     *
     * @param {import("../style/Style.js").default} style The rendering style.
     */
    setStyle(t) {
    }
    /**
     * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
     * @param {import("../Feature.js").default} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawCircle(t, e, n) {
    }
    /**
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("../style/Style.js").default} style Style.
     * @param {number} [index] Render order index.
     */
    drawFeature(t, e, n) {
    }
    /**
     * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
     * @param {import("../Feature.js").default} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawGeometryCollection(t, e, n) {
    }
    /**
     * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawLineString(t, e, n) {
    }
    /**
     * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawMultiLineString(t, e, n) {
    }
    /**
     * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawMultiPoint(t, e, n) {
    }
    /**
     * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawMultiPolygon(t, e, n) {
    }
    /**
     * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawPoint(t, e, n) {
    }
    /**
     * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawPolygon(t, e, n) {
    }
    /**
     * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawText(t, e, n) {
    }
    /**
     * @param {import("../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
     */
    setFillStrokeStyle(t, e) {
    }
    /**
     * @param {import("../style/Image.js").default} imageStyle Image style.
     * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
     */
    setImageStyle(t, e) {
    }
    /**
     * @param {import("../style/Text.js").default} textStyle Text style.
     * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
     */
    setTextStyle(t, e) {
    }
  }
  class Wh extends gf {
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../../extent.js").Extent} extent Extent.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
     * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
     */
    constructor(t, e, n, s, r, a, o) {
      super(), this.context_ = t, this.pixelRatio_ = e, this.extent_ = n, this.transform_ = s, this.transformRotation_ = s ? eh(Math.atan2(s[1], s[0]), 10) : 0, this.viewRotation_ = r, this.squaredTolerance_ = a, this.userTransform_ = o, this.contextFillState_ = null, this.contextStrokeState_ = null, this.contextTextState_ = null, this.fillState_ = null, this.strokeState_ = null, this.image_ = null, this.imageAnchorX_ = 0, this.imageAnchorY_ = 0, this.imageHeight_ = 0, this.imageOpacity_ = 0, this.imageOriginX_ = 0, this.imageOriginY_ = 0, this.imageRotateWithView_ = !1, this.imageRotation_ = 0, this.imageScale_ = [0, 0], this.imageWidth_ = 0, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = !1, this.textRotation_ = 0, this.textScale_ = [0, 0], this.textFillState_ = null, this.textStrokeState_ = null, this.textState_ = null, this.pixelCoordinates_ = [], this.tmpLocalTransform_ = $e();
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @private
     */
    drawImages_(t, e, n, s) {
      if (!this.image_)
        return;
      const r = ji(
        t,
        e,
        n,
        s,
        this.transform_,
        this.pixelCoordinates_
      ), a = this.context_, o = this.tmpLocalTransform_, l = a.globalAlpha;
      this.imageOpacity_ != 1 && (a.globalAlpha = l * this.imageOpacity_);
      let h = this.imageRotation_;
      this.transformRotation_ === 0 && (h -= this.viewRotation_), this.imageRotateWithView_ && (h += this.viewRotation_);
      for (let c = 0, u = r.length; c < u; c += 2) {
        const d = r[c] - this.imageAnchorX_, g = r[c + 1] - this.imageAnchorY_;
        if (h !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
          const _ = d + this.imageAnchorX_, y = g + this.imageAnchorY_;
          Ci(
            o,
            _,
            y,
            1,
            1,
            h,
            -_,
            -y
          ), a.save(), a.transform.apply(a, o), a.translate(_, y), a.scale(this.imageScale_[0], this.imageScale_[1]), a.drawImage(
            this.image_,
            this.imageOriginX_,
            this.imageOriginY_,
            this.imageWidth_,
            this.imageHeight_,
            -this.imageAnchorX_,
            -this.imageAnchorY_,
            this.imageWidth_,
            this.imageHeight_
          ), a.restore();
        } else
          a.drawImage(
            this.image_,
            this.imageOriginX_,
            this.imageOriginY_,
            this.imageWidth_,
            this.imageHeight_,
            d,
            g,
            this.imageWidth_,
            this.imageHeight_
          );
      }
      this.imageOpacity_ != 1 && (a.globalAlpha = l);
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @private
     */
    drawText_(t, e, n, s) {
      if (!this.textState_ || this.text_ === "")
        return;
      this.textFillState_ && this.setContextFillState_(this.textFillState_), this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_), this.setContextTextState_(this.textState_);
      const r = ji(
        t,
        e,
        n,
        s,
        this.transform_,
        this.pixelCoordinates_
      ), a = this.context_;
      let o = this.textRotation_;
      for (this.transformRotation_ === 0 && (o -= this.viewRotation_), this.textRotateWithView_ && (o += this.viewRotation_); e < n; e += s) {
        const l = r[e] + this.textOffsetX_, h = r[e + 1] + this.textOffsetY_;
        o !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1 ? (a.save(), a.translate(l - this.textOffsetX_, h - this.textOffsetY_), a.rotate(o), a.translate(this.textOffsetX_, this.textOffsetY_), a.scale(this.textScale_[0], this.textScale_[1]), this.textStrokeState_ && a.strokeText(this.text_, 0, 0), this.textFillState_ && a.fillText(this.text_, 0, 0), a.restore()) : (this.textStrokeState_ && a.strokeText(this.text_, l, h), this.textFillState_ && a.fillText(this.text_, l, h));
      }
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {boolean} close Close.
     * @private
     * @return {number} end End.
     */
    moveToLineTo_(t, e, n, s, r) {
      const a = this.context_, o = ji(
        t,
        e,
        n,
        s,
        this.transform_,
        this.pixelCoordinates_
      );
      a.moveTo(o[0], o[1]);
      let l = o.length;
      r && (l -= 2);
      for (let h = 2; h < l; h += 2)
        a.lineTo(o[h], o[h + 1]);
      return r && a.closePath(), n;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @private
     * @return {number} End.
     */
    drawRings_(t, e, n, s) {
      for (let r = 0, a = n.length; r < a; ++r)
        e = this.moveToLineTo_(
          t,
          e,
          n[r],
          s,
          !0
        );
      return e;
    }
    /**
     * Render a circle geometry into the canvas.  Rendering is immediate and uses
     * the current fill and stroke styles.
     *
     * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
     * @api
     * @override
     */
    drawCircle(t) {
      if (this.squaredTolerance_ && (t = /** @type {import("../../geom/Circle.js").default} */
      t.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      )), !!he(this.extent_, t.getExtent())) {
        if (this.fillState_ || this.strokeState_) {
          this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
          const e = Om(
            t,
            this.transform_,
            this.pixelCoordinates_
          ), n = e[2] - e[0], s = e[3] - e[1], r = Math.sqrt(n * n + s * s), a = this.context_;
          a.beginPath(), a.arc(
            e[0],
            e[1],
            r,
            0,
            2 * Math.PI
          ), this.fillState_ && a.fill(), this.strokeState_ && a.stroke();
        }
        this.text_ !== "" && this.drawText_(t.getCenter(), 0, 2, 2);
      }
    }
    /**
     * Set the rendering style.  Note that since this is an immediate rendering API,
     * any `zIndex` on the provided style will be ignored.
     *
     * @param {import("../../style/Style.js").default} style The rendering style.
     * @api
     * @override
     */
    setStyle(t) {
      this.setFillStrokeStyle(t.getFill(), t.getStroke()), this.setImageStyle(t.getImage()), this.setTextStyle(t.getText());
    }
    /**
     * @param {import("../../transform.js").Transform} transform Transform.
     */
    setTransform(t) {
      this.transform_ = t;
    }
    /**
     * Render a geometry into the canvas.  Call
     * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
     *
     * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
     * @api
     * @override
     */
    drawGeometry(t) {
      switch (t.getType()) {
        case "Point":
          this.drawPoint(
            /** @type {import("../../geom/Point.js").default} */
            t
          );
          break;
        case "LineString":
          this.drawLineString(
            /** @type {import("../../geom/LineString.js").default} */
            t
          );
          break;
        case "Polygon":
          this.drawPolygon(
            /** @type {import("../../geom/Polygon.js").default} */
            t
          );
          break;
        case "MultiPoint":
          this.drawMultiPoint(
            /** @type {import("../../geom/MultiPoint.js").default} */
            t
          );
          break;
        case "MultiLineString":
          this.drawMultiLineString(
            /** @type {import("../../geom/MultiLineString.js").default} */
            t
          );
          break;
        case "MultiPolygon":
          this.drawMultiPolygon(
            /** @type {import("../../geom/MultiPolygon.js").default} */
            t
          );
          break;
        case "GeometryCollection":
          this.drawGeometryCollection(
            /** @type {import("../../geom/GeometryCollection.js").default} */
            t
          );
          break;
        case "Circle":
          this.drawCircle(
            /** @type {import("../../geom/Circle.js").default} */
            t
          );
          break;
      }
    }
    /**
     * Render a feature into the canvas.  Note that any `zIndex` on the provided
     * style will be ignored - features are rendered immediately in the order that
     * this method is called.  If you need `zIndex` support, you should be using an
     * {@link module:ol/layer/Vector~VectorLayer} instead.
     *
     * @param {import("../../Feature.js").default} feature Feature.
     * @param {import("../../style/Style.js").default} style Style.
     * @api
     * @override
     */
    drawFeature(t, e) {
      const n = e.getGeometryFunction()(t);
      n && (this.setStyle(e), this.drawGeometry(n));
    }
    /**
     * Render a GeometryCollection to the canvas.  Rendering is immediate and
     * uses the current styles appropriate for each geometry in the collection.
     *
     * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
     * @override
     */
    drawGeometryCollection(t) {
      const e = t.getGeometriesArray();
      for (let n = 0, s = e.length; n < s; ++n)
        this.drawGeometry(e[n]);
    }
    /**
     * Render a Point geometry into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
     * @override
     */
    drawPoint(t) {
      this.squaredTolerance_ && (t = /** @type {import("../../geom/Point.js").default} */
      t.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      ));
      const e = t.getFlatCoordinates(), n = t.getStride();
      this.image_ && this.drawImages_(e, 0, e.length, n), this.text_ !== "" && this.drawText_(e, 0, e.length, n);
    }
    /**
     * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
     * uses the current style.
     *
     * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
     * @override
     */
    drawMultiPoint(t) {
      this.squaredTolerance_ && (t = /** @type {import("../../geom/MultiPoint.js").default} */
      t.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      ));
      const e = t.getFlatCoordinates(), n = t.getStride();
      this.image_ && this.drawImages_(e, 0, e.length, n), this.text_ !== "" && this.drawText_(e, 0, e.length, n);
    }
    /**
     * Render a LineString into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
     * @override
     */
    drawLineString(t) {
      if (this.squaredTolerance_ && (t = /** @type {import("../../geom/LineString.js").default} */
      t.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      )), !!he(this.extent_, t.getExtent())) {
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
          const e = this.context_, n = t.getFlatCoordinates();
          e.beginPath(), this.moveToLineTo_(
            n,
            0,
            n.length,
            t.getStride(),
            !1
          ), e.stroke();
        }
        if (this.text_ !== "") {
          const e = t.getFlatMidpoint();
          this.drawText_(e, 0, 2, 2);
        }
      }
    }
    /**
     * Render a MultiLineString geometry into the canvas.  Rendering is immediate
     * and uses the current style.
     *
     * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
     * @override
     */
    drawMultiLineString(t) {
      this.squaredTolerance_ && (t = /** @type {import("../../geom/MultiLineString.js").default} */
      t.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      ));
      const e = t.getExtent();
      if (he(this.extent_, e)) {
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
          const n = this.context_, s = t.getFlatCoordinates();
          let r = 0;
          const a = (
            /** @type {Array<number>} */
            t.getEnds()
          ), o = t.getStride();
          n.beginPath();
          for (let l = 0, h = a.length; l < h; ++l)
            r = this.moveToLineTo_(
              s,
              r,
              a[l],
              o,
              !1
            );
          n.stroke();
        }
        if (this.text_ !== "") {
          const n = t.getFlatMidpoints();
          this.drawText_(n, 0, n.length, 2);
        }
      }
    }
    /**
     * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
     * @override
     */
    drawPolygon(t) {
      if (this.squaredTolerance_ && (t = /** @type {import("../../geom/Polygon.js").default} */
      t.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      )), !!he(this.extent_, t.getExtent())) {
        if (this.strokeState_ || this.fillState_) {
          this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
          const e = this.context_;
          e.beginPath(), this.drawRings_(
            t.getOrientedFlatCoordinates(),
            0,
            /** @type {Array<number>} */
            t.getEnds(),
            t.getStride()
          ), this.fillState_ && e.fill(), this.strokeState_ && e.stroke();
        }
        if (this.text_ !== "") {
          const e = t.getFlatInteriorPoint();
          this.drawText_(e, 0, 2, 2);
        }
      }
    }
    /**
     * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
     * uses the current style.
     * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
     * @override
     */
    drawMultiPolygon(t) {
      if (this.squaredTolerance_ && (t = /** @type {import("../../geom/MultiPolygon.js").default} */
      t.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      )), !!he(this.extent_, t.getExtent())) {
        if (this.strokeState_ || this.fillState_) {
          this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
          const e = this.context_, n = t.getOrientedFlatCoordinates();
          let s = 0;
          const r = t.getEndss(), a = t.getStride();
          e.beginPath();
          for (let o = 0, l = r.length; o < l; ++o) {
            const h = r[o];
            s = this.drawRings_(n, s, h, a);
          }
          this.fillState_ && e.fill(), this.strokeState_ && e.stroke();
        }
        if (this.text_ !== "") {
          const e = t.getFlatInteriorPoints();
          this.drawText_(e, 0, e.length, 2);
        }
      }
    }
    /**
     * @param {import("../canvas.js").FillState} fillState Fill state.
     * @private
     */
    setContextFillState_(t) {
      const e = this.context_, n = this.contextFillState_;
      n ? n.fillStyle != t.fillStyle && (n.fillStyle = t.fillStyle, e.fillStyle = t.fillStyle) : (e.fillStyle = t.fillStyle, this.contextFillState_ = {
        fillStyle: t.fillStyle
      });
    }
    /**
     * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
     * @private
     */
    setContextStrokeState_(t) {
      const e = this.context_, n = this.contextStrokeState_;
      n ? (n.lineCap != t.lineCap && (n.lineCap = t.lineCap, e.lineCap = t.lineCap), rn(n.lineDash, t.lineDash) || e.setLineDash(
        n.lineDash = t.lineDash
      ), n.lineDashOffset != t.lineDashOffset && (n.lineDashOffset = t.lineDashOffset, e.lineDashOffset = t.lineDashOffset), n.lineJoin != t.lineJoin && (n.lineJoin = t.lineJoin, e.lineJoin = t.lineJoin), n.lineWidth != t.lineWidth && (n.lineWidth = t.lineWidth, e.lineWidth = t.lineWidth), n.miterLimit != t.miterLimit && (n.miterLimit = t.miterLimit, e.miterLimit = t.miterLimit), n.strokeStyle != t.strokeStyle && (n.strokeStyle = t.strokeStyle, e.strokeStyle = t.strokeStyle)) : (e.lineCap = t.lineCap, e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset, e.lineJoin = t.lineJoin, e.lineWidth = t.lineWidth, e.miterLimit = t.miterLimit, e.strokeStyle = t.strokeStyle, this.contextStrokeState_ = {
        lineCap: t.lineCap,
        lineDash: t.lineDash,
        lineDashOffset: t.lineDashOffset,
        lineJoin: t.lineJoin,
        lineWidth: t.lineWidth,
        miterLimit: t.miterLimit,
        strokeStyle: t.strokeStyle
      });
    }
    /**
     * @param {import("../canvas.js").TextState} textState Text state.
     * @private
     */
    setContextTextState_(t) {
      const e = this.context_, n = this.contextTextState_, s = t.textAlign ? t.textAlign : Tr;
      n ? (n.font != t.font && (n.font = t.font, e.font = t.font), n.textAlign != s && (n.textAlign = s, e.textAlign = s), n.textBaseline != t.textBaseline && (n.textBaseline = t.textBaseline, e.textBaseline = t.textBaseline)) : (e.font = t.font, e.textAlign = s, e.textBaseline = t.textBaseline, this.contextTextState_ = {
        font: t.font,
        textAlign: s,
        textBaseline: t.textBaseline
      });
    }
    /**
     * Set the fill and stroke style for subsequent draw operations.  To clear
     * either fill or stroke styles, pass null for the appropriate parameter.
     *
     * @param {import("../../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
     * @override
     */
    setFillStrokeStyle(t, e) {
      if (!t)
        this.fillState_ = null;
      else {
        const n = t.getColor();
        this.fillState_ = {
          fillStyle: si(
            n || xe
          )
        };
      }
      if (!e)
        this.strokeState_ = null;
      else {
        const n = e.getColor(), s = e.getLineCap(), r = e.getLineDash(), a = e.getLineDashOffset(), o = e.getLineJoin(), l = e.getWidth(), h = e.getMiterLimit(), c = r || xi;
        this.strokeState_ = {
          lineCap: s !== void 0 ? s : Os,
          lineDash: this.pixelRatio_ === 1 ? c : c.map((u) => u * this.pixelRatio_),
          lineDashOffset: (a || wi) * this.pixelRatio_,
          lineJoin: o !== void 0 ? o : Ns,
          lineWidth: (l !== void 0 ? l : Ar) * this.pixelRatio_,
          miterLimit: h !== void 0 ? h : Rr,
          strokeStyle: si(
            n || Ir
          )
        };
      }
    }
    /**
     * Set the image style for subsequent draw operations.  Pass null to remove
     * the image style.
     *
     * @param {import("../../style/Image.js").default} imageStyle Image style.
     * @override
     */
    setImageStyle(t) {
      let e;
      if (!t || !(e = t.getSize())) {
        this.image_ = null;
        return;
      }
      const n = t.getPixelRatio(this.pixelRatio_), s = t.getAnchor(), r = t.getOrigin();
      this.image_ = t.getImage(this.pixelRatio_), this.imageAnchorX_ = s[0] * n, this.imageAnchorY_ = s[1] * n, this.imageHeight_ = e[1] * n, this.imageOpacity_ = t.getOpacity(), this.imageOriginX_ = r[0], this.imageOriginY_ = r[1], this.imageRotateWithView_ = t.getRotateWithView(), this.imageRotation_ = t.getRotation();
      const a = t.getScaleArray();
      this.imageScale_ = [
        a[0] * this.pixelRatio_ / n,
        a[1] * this.pixelRatio_ / n
      ], this.imageWidth_ = e[0] * n;
    }
    /**
     * Set the text style for subsequent draw operations.  Pass null to
     * remove the text style.
     *
     * @param {import("../../style/Text.js").default} textStyle Text style.
     * @override
     */
    setTextStyle(t) {
      if (!t)
        this.text_ = "";
      else {
        const e = t.getFill();
        if (!e)
          this.textFillState_ = null;
        else {
          const g = e.getColor();
          this.textFillState_ = {
            fillStyle: si(
              g || xe
            )
          };
        }
        const n = t.getStroke();
        if (!n)
          this.textStrokeState_ = null;
        else {
          const g = n.getColor(), _ = n.getLineCap(), y = n.getLineDash(), E = n.getLineDashOffset(), M = n.getLineJoin(), w = n.getWidth(), R = n.getMiterLimit();
          this.textStrokeState_ = {
            lineCap: _ !== void 0 ? _ : Os,
            lineDash: y || xi,
            lineDashOffset: E || wi,
            lineJoin: M !== void 0 ? M : Ns,
            lineWidth: w !== void 0 ? w : Ar,
            miterLimit: R !== void 0 ? R : Rr,
            strokeStyle: si(
              g || Ir
            )
          };
        }
        const s = t.getFont(), r = t.getOffsetX(), a = t.getOffsetY(), o = t.getRotateWithView(), l = t.getRotation(), h = t.getScaleArray(), c = t.getText(), u = t.getTextAlign(), d = t.getTextBaseline();
        this.textState_ = {
          font: s !== void 0 ? s : ef,
          textAlign: u !== void 0 ? u : Tr,
          textBaseline: d !== void 0 ? d : Ya
        }, this.text_ = c !== void 0 ? Array.isArray(c) ? c.reduce((g, _, y) => g += y % 2 ? " " : _, "") : c : "", this.textOffsetX_ = r !== void 0 ? this.pixelRatio_ * r : 0, this.textOffsetY_ = a !== void 0 ? this.pixelRatio_ * a : 0, this.textRotateWithView_ = o !== void 0 ? o : !1, this.textRotation_ = l !== void 0 ? l : 0, this.textScale_ = [
          this.pixelRatio_ * h[0],
          this.pixelRatio_ * h[1]
        ];
      }
    }
  }
  const Kp = 0.5, mf = {
    Point: iy,
    LineString: Qp,
    Polygon: sy,
    MultiPoint: ny,
    MultiLineString: ty,
    MultiPolygon: ey,
    GeometryCollection: Jp,
    Circle: jp
  };
  function Vp(i, t) {
    return parseInt(Ct(i), 10) - parseInt(Ct(t), 10);
  }
  function kl(i, t) {
    const e = _f(i, t);
    return e * e;
  }
  function _f(i, t) {
    return Kp * i / t;
  }
  function jp(i, t, e, n, s) {
    const r = e.getFill(), a = e.getStroke();
    if (r || a) {
      const l = i.getBuilder(e.getZIndex(), "Circle");
      l.setFillStrokeStyle(r, a), l.drawCircle(t, n, s);
    }
    const o = e.getText();
    if (o && o.getText()) {
      const l = i.getBuilder(e.getZIndex(), "Text");
      l.setTextStyle(o), l.drawText(t, n);
    }
  }
  function _u(i, t, e, n, s, r, a, o) {
    const l = [], h = e.getImage();
    if (h) {
      let d = !0;
      const g = h.getImageState();
      g == ut.LOADED || g == ut.ERROR ? d = !1 : g == ut.IDLE && h.load(), d && l.push(h.ready());
    }
    const c = e.getFill();
    c && c.loading() && l.push(c.ready());
    const u = l.length > 0;
    return u && Promise.all(l).then(() => s(null)), Hp(
      i,
      t,
      e,
      n,
      r,
      a,
      o
    ), u;
  }
  function Hp(i, t, e, n, s, r, a) {
    const o = e.getGeometryFunction()(t);
    if (!o)
      return;
    const l = o.simplifyTransformed(
      n,
      s
    );
    if (e.getRenderer())
      pf(i, l, e, t, a);
    else {
      const c = mf[l.getType()];
      c(
        i,
        l,
        e,
        t,
        a,
        r
      );
    }
  }
  function pf(i, t, e, n, s) {
    if (t.getType() == "GeometryCollection") {
      const a = (
        /** @type {import("../geom/GeometryCollection.js").default} */
        t.getGeometries()
      );
      for (let o = 0, l = a.length; o < l; ++o)
        pf(i, a[o], e, n, s);
      return;
    }
    i.getBuilder(e.getZIndex(), "Default").drawCustom(
      /** @type {import("../geom/SimpleGeometry.js").default} */
      t,
      n,
      e.getRenderer(),
      e.getHitDetectionRenderer(),
      s
    );
  }
  function Jp(i, t, e, n, s, r) {
    const a = t.getGeometriesArray();
    let o, l;
    for (o = 0, l = a.length; o < l; ++o) {
      const h = mf[a[o].getType()];
      h(
        i,
        a[o],
        e,
        n,
        s,
        r
      );
    }
  }
  function Qp(i, t, e, n, s) {
    const r = e.getStroke();
    if (r) {
      const o = i.getBuilder(
        e.getZIndex(),
        "LineString"
      );
      o.setFillStrokeStyle(null, r), o.drawLineString(t, n, s);
    }
    const a = e.getText();
    if (a && a.getText()) {
      const o = i.getBuilder(e.getZIndex(), "Text");
      o.setTextStyle(a), o.drawText(t, n, s);
    }
  }
  function ty(i, t, e, n, s) {
    const r = e.getStroke();
    if (r) {
      const o = i.getBuilder(
        e.getZIndex(),
        "LineString"
      );
      o.setFillStrokeStyle(null, r), o.drawMultiLineString(t, n, s);
    }
    const a = e.getText();
    if (a && a.getText()) {
      const o = i.getBuilder(e.getZIndex(), "Text");
      o.setTextStyle(a), o.drawText(t, n, s);
    }
  }
  function ey(i, t, e, n, s) {
    const r = e.getFill(), a = e.getStroke();
    if (a || r) {
      const l = i.getBuilder(e.getZIndex(), "Polygon");
      l.setFillStrokeStyle(r, a), l.drawMultiPolygon(t, n, s);
    }
    const o = e.getText();
    if (o && o.getText()) {
      const l = i.getBuilder(e.getZIndex(), "Text");
      l.setTextStyle(o), l.drawText(t, n, s);
    }
  }
  function iy(i, t, e, n, s, r) {
    const a = e.getImage(), o = e.getText(), l = o && o.getText(), h = r && a && l ? {} : void 0;
    if (a) {
      if (a.getImageState() != ut.LOADED)
        return;
      const c = i.getBuilder(e.getZIndex(), "Image");
      c.setImageStyle(a, h), c.drawPoint(t, n, s);
    }
    if (l) {
      const c = i.getBuilder(e.getZIndex(), "Text");
      c.setTextStyle(o, h), c.drawText(t, n, s);
    }
  }
  function ny(i, t, e, n, s, r) {
    const a = e.getImage(), o = a && a.getOpacity() !== 0, l = e.getText(), h = l && l.getText(), c = r && o && h ? {} : void 0;
    if (o) {
      if (a.getImageState() != ut.LOADED)
        return;
      const u = i.getBuilder(e.getZIndex(), "Image");
      u.setImageStyle(a, c), u.drawMultiPoint(t, n, s);
    }
    if (h) {
      const u = i.getBuilder(e.getZIndex(), "Text");
      u.setTextStyle(l, c), u.drawText(t, n, s);
    }
  }
  function sy(i, t, e, n, s) {
    const r = e.getFill(), a = e.getStroke();
    if (r || a) {
      const l = i.getBuilder(e.getZIndex(), "Polygon");
      l.setFillStrokeStyle(r, a), l.drawPolygon(t, n, s);
    }
    const o = e.getText();
    if (o && o.getText()) {
      const l = i.getBuilder(e.getZIndex(), "Text");
      l.setTextStyle(o), l.drawText(t, n, s);
    }
  }
  function ry(i, t) {
    const e = i.canvas;
    t = t || {};
    const n = t.pixelRatio || co, s = t.size;
    s && (e.width = s[0] * n, e.height = s[1] * n, e.style.width = s[0] + "px", e.style.height = s[1] + "px");
    const r = [0, 0, e.width, e.height], a = Rm($e(), n, n);
    return new Wh(i, n, r, a, 0);
  }
  function ay(i) {
    if (!(i.context instanceof CanvasRenderingContext2D))
      throw new Error("Only works for render events from Canvas 2D layers");
    const t = i.inversePixelTransform[0], e = i.inversePixelTransform[1], n = Math.sqrt(t * t + e * e), s = i.frameState, r = Ad(
      i.inversePixelTransform.slice(),
      s.coordinateToPixelTransform
    ), a = kl(
      s.viewState.resolution,
      n
    );
    let o;
    return new Wh(
      i.context,
      n,
      s.extent,
      r,
      s.viewState.rotation,
      a,
      o
    );
  }
  function oy(i, t) {
    return Xt(i.inversePixelTransform, t.slice(0));
  }
  const ly = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    getRenderPixel: oy,
    getVectorContext: ay,
    toContext: ry
  }, Symbol.toStringTag, { value: "Module" }));
  let hy = !1;
  function cy(i, t, e, n, s, r, a) {
    const o = new XMLHttpRequest();
    o.open(
      "GET",
      typeof i == "function" ? i(e, n, s) : i,
      !0
    ), t.getType() == "arraybuffer" && (o.responseType = "arraybuffer"), o.withCredentials = hy, o.onload = function(l) {
      if (!o.status || o.status >= 200 && o.status < 300) {
        const h = t.getType();
        try {
          let c;
          h == "text" || h == "json" ? c = o.responseText : h == "xml" ? c = o.responseXML || o.responseText : h == "arraybuffer" && (c = /** @type {ArrayBuffer} */
          o.response), c ? r(
            /** @type {Array<FeatureType>} */
            t.readFeatures(c, {
              extent: e,
              featureProjection: s
            }),
            t.readProjection(c)
          ) : a();
        } catch {
          a();
        }
      } else
        a();
    }, o.onerror = a, o.send();
  }
  function pu(i, t) {
    return function(e, n, s, r, a) {
      cy(
        i,
        t,
        e,
        n,
        s,
        /**
         * @param {Array<FeatureType>} features The loaded features.
         * @param {import("./proj/Projection.js").default} dataProjection Data
         * projection.
         */
        (o, l) => {
          this.addFeatures(o), r !== void 0 && r(o);
        },
        /* FIXME handle error */
        a || Is
      );
    };
  }
  function uy(i, t) {
    return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]];
  }
  function yf(i, t, e, n) {
    const s = [];
    let r = Pe();
    for (let a = 0, o = e.length; a < o; ++a) {
      const l = e[a];
      r = go(
        i,
        t,
        l[0],
        n
      ), s.push((r[0] + r[2]) / 2, (r[1] + r[3]) / 2), t = l[l.length - 1];
    }
    return s;
  }
  class Po extends Ti {
    /**
     * @param {!import("../coordinate.js").Coordinate} center Center.
     *     For internal use, flat coordinates in combination with `layout` and no
     *     `radius` are also accepted.
     * @param {number} [radius] Radius in units of the projection.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    constructor(t, e, n) {
      super(), n !== void 0 && e === void 0 ? this.setFlatCoordinates(n, t) : (e = e || 0, this.setCenterAndRadius(t, e, n));
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!Circle} Clone.
     * @api
     * @override
     */
    clone() {
      const t = new Po(
        this.flatCoordinates.slice(),
        void 0,
        this.layout
      );
      return t.applyProperties(this), t;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(t, e, n, s) {
      const r = this.flatCoordinates, a = t - r[0], o = e - r[1], l = a * a + o * o;
      if (l < s) {
        if (l === 0)
          for (let h = 0; h < this.stride; ++h)
            n[h] = r[h];
        else {
          const h = this.getRadius() / Math.sqrt(l);
          n[0] = r[0] + h * a, n[1] = r[1] + h * o;
          for (let c = 2; c < this.stride; ++c)
            n[c] = r[c];
        }
        return n.length = this.stride, l;
      }
      return s;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     * @override
     */
    containsXY(t, e) {
      const n = this.flatCoordinates, s = t - n[0], r = e - n[1];
      return s * s + r * r <= this.getRadiusSquared_();
    }
    /**
     * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
     * @return {import("../coordinate.js").Coordinate} Center.
     * @api
     */
    getCenter() {
      return this.flatCoordinates.slice(0, this.stride);
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     * @override
     */
    computeExtent(t) {
      const e = this.flatCoordinates, n = e[this.stride] - e[0];
      return Le(
        e[0] - n,
        e[1] - n,
        e[0] + n,
        e[1] + n,
        t
      );
    }
    /**
     * Return the radius of the circle.
     * @return {number} Radius.
     * @api
     */
    getRadius() {
      return Math.sqrt(this.getRadiusSquared_());
    }
    /**
     * @private
     * @return {number} Radius squared.
     */
    getRadiusSquared_() {
      const t = this.flatCoordinates[this.stride] - this.flatCoordinates[0], e = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
      return t * t + e * e;
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "Circle";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(t) {
      const e = this.getExtent();
      if (he(t, e)) {
        const n = this.getCenter();
        return t[0] <= n[0] && t[2] >= n[0] || t[1] <= n[1] && t[3] >= n[1] ? !0 : _o(t, this.intersectsCoordinate.bind(this));
      }
      return !1;
    }
    /**
     * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
     * @param {import("../coordinate.js").Coordinate} center Center.
     * @api
     */
    setCenter(t) {
      const e = this.stride, n = this.flatCoordinates[e] - this.flatCoordinates[0], s = t.slice();
      s[e] = s[0] + n;
      for (let r = 1; r < e; ++r)
        s[e + r] = t[r];
      this.setFlatCoordinates(this.layout, s), this.changed();
    }
    /**
     * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
     * number) of the circle.
     * @param {!import("../coordinate.js").Coordinate} center Center.
     * @param {number} radius Radius.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     */
    setCenterAndRadius(t, e, n) {
      this.setLayout(n, t, 0), this.flatCoordinates || (this.flatCoordinates = []);
      const s = this.flatCoordinates;
      let r = Od(s, 0, t, this.stride);
      s[r++] = s[0] + e;
      for (let a = 1, o = this.stride; a < o; ++a)
        s[r++] = s[a];
      s.length = r, this.changed();
    }
    /**
     * @override
     */
    getCoordinates() {
      return null;
    }
    /**
     * @override
     */
    setCoordinates(t, e) {
    }
    /**
     * Set the radius of the circle. The radius is in the units of the projection.
     * @param {number} radius Radius.
     * @api
     */
    setRadius(t) {
      this.flatCoordinates[this.stride] = this.flatCoordinates[0] + t, this.changed();
    }
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @param {number} angle Rotation angle in counter-clockwise radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     * @override
     */
    rotate(t, e) {
      const n = this.getCenter(), s = this.getStride();
      this.setCenter(
        _h(n, 0, n.length, s, t, e, n)
      ), this.changed();
    }
  }
  Po.prototype.transform;
  class ja extends Eo {
    /**
     * @param {Array<Geometry>} geometries Geometries.
     */
    constructor(t) {
      super(), this.geometries_ = t, this.changeEventsKeys_ = [], this.listenGeometriesChange_();
    }
    /**
     * @private
     */
    unlistenGeometriesChange_() {
      this.changeEventsKeys_.forEach(Pt), this.changeEventsKeys_.length = 0;
    }
    /**
     * @private
     */
    listenGeometriesChange_() {
      const t = this.geometries_;
      for (let e = 0, n = t.length; e < n; ++e)
        this.changeEventsKeys_.push(
          vt(t[e], at.CHANGE, this.changed, this)
        );
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!GeometryCollection} Clone.
     * @api
     * @override
     */
    clone() {
      const t = new ja(
        rl(this.geometries_)
      );
      return t.applyProperties(this), t;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(t, e, n, s) {
      if (s < an(this.getExtent(), t, e))
        return s;
      const r = this.geometries_;
      for (let a = 0, o = r.length; a < o; ++a)
        s = r[a].closestPointXY(
          t,
          e,
          n,
          s
        );
      return s;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     * @override
     */
    containsXY(t, e) {
      const n = this.geometries_;
      for (let s = 0, r = n.length; s < r; ++s)
        if (n[s].containsXY(t, e))
          return !0;
      return !1;
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     * @override
     */
    computeExtent(t) {
      Ii(t);
      const e = this.geometries_;
      for (let n = 0, s = e.length; n < s; ++n)
        mo(t, e[n].getExtent());
      return t;
    }
    /**
     * Return the geometries that make up this geometry collection.
     * @return {Array<Geometry>} Geometries.
     * @api
     */
    getGeometries() {
      return rl(this.geometries_);
    }
    /**
     * @return {Array<Geometry>} Geometries.
     */
    getGeometriesArray() {
      return this.geometries_;
    }
    /**
     * @return {Array<Geometry>} Geometries.
     */
    getGeometriesArrayRecursive() {
      let t = [];
      const e = this.geometries_;
      for (let n = 0, s = e.length; n < s; ++n)
        e[n].getType() === this.getType() ? t = t.concat(
          /** @type {GeometryCollection} */
          e[n].getGeometriesArrayRecursive()
        ) : t.push(e[n]);
      return t;
    }
    /**
     * Create a simplified version of this geometry using the Douglas Peucker algorithm.
     * @param {number} squaredTolerance Squared tolerance.
     * @return {GeometryCollection} Simplified GeometryCollection.
     * @override
     */
    getSimplifiedGeometry(t) {
      if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && t < this.simplifiedGeometryMaxMinSquaredTolerance)
        return this;
      const e = [], n = this.geometries_;
      let s = !1;
      for (let r = 0, a = n.length; r < a; ++r) {
        const o = n[r], l = o.getSimplifiedGeometry(t);
        e.push(l), l !== o && (s = !0);
      }
      return s ? new ja(
        e
      ) : (this.simplifiedGeometryMaxMinSquaredTolerance = t, this);
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "GeometryCollection";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(t) {
      const e = this.geometries_;
      for (let n = 0, s = e.length; n < s; ++n)
        if (e[n].intersectsExtent(t))
          return !0;
      return !1;
    }
    /**
     * @return {boolean} Is empty.
     */
    isEmpty() {
      return this.geometries_.length === 0;
    }
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @param {number} angle Rotation angle in radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     * @override
     */
    rotate(t, e) {
      const n = this.geometries_;
      for (let s = 0, r = n.length; s < r; ++s)
        n[s].rotate(t, e);
      this.changed();
    }
    /**
     * Scale the geometry (with an optional origin).  This modifies the geometry
     * coordinates in place.
     * @abstract
     * @param {number} sx The scaling factor in the x-direction.
     * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
     * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
     *     of the geometry extent).
     * @api
     * @override
     */
    scale(t, e, n) {
      n || (n = Si(this.getExtent()));
      const s = this.geometries_;
      for (let r = 0, a = s.length; r < a; ++r)
        s[r].scale(t, e, n);
      this.changed();
    }
    /**
     * Set the geometries that make up this geometry collection.
     * @param {Array<Geometry>} geometries Geometries.
     * @api
     */
    setGeometries(t) {
      this.setGeometriesArray(rl(t));
    }
    /**
     * @param {Array<Geometry>} geometries Geometries.
     */
    setGeometriesArray(t) {
      this.unlistenGeometriesChange_(), this.geometries_ = t, this.listenGeometriesChange_(), this.changed();
    }
    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     * Called with a flat array of geometry coordinates.
     * @api
     * @override
     */
    applyTransform(t) {
      const e = this.geometries_;
      for (let n = 0, s = e.length; n < s; ++n)
        e[n].applyTransform(t);
      this.changed();
    }
    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     * @override
     */
    translate(t, e) {
      const n = this.geometries_;
      for (let s = 0, r = n.length; s < r; ++s)
        n[s].translate(t, e);
      this.changed();
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.unlistenGeometriesChange_(), super.disposeInternal();
    }
  }
  function rl(i) {
    return i.map((t) => t.clone());
  }
  class Fs extends Ti {
    /**
     * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
     *     Coordinates or LineString geometries. (For internal use, flat coordinates in
     *     combination with `layout` and `ends` are also accepted.)
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @param {Array<number>} [ends] Flat coordinate ends for internal use.
     */
    constructor(t, e, n) {
      if (super(), this.ends_ = [], this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, Array.isArray(t[0]))
        this.setCoordinates(
          /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
          t,
          e
        );
      else if (e !== void 0 && n)
        this.setFlatCoordinates(
          e,
          /** @type {Array<number>} */
          t
        ), this.ends_ = n;
      else {
        const s = (
          /** @type {Array<LineString>} */
          t
        ), r = [], a = [];
        for (let l = 0, h = s.length; l < h; ++l) {
          const c = s[l];
          pe(r, c.getFlatCoordinates()), a.push(r.length);
        }
        const o = s.length === 0 ? this.getLayout() : s[0].getLayout();
        this.setFlatCoordinates(o, r), this.ends_ = a;
      }
    }
    /**
     * Append the passed linestring to the multilinestring.
     * @param {LineString} lineString LineString.
     * @api
     */
    appendLineString(t) {
      pe(this.flatCoordinates, t.getFlatCoordinates().slice()), this.ends_.push(this.flatCoordinates.length), this.changed();
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!MultiLineString} Clone.
     * @api
     * @override
     */
    clone() {
      const t = new Fs(
        this.flatCoordinates.slice(),
        this.layout,
        this.ends_.slice()
      );
      return t.applyProperties(this), t;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(t, e, n, s) {
      return s < an(this.getExtent(), t, e) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
        yh(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          0
        )
      ), this.maxDeltaRevision_ = this.getRevision()), Eh(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        this.maxDelta_,
        !1,
        t,
        e,
        n,
        s
      ));
    }
    /**
     * Returns the coordinate at `m` using linear interpolation, or `null` if no
     * such coordinate exists.
     *
     * `extrapolate` controls extrapolation beyond the range of Ms in the
     * MultiLineString. If `extrapolate` is `true` then Ms less than the first
     * M will return the first coordinate and Ms greater than the last M will
     * return the last coordinate.
     *
     * `interpolate` controls interpolation between consecutive LineStrings
     * within the MultiLineString. If `interpolate` is `true` the coordinates
     * will be linearly interpolated between the last coordinate of one LineString
     * and the first coordinate of the next LineString.  If `interpolate` is
     * `false` then the function will return `null` for Ms falling between
     * LineStrings.
     *
     * @param {number} m M.
     * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
     * @param {boolean} [interpolate] Interpolate. Default is `false`.
     * @return {import("../coordinate.js").Coordinate|null} Coordinate.
     * @api
     */
    getCoordinateAtM(t, e, n) {
      return this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0 ? null : (e = e !== void 0 ? e : !1, n = n !== void 0 ? n : !1, qp(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        t,
        e,
        n
      ));
    }
    /**
     * Return the coordinates of the multilinestring.
     * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
     * @api
     * @override
     */
    getCoordinates() {
      return wr(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride
      );
    }
    /**
     * @return {Array<number>} Ends.
     */
    getEnds() {
      return this.ends_;
    }
    /**
     * Return the linestring at the specified index.
     * @param {number} index Index.
     * @return {LineString} LineString.
     * @api
     */
    getLineString(t) {
      return t < 0 || this.ends_.length <= t ? null : new en(
        this.flatCoordinates.slice(
          t === 0 ? 0 : this.ends_[t - 1],
          this.ends_[t]
        ),
        this.layout
      );
    }
    /**
     * Return the linestrings of this multilinestring.
     * @return {Array<LineString>} LineStrings.
     * @api
     */
    getLineStrings() {
      const t = this.flatCoordinates, e = this.ends_, n = this.layout, s = [];
      let r = 0;
      for (let a = 0, o = e.length; a < o; ++a) {
        const l = e[a], h = new en(
          t.slice(r, l),
          n
        );
        s.push(h), r = l;
      }
      return s;
    }
    /**
     * @return {Array<number>} Flat midpoints.
     */
    getFlatMidpoints() {
      const t = [], e = this.flatCoordinates;
      let n = 0;
      const s = this.ends_, r = this.stride;
      for (let a = 0, o = s.length; a < o; ++a) {
        const l = s[a], h = Va(
          e,
          n,
          l,
          r,
          0.5
        );
        pe(t, h), n = l;
      }
      return t;
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {MultiLineString} Simplified MultiLineString.
     * @protected
     * @override
     */
    getSimplifiedGeometryInternal(t) {
      const e = [], n = [];
      return e.length = Nd(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        t,
        e,
        0,
        n
      ), new Fs(e, "XY", n);
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "MultiLineString";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(t) {
      return Bm(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        t
      );
    }
    /**
     * Set the coordinates of the multilinestring.
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    setCoordinates(t, e) {
      this.setLayout(e, t, 2), this.flatCoordinates || (this.flatCoordinates = []);
      const n = Mh(
        this.flatCoordinates,
        0,
        t,
        this.stride,
        this.ends_
      );
      this.flatCoordinates.length = n.length === 0 ? 0 : n[n.length - 1], this.changed();
    }
  }
  class Kr extends Ti {
    /**
     * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `layout` are also accepted.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    constructor(t, e) {
      super(), e && !Array.isArray(t[0]) ? this.setFlatCoordinates(
        e,
        /** @type {Array<number>} */
        t
      ) : this.setCoordinates(
        /** @type {Array<import("../coordinate.js").Coordinate>} */
        t,
        e
      );
    }
    /**
     * Append the passed point to this multipoint.
     * @param {Point} point Point.
     * @api
     */
    appendPoint(t) {
      pe(this.flatCoordinates, t.getFlatCoordinates()), this.changed();
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!MultiPoint} Clone.
     * @api
     * @override
     */
    clone() {
      const t = new Kr(
        this.flatCoordinates.slice(),
        this.layout
      );
      return t.applyProperties(this), t;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(t, e, n, s) {
      if (s < an(this.getExtent(), t, e))
        return s;
      const r = this.flatCoordinates, a = this.stride;
      for (let o = 0, l = r.length; o < l; o += a) {
        const h = Ln(
          t,
          e,
          r[o],
          r[o + 1]
        );
        if (h < s) {
          s = h;
          for (let c = 0; c < a; ++c)
            n[c] = r[o + c];
          n.length = a;
        }
      }
      return s;
    }
    /**
     * Return the coordinates of the multipoint.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     * @override
     */
    getCoordinates() {
      return Xi(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    /**
     * Return the point at the specified index.
     * @param {number} index Index.
     * @return {Point} Point.
     * @api
     */
    getPoint(t) {
      const e = this.flatCoordinates.length / this.stride;
      return t < 0 || e <= t ? null : new Sr(
        this.flatCoordinates.slice(
          t * this.stride,
          (t + 1) * this.stride
        ),
        this.layout
      );
    }
    /**
     * Return the points of this multipoint.
     * @return {Array<Point>} Points.
     * @api
     */
    getPoints() {
      const t = this.flatCoordinates, e = this.layout, n = this.stride, s = [];
      for (let r = 0, a = t.length; r < a; r += n) {
        const o = new Sr(t.slice(r, r + n), e);
        s.push(o);
      }
      return s;
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "MultiPoint";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(t) {
      const e = this.flatCoordinates, n = this.stride;
      for (let s = 0, r = e.length; s < r; s += n) {
        const a = e[s], o = e[s + 1];
        if (fo(t, a, o))
          return !0;
      }
      return !1;
    }
    /**
     * Set the coordinates of the multipoint.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    setCoordinates(t, e) {
      this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Mo(
        this.flatCoordinates,
        0,
        t,
        this.stride
      ), this.changed();
    }
  }
  class Ds extends Ti {
    /**
     * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
     */
    constructor(t, e, n) {
      if (super(), this.endss_ = [], this.flatInteriorPointsRevision_ = -1, this.flatInteriorPoints_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, !n && !Array.isArray(t[0])) {
        const s = (
          /** @type {Array<Polygon>} */
          t
        ), r = [], a = [];
        for (let o = 0, l = s.length; o < l; ++o) {
          const h = s[o], c = r.length, u = h.getEnds();
          for (let d = 0, g = u.length; d < g; ++d)
            u[d] += c;
          pe(r, h.getFlatCoordinates()), a.push(u);
        }
        e = s.length === 0 ? this.getLayout() : s[0].getLayout(), t = r, n = a;
      }
      e !== void 0 && n ? (this.setFlatCoordinates(
        e,
        /** @type {Array<number>} */
        t
      ), this.endss_ = n) : this.setCoordinates(
        /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
        t,
        e
      );
    }
    /**
     * Append the passed polygon to this multipolygon.
     * @param {Polygon} polygon Polygon.
     * @api
     */
    appendPolygon(t) {
      let e;
      if (!this.flatCoordinates)
        this.flatCoordinates = t.getFlatCoordinates().slice(), e = t.getEnds().slice(), this.endss_.push();
      else {
        const n = this.flatCoordinates.length;
        pe(this.flatCoordinates, t.getFlatCoordinates()), e = t.getEnds().slice();
        for (let s = 0, r = e.length; s < r; ++s)
          e[s] += n;
      }
      this.endss_.push(e), this.changed();
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!MultiPolygon} Clone.
     * @api
     * @override
     */
    clone() {
      const t = this.endss_.length, e = new Array(t);
      for (let s = 0; s < t; ++s)
        e[s] = this.endss_[s].slice();
      const n = new Ds(
        this.flatCoordinates.slice(),
        this.layout,
        e
      );
      return n.applyProperties(this), n;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(t, e, n, s) {
      return s < an(this.getExtent(), t, e) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
        Fm(
          this.flatCoordinates,
          0,
          this.endss_,
          this.stride,
          0
        )
      ), this.maxDeltaRevision_ = this.getRevision()), Dm(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        this.maxDelta_,
        !0,
        t,
        e,
        n,
        s
      ));
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     * @override
     */
    containsXY(t, e) {
      return Um(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        t,
        e
      );
    }
    /**
     * Return the area of the multipolygon on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */
    getArea() {
      return Nm(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride
      );
    }
    /**
     * Get the coordinate array for this geometry.  This array has the structure
     * of a GeoJSON coordinate array for multi-polygons.
     *
     * @param {boolean} [right] Orient coordinates according to the right-hand
     *     rule (counter-clockwise for exterior and clockwise for interior rings).
     *     If `false`, coordinates will be oriented according to the left-hand rule
     *     (clockwise for exterior and counter-clockwise for interior rings).
     *     By default, coordinate orientation will depend on how the geometry was
     *     constructed.
     * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
     * @api
     * @override
     */
    getCoordinates(t) {
      let e;
      return t !== void 0 ? (e = this.getOrientedFlatCoordinates().slice(), Zc(
        e,
        0,
        this.endss_,
        this.stride,
        t
      )) : e = this.flatCoordinates, Al(
        e,
        0,
        this.endss_,
        this.stride
      );
    }
    /**
     * @return {Array<Array<number>>} Endss.
     */
    getEndss() {
      return this.endss_;
    }
    /**
     * @return {Array<number>} Flat interior points.
     */
    getFlatInteriorPoints() {
      if (this.flatInteriorPointsRevision_ != this.getRevision()) {
        const t = yf(
          this.flatCoordinates,
          0,
          this.endss_,
          this.stride
        );
        this.flatInteriorPoints_ = Dd(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride,
          t
        ), this.flatInteriorPointsRevision_ = this.getRevision();
      }
      return (
        /** @type {Array<number>} */
        this.flatInteriorPoints_
      );
    }
    /**
     * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
     * @return {MultiPoint} Interior points as XYM coordinates, where M is
     * the length of the horizontal intersection that the point belongs to.
     * @api
     */
    getInteriorPoints() {
      return new Kr(this.getFlatInteriorPoints().slice(), "XYM");
    }
    /**
     * @return {Array<number>} Oriented flat coordinates.
     */
    getOrientedFlatCoordinates() {
      if (this.orientedRevision_ != this.getRevision()) {
        const t = this.flatCoordinates;
        Ym(t, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = Zc(
          this.orientedFlatCoordinates_,
          0,
          this.endss_,
          this.stride
        )), this.orientedRevision_ = this.getRevision();
      }
      return (
        /** @type {Array<number>} */
        this.orientedFlatCoordinates_
      );
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {MultiPolygon} Simplified MultiPolygon.
     * @protected
     * @override
     */
    getSimplifiedGeometryInternal(t) {
      const e = [], n = [];
      return e.length = zm(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride,
        Math.sqrt(t),
        e,
        0,
        n
      ), new Ds(e, "XY", n);
    }
    /**
     * Return the polygon at the specified index.
     * @param {number} index Index.
     * @return {Polygon} Polygon.
     * @api
     */
    getPolygon(t) {
      if (t < 0 || this.endss_.length <= t)
        return null;
      let e;
      if (t === 0)
        e = 0;
      else {
        const r = this.endss_[t - 1];
        e = r[r.length - 1];
      }
      const n = this.endss_[t].slice(), s = n[n.length - 1];
      if (e !== 0)
        for (let r = 0, a = n.length; r < a; ++r)
          n[r] -= e;
      return new oi(
        this.flatCoordinates.slice(e, s),
        this.layout,
        n
      );
    }
    /**
     * Return the polygons of this multipolygon.
     * @return {Array<Polygon>} Polygons.
     * @api
     */
    getPolygons() {
      const t = this.layout, e = this.flatCoordinates, n = this.endss_, s = [];
      let r = 0;
      for (let a = 0, o = n.length; a < o; ++a) {
        const l = n[a].slice(), h = l[l.length - 1];
        if (r !== 0)
          for (let u = 0, d = l.length; u < d; ++u)
            l[u] -= r;
        const c = new oi(
          e.slice(r, h),
          t,
          l
        );
        s.push(c), r = h;
      }
      return s;
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "MultiPolygon";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(t) {
      return Wm(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        t
      );
    }
    /**
     * Set the coordinates of the multipolygon.
     * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    setCoordinates(t, e) {
      this.setLayout(e, t, 3), this.flatCoordinates || (this.flatCoordinates = []);
      const n = km(
        this.flatCoordinates,
        0,
        t,
        this.stride,
        this.endss_
      );
      if (n.length === 0)
        this.flatCoordinates.length = 0;
      else {
        const s = n[n.length - 1];
        this.flatCoordinates.length = s.length === 0 ? 0 : s[s.length - 1];
      }
      this.changed();
    }
  }
  const dy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Circle: Po,
    Geometry: Eo,
    GeometryCollection: ja,
    LineString: en,
    LinearRing: kn,
    MultiLineString: Fs,
    MultiPoint: Kr,
    MultiPolygon: Ds,
    Point: Sr,
    Polygon: oi,
    SimpleGeometry: Ti
  }, Symbol.toStringTag, { value: "Module" })), yu = $e();
  class qe {
    /**
     * @param {Type} type Geometry type.
     * @param {Array<number>} flatCoordinates Flat coordinates. These always need
     *     to be right-handed for polygons.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {Object<string, *>} properties Properties.
     * @param {number|string|undefined} id Feature id.
     */
    constructor(t, e, n, s, r, a) {
      this.styleFunction, this.extent_, this.id_ = a, this.type_ = t, this.flatCoordinates_ = e, this.flatInteriorPoints_ = null, this.flatMidpoints_ = null, this.ends_ = n || null, this.properties_ = r, this.squaredTolerance_, this.stride_ = s, this.simplifiedGeometry_;
    }
    /**
     * Get a feature property by its key.
     * @param {string} key Key
     * @return {*} Value for the requested key.
     * @api
     */
    get(t) {
      return this.properties_[t];
    }
    /**
     * Get the extent of this feature's geometry.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getExtent() {
      return this.extent_ || (this.extent_ = this.type_ === "Point" ? nh(this.flatCoordinates_) : go(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2
      )), this.extent_;
    }
    /**
     * @return {Array<number>} Flat interior points.
     */
    getFlatInteriorPoint() {
      if (!this.flatInteriorPoints_) {
        const t = Si(this.getExtent());
        this.flatInteriorPoints_ = Sh(
          this.flatCoordinates_,
          0,
          this.ends_,
          2,
          t,
          0
        );
      }
      return this.flatInteriorPoints_;
    }
    /**
     * @return {Array<number>} Flat interior points.
     */
    getFlatInteriorPoints() {
      if (!this.flatInteriorPoints_) {
        const t = Zm(this.flatCoordinates_, this.ends_), e = yf(this.flatCoordinates_, 0, t, 2);
        this.flatInteriorPoints_ = Dd(
          this.flatCoordinates_,
          0,
          t,
          2,
          e
        );
      }
      return this.flatInteriorPoints_;
    }
    /**
     * @return {Array<number>} Flat midpoint.
     */
    getFlatMidpoint() {
      return this.flatMidpoints_ || (this.flatMidpoints_ = Va(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2,
        0.5
      )), this.flatMidpoints_;
    }
    /**
     * @return {Array<number>} Flat midpoints.
     */
    getFlatMidpoints() {
      if (!this.flatMidpoints_) {
        this.flatMidpoints_ = [];
        const t = this.flatCoordinates_;
        let e = 0;
        const n = (
          /** @type {Array<number>} */
          this.ends_
        );
        for (let s = 0, r = n.length; s < r; ++s) {
          const a = n[s], o = Va(t, e, a, 2, 0.5);
          pe(this.flatMidpoints_, o), e = a;
        }
      }
      return this.flatMidpoints_;
    }
    /**
     * Get the feature identifier.  This is a stable identifier for the feature and
     * is set when reading data from a remote source.
     * @return {number|string|undefined} Id.
     * @api
     */
    getId() {
      return this.id_;
    }
    /**
     * @return {Array<number>} Flat coordinates.
     */
    getOrientedFlatCoordinates() {
      return this.flatCoordinates_;
    }
    /**
     * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
     * determining the geometry type in style function (see {@link #getType}).
     * @return {RenderFeature} Feature.
     * @api
     */
    getGeometry() {
      return this;
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {RenderFeature} Simplified geometry.
     */
    getSimplifiedGeometry(t) {
      return this;
    }
    /**
     * Get a transformed and simplified version of the geometry.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
     * @return {RenderFeature} Simplified geometry.
     */
    simplifyTransformed(t, e) {
      return this;
    }
    /**
     * Get the feature properties.
     * @return {Object<string, *>} Feature properties.
     * @api
     */
    getProperties() {
      return this.properties_;
    }
    /**
     * Get an object of all property names and values.  This has the same behavior as getProperties,
     * but is here to conform with the {@link module:ol/Feature~Feature} interface.
     * @return {Object<string, *>?} Object.
     */
    getPropertiesInternal() {
      return this.properties_;
    }
    /**
     * @return {number} Stride.
     */
    getStride() {
      return this.stride_;
    }
    /**
     * @return {import('../style/Style.js').StyleFunction|undefined} Style
     */
    getStyleFunction() {
      return this.styleFunction;
    }
    /**
     * Get the type of this feature's geometry.
     * @return {Type} Geometry type.
     * @api
     */
    getType() {
      return this.type_;
    }
    /**
     * Transform geometry coordinates from tile pixel space to projected.
     *
     * @param {import("../proj.js").ProjectionLike} projection The data projection
     */
    transform(t) {
      t = At(t);
      const e = t.getExtent(), n = t.getWorldExtent();
      if (e && n) {
        const s = te(n) / te(e);
        Ci(
          yu,
          n[0],
          n[3],
          s,
          -s,
          0,
          0,
          0
        ), ji(
          this.flatCoordinates_,
          0,
          this.flatCoordinates_.length,
          2,
          yu,
          this.flatCoordinates_
        );
      }
    }
    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     */
    applyTransform(t) {
      t(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
    }
    /**
     * @return {RenderFeature} A cloned render feature.
     */
    clone() {
      var t;
      return new qe(
        this.type_,
        this.flatCoordinates_.slice(),
        (t = this.ends_) == null ? void 0 : t.slice(),
        this.stride_,
        Object.assign({}, this.properties_),
        this.id_
      );
    }
    /**
     * @return {Array<number>|null} Ends.
     */
    getEnds() {
      return this.ends_;
    }
    /**
     * Add transform and resolution based geometry simplification to this instance.
     * @return {RenderFeature} This render feature.
     */
    enableSimplifyTransformed() {
      return this.simplifyTransformed = ld((t, e) => {
        if (t === this.squaredTolerance_)
          return this.simplifiedGeometry_;
        this.simplifiedGeometry_ = this.clone(), e && this.simplifiedGeometry_.applyTransform(e);
        const n = this.simplifiedGeometry_.getFlatCoordinates();
        let s;
        switch (this.type_) {
          case "LineString":
            n.length = xo(
              n,
              0,
              this.simplifiedGeometry_.flatCoordinates_.length,
              this.simplifiedGeometry_.stride_,
              t,
              n,
              0
            ), s = [n.length];
            break;
          case "MultiLineString":
            s = [], n.length = Nd(
              n,
              0,
              this.simplifiedGeometry_.ends_,
              this.simplifiedGeometry_.stride_,
              t,
              n,
              0,
              s
            );
            break;
          case "Polygon":
            s = [], n.length = xh(
              n,
              0,
              this.simplifiedGeometry_.ends_,
              this.simplifiedGeometry_.stride_,
              Math.sqrt(t),
              n,
              0,
              s
            );
            break;
        }
        return s && (this.simplifiedGeometry_ = new qe(
          this.type_,
          n,
          s,
          2,
          this.properties_,
          this.id_
        )), this.squaredTolerance_ = t, this.simplifiedGeometry_;
      }), this;
    }
  }
  qe.prototype.getFlatCoordinates = qe.prototype.getOrientedFlatCoordinates;
  class vu {
    /**
     * @param {number} [maxEntries] Max entries.
     */
    constructor(t) {
      this.rbush_ = new Vd(t), this.items_ = {};
    }
    /**
     * Insert a value into the RBush.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {T} value Value.
     */
    insert(t, e) {
      const n = {
        minX: t[0],
        minY: t[1],
        maxX: t[2],
        maxY: t[3],
        value: e
      };
      this.rbush_.insert(n), this.items_[Ct(e)] = n;
    }
    /**
     * Bulk-insert values into the RBush.
     * @param {Array<import("../extent.js").Extent>} extents Extents.
     * @param {Array<T>} values Values.
     */
    load(t, e) {
      const n = new Array(e.length);
      for (let s = 0, r = e.length; s < r; s++) {
        const a = t[s], o = e[s], l = {
          minX: a[0],
          minY: a[1],
          maxX: a[2],
          maxY: a[3],
          value: o
        };
        n[s] = l, this.items_[Ct(o)] = l;
      }
      this.rbush_.load(n);
    }
    /**
     * Remove a value from the RBush.
     * @param {T} value Value.
     * @return {boolean} Removed.
     */
    remove(t) {
      const e = Ct(t), n = this.items_[e];
      return delete this.items_[e], this.rbush_.remove(n) !== null;
    }
    /**
     * Update the extent of a value in the RBush.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {T} value Value.
     */
    update(t, e) {
      const n = this.items_[Ct(e)], s = [n.minX, n.minY, n.maxX, n.maxY];
      As(s, t) || (this.remove(e), this.insert(t, e));
    }
    /**
     * Return all values in the RBush.
     * @return {Array<T>} All.
     */
    getAll() {
      return this.rbush_.all().map(function(e) {
        return e.value;
      });
    }
    /**
     * Return all values in the given extent.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {Array<T>} All in extent.
     */
    getInExtent(t) {
      const e = {
        minX: t[0],
        minY: t[1],
        maxX: t[2],
        maxY: t[3]
      };
      return this.rbush_.search(e).map(function(s) {
        return s.value;
      });
    }
    /**
     * Calls a callback function with each value in the tree.
     * If the callback returns a truthy value, this value is returned without
     * checking the rest of the tree.
     * @param {function(T): R} callback Callback.
     * @return {R|undefined} Callback return value.
     * @template R
     */
    forEach(t) {
      return this.forEach_(this.getAll(), t);
    }
    /**
     * Calls a callback function with each value in the provided extent.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(T): R} callback Callback.
     * @return {R|undefined} Callback return value.
     * @template R
     */
    forEachInExtent(t, e) {
      return this.forEach_(this.getInExtent(t), e);
    }
    /**
     * @param {Array<T>} values Values.
     * @param {function(T): R} callback Callback.
     * @return {R|undefined} Callback return value.
     * @template R
     * @private
     */
    forEach_(t, e) {
      let n;
      for (let s = 0, r = t.length; s < r; s++)
        if (n = e(t[s]), n)
          return n;
      return n;
    }
    /**
     * @return {boolean} Is empty.
     */
    isEmpty() {
      return Ts(this.items_);
    }
    /**
     * Remove all values from the RBush.
     */
    clear() {
      this.rbush_.clear(), this.items_ = {};
    }
    /**
     * @param {import("../extent.js").Extent} [extent] Extent.
     * @return {import("../extent.js").Extent} Extent.
     */
    getExtent(t) {
      const e = this.rbush_.toJSON();
      return Le(e.minX, e.minY, e.maxX, e.maxY, t);
    }
    /**
     * @param {RBush<T>} rbush R-Tree.
     */
    concat(t) {
      this.rbush_.load(t.rbush_.all());
      for (const e in t.items_)
        this.items_[e] = t.items_[e];
    }
  }
  class vf extends Qe {
    /**
     * @param {Options} options Source options.
     */
    constructor(t) {
      super(), this.projection = At(t.projection), this.attributions_ = Eu(t.attributions), this.attributionsCollapsible_ = t.attributionsCollapsible ?? !0, this.loading = !1, this.state_ = t.state !== void 0 ? t.state : "ready", this.wrapX_ = t.wrapX !== void 0 ? t.wrapX : !1, this.interpolate_ = !!t.interpolate, this.viewResolver = null, this.viewRejector = null;
      const e = this;
      this.viewPromise_ = new Promise(function(n, s) {
        e.viewResolver = n, e.viewRejector = s;
      });
    }
    /**
     * Get the attribution function for the source.
     * @return {?Attribution} Attribution function.
     * @api
     */
    getAttributions() {
      return this.attributions_;
    }
    /**
     * @return {boolean} Attributions are collapsible.
     * @api
     */
    getAttributionsCollapsible() {
      return this.attributionsCollapsible_;
    }
    /**
     * Get the projection of the source.
     * @return {import("../proj/Projection.js").default|null} Projection.
     * @api
     */
    getProjection() {
      return this.projection;
    }
    /**
     * @param {import("../proj/Projection").default} [projection] Projection.
     * @return {Array<number>|null} Resolutions.
     */
    getResolutions(t) {
      return null;
    }
    /**
     * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
     */
    getView() {
      return this.viewPromise_;
    }
    /**
     * Get the state of the source, see {@link import("./Source.js").State} for possible states.
     * @return {import("./Source.js").State} State.
     * @api
     */
    getState() {
      return this.state_;
    }
    /**
     * @return {boolean|undefined} Wrap X.
     */
    getWrapX() {
      return this.wrapX_;
    }
    /**
     * @return {boolean} Use linear interpolation when resampling.
     */
    getInterpolate() {
      return this.interpolate_;
    }
    /**
     * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
     * @api
     */
    refresh() {
      this.changed();
    }
    /**
     * Set the attributions of the source.
     * @param {AttributionLike|undefined} attributions Attributions.
     *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
     *     or `undefined`.
     * @api
     */
    setAttributions(t) {
      this.attributions_ = Eu(t), this.changed();
    }
    /**
     * Set the state of the source.
     * @param {import("./Source.js").State} state State.
     */
    setState(t) {
      this.state_ = t, this.changed();
    }
  }
  function Eu(i) {
    return i ? typeof i == "function" ? i : (Array.isArray(i) || (i = [i]), (t) => i) : null;
  }
  const Fe = {
    /**
     * Triggered when a feature is added to the source.
     * @event module:ol/source/Vector.VectorSourceEvent#addfeature
     * @api
     */
    ADDFEATURE: "addfeature",
    /**
     * Triggered when a feature is updated.
     * @event module:ol/source/Vector.VectorSourceEvent#changefeature
     * @api
     */
    CHANGEFEATURE: "changefeature",
    /**
     * Triggered when the clear method is called on the source.
     * @event module:ol/source/Vector.VectorSourceEvent#clear
     * @api
     */
    CLEAR: "clear",
    /**
     * Triggered when a feature is removed from the source.
     * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
     * @event module:ol/source/Vector.VectorSourceEvent#removefeature
     * @api
     */
    REMOVEFEATURE: "removefeature",
    /**
     * Triggered when features starts loading.
     * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
     * @api
     */
    FEATURESLOADSTART: "featuresloadstart",
    /**
     * Triggered when features finishes loading.
     * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
     * @api
     */
    FEATURESLOADEND: "featuresloadend",
    /**
     * Triggered if feature loading results in an error.
     * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
     * @api
     */
    FEATURESLOADERROR: "featuresloaderror"
  };
  class Di extends Ri {
    /**
     * @param {string} type Type.
     * @param {FeatureType} [feature] Feature.
     * @param {Array<FeatureType>} [features] Features.
     */
    constructor(t, e, n) {
      super(t), this.feature = e, this.features = n;
    }
  }
  class fy extends vf {
    /**
     * @param {Options<FeatureType>} [options] Vector source options.
     */
    constructor(t) {
      t = t || {}, super({
        attributions: t.attributions,
        interpolate: !0,
        projection: void 0,
        state: "ready",
        wrapX: t.wrapX !== void 0 ? t.wrapX : !0
      }), this.on, this.once, this.un, this.loader_ = Is, this.format_ = t.format || null, this.overlaps_ = t.overlaps === void 0 ? !0 : t.overlaps, this.url_ = t.url, t.loader !== void 0 ? this.loader_ = t.loader : this.url_ !== void 0 && (xt(this.format_, "`format` must be set when `url` is set"), this.loader_ = pu(this.url_, this.format_)), this.strategy_ = t.strategy !== void 0 ? t.strategy : uy;
      const e = t.useSpatialIndex !== void 0 ? t.useSpatialIndex : !0;
      this.featuresRtree_ = e ? new vu() : null, this.loadedExtentsRtree_ = new vu(), this.loadingExtentsCount_ = 0, this.nullGeometryFeatures_ = {}, this.idIndex_ = {}, this.uidIndex_ = {}, this.featureChangeKeys_ = {}, this.featuresCollection_ = null;
      let n, s;
      Array.isArray(t.features) ? s = t.features : t.features && (n = t.features, s = n.getArray()), !e && n === void 0 && (n = new ni(s)), s !== void 0 && this.addFeaturesInternal(s), n !== void 0 && this.bindFeaturesCollection_(n);
    }
    /**
     * Add a single feature to the source.  If you want to add a batch of features
     * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
     * instead. A feature will not be added to the source if feature with
     * the same id is already there. The reason for this behavior is to avoid
     * feature duplication when using bbox or tile loading strategies.
     * Note: this also applies if a {@link module:ol/Collection~Collection} is used for features,
     * meaning that if a feature with a duplicate id is added in the collection, it will
     * be removed from it right away.
     * @param {FeatureType} feature Feature to add.
     * @api
     */
    addFeature(t) {
      this.addFeatureInternal(t), this.changed();
    }
    /**
     * Add a feature without firing a `change` event.
     * @param {FeatureType} feature Feature.
     * @protected
     */
    addFeatureInternal(t) {
      const e = Ct(t);
      if (!this.addToIndex_(e, t)) {
        this.featuresCollection_ && this.featuresCollection_.remove(t);
        return;
      }
      this.setupChangeEvents_(e, t);
      const n = t.getGeometry();
      if (n) {
        const s = n.getExtent();
        this.featuresRtree_ && this.featuresRtree_.insert(s, t);
      } else
        this.nullGeometryFeatures_[e] = t;
      this.dispatchEvent(
        new Di(Fe.ADDFEATURE, t)
      );
    }
    /**
     * @param {string} featureKey Unique identifier for the feature.
     * @param {FeatureType} feature The feature.
     * @private
     */
    setupChangeEvents_(t, e) {
      e instanceof qe || (this.featureChangeKeys_[t] = [
        vt(e, at.CHANGE, this.handleFeatureChange_, this),
        vt(
          e,
          Rs.PROPERTYCHANGE,
          this.handleFeatureChange_,
          this
        )
      ]);
    }
    /**
     * @param {string} featureKey Unique identifier for the feature.
     * @param {FeatureType} feature The feature.
     * @return {boolean} The feature is "valid", in the sense that it is also a
     *     candidate for insertion into the Rtree.
     * @private
     */
    addToIndex_(t, e) {
      let n = !0;
      if (e.getId() !== void 0) {
        const s = String(e.getId());
        if (!(s in this.idIndex_))
          this.idIndex_[s] = e;
        else if (e instanceof qe) {
          const r = this.idIndex_[s];
          r instanceof qe ? Array.isArray(r) ? r.push(e) : this.idIndex_[s] = [r, e] : n = !1;
        } else
          n = !1;
      }
      return n && (xt(
        !(t in this.uidIndex_),
        "The passed `feature` was already added to the source"
      ), this.uidIndex_[t] = e), n;
    }
    /**
     * Add a batch of features to the source.
     * @param {Array<FeatureType>} features Features to add.
     * @api
     */
    addFeatures(t) {
      this.addFeaturesInternal(t), this.changed();
    }
    /**
     * Add features without firing a `change` event.
     * @param {Array<FeatureType>} features Features.
     * @protected
     */
    addFeaturesInternal(t) {
      const e = [], n = [], s = [];
      for (let r = 0, a = t.length; r < a; r++) {
        const o = t[r], l = Ct(o);
        this.addToIndex_(l, o) && n.push(o);
      }
      for (let r = 0, a = n.length; r < a; r++) {
        const o = n[r], l = Ct(o);
        this.setupChangeEvents_(l, o);
        const h = o.getGeometry();
        if (h) {
          const c = h.getExtent();
          e.push(c), s.push(o);
        } else
          this.nullGeometryFeatures_[l] = o;
      }
      if (this.featuresRtree_ && this.featuresRtree_.load(e, s), this.hasListener(Fe.ADDFEATURE))
        for (let r = 0, a = n.length; r < a; r++)
          this.dispatchEvent(
            new Di(Fe.ADDFEATURE, n[r])
          );
    }
    /**
     * @param {!Collection<FeatureType>} collection Collection.
     * @private
     */
    bindFeaturesCollection_(t) {
      let e = !1;
      this.addEventListener(
        Fe.ADDFEATURE,
        /**
         * @param {VectorSourceEvent<FeatureType>} evt The vector source event
         */
        function(n) {
          e || (e = !0, t.push(n.feature), e = !1);
        }
      ), this.addEventListener(
        Fe.REMOVEFEATURE,
        /**
         * @param {VectorSourceEvent<FeatureType>} evt The vector source event
         */
        function(n) {
          e || (e = !0, t.remove(n.feature), e = !1);
        }
      ), t.addEventListener(
        Ee.ADD,
        /**
         * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
         */
        (n) => {
          e || (e = !0, this.addFeature(n.element), e = !1);
        }
      ), t.addEventListener(
        Ee.REMOVE,
        /**
         * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
         */
        (n) => {
          e || (e = !0, this.removeFeature(n.element), e = !1);
        }
      ), this.featuresCollection_ = t;
    }
    /**
     * Remove all features from the source.
     * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
     * @api
     */
    clear(t) {
      if (t) {
        for (const n in this.featureChangeKeys_)
          this.featureChangeKeys_[n].forEach(Pt);
        this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.uidIndex_ = {});
      } else if (this.featuresRtree_) {
        this.featuresRtree_.forEach((n) => {
          this.removeFeatureInternal(n);
        });
        for (const n in this.nullGeometryFeatures_)
          this.removeFeatureInternal(this.nullGeometryFeatures_[n]);
      }
      this.featuresCollection_ && this.featuresCollection_.clear(), this.featuresRtree_ && this.featuresRtree_.clear(), this.nullGeometryFeatures_ = {};
      const e = new Di(Fe.CLEAR);
      this.dispatchEvent(e), this.changed();
    }
    /**
     * Iterate through all features on the source, calling the provided callback
     * with each one.  If the callback returns any "truthy" value, iteration will
     * stop and the function will return the same value.
     * Note: this function only iterate through the feature that have a defined geometry.
     *
     * @param {function(FeatureType): T} callback Called with each feature
     *     on the source.  Return a truthy value to stop iteration.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */
    forEachFeature(t) {
      if (this.featuresRtree_)
        return this.featuresRtree_.forEach(t);
      this.featuresCollection_ && this.featuresCollection_.forEach(t);
    }
    /**
     * Iterate through all features whose geometries contain the provided
     * coordinate, calling the callback with each feature.  If the callback returns
     * a "truthy" value, iteration will stop and the function will return the same
     * value.
     *
     * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be
     * called for all features.
     *
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {function(FeatureType): T} callback Called with each feature
     *     whose goemetry contains the provided coordinate.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     */
    forEachFeatureAtCoordinateDirect(t, e) {
      const n = [t[0], t[1], t[0], t[1]];
      return this.forEachFeatureInExtent(n, function(s) {
        const r = s.getGeometry();
        if (r instanceof qe || r.intersectsCoordinate(t))
          return e(s);
      });
    }
    /**
     * Iterate through all features whose bounding box intersects the provided
     * extent (note that the feature's geometry may not intersect the extent),
     * calling the callback with each feature.  If the callback returns a "truthy"
     * value, iteration will stop and the function will return the same value.
     *
     * If you are interested in features whose geometry intersects an extent, call
     * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
     *
     * When `useSpatialIndex` is set to false, this method will loop through all
     * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(FeatureType): T} callback Called with each feature
     *     whose bounding box intersects the provided extent.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */
    forEachFeatureInExtent(t, e) {
      if (this.featuresRtree_)
        return this.featuresRtree_.forEachInExtent(t, e);
      this.featuresCollection_ && this.featuresCollection_.forEach(e);
    }
    /**
     * Iterate through all features whose geometry intersects the provided extent,
     * calling the callback with each feature.  If the callback returns a "truthy"
     * value, iteration will stop and the function will return the same value.
     *
     * If you only want to test for bounding box intersection, call the
     * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(FeatureType): T} callback Called with each feature
     *     whose geometry intersects the provided extent.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */
    forEachFeatureIntersectingExtent(t, e) {
      return this.forEachFeatureInExtent(
        t,
        /**
         * @param {FeatureType} feature Feature.
         * @return {T|undefined} The return value from the last call to the callback.
         */
        function(n) {
          const s = n.getGeometry();
          if (s instanceof qe || s.intersectsExtent(t)) {
            const r = e(n);
            if (r)
              return r;
          }
        }
      );
    }
    /**
     * Get the features collection associated with this source. Will be `null`
     * unless the source was configured with `useSpatialIndex` set to `false`, or
     * with a {@link module:ol/Collection~Collection} as `features`.
     * @return {Collection<FeatureType>|null} The collection of features.
     * @api
     */
    getFeaturesCollection() {
      return this.featuresCollection_;
    }
    /**
     * Get a snapshot of the features currently on the source in random order. The returned array
     * is a copy, the features are references to the features in the source.
     * @return {Array<FeatureType>} Features.
     * @api
     */
    getFeatures() {
      let t;
      return this.featuresCollection_ ? t = this.featuresCollection_.getArray().slice(0) : this.featuresRtree_ && (t = this.featuresRtree_.getAll(), Ts(this.nullGeometryFeatures_) || pe(t, Object.values(this.nullGeometryFeatures_))), t;
    }
    /**
     * Get all features whose geometry intersects the provided coordinate.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {Array<FeatureType>} Features.
     * @api
     */
    getFeaturesAtCoordinate(t) {
      const e = [];
      return this.forEachFeatureAtCoordinateDirect(t, function(n) {
        e.push(n);
      }), e;
    }
    /**
     * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
     * all features intersecting the given extent in random order (so it may include
     * features whose geometries do not intersect the extent).
     *
     * When `useSpatialIndex` is set to false, this method will return all
     * features.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {import("../proj/Projection.js").default} [projection] Include features
     * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
     * @return {Array<FeatureType>} Features.
     * @api
     */
    getFeaturesInExtent(t, e) {
      if (this.featuresRtree_) {
        if (!(e && e.canWrapX() && this.getWrapX()))
          return this.featuresRtree_.getInExtent(t);
        const s = lh(t, e);
        return [].concat(
          ...s.map((r) => this.featuresRtree_.getInExtent(r))
        );
      }
      return this.featuresCollection_ ? this.featuresCollection_.getArray().slice(0) : [];
    }
    /**
     * Get the closest feature to the provided coordinate.
     *
     * This method is not available when the source is configured with
     * `useSpatialIndex` set to `false` and the features in this source are of type
     * {@link module:ol/Feature~Feature}.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {function(FeatureType):boolean} [filter] Feature filter function.
     *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
     *     and it should return a boolean value. By default, no filtering is made.
     * @return {FeatureType} Closest feature.
     * @api
     */
    getClosestFeatureToCoordinate(t, e) {
      const n = t[0], s = t[1];
      let r = null;
      const a = [NaN, NaN];
      let o = 1 / 0;
      const l = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
      return e = e || Mr, this.featuresRtree_.forEachInExtent(
        l,
        /**
         * @param {FeatureType} feature Feature.
         */
        function(h) {
          if (e(h)) {
            const c = h.getGeometry(), u = o;
            if (o = c instanceof qe ? 0 : c.closestPointXY(n, s, a, o), o < u) {
              r = h;
              const d = Math.sqrt(o);
              l[0] = n - d, l[1] = s - d, l[2] = n + d, l[3] = s + d;
            }
          }
        }
      ), r;
    }
    /**
     * Get the extent of the features currently in the source.
     *
     * This method is not available when the source is configured with
     * `useSpatialIndex` set to `false`.
     * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
     *     will be created. Instead, that extent's coordinates will be overwritten.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getExtent(t) {
      return this.featuresRtree_.getExtent(t);
    }
    /**
     * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s
     * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling
     * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per
     * `GeometryCollection` member.
     * Note that the index treats string and numeric identifiers as the same.  So
     * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
     *
     * @param {string|number} id Feature identifier.
     * @return {FeatureClassOrArrayOfRenderFeatures<FeatureType>|null} The feature (or `null` if not found).
     * @api
     */
    getFeatureById(t) {
      const e = this.idIndex_[t.toString()];
      return e !== void 0 ? (
        /** @type {FeatureClassOrArrayOfRenderFeatures<FeatureType>} */
        e
      ) : null;
    }
    /**
     * Get a feature by its internal unique identifier (using `getUid`).
     *
     * @param {string} uid Feature identifier.
     * @return {FeatureType|null} The feature (or `null` if not found).
     */
    getFeatureByUid(t) {
      const e = this.uidIndex_[t];
      return e !== void 0 ? e : null;
    }
    /**
     * Get the format associated with this source.
     *
     * @return {import("../format/Feature.js").default<FeatureType>|null}} The feature format.
     * @api
     */
    getFormat() {
      return this.format_;
    }
    /**
     * @return {boolean} The source can have overlapping geometries.
     */
    getOverlaps() {
      return this.overlaps_;
    }
    /**
     * Get the url associated with this source.
     *
     * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
     * @api
     */
    getUrl() {
      return this.url_;
    }
    /**
     * @param {Event} event Event.
     * @private
     */
    handleFeatureChange_(t) {
      const e = (
        /** @type {FeatureType} */
        t.target
      ), n = Ct(e), s = e.getGeometry();
      if (!s)
        n in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(e), this.nullGeometryFeatures_[n] = e);
      else {
        const a = s.getExtent();
        n in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[n], this.featuresRtree_ && this.featuresRtree_.insert(a, e)) : this.featuresRtree_ && this.featuresRtree_.update(a, e);
      }
      const r = e.getId();
      if (r !== void 0) {
        const a = r.toString();
        this.idIndex_[a] !== e && (this.removeFromIdIndex_(e), this.idIndex_[a] = e);
      } else
        this.removeFromIdIndex_(e), this.uidIndex_[n] = e;
      this.changed(), this.dispatchEvent(
        new Di(Fe.CHANGEFEATURE, e)
      );
    }
    /**
     * Returns true if the feature is contained within the source.
     * @param {FeatureType} feature Feature.
     * @return {boolean} Has feature.
     * @api
     */
    hasFeature(t) {
      const e = t.getId();
      return e !== void 0 ? e in this.idIndex_ : Ct(t) in this.uidIndex_;
    }
    /**
     * @return {boolean} Is empty.
     */
    isEmpty() {
      return this.featuresRtree_ ? this.featuresRtree_.isEmpty() && Ts(this.nullGeometryFeatures_) : this.featuresCollection_ ? this.featuresCollection_.getLength() === 0 : !0;
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */
    loadFeatures(t, e, n) {
      const s = this.loadedExtentsRtree_, r = this.strategy_(t, e, n);
      for (let a = 0, o = r.length; a < o; ++a) {
        const l = r[a];
        s.forEachInExtent(
          l,
          /**
           * @param {{extent: import("../extent.js").Extent}} object Object.
           * @return {boolean} Contains.
           */
          function(c) {
            return Rn(c.extent, l);
          }
        ) || (++this.loadingExtentsCount_, this.dispatchEvent(
          new Di(Fe.FEATURESLOADSTART)
        ), this.loader_.call(
          this,
          l,
          e,
          n,
          /**
           * @param {Array<FeatureType>} features Loaded features
           */
          (c) => {
            --this.loadingExtentsCount_, this.dispatchEvent(
              new Di(
                Fe.FEATURESLOADEND,
                void 0,
                c
              )
            );
          },
          () => {
            --this.loadingExtentsCount_, this.dispatchEvent(
              new Di(Fe.FEATURESLOADERROR)
            );
          }
        ), s.insert(l, { extent: l.slice() }));
      }
      this.loading = this.loader_.length < 4 ? !1 : this.loadingExtentsCount_ > 0;
    }
    /**
     * @override
     */
    refresh() {
      this.clear(!0), this.loadedExtentsRtree_.clear(), super.refresh();
    }
    /**
     * Remove an extent from the list of loaded extents.
     * @param {import("../extent.js").Extent} extent Extent.
     * @api
     */
    removeLoadedExtent(t) {
      const e = this.loadedExtentsRtree_, n = e.forEachInExtent(t, function(s) {
        if (As(s.extent, t))
          return s;
      });
      n && e.remove(n);
    }
    /**
     * Batch remove features from the source.  If you want to remove all features
     * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
     * instead.
     * @param {Array<FeatureType>} features Features to remove.
     * @api
     */
    removeFeatures(t) {
      let e = !1;
      for (let n = 0, s = t.length; n < s; ++n)
        e = this.removeFeatureInternal(t[n]) || e;
      e && this.changed();
    }
    /**
     * Remove a single feature from the source. If you want to batch remove
     * features, use the {@link module:ol/source/Vector~VectorSource#removeFeatures #removeFeatures()} method
     * instead.
     * @param {FeatureType} feature Feature to remove.
     * @api
     */
    removeFeature(t) {
      if (!t)
        return;
      this.removeFeatureInternal(t) && this.changed();
    }
    /**
     * Remove feature without firing a `change` event.
     * @param {FeatureType} feature Feature.
     * @return {boolean} True if the feature was removed, false if it was not found.
     * @protected
     */
    removeFeatureInternal(t) {
      const e = Ct(t);
      if (!(e in this.uidIndex_))
        return !1;
      e in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[e] : this.featuresRtree_ && this.featuresRtree_.remove(t);
      const n = this.featureChangeKeys_[e];
      n == null || n.forEach(Pt), delete this.featureChangeKeys_[e];
      const s = t.getId();
      if (s !== void 0) {
        const r = s.toString(), a = this.idIndex_[r];
        a === t ? delete this.idIndex_[r] : Array.isArray(a) && (a.splice(a.indexOf(t), 1), a.length === 1 && (this.idIndex_[r] = a[0]));
      }
      return delete this.uidIndex_[e], this.hasListener(Fe.REMOVEFEATURE) && this.dispatchEvent(
        new Di(Fe.REMOVEFEATURE, t)
      ), !0;
    }
    /**
     * Remove a feature from the id index.  Called internally when the feature id
     * may have changed.
     * @param {FeatureType} feature The feature.
     * @private
     */
    removeFromIdIndex_(t) {
      for (const e in this.idIndex_)
        if (this.idIndex_[e] === t) {
          delete this.idIndex_[e];
          break;
        }
    }
    /**
     * Set the new loader of the source. The next render cycle will use the
     * new loader.
     * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
     * @api
     */
    setLoader(t) {
      this.loader_ = t;
    }
    /**
     * Points the source to a new url. The next render cycle will use the new url.
     * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
     * @api
     */
    setUrl(t) {
      xt(this.format_, "`format` must be set when `url` is set"), this.url_ = t, this.setLoader(pu(t, this.format_));
    }
    /**
     * @param {boolean} overlaps The source can have overlapping geometries.
     */
    setOverlaps(t) {
      this.overlaps_ = t, this.changed();
    }
  }
  const H = {
    BEGIN_GEOMETRY: 0,
    BEGIN_PATH: 1,
    CIRCLE: 2,
    CLOSE_PATH: 3,
    CUSTOM: 4,
    DRAW_CHARS: 5,
    DRAW_IMAGE: 6,
    END_GEOMETRY: 7,
    FILL: 8,
    MOVE_TO_LINE_TO: 9,
    SET_FILL_STYLE: 10,
    SET_STROKE_STYLE: 11,
    STROKE: 12
  }, Ea = [H.FILL], Yi = [H.STROKE], bn = [H.BEGIN_PATH], Mu = [H.CLOSE_PATH];
  class Vr extends gf {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(t, e, n, s) {
      super(), this.tolerance = t, this.maxExtent = e, this.pixelRatio = s, this.maxLineWidth = 0, this.resolution = n, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_ = null, this.bufferedMaxExtent_ = null, this.instructions = [], this.coordinates = [], this.tmpCoordinate_ = [], this.hitDetectionInstructions = [], this.state = /** @type {import("../canvas.js").FillStrokeState} */
      {};
    }
    /**
     * @protected
     * @param {Array<number>} dashArray Dash array.
     * @return {Array<number>} Dash array with pixel ratio applied
     */
    applyPixelRatio(t) {
      const e = this.pixelRatio;
      return e == 1 ? t : t.map(function(n) {
        return n * e;
      });
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} stride Stride.
     * @protected
     * @return {number} My end
     */
    appendFlatPointCoordinates(t, e) {
      const n = this.getBufferedMaxExtent(), s = this.tmpCoordinate_, r = this.coordinates;
      let a = r.length;
      for (let o = 0, l = t.length; o < l; o += e)
        s[0] = t[o], s[1] = t[o + 1], Fn(n, s) && (r[a++] = s[0], r[a++] = s[1]);
      return a;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {boolean} closed Last input coordinate equals first.
     * @param {boolean} skipFirst Skip first coordinate.
     * @protected
     * @return {number} My end.
     */
    appendFlatLineCoordinates(t, e, n, s, r, a) {
      const o = this.coordinates;
      let l = o.length;
      const h = this.getBufferedMaxExtent();
      a && (e += s);
      let c = t[e], u = t[e + 1];
      const d = this.tmpCoordinate_;
      let g = !0, _, y, E;
      for (_ = e + s; _ < n; _ += s)
        d[0] = t[_], d[1] = t[_ + 1], E = Ga(h, d), E !== y ? (g && (o[l++] = c, o[l++] = u, g = !1), o[l++] = d[0], o[l++] = d[1]) : E === Zt.INTERSECTING ? (o[l++] = d[0], o[l++] = d[1], g = !1) : g = !0, c = d[0], u = d[1], y = E;
      return (r && g || _ === e + s) && (o[l++] = c, o[l++] = u), l;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {Array<number>} builderEnds Builder ends.
     * @return {number} Offset.
     */
    drawCustomCoordinates_(t, e, n, s, r) {
      for (let a = 0, o = n.length; a < o; ++a) {
        const l = n[a], h = this.appendFlatLineCoordinates(
          t,
          e,
          l,
          s,
          !1,
          !1
        );
        r.push(h), e = l;
      }
      return e;
    }
    /**
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {Function} renderer Renderer.
     * @param {Function} hitDetectionRenderer Renderer.
     * @param {number} [index] Render order index.
     * @override
     */
    drawCustom(t, e, n, s, r) {
      this.beginGeometry(t, e, r);
      const a = t.getType(), o = t.getStride(), l = this.coordinates.length;
      let h, c, u, d, g;
      switch (a) {
        case "MultiPolygon":
          h = /** @type {import("../../geom/MultiPolygon.js").default} */
          t.getOrientedFlatCoordinates(), d = [];
          const _ = (
            /** @type {import("../../geom/MultiPolygon.js").default} */
            t.getEndss()
          );
          g = 0;
          for (let y = 0, E = _.length; y < E; ++y) {
            const M = [];
            g = this.drawCustomCoordinates_(
              h,
              g,
              _[y],
              o,
              M
            ), d.push(M);
          }
          this.instructions.push([
            H.CUSTOM,
            l,
            d,
            t,
            n,
            Al,
            r
          ]), this.hitDetectionInstructions.push([
            H.CUSTOM,
            l,
            d,
            t,
            s || n,
            Al,
            r
          ]);
          break;
        case "Polygon":
        case "MultiLineString":
          u = [], h = a == "Polygon" ? (
            /** @type {import("../../geom/Polygon.js").default} */
            t.getOrientedFlatCoordinates()
          ) : t.getFlatCoordinates(), g = this.drawCustomCoordinates_(
            h,
            0,
            /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
            t.getEnds(),
            o,
            u
          ), this.instructions.push([
            H.CUSTOM,
            l,
            u,
            t,
            n,
            wr,
            r
          ]), this.hitDetectionInstructions.push([
            H.CUSTOM,
            l,
            u,
            t,
            s || n,
            wr,
            r
          ]);
          break;
        case "LineString":
        case "Circle":
          h = t.getFlatCoordinates(), c = this.appendFlatLineCoordinates(
            h,
            0,
            h.length,
            o,
            !1,
            !1
          ), this.instructions.push([
            H.CUSTOM,
            l,
            c,
            t,
            n,
            Xi,
            r
          ]), this.hitDetectionInstructions.push([
            H.CUSTOM,
            l,
            c,
            t,
            s || n,
            Xi,
            r
          ]);
          break;
        case "MultiPoint":
          h = t.getFlatCoordinates(), c = this.appendFlatPointCoordinates(h, o), c > l && (this.instructions.push([
            H.CUSTOM,
            l,
            c,
            t,
            n,
            Xi,
            r
          ]), this.hitDetectionInstructions.push([
            H.CUSTOM,
            l,
            c,
            t,
            s || n,
            Xi,
            r
          ]));
          break;
        case "Point":
          h = t.getFlatCoordinates(), this.coordinates.push(h[0], h[1]), c = this.coordinates.length, this.instructions.push([
            H.CUSTOM,
            l,
            c,
            t,
            n,
            void 0,
            r
          ]), this.hitDetectionInstructions.push([
            H.CUSTOM,
            l,
            c,
            t,
            s || n,
            void 0,
            r
          ]);
          break;
      }
      this.endGeometry(e);
    }
    /**
     * @protected
     * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} index Render order index
     */
    beginGeometry(t, e, n) {
      this.beginGeometryInstruction1_ = [
        H.BEGIN_GEOMETRY,
        e,
        0,
        t,
        n
      ], this.instructions.push(this.beginGeometryInstruction1_), this.beginGeometryInstruction2_ = [
        H.BEGIN_GEOMETRY,
        e,
        0,
        t,
        n
      ], this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */
    finish() {
      return {
        instructions: this.instructions,
        hitDetectionInstructions: this.hitDetectionInstructions,
        coordinates: this.coordinates
      };
    }
    /**
     * Reverse the hit detection instructions.
     */
    reverseHitDetectionInstructions() {
      const t = this.hitDetectionInstructions;
      t.reverse();
      let e;
      const n = t.length;
      let s, r, a = -1;
      for (e = 0; e < n; ++e)
        s = t[e], r = /** @type {import("./Instruction.js").default} */
        s[0], r == H.END_GEOMETRY ? a = e : r == H.BEGIN_GEOMETRY && (s[2] = e, y0(this.hitDetectionInstructions, a, e), a = -1);
    }
    /**
     * @param {import("../../style/Fill.js").default} fillStyle Fill style.
     * @param {import('../canvas.js').FillStrokeState} [state] State.
     * @return {import('../canvas.js').FillStrokeState} State.
     */
    fillStyleToState(t, e = (
      /** @type {import('../canvas.js').FillStrokeState} */
      {}
    )) {
      if (t) {
        const n = t.getColor();
        e.fillPatternScale = n && typeof n == "object" && "src" in n ? this.pixelRatio : 1, e.fillStyle = si(
          n || xe
        );
      } else
        e.fillStyle = void 0;
      return e;
    }
    /**
     * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @return {import("../canvas.js").FillStrokeState} State.
     */
    strokeStyleToState(t, e = (
      /** @type {import('../canvas.js').FillStrokeState} */
      {}
    )) {
      if (t) {
        const n = t.getColor();
        e.strokeStyle = si(
          n || Ir
        );
        const s = t.getLineCap();
        e.lineCap = s !== void 0 ? s : Os;
        const r = t.getLineDash();
        e.lineDash = r ? r.slice() : xi;
        const a = t.getLineDashOffset();
        e.lineDashOffset = a || wi;
        const o = t.getLineJoin();
        e.lineJoin = o !== void 0 ? o : Ns;
        const l = t.getWidth();
        e.lineWidth = l !== void 0 ? l : Ar;
        const h = t.getMiterLimit();
        e.miterLimit = h !== void 0 ? h : Rr, e.lineWidth > this.maxLineWidth && (this.maxLineWidth = e.lineWidth, this.bufferedMaxExtent_ = null);
      } else
        e.strokeStyle = void 0, e.lineCap = void 0, e.lineDash = null, e.lineDashOffset = void 0, e.lineJoin = void 0, e.lineWidth = void 0, e.miterLimit = void 0;
      return e;
    }
    /**
     * @param {import("../../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
     * @override
     */
    setFillStrokeStyle(t, e) {
      const n = this.state;
      this.fillStyleToState(t, n), this.strokeStyleToState(e, n);
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @return {Array<*>} Fill instruction.
     */
    createFill(t) {
      const e = t.fillStyle, n = [H.SET_FILL_STYLE, e];
      return typeof e != "string" && n.push(t.fillPatternScale), n;
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     */
    applyStroke(t) {
      this.instructions.push(this.createStroke(t));
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @return {Array<*>} Stroke instruction.
     */
    createStroke(t) {
      return [
        H.SET_STROKE_STYLE,
        t.strokeStyle,
        t.lineWidth * this.pixelRatio,
        t.lineCap,
        t.lineJoin,
        t.miterLimit,
        t.lineDash ? this.applyPixelRatio(t.lineDash) : null,
        t.lineDashOffset * this.pixelRatio
      ];
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
     */
    updateFillStyle(t, e) {
      const n = t.fillStyle;
      (typeof n != "string" || t.currentFillStyle != n) && (n !== void 0 && this.instructions.push(e.call(this, t)), t.currentFillStyle = n);
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
     */
    updateStrokeStyle(t, e) {
      const n = t.strokeStyle, s = t.lineCap, r = t.lineDash, a = t.lineDashOffset, o = t.lineJoin, l = t.lineWidth, h = t.miterLimit;
      (t.currentStrokeStyle != n || t.currentLineCap != s || r != t.currentLineDash && !rn(t.currentLineDash, r) || t.currentLineDashOffset != a || t.currentLineJoin != o || t.currentLineWidth != l || t.currentMiterLimit != h) && (n !== void 0 && e.call(this, t), t.currentStrokeStyle = n, t.currentLineCap = s, t.currentLineDash = r, t.currentLineDashOffset = a, t.currentLineJoin = o, t.currentLineWidth = l, t.currentMiterLimit = h);
    }
    /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
    endGeometry(t) {
      this.beginGeometryInstruction1_[2] = this.instructions.length, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length, this.beginGeometryInstruction2_ = null;
      const e = [H.END_GEOMETRY, t];
      this.instructions.push(e), this.hitDetectionInstructions.push(e);
    }
    /**
     * Get the buffered rendering extent.  Rendering will be clipped to the extent
     * provided to the constructor.  To account for symbolizers that may intersect
     * this extent, we calculate a buffered extent (e.g. based on stroke width).
     * @return {import("../../extent.js").Extent} The buffered rendering extent.
     * @protected
     */
    getBufferedMaxExtent() {
      if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = ih(this.maxExtent), this.maxLineWidth > 0)) {
        const t = this.resolution * (this.maxLineWidth + 1) / 2;
        uo(this.bufferedMaxExtent_, t, this.bufferedMaxExtent_);
      }
      return this.bufferedMaxExtent_;
    }
  }
  class gy extends Vr {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(t, e, n, s) {
      super(t, e, n, s), this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.anchorX_ = void 0, this.anchorY_ = void 0, this.height_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.scale_ = void 0, this.width_ = void 0, this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
    }
    /**
     * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     * @override
     */
    drawPoint(t, e, n) {
      if (!this.image_ || this.maxExtent && !Fn(this.maxExtent, t.getFlatCoordinates()))
        return;
      this.beginGeometry(t, e, n);
      const s = t.getFlatCoordinates(), r = t.getStride(), a = this.coordinates.length, o = this.appendFlatPointCoordinates(s, r);
      this.instructions.push([
        H.DRAW_IMAGE,
        a,
        o,
        this.image_,
        // Remaining arguments to DRAW_IMAGE are in alphabetical order
        this.anchorX_ * this.imagePixelRatio_,
        this.anchorY_ * this.imagePixelRatio_,
        Math.ceil(this.height_ * this.imagePixelRatio_),
        this.opacity_,
        this.originX_ * this.imagePixelRatio_,
        this.originY_ * this.imagePixelRatio_,
        this.rotateWithView_,
        this.rotation_,
        [
          this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
          this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
        ],
        Math.ceil(this.width_ * this.imagePixelRatio_),
        this.declutterMode_,
        this.declutterImageWithText_
      ]), this.hitDetectionInstructions.push([
        H.DRAW_IMAGE,
        a,
        o,
        this.hitDetectionImage_,
        // Remaining arguments to DRAW_IMAGE are in alphabetical order
        this.anchorX_,
        this.anchorY_,
        this.height_,
        1,
        this.originX_,
        this.originY_,
        this.rotateWithView_,
        this.rotation_,
        this.scale_,
        this.width_,
        this.declutterMode_,
        this.declutterImageWithText_
      ]), this.endGeometry(e);
    }
    /**
     * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     * @override
     */
    drawMultiPoint(t, e, n) {
      if (!this.image_)
        return;
      this.beginGeometry(t, e, n);
      const s = t.getFlatCoordinates(), r = [];
      for (let l = 0, h = s.length; l < h; l += t.getStride())
        (!this.maxExtent || Fn(this.maxExtent, s.slice(l, l + 2))) && r.push(
          s[l],
          s[l + 1]
        );
      const a = this.coordinates.length, o = this.appendFlatPointCoordinates(r, 2);
      this.instructions.push([
        H.DRAW_IMAGE,
        a,
        o,
        this.image_,
        // Remaining arguments to DRAW_IMAGE are in alphabetical order
        this.anchorX_ * this.imagePixelRatio_,
        this.anchorY_ * this.imagePixelRatio_,
        Math.ceil(this.height_ * this.imagePixelRatio_),
        this.opacity_,
        this.originX_ * this.imagePixelRatio_,
        this.originY_ * this.imagePixelRatio_,
        this.rotateWithView_,
        this.rotation_,
        [
          this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
          this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
        ],
        Math.ceil(this.width_ * this.imagePixelRatio_),
        this.declutterMode_,
        this.declutterImageWithText_
      ]), this.hitDetectionInstructions.push([
        H.DRAW_IMAGE,
        a,
        o,
        this.hitDetectionImage_,
        // Remaining arguments to DRAW_IMAGE are in alphabetical order
        this.anchorX_,
        this.anchorY_,
        this.height_,
        1,
        this.originX_,
        this.originY_,
        this.rotateWithView_,
        this.rotation_,
        this.scale_,
        this.width_,
        this.declutterMode_,
        this.declutterImageWithText_
      ]), this.endGeometry(e);
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     * @override
     */
    finish() {
      return this.reverseHitDetectionInstructions(), this.anchorX_ = void 0, this.anchorY_ = void 0, this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.height_ = void 0, this.scale_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.width_ = void 0, super.finish();
    }
    /**
     * @param {import("../../style/Image.js").default} imageStyle Image style.
     * @param {Object} [sharedData] Shared data.
     * @override
     */
    setImageStyle(t, e) {
      const n = t.getAnchor(), s = t.getSize(), r = t.getOrigin();
      this.imagePixelRatio_ = t.getPixelRatio(this.pixelRatio), this.anchorX_ = n[0], this.anchorY_ = n[1], this.hitDetectionImage_ = t.getHitDetectionImage(), this.image_ = t.getImage(this.pixelRatio), this.height_ = s[1], this.opacity_ = t.getOpacity(), this.originX_ = r[0], this.originY_ = r[1], this.rotateWithView_ = t.getRotateWithView(), this.rotation_ = t.getRotation(), this.scale_ = t.getScaleArray(), this.width_ = s[0], this.declutterMode_ = t.getDeclutterMode(), this.declutterImageWithText_ = e;
    }
  }
  class my extends Vr {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(t, e, n, s) {
      super(t, e, n, s);
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @private
     * @return {number} end.
     */
    drawFlatCoordinates_(t, e, n, s) {
      const r = this.coordinates.length, a = this.appendFlatLineCoordinates(
        t,
        e,
        n,
        s,
        !1,
        !1
      ), o = [
        H.MOVE_TO_LINE_TO,
        r,
        a
      ];
      return this.instructions.push(o), this.hitDetectionInstructions.push(o), n;
    }
    /**
     * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     * @override
     */
    drawLineString(t, e, n) {
      const s = this.state, r = s.strokeStyle, a = s.lineWidth;
      if (r === void 0 || a === void 0)
        return;
      this.updateStrokeStyle(s, this.applyStroke), this.beginGeometry(t, e, n), this.hitDetectionInstructions.push(
        [
          H.SET_STROKE_STYLE,
          s.strokeStyle,
          s.lineWidth,
          s.lineCap,
          s.lineJoin,
          s.miterLimit,
          xi,
          wi
        ],
        bn
      );
      const o = t.getFlatCoordinates(), l = t.getStride();
      this.drawFlatCoordinates_(
        o,
        0,
        o.length,
        l
      ), this.hitDetectionInstructions.push(Yi), this.endGeometry(e);
    }
    /**
     * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     * @override
     */
    drawMultiLineString(t, e, n) {
      const s = this.state, r = s.strokeStyle, a = s.lineWidth;
      if (r === void 0 || a === void 0)
        return;
      this.updateStrokeStyle(s, this.applyStroke), this.beginGeometry(t, e, n), this.hitDetectionInstructions.push(
        [
          H.SET_STROKE_STYLE,
          s.strokeStyle,
          s.lineWidth,
          s.lineCap,
          s.lineJoin,
          s.miterLimit,
          xi,
          wi
        ],
        bn
      );
      const o = t.getEnds(), l = t.getFlatCoordinates(), h = t.getStride();
      let c = 0;
      for (let u = 0, d = o.length; u < d; ++u)
        c = this.drawFlatCoordinates_(
          l,
          c,
          /** @type {number} */
          o[u],
          h
        );
      this.hitDetectionInstructions.push(Yi), this.endGeometry(e);
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     * @override
     */
    finish() {
      const t = this.state;
      return t.lastStroke != null && t.lastStroke != this.coordinates.length && this.instructions.push(Yi), this.reverseHitDetectionInstructions(), this.state = null, super.finish();
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @override
     */
    applyStroke(t) {
      t.lastStroke != null && t.lastStroke != this.coordinates.length && (this.instructions.push(Yi), t.lastStroke = this.coordinates.length), t.lastStroke = 0, super.applyStroke(t), this.instructions.push(bn);
    }
  }
  class xu extends Vr {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(t, e, n, s) {
      super(t, e, n, s);
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @private
     * @return {number} End.
     */
    drawFlatCoordinatess_(t, e, n, s) {
      const r = this.state, a = r.fillStyle !== void 0, o = r.strokeStyle !== void 0, l = n.length;
      this.instructions.push(bn), this.hitDetectionInstructions.push(bn);
      for (let h = 0; h < l; ++h) {
        const c = n[h], u = this.coordinates.length, d = this.appendFlatLineCoordinates(
          t,
          e,
          c,
          s,
          !0,
          !o
        ), g = [
          H.MOVE_TO_LINE_TO,
          u,
          d
        ];
        this.instructions.push(g), this.hitDetectionInstructions.push(g), o && (this.instructions.push(Mu), this.hitDetectionInstructions.push(Mu)), e = c;
      }
      return a && (this.instructions.push(Ea), this.hitDetectionInstructions.push(Ea)), o && (this.instructions.push(Yi), this.hitDetectionInstructions.push(Yi)), e;
    }
    /**
     * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
     * @param {import("../../Feature.js").default} feature Feature.
     * @param {number} [index] Render order index.
     * @override
     */
    drawCircle(t, e, n) {
      const s = this.state, r = s.fillStyle, a = s.strokeStyle;
      if (r === void 0 && a === void 0)
        return;
      this.setFillStrokeStyles_(), this.beginGeometry(t, e, n), s.fillStyle !== void 0 && this.hitDetectionInstructions.push([
        H.SET_FILL_STYLE,
        xe
      ]), s.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
        H.SET_STROKE_STYLE,
        s.strokeStyle,
        s.lineWidth,
        s.lineCap,
        s.lineJoin,
        s.miterLimit,
        xi,
        wi
      ]);
      const o = t.getFlatCoordinates(), l = t.getStride(), h = this.coordinates.length;
      this.appendFlatLineCoordinates(
        o,
        0,
        o.length,
        l,
        !1,
        !1
      );
      const c = [H.CIRCLE, h];
      this.instructions.push(bn, c), this.hitDetectionInstructions.push(bn, c), s.fillStyle !== void 0 && (this.instructions.push(Ea), this.hitDetectionInstructions.push(Ea)), s.strokeStyle !== void 0 && (this.instructions.push(Yi), this.hitDetectionInstructions.push(Yi)), this.endGeometry(e);
    }
    /**
     * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     * @override
     */
    drawPolygon(t, e, n) {
      const s = this.state, r = s.fillStyle, a = s.strokeStyle;
      if (r === void 0 && a === void 0)
        return;
      this.setFillStrokeStyles_(), this.beginGeometry(t, e, n), s.fillStyle !== void 0 && this.hitDetectionInstructions.push([
        H.SET_FILL_STYLE,
        xe
      ]), s.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
        H.SET_STROKE_STYLE,
        s.strokeStyle,
        s.lineWidth,
        s.lineCap,
        s.lineJoin,
        s.miterLimit,
        xi,
        wi
      ]);
      const o = t.getEnds(), l = t.getOrientedFlatCoordinates(), h = t.getStride();
      this.drawFlatCoordinatess_(
        l,
        0,
        /** @type {Array<number>} */
        o,
        h
      ), this.endGeometry(e);
    }
    /**
     * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     * @override
     */
    drawMultiPolygon(t, e, n) {
      const s = this.state, r = s.fillStyle, a = s.strokeStyle;
      if (r === void 0 && a === void 0)
        return;
      this.setFillStrokeStyles_(), this.beginGeometry(t, e, n), s.fillStyle !== void 0 && this.hitDetectionInstructions.push([
        H.SET_FILL_STYLE,
        xe
      ]), s.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
        H.SET_STROKE_STYLE,
        s.strokeStyle,
        s.lineWidth,
        s.lineCap,
        s.lineJoin,
        s.miterLimit,
        xi,
        wi
      ]);
      const o = t.getEndss(), l = t.getOrientedFlatCoordinates(), h = t.getStride();
      let c = 0;
      for (let u = 0, d = o.length; u < d; ++u)
        c = this.drawFlatCoordinatess_(
          l,
          c,
          o[u],
          h
        );
      this.endGeometry(e);
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     * @override
     */
    finish() {
      this.reverseHitDetectionInstructions(), this.state = null;
      const t = this.tolerance;
      if (t !== 0) {
        const e = this.coordinates;
        for (let n = 0, s = e.length; n < s; ++n)
          e[n] = Sn(e[n], t);
      }
      return super.finish();
    }
    /**
     * @private
     */
    setFillStrokeStyles_() {
      const t = this.state;
      t.fillStyle !== void 0 && this.updateFillStyle(t, this.createFill), t.strokeStyle !== void 0 && this.updateStrokeStyle(t, this.applyStroke);
    }
  }
  function _y(i, t, e, n, s) {
    const r = [];
    let a = e, o = 0, l = t.slice(e, 2);
    for (; o < i && a + s < n; ) {
      const [h, c] = l.slice(-2), u = t[a + s], d = t[a + s + 1], g = Math.sqrt(
        (u - h) * (u - h) + (d - c) * (d - c)
      );
      if (o += g, o >= i) {
        const _ = (i - o + g) / g, y = be(h, u, _), E = be(c, d, _);
        l.push(y, E), r.push(l), l = [y, E], o == i && (a += s), o = 0;
      } else if (o < i)
        l.push(
          t[a + s],
          t[a + s + 1]
        ), a += s;
      else {
        const _ = g - o, y = be(h, u, _ / g), E = be(c, d, _ / g);
        l.push(y, E), r.push(l), l = [y, E], o = 0, a += s;
      }
    }
    return o > 0 && r.push(l), r;
  }
  function py(i, t, e, n, s) {
    let r = e, a = e, o = 0, l = 0, h = e, c, u, d, g, _, y, E, M, w, R;
    for (u = e; u < n; u += s) {
      const S = t[u], C = t[u + 1];
      _ !== void 0 && (w = S - _, R = C - y, g = Math.sqrt(w * w + R * R), E !== void 0 && (l += d, c = Math.acos((E * w + M * R) / (d * g)), c > i && (l > o && (o = l, r = h, a = u), l = 0, h = u - s)), d = g, E = w, M = R), _ = S, y = C;
    }
    return l += g, l > o ? [h, u] : [r, a];
  }
  const Ha = {
    left: 0,
    center: 0.5,
    right: 1,
    top: 0,
    middle: 0.5,
    hanging: 0.2,
    alphabetic: 0.8,
    ideographic: 0.8,
    bottom: 1
  };
  class yy extends Vr {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(t, e, n, s) {
      super(t, e, n, s), this.labels_ = null, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = void 0, this.textKeepUpright_ = void 0, this.textRotation_ = 0, this.textFillState_ = null, this.fillStates = {}, this.fillStates[xe] = { fillStyle: xe }, this.textStrokeState_ = null, this.strokeStates = {}, this.textState_ = /** @type {import("../canvas.js").TextState} */
      {}, this.textStates = {}, this.textKey_ = "", this.fillKey_ = "", this.strokeKey_ = "", this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     * @override
     */
    finish() {
      const t = super.finish();
      return t.textStates = this.textStates, t.fillStates = this.fillStates, t.strokeStates = this.strokeStates, t;
    }
    /**
     * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     * @override
     */
    drawText(t, e, n) {
      const s = this.textFillState_, r = this.textStrokeState_, a = this.textState_;
      if (this.text_ === "" || !a || !s && !r)
        return;
      const o = this.coordinates;
      let l = o.length;
      const h = t.getType();
      let c = null, u = t.getStride();
      if (a.placement === "line" && (h == "LineString" || h == "MultiLineString" || h == "Polygon" || h == "MultiPolygon")) {
        if (!he(this.maxExtent, t.getExtent()))
          return;
        let d;
        if (c = t.getFlatCoordinates(), h == "LineString")
          d = [c.length];
        else if (h == "MultiLineString")
          d = /** @type {import("../../geom/MultiLineString.js").default} */
          t.getEnds();
        else if (h == "Polygon")
          d = /** @type {import("../../geom/Polygon.js").default} */
          t.getEnds().slice(0, 1);
        else if (h == "MultiPolygon") {
          const E = (
            /** @type {import("../../geom/MultiPolygon.js").default} */
            t.getEndss()
          );
          d = [];
          for (let M = 0, w = E.length; M < w; ++M)
            d.push(E[M][0]);
        }
        this.beginGeometry(t, e, n);
        const g = a.repeat, _ = g ? void 0 : a.textAlign;
        let y = 0;
        for (let E = 0, M = d.length; E < M; ++E) {
          let w;
          g ? w = _y(
            g * this.resolution,
            c,
            y,
            d[E],
            u
          ) : w = [c.slice(y, d[E])];
          for (let R = 0, S = w.length; R < S; ++R) {
            const C = w[R];
            let T = 0, L = C.length;
            if (_ == null) {
              const O = py(
                a.maxAngle,
                C,
                0,
                C.length,
                2
              );
              T = O[0], L = O[1];
            }
            for (let O = T; O < L; O += u)
              o.push(C[O], C[O + 1]);
            const A = o.length;
            y = d[E], this.drawChars_(l, A), l = A;
          }
        }
        this.endGeometry(e);
      } else {
        let d = a.overflow ? null : [];
        switch (h) {
          case "Point":
          case "MultiPoint":
            c = /** @type {import("../../geom/MultiPoint.js").default} */
            t.getFlatCoordinates();
            break;
          case "LineString":
            c = /** @type {import("../../geom/LineString.js").default} */
            t.getFlatMidpoint();
            break;
          case "Circle":
            c = /** @type {import("../../geom/Circle.js").default} */
            t.getCenter();
            break;
          case "MultiLineString":
            c = /** @type {import("../../geom/MultiLineString.js").default} */
            t.getFlatMidpoints(), u = 2;
            break;
          case "Polygon":
            c = /** @type {import("../../geom/Polygon.js").default} */
            t.getFlatInteriorPoint(), a.overflow || d.push(c[2] / this.resolution), u = 3;
            break;
          case "MultiPolygon":
            const S = (
              /** @type {import("../../geom/MultiPolygon.js").default} */
              t.getFlatInteriorPoints()
            );
            c = [];
            for (let C = 0, T = S.length; C < T; C += 3)
              a.overflow || d.push(S[C + 2] / this.resolution), c.push(S[C], S[C + 1]);
            if (c.length === 0)
              return;
            u = 2;
            break;
        }
        const g = this.appendFlatPointCoordinates(c, u);
        if (g === l)
          return;
        if (d && (g - l) / 2 !== c.length / u) {
          let S = l / 2;
          d = d.filter((C, T) => {
            const L = o[(S + T) * 2] === c[T * u] && o[(S + T) * 2 + 1] === c[T * u + 1];
            return L || --S, L;
          });
        }
        this.saveTextStates_();
        const _ = a.backgroundFill ? this.createFill(this.fillStyleToState(a.backgroundFill)) : null, y = a.backgroundStroke ? this.createStroke(this.strokeStyleToState(a.backgroundStroke)) : null;
        this.beginGeometry(t, e, n);
        let E = a.padding;
        if (E != An && (a.scale[0] < 0 || a.scale[1] < 0)) {
          let S = a.padding[0], C = a.padding[1], T = a.padding[2], L = a.padding[3];
          a.scale[0] < 0 && (C = -C, L = -L), a.scale[1] < 0 && (S = -S, T = -T), E = [S, C, T, L];
        }
        const M = this.pixelRatio;
        this.instructions.push([
          H.DRAW_IMAGE,
          l,
          g,
          null,
          NaN,
          NaN,
          NaN,
          1,
          0,
          0,
          this.textRotateWithView_,
          this.textRotation_,
          [1, 1],
          NaN,
          this.declutterMode_,
          this.declutterImageWithText_,
          E == An ? An : E.map(function(S) {
            return S * M;
          }),
          _,
          y,
          this.text_,
          this.textKey_,
          this.strokeKey_,
          this.fillKey_,
          this.textOffsetX_,
          this.textOffsetY_,
          d
        ]);
        const w = 1 / M, R = _ ? _.slice(0) : null;
        R && (R[1] = xe), this.hitDetectionInstructions.push([
          H.DRAW_IMAGE,
          l,
          g,
          null,
          NaN,
          NaN,
          NaN,
          1,
          0,
          0,
          this.textRotateWithView_,
          this.textRotation_,
          [w, w],
          NaN,
          this.declutterMode_,
          this.declutterImageWithText_,
          E,
          R,
          y,
          this.text_,
          this.textKey_,
          this.strokeKey_,
          this.fillKey_ ? xe : this.fillKey_,
          this.textOffsetX_,
          this.textOffsetY_,
          d
        ]), this.endGeometry(e);
      }
    }
    /**
     * @private
     */
    saveTextStates_() {
      const t = this.textStrokeState_, e = this.textState_, n = this.textFillState_, s = this.strokeKey_;
      t && (s in this.strokeStates || (this.strokeStates[s] = {
        strokeStyle: t.strokeStyle,
        lineCap: t.lineCap,
        lineDashOffset: t.lineDashOffset,
        lineWidth: t.lineWidth,
        lineJoin: t.lineJoin,
        miterLimit: t.miterLimit,
        lineDash: t.lineDash
      }));
      const r = this.textKey_;
      r in this.textStates || (this.textStates[r] = {
        font: e.font,
        textAlign: e.textAlign || Tr,
        justify: e.justify,
        textBaseline: e.textBaseline || Ya,
        scale: e.scale
      });
      const a = this.fillKey_;
      n && (a in this.fillStates || (this.fillStates[a] = {
        fillStyle: n.fillStyle
      }));
    }
    /**
     * @private
     * @param {number} begin Begin.
     * @param {number} end End.
     */
    drawChars_(t, e) {
      const n = this.textStrokeState_, s = this.textState_, r = this.strokeKey_, a = this.textKey_, o = this.fillKey_;
      this.saveTextStates_();
      const l = this.pixelRatio, h = Ha[s.textBaseline], c = this.textOffsetY_ * l, u = this.text_, d = n ? n.lineWidth * Math.abs(s.scale[0]) / 2 : 0;
      this.instructions.push([
        H.DRAW_CHARS,
        t,
        e,
        h,
        s.overflow,
        o,
        s.maxAngle,
        l,
        c,
        r,
        d * l,
        u,
        a,
        1,
        this.declutterMode_,
        this.textKeepUpright_
      ]), this.hitDetectionInstructions.push([
        H.DRAW_CHARS,
        t,
        e,
        h,
        s.overflow,
        o && xe,
        s.maxAngle,
        l,
        c,
        r,
        d * l,
        u,
        a,
        1 / l,
        this.declutterMode_,
        this.textKeepUpright_
      ]);
    }
    /**
     * @param {import("../../style/Text.js").default} textStyle Text style.
     * @param {Object} [sharedData] Shared data.
     * @override
     */
    setTextStyle(t, e) {
      let n, s, r;
      if (!t)
        this.text_ = "";
      else {
        const a = t.getFill();
        a ? (s = this.textFillState_, s || (s = /** @type {import("../canvas.js").FillState} */
        {}, this.textFillState_ = s), s.fillStyle = si(
          a.getColor() || xe
        )) : (s = null, this.textFillState_ = s);
        const o = t.getStroke();
        if (!o)
          r = null, this.textStrokeState_ = r;
        else {
          r = this.textStrokeState_, r || (r = /** @type {import("../canvas.js").StrokeState} */
          {}, this.textStrokeState_ = r);
          const y = o.getLineDash(), E = o.getLineDashOffset(), M = o.getWidth(), w = o.getMiterLimit();
          r.lineCap = o.getLineCap() || Os, r.lineDash = y ? y.slice() : xi, r.lineDashOffset = E === void 0 ? wi : E, r.lineJoin = o.getLineJoin() || Ns, r.lineWidth = M === void 0 ? Ar : M, r.miterLimit = w === void 0 ? Rr : w, r.strokeStyle = si(
            o.getColor() || Ir
          );
        }
        n = this.textState_;
        const l = t.getFont() || ef;
        vp(l);
        const h = t.getScaleArray();
        n.overflow = t.getOverflow(), n.font = l, n.maxAngle = t.getMaxAngle(), n.placement = t.getPlacement(), n.textAlign = t.getTextAlign(), n.repeat = t.getRepeat(), n.justify = t.getJustify(), n.textBaseline = t.getTextBaseline() || Ya, n.backgroundFill = t.getBackgroundFill(), n.backgroundStroke = t.getBackgroundStroke(), n.padding = t.getPadding() || An, n.scale = h === void 0 ? [1, 1] : h;
        const c = t.getOffsetX(), u = t.getOffsetY(), d = t.getRotateWithView(), g = t.getKeepUpright(), _ = t.getRotation();
        this.text_ = t.getText() || "", this.textOffsetX_ = c === void 0 ? 0 : c, this.textOffsetY_ = u === void 0 ? 0 : u, this.textRotateWithView_ = d === void 0 ? !1 : d, this.textKeepUpright_ = g === void 0 ? !0 : g, this.textRotation_ = _ === void 0 ? 0 : _, this.strokeKey_ = r ? (typeof r.strokeStyle == "string" ? r.strokeStyle : Ct(r.strokeStyle)) + r.lineCap + r.lineDashOffset + "|" + r.lineWidth + r.lineJoin + r.miterLimit + "[" + r.lineDash.join() + "]" : "", this.textKey_ = n.font + n.scale + (n.textAlign || "?") + (n.repeat || "?") + (n.justify || "?") + (n.textBaseline || "?"), this.fillKey_ = s && s.fillStyle ? typeof s.fillStyle == "string" ? s.fillStyle : "|" + Ct(s.fillStyle) : "";
      }
      this.declutterMode_ = t.getDeclutterMode(), this.declutterImageWithText_ = e;
    }
  }
  const vy = {
    Circle: xu,
    Default: Vr,
    Image: gy,
    LineString: my,
    Polygon: xu,
    Text: yy
  };
  class Ey {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Max extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(t, e, n, s) {
      this.tolerance_ = t, this.maxExtent_ = e, this.pixelRatio_ = s, this.resolution_ = n, this.buildersByZIndex_ = {};
    }
    /**
     * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
     */
    finish() {
      const t = {};
      for (const e in this.buildersByZIndex_) {
        t[e] = t[e] || {};
        const n = this.buildersByZIndex_[e];
        for (const s in n) {
          const r = n[s].finish();
          t[e][s] = r;
        }
      }
      return t;
    }
    /**
     * @param {number|undefined} zIndex Z index.
     * @param {import("../canvas.js").BuilderType} builderType Replay type.
     * @return {import("../VectorContext.js").default} Replay.
     */
    getBuilder(t, e) {
      const n = t !== void 0 ? t.toString() : "0";
      let s = this.buildersByZIndex_[n];
      s === void 0 && (s = {}, this.buildersByZIndex_[n] = s);
      let r = s[e];
      if (r === void 0) {
        const a = vy[e];
        r = new a(
          this.tolerance_,
          this.maxExtent_,
          this.resolution_,
          this.pixelRatio_
        ), s[e] = r;
      }
      return r;
    }
  }
  function My(i, t, e, n, s, r, a, o, l, h, c, u, d = !0) {
    let g = i[t], _ = i[t + 1], y = 0, E = 0, M = 0, w = 0;
    function R() {
      y = g, E = _, t += n, g = i[t], _ = i[t + 1], w += M, M = Math.sqrt((g - y) * (g - y) + (_ - E) * (_ - E));
    }
    do
      R();
    while (t < e - n && w + M < r);
    let S = M === 0 ? 0 : (r - w) / M;
    const C = be(y, g, S), T = be(E, _, S), L = t - n, A = w, O = r + o * l(h, s, c);
    for (; t < e - n && w + M < O; )
      R();
    S = M === 0 ? 0 : (O - w) / M;
    const $ = be(y, g, S), q = be(E, _, S);
    let Z = !1;
    if (d)
      if (u) {
        const st = [C, T, $, q];
        _h(st, 0, 4, 2, u, st, st), Z = st[0] > st[2];
      } else
        Z = C > $;
    const Q = Math.PI, X = [], mt = L + n === t;
    t = L, M = 0, w = A, g = i[t], _ = i[t + 1];
    let V;
    if (mt) {
      R(), V = Math.atan2(_ - E, g - y), Z && (V += V > 0 ? -Q : Q);
      const st = ($ + C) / 2, et = (q + T) / 2;
      return X[0] = [st, et, (O - r) / 2, V, s], X;
    }
    s = s.replace(/\n/g, " ");
    for (let st = 0, et = s.length; st < et; ) {
      R();
      let lt = Math.atan2(_ - E, g - y);
      if (Z && (lt += lt > 0 ? -Q : Q), V !== void 0) {
        let dt = lt - V;
        if (dt += dt > Q ? -2 * Q : dt < -Q ? 2 * Q : 0, Math.abs(dt) > a)
          return null;
      }
      V = lt;
      const rt = st;
      let tt = 0;
      for (; st < et; ++st) {
        const dt = Z ? et - st - 1 : st, Vt = o * l(h, s[dt], c);
        if (t + n < e && w + M < r + tt + Vt / 2)
          break;
        tt += Vt;
      }
      if (st === rt)
        continue;
      const D = Z ? s.substring(et - rt, et - st) : s.substring(rt, st);
      S = M === 0 ? 0 : (r + tt / 2 - w) / M;
      const _t = be(y, g, S), U = be(E, _, S);
      X.push([_t, U, tt / 2, lt, D]), r += tt;
    }
    return X;
  }
  class Ef {
    constructor() {
      /**
       * @private
       * @param {...*} args Args.
       * @return {ZIndexContext} This.
       */
      En(this, "pushMethodArgs_", (...t) => (this.instructions_[this.zIndex + this.offset_].push(t), this));
      this.instructions_ = [], this.zIndex = 0, this.offset_ = 0, this.context_ = /** @type {ZIndexContextProxy} */
      new Proxy(Xa(), {
        get: (t, e) => {
          if (typeof /** @type {*} */
          Xa()[e] == "function")
            return this.instructions_[this.zIndex + this.offset_] || (this.instructions_[this.zIndex + this.offset_] = []), this.instructions_[this.zIndex + this.offset_].push(e), this.pushMethodArgs_;
        },
        set: (t, e, n) => (this.instructions_[this.zIndex + this.offset_] || (this.instructions_[this.zIndex + this.offset_] = []), this.instructions_[this.zIndex + this.offset_].push(e, n), !0)
      });
    }
    /**
     * Push a function that renders to the context directly.
     * @param {function(CanvasRenderingContext2D): void} render Function.
     */
    pushFunction(t) {
      this.instructions_[this.zIndex + this.offset_].push(t);
    }
    /**
     * Get a proxy for CanvasRenderingContext2D which does not support getting state
     * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a
     * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,
     * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.
     * @return {ZIndexContextProxy} Context.
     */
    getContext() {
      return this.context_;
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     */
    draw(t) {
      this.instructions_.forEach((e) => {
        for (let n = 0, s = e.length; n < s; ++n) {
          const r = e[n];
          if (typeof r == "function") {
            r(t);
            continue;
          }
          const a = e[++n];
          if (typeof /** @type {*} */
          t[r] == "function")
            t[r](...a);
          else {
            if (typeof a == "function") {
              t[r] = a(t);
              continue;
            }
            t[r] = a;
          }
        }
      });
    }
    clear() {
      this.instructions_.length = 0, this.zIndex = 0, this.offset_ = 0;
    }
    /**
     * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to
     * avoid conflicting context.clip() or context.save()/restore() calls.
     */
    offset() {
      this.offset_ = this.instructions_.length, this.zIndex = 0;
    }
  }
  const es = Pe(), ki = [], mi = [], _i = [], Gi = [];
  function wu(i) {
    return i[3].declutterBox;
  }
  const Su = new RegExp(
    /* eslint-disable prettier/prettier */
    "[-----]"
    /* eslint-enable prettier/prettier */
  );
  function al(i, t) {
    return t === "start" ? t = Su.test(i) ? "right" : "left" : t === "end" && (t = Su.test(i) ? "left" : "right"), Ha[t];
  }
  function xy(i, t, e) {
    return e > 0 && i.push(`
`, ""), i.push(t, ""), i;
  }
  class wy {
    /**
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {boolean} overlaps The replay can have overlapping geometries.
     * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions.
     * @param {boolean} [deferredRendering] Enable deferred rendering.
     */
    constructor(t, e, n, s, r) {
      this.overlaps = n, this.pixelRatio = e, this.resolution = t, this.alignAndScaleFill_, this.instructions = s.instructions, this.coordinates = s.coordinates, this.coordinateCache_ = {}, this.renderedTransform_ = $e(), this.hitDetectionInstructions = s.hitDetectionInstructions, this.pixelCoordinates_ = null, this.viewRotation_ = 0, this.fillStates = s.fillStates || {}, this.strokeStates = s.strokeStates || {}, this.textStates = s.textStates || {}, this.widths_ = {}, this.labels_ = {}, this.zIndexContext_ = r ? new Ef() : null;
    }
    /**
     * @return {ZIndexContext} ZIndex context.
     */
    getZIndexContext() {
      return this.zIndexContext_;
    }
    /**
     * @param {string|Array<string>} text Text.
     * @param {string} textKey Text style key.
     * @param {string} fillKey Fill style key.
     * @param {string} strokeKey Stroke style key.
     * @return {import("../canvas.js").Label} Label.
     */
    createLabel(t, e, n, s) {
      const r = t + e + n + s;
      if (this.labels_[r])
        return this.labels_[r];
      const a = s ? this.strokeStates[s] : null, o = n ? this.fillStates[n] : null, l = this.textStates[e], h = this.pixelRatio, c = [
        l.scale[0] * h,
        l.scale[1] * h
      ], u = l.justify ? Ha[l.justify] : al(
        Array.isArray(t) ? t[0] : t,
        l.textAlign || Tr
      ), d = s && a.lineWidth ? a.lineWidth : 0, g = Array.isArray(t) ? t : String(t).split(`
`).reduce(xy, []), { width: _, height: y, widths: E, heights: M, lineWidths: w } = Mp(
        l,
        g
      ), R = _ + d, S = [], C = (R + 2) * c[0], T = (y + d) * c[1], L = {
        width: C < 0 ? Math.floor(C) : Math.ceil(C),
        height: T < 0 ? Math.floor(T) : Math.ceil(T),
        contextInstructions: S
      };
      (c[0] != 1 || c[1] != 1) && S.push("scale", c), s && (S.push("strokeStyle", a.strokeStyle), S.push("lineWidth", d), S.push("lineCap", a.lineCap), S.push("lineJoin", a.lineJoin), S.push("miterLimit", a.miterLimit), S.push("setLineDash", [a.lineDash]), S.push("lineDashOffset", a.lineDashOffset)), n && S.push("fillStyle", o.fillStyle), S.push("textBaseline", "middle"), S.push("textAlign", "center");
      const A = 0.5 - u;
      let O = u * R + A * d;
      const $ = [], q = [];
      let Z = 0, Q = 0, X = 0, mt = 0, V;
      for (let st = 0, et = g.length; st < et; st += 2) {
        const lt = g[st];
        if (lt === `
`) {
          Q += Z, Z = 0, O = u * R + A * d, ++mt;
          continue;
        }
        const rt = g[st + 1] || l.font;
        rt !== V && (s && $.push("font", rt), n && q.push("font", rt), V = rt), Z = Math.max(Z, M[X]);
        const tt = [
          lt,
          O + A * E[X] + u * (E[X] - w[mt]),
          0.5 * (d + Z) + Q
        ];
        O += E[X], s && $.push("strokeText", tt), n && q.push("fillText", tt), ++X;
      }
      return Array.prototype.push.apply(S, $), Array.prototype.push.apply(S, q), this.labels_[r] = L, L;
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
     * @param {Array<*>} fillInstruction Fill instruction.
     * @param {Array<*>} strokeInstruction Stroke instruction.
     */
    replayTextBackground_(t, e, n, s, r, a, o) {
      t.beginPath(), t.moveTo.apply(t, e), t.lineTo.apply(t, n), t.lineTo.apply(t, s), t.lineTo.apply(t, r), t.lineTo.apply(t, e), a && (this.alignAndScaleFill_ = /** @type {number} */
      a[2], t.fillStyle = /** @type {string} */
      a[1], this.fill_(t)), o && (this.setStrokeStyle_(
        t,
        /** @type {Array<*>} */
        o
      ), t.stroke());
    }
    /**
     * @private
     * @param {number} sheetWidth Width of the sprite sheet.
     * @param {number} sheetHeight Height of the sprite sheet.
     * @param {number} centerX X.
     * @param {number} centerY Y.
     * @param {number} width Width.
     * @param {number} height Height.
     * @param {number} anchorX Anchor X.
     * @param {number} anchorY Anchor Y.
     * @param {number} originX Origin X.
     * @param {number} originY Origin Y.
     * @param {number} rotation Rotation.
     * @param {import("../../size.js").Size} scale Scale.
     * @param {boolean} snapToPixel Snap to pixel.
     * @param {Array<number>} padding Padding.
     * @param {boolean} fillStroke Background fill or stroke.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
     */
    calculateImageOrLabelDimensions_(t, e, n, s, r, a, o, l, h, c, u, d, g, _, y, E) {
      o *= d[0], l *= d[1];
      let M = n - o, w = s - l;
      const R = r + h > t ? t - h : r, S = a + c > e ? e - c : a, C = _[3] + R * d[0] + _[1], T = _[0] + S * d[1] + _[2], L = M - _[3], A = w - _[0];
      (y || u !== 0) && (ki[0] = L, Gi[0] = L, ki[1] = A, mi[1] = A, mi[0] = L + C, _i[0] = mi[0], _i[1] = A + T, Gi[1] = _i[1]);
      let O;
      return u !== 0 ? (O = Ci(
        $e(),
        n,
        s,
        1,
        1,
        u,
        -n,
        -s
      ), Xt(O, ki), Xt(O, mi), Xt(O, _i), Xt(O, Gi), Le(
        Math.min(ki[0], mi[0], _i[0], Gi[0]),
        Math.min(ki[1], mi[1], _i[1], Gi[1]),
        Math.max(ki[0], mi[0], _i[0], Gi[0]),
        Math.max(ki[1], mi[1], _i[1], Gi[1]),
        es
      )) : Le(
        Math.min(L, L + C),
        Math.min(A, A + T),
        Math.max(L, L + C),
        Math.max(A, A + T),
        es
      ), g && (M = Math.round(M), w = Math.round(w)), {
        drawImageX: M,
        drawImageY: w,
        drawImageW: R,
        drawImageH: S,
        originX: h,
        originY: c,
        declutterBox: {
          minX: es[0],
          minY: es[1],
          maxX: es[2],
          maxY: es[3],
          value: E
        },
        canvasTransform: O,
        scale: d
      };
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
     * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
     * @param {ImageOrLabelDimensions} dimensions Dimensions.
     * @param {number} opacity Opacity.
     * @param {Array<*>} fillInstruction Fill instruction.
     * @param {Array<*>} strokeInstruction Stroke instruction.
     * @return {boolean} The image or label was rendered.
     */
    replayImageOrLabel_(t, e, n, s, r, a, o) {
      const l = !!(a || o), h = s.declutterBox, c = o ? o[2] * s.scale[0] / 2 : 0;
      return h.minX - c <= e[0] && h.maxX + c >= 0 && h.minY - c <= e[1] && h.maxY + c >= 0 && (l && this.replayTextBackground_(
        t,
        ki,
        mi,
        _i,
        Gi,
        /** @type {Array<*>} */
        a,
        /** @type {Array<*>} */
        o
      ), xp(
        t,
        s.canvasTransform,
        r,
        n,
        s.originX,
        s.originY,
        s.drawImageW,
        s.drawImageH,
        s.drawImageX,
        s.drawImageY,
        s.scale
      )), !0;
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     */
    fill_(t) {
      const e = this.alignAndScaleFill_;
      if (e) {
        const n = Xt(this.renderedTransform_, [0, 0]), s = 512 * this.pixelRatio;
        t.save(), t.translate(n[0] % s, n[1] % s), e !== 1 && t.scale(e, e), t.rotate(this.viewRotation_);
      }
      t.fill(), e && t.restore();
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {Array<*>} instruction Instruction.
     */
    setStrokeStyle_(t, e) {
      t.strokeStyle = /** @type {import("../../colorlike.js").ColorLike} */
      e[1], t.lineWidth = /** @type {number} */
      e[2], t.lineCap = /** @type {CanvasLineCap} */
      e[3], t.lineJoin = /** @type {CanvasLineJoin} */
      e[4], t.miterLimit = /** @type {number} */
      e[5], t.lineDashOffset = /** @type {number} */
      e[7], t.setLineDash(
        /** @type {Array<number>} */
        e[6]
      );
    }
    /**
     * @private
     * @param {string|Array<string>} text The text to draw.
     * @param {string} textKey The key of the text state.
     * @param {string} strokeKey The key for the stroke state.
     * @param {string} fillKey The key for the fill state.
     * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
     */
    drawLabelWithPointPlacement_(t, e, n, s) {
      const r = this.textStates[e], a = this.createLabel(t, e, s, n), o = this.strokeStates[n], l = this.pixelRatio, h = al(
        Array.isArray(t) ? t[0] : t,
        r.textAlign || Tr
      ), c = Ha[r.textBaseline || Ya], u = o && o.lineWidth ? o.lineWidth : 0, d = a.width / l - 2 * r.scale[0], g = h * d + 2 * (0.5 - h) * u, _ = c * a.height / l + 2 * (0.5 - c) * u;
      return {
        label: a,
        anchorX: g,
        anchorY: _
      };
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {Array<*>} instructions Instructions array.
     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
     * @param {FeatureCallback<T>} [featureCallback] Feature callback.
     * @param {import("../../extent.js").Extent} [hitExtent] Only check
     *     features that intersect this extent.
     * @param {import("rbush").default<DeclutterEntry>} [declutterTree] Declutter tree.
     * @return {T|undefined} Callback result.
     * @template T
     */
    execute_(t, e, n, s, r, a, o, l) {
      const h = this.zIndexContext_;
      let c;
      this.pixelCoordinates_ && rn(n, this.renderedTransform_) ? c = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), c = ji(
        this.coordinates,
        0,
        this.coordinates.length,
        2,
        n,
        this.pixelCoordinates_
      ), Cm(this.renderedTransform_, n));
      let u = 0;
      const d = s.length;
      let g = 0, _, y, E, M, w, R, S, C, T, L, A, O, $, q = 0, Z = 0;
      const Q = this.coordinateCache_, X = this.viewRotation_, mt = Math.round(Math.atan2(-n[1], n[0]) * 1e12) / 1e12, V = (
        /** @type {import("../../render.js").State} */
        {
          context: t,
          pixelRatio: this.pixelRatio,
          resolution: this.resolution,
          rotation: X
        }
      ), st = this.instructions != s || this.overlaps ? 0 : 200;
      let et, lt, rt, tt;
      for (; u < d; ) {
        const D = s[u];
        switch (
          /** @type {import("./Instruction.js").default} */
          D[0]
        ) {
          case H.BEGIN_GEOMETRY:
            et = /** @type {import("../../Feature.js").FeatureLike} */
            D[1], tt = D[3], et.getGeometry() ? o !== void 0 && !he(o, tt.getExtent()) ? u = /** @type {number} */
            D[2] + 1 : ++u : u = /** @type {number} */
            D[2], h && (h.zIndex = D[4]);
            break;
          case H.BEGIN_PATH:
            q > st && (this.fill_(t), q = 0), Z > st && (t.stroke(), Z = 0), !q && !Z && (t.beginPath(), w = NaN, R = NaN), ++u;
            break;
          case H.CIRCLE:
            g = /** @type {number} */
            D[1];
            const U = c[g], dt = c[g + 1], Vt = c[g + 2], jt = c[g + 3], $t = Vt - U, hi = jt - dt, Ut = Math.sqrt($t * $t + hi * hi);
            t.moveTo(U + Ut, dt), t.arc(U, dt, Ut, 0, 2 * Math.PI, !0), ++u;
            break;
          case H.CLOSE_PATH:
            t.closePath(), ++u;
            break;
          case H.CUSTOM:
            g = /** @type {number} */
            D[1], _ = D[2];
            const hn = (
              /** @type {import("../../geom/SimpleGeometry.js").default} */
              D[3]
            ), Wn = D[4], ci = D[5];
            V.geometry = hn, V.feature = et, u in Q || (Q[u] = []);
            const ti = Q[u];
            ci ? ci(c, g, _, 2, ti) : (ti[0] = c[g], ti[1] = c[g + 1], ti.length = 2), h && (h.zIndex = D[6]), Wn(ti, V), ++u;
            break;
          case H.DRAW_IMAGE:
            g = /** @type {number} */
            D[1], _ = /** @type {number} */
            D[2], T = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
            D[3], y = /** @type {number} */
            D[4], E = /** @type {number} */
            D[5];
            let cn = (
              /** @type {number} */
              D[6]
            );
            const Oe = (
              /** @type {number} */
              D[7]
            ), Ne = (
              /** @type {number} */
              D[8]
            ), Pi = (
              /** @type {number} */
              D[9]
            ), ui = (
              /** @type {boolean} */
              D[10]
            );
            let Be = (
              /** @type {number} */
              D[11]
            );
            const un = (
              /** @type {import("../../size.js").Size} */
              D[12]
            );
            let We = (
              /** @type {number} */
              D[13]
            );
            M = D[14] || "declutter";
            const di = (
              /** @type {{args: import("../canvas.js").DeclutterImageWithText, declutterMode: import('../../style/Style.js').DeclutterMode}} */
              D[15]
            );
            if (!T && D.length >= 20) {
              L = /** @type {string} */
              D[19], A = /** @type {string} */
              D[20], O = /** @type {string} */
              D[21], $ = /** @type {string} */
              D[22];
              const de = this.drawLabelWithPointPlacement_(
                L,
                A,
                O,
                $
              );
              T = de.label, D[3] = T;
              const fi = (
                /** @type {number} */
                D[23]
              );
              y = (de.anchorX - fi) * this.pixelRatio, D[4] = y;
              const ye = (
                /** @type {number} */
                D[24]
              );
              E = (de.anchorY - ye) * this.pixelRatio, D[5] = E, cn = T.height, D[6] = cn, We = T.width, D[13] = We;
            }
            let Yt;
            D.length > 25 && (Yt = /** @type {number} */
            D[25]);
            let Ws, dn, fn;
            D.length > 17 ? (Ws = /** @type {Array<number>} */
            D[16], dn = /** @type {Array<*>} */
            D[17], fn = /** @type {Array<*>} */
            D[18]) : (Ws = An, dn = null, fn = null), ui && mt ? Be += X : !ui && !mt && (Be -= X);
            let Xs = 0;
            for (; g < _; g += 2) {
              if (Yt && Yt[Xs++] < We / this.pixelRatio)
                continue;
              const de = this.calculateImageOrLabelDimensions_(
                T.width,
                T.height,
                c[g],
                c[g + 1],
                We,
                cn,
                y,
                E,
                Ne,
                Pi,
                Be,
                un,
                r,
                Ws,
                !!dn || !!fn,
                et
              ), fi = [
                t,
                e,
                T,
                de,
                Oe,
                dn,
                fn
              ];
              if (l) {
                let ye, Ie, ie;
                if (di) {
                  const Nt = _ - g;
                  if (!di[Nt]) {
                    di[Nt] = { args: fi, declutterMode: M };
                    continue;
                  }
                  const Ht = di[Nt];
                  ye = Ht.args, Ie = Ht.declutterMode, delete di[Nt], ie = wu(ye);
                }
                let Te, Xe;
                if (ye && (Ie !== "declutter" || !l.collides(ie)) && (Te = !0), (M !== "declutter" || !l.collides(de.declutterBox)) && (Xe = !0), Ie === "declutter" && M === "declutter") {
                  const Nt = Te && Xe;
                  Te = Nt, Xe = Nt;
                }
                Te && (Ie !== "none" && l.insert(ie), this.replayImageOrLabel_.apply(this, ye)), Xe && (M !== "none" && l.insert(de.declutterBox), this.replayImageOrLabel_.apply(this, fi));
              } else
                this.replayImageOrLabel_.apply(this, fi);
            }
            ++u;
            break;
          case H.DRAW_CHARS:
            const Xn = (
              /** @type {number} */
              D[1]
            ), gn = (
              /** @type {number} */
              D[2]
            ), mn = (
              /** @type {number} */
              D[3]
            ), Ys = (
              /** @type {number} */
              D[4]
            );
            $ = /** @type {string} */
            D[5];
            const _n = (
              /** @type {number} */
              D[6]
            ), ia = (
              /** @type {number} */
              D[7]
            ), na = (
              /** @type {number} */
              D[8]
            );
            O = /** @type {string} */
            D[9];
            const Yn = (
              /** @type {number} */
              D[10]
            );
            L = /** @type {string} */
            D[11], A = /** @type {string} */
            D[12];
            const Zs = [
              /** @type {number} */
              D[13],
              /** @type {number} */
              D[13]
            ];
            M = D[14] || "declutter";
            const qs = (
              /** @type {boolean} */
              D[15]
            ), Zn = this.textStates[A], pn = Zn.font, Li = [
              Zn.scale[0] * ia,
              Zn.scale[1] * ia
            ];
            let Oi;
            pn in this.widths_ ? Oi = this.widths_[pn] : (Oi = {}, this.widths_[pn] = Oi);
            const qn = ff(c, Xn, gn, 2), Kn = Math.abs(Li[0]) * lu(pn, L, Oi);
            if (Ys || Kn <= qn) {
              const de = this.textStates[A].textAlign, fi = (qn - Kn) * al(L, de), ye = My(
                c,
                Xn,
                gn,
                2,
                L,
                fi,
                _n,
                Math.abs(Li[0]),
                lu,
                pn,
                Oi,
                mt ? 0 : this.viewRotation_,
                qs
              );
              t: if (ye) {
                const Ie = [];
                let ie, Te, Xe, Nt, Ht;
                if (O)
                  for (ie = 0, Te = ye.length; ie < Te; ++ie) {
                    Ht = ye[ie], Xe = /** @type {string} */
                    Ht[4], Nt = this.createLabel(Xe, A, "", O), y = /** @type {number} */
                    Ht[2] + (Li[0] < 0 ? -Yn : Yn), E = mn * Nt.height + (0.5 - mn) * 2 * Yn * Li[1] / Li[0] - na;
                    const Ye = this.calculateImageOrLabelDimensions_(
                      Nt.width,
                      Nt.height,
                      Ht[0],
                      Ht[1],
                      Nt.width,
                      Nt.height,
                      y,
                      E,
                      0,
                      0,
                      Ht[3],
                      Zs,
                      !1,
                      An,
                      !1,
                      et
                    );
                    if (l && M === "declutter" && l.collides(Ye.declutterBox))
                      break t;
                    Ie.push([
                      t,
                      e,
                      Nt,
                      Ye,
                      1,
                      null,
                      null
                    ]);
                  }
                if ($)
                  for (ie = 0, Te = ye.length; ie < Te; ++ie) {
                    Ht = ye[ie], Xe = /** @type {string} */
                    Ht[4], Nt = this.createLabel(Xe, A, $, ""), y = /** @type {number} */
                    Ht[2], E = mn * Nt.height - na;
                    const Ye = this.calculateImageOrLabelDimensions_(
                      Nt.width,
                      Nt.height,
                      Ht[0],
                      Ht[1],
                      Nt.width,
                      Nt.height,
                      y,
                      E,
                      0,
                      0,
                      Ht[3],
                      Zs,
                      !1,
                      An,
                      !1,
                      et
                    );
                    if (l && M === "declutter" && l.collides(Ye.declutterBox))
                      break t;
                    Ie.push([
                      t,
                      e,
                      Nt,
                      Ye,
                      1,
                      null,
                      null
                    ]);
                  }
                l && M !== "none" && l.load(Ie.map(wu));
                for (let Ye = 0, sa = Ie.length; Ye < sa; ++Ye)
                  this.replayImageOrLabel_.apply(this, Ie[Ye]);
              }
            }
            ++u;
            break;
          case H.END_GEOMETRY:
            if (a !== void 0) {
              et = /** @type {import("../../Feature.js").FeatureLike} */
              D[1];
              const de = a(
                et,
                tt,
                M
              );
              if (de)
                return de;
            }
            ++u;
            break;
          case H.FILL:
            st ? q++ : this.fill_(t), ++u;
            break;
          case H.MOVE_TO_LINE_TO:
            for (g = /** @type {number} */
            D[1], _ = /** @type {number} */
            D[2], lt = c[g], rt = c[g + 1], t.moveTo(lt, rt), w = lt + 0.5 | 0, R = rt + 0.5 | 0, g += 2; g < _; g += 2)
              lt = c[g], rt = c[g + 1], S = lt + 0.5 | 0, C = rt + 0.5 | 0, (g == _ - 2 || S !== w || C !== R) && (t.lineTo(lt, rt), w = S, R = C);
            ++u;
            break;
          case H.SET_FILL_STYLE:
            this.alignAndScaleFill_ = D[2], q && (this.fill_(t), q = 0, Z && (t.stroke(), Z = 0)), t.fillStyle = D[1], ++u;
            break;
          case H.SET_STROKE_STYLE:
            Z && (t.stroke(), Z = 0), this.setStrokeStyle_(
              t,
              /** @type {Array<*>} */
              D
            ), ++u;
            break;
          case H.STROKE:
            st ? Z++ : t.stroke(), ++u;
            break;
          default:
            ++u;
            break;
        }
      }
      q && this.fill_(t), Z && t.stroke();
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
     * @param {import("rbush").default<DeclutterEntry>} [declutterTree] Declutter tree.
     */
    execute(t, e, n, s, r, a) {
      this.viewRotation_ = s, this.execute_(
        t,
        e,
        n,
        this.instructions,
        r,
        void 0,
        void 0,
        a
      );
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {FeatureCallback<T>} [featureCallback] Feature callback.
     * @param {import("../../extent.js").Extent} [hitExtent] Only check
     *     features that intersect this extent.
     * @return {T|undefined} Callback result.
     * @template T
     */
    executeHitDetection(t, e, n, s, r) {
      return this.viewRotation_ = n, this.execute_(
        t,
        [t.canvas.width, t.canvas.height],
        e,
        this.hitDetectionInstructions,
        !0,
        s,
        r
      );
    }
  }
  const us = [
    "Polygon",
    "Circle",
    "LineString",
    "Image",
    "Text",
    "Default"
  ], Mf = ["Image", "Text"], Sy = us.filter(
    (i) => !Mf.includes(i)
  );
  class Cy {
    /**
     * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
     * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
     * should be set here, unless the target context does not exceed that extent (which
     * can be the case when rendering to tiles).
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {boolean} overlaps The executor group can have overlapping geometries.
     * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
     * The serializable instructions.
     * @param {number} [renderBuffer] Optional rendering buffer.
     * @param {boolean} [deferredRendering] Enable deferred rendering with renderDeferred().
     */
    constructor(t, e, n, s, r, a, o) {
      this.maxExtent_ = t, this.overlaps_ = s, this.pixelRatio_ = n, this.resolution_ = e, this.renderBuffer_ = a, this.executorsByZIndex_ = {}, this.hitDetectionContext_ = null, this.hitDetectionTransform_ = $e(), this.renderedContext_ = null, this.deferredZIndexContexts_ = {}, this.createExecutors_(r, o);
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../transform.js").Transform} transform Transform.
     */
    clip(t, e) {
      const n = this.getClipCoords(e);
      t.beginPath(), t.moveTo(n[0], n[1]), t.lineTo(n[2], n[3]), t.lineTo(n[4], n[5]), t.lineTo(n[6], n[7]), t.clip();
    }
    /**
     * Create executors and populate them using the provided instructions.
     * @private
     * @param {!Object<string, !Object<string, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
     * @param {boolean} deferredRendering Enable deferred rendering.
     */
    createExecutors_(t, e) {
      for (const n in t) {
        let s = this.executorsByZIndex_[n];
        s === void 0 && (s = {}, this.executorsByZIndex_[n] = s);
        const r = t[n];
        for (const a in r) {
          const o = r[a];
          s[a] = new wy(
            this.resolution_,
            this.pixelRatio_,
            this.overlaps_,
            o,
            e
          );
        }
      }
    }
    /**
     * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
     * @return {boolean} Has executors of the provided types.
     */
    hasExecutors(t) {
      for (const e in this.executorsByZIndex_) {
        const n = this.executorsByZIndex_[e];
        for (let s = 0, r = t.length; s < r; ++s)
          if (t[s] in n)
            return !0;
      }
      return !1;
    }
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
     * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
     * @return {T|undefined} Callback result.
     * @template T
     */
    forEachFeatureAtCoordinate(t, e, n, s, r, a) {
      s = Math.round(s);
      const o = s * 2 + 1, l = Ci(
        this.hitDetectionTransform_,
        s + 0.5,
        s + 0.5,
        1 / e,
        -1 / e,
        -n,
        -t[0],
        -t[1]
      ), h = !this.hitDetectionContext_;
      h && (this.hitDetectionContext_ = Kt(
        o,
        o,
        void 0,
        { willReadFrequently: !0 }
      ));
      const c = this.hitDetectionContext_;
      c.canvas.width !== o || c.canvas.height !== o ? (c.canvas.width = o, c.canvas.height = o) : h || c.clearRect(0, 0, o, o);
      let u;
      this.renderBuffer_ !== void 0 && (u = Pe(), On(u, t), uo(
        u,
        e * (this.renderBuffer_ + s),
        u
      ));
      const d = Ry(s);
      let g;
      function _(C, T, L) {
        const A = c.getImageData(
          0,
          0,
          o,
          o
        ).data;
        for (let O = 0, $ = d.length; O < $; O++)
          if (A[d[O]] > 0) {
            if (!a || L === "none" || g !== "Image" && g !== "Text" || a.includes(C)) {
              const q = (d[O] - 3) / 4, Z = s - q % o, Q = s - (q / o | 0), X = r(C, T, Z * Z + Q * Q);
              if (X)
                return X;
            }
            c.clearRect(0, 0, o, o);
            break;
          }
      }
      const y = Object.keys(this.executorsByZIndex_).map(Number);
      y.sort(Ki);
      let E, M, w, R, S;
      for (E = y.length - 1; E >= 0; --E) {
        const C = y[E].toString();
        for (w = this.executorsByZIndex_[C], M = us.length - 1; M >= 0; --M)
          if (g = us[M], R = w[g], R !== void 0 && (S = R.executeHitDetection(
            c,
            l,
            n,
            _,
            u
          ), S))
            return S;
      }
    }
    /**
     * @param {import("../../transform.js").Transform} transform Transform.
     * @return {Array<number>|null} Clip coordinates.
     */
    getClipCoords(t) {
      const e = this.maxExtent_;
      if (!e)
        return null;
      const n = e[0], s = e[1], r = e[2], a = e[3], o = [n, s, n, a, r, a, r, s];
      return ji(o, 0, 8, 2, t, o), o;
    }
    /**
     * @return {boolean} Is empty.
     */
    isEmpty() {
      return Ts(this.executorsByZIndex_);
    }
    /**
     * @param {CanvasRenderingContext2D} targetContext Context.
     * @param {import('../../size.js').Size} scaledCanvasSize Scale of the context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
     * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
     *     Default is {@link module:ol/render/replay~ALL}
     * @param {import("rbush").default<import('./Executor.js').DeclutterEntry>|null} [declutterTree] Declutter tree.
     *     When set to null, no decluttering is done, even when the executor group has a `ZIndexContext`.
     */
    execute(t, e, n, s, r, a, o) {
      const l = Object.keys(this.executorsByZIndex_).map(Number);
      l.sort(o ? p0 : Ki), a = a || us;
      const h = us.length;
      for (let c = 0, u = l.length; c < u; ++c) {
        const d = l[c].toString(), g = this.executorsByZIndex_[d];
        for (let _ = 0, y = a.length; _ < y; ++_) {
          const E = a[_], M = g[E];
          if (M !== void 0) {
            const w = o === null ? void 0 : M.getZIndexContext(), R = w ? w.getContext() : t, S = this.maxExtent_ && E !== "Image" && E !== "Text";
            if (S && (R.save(), this.clip(R, n)), !w || E === "Text" || E === "Image" ? M.execute(
              R,
              e,
              n,
              s,
              r,
              o
            ) : w.pushFunction(
              (C) => M.execute(
                C,
                e,
                n,
                s,
                r,
                o
              )
            ), S && R.restore(), w) {
              w.offset();
              const C = l[c] * h + _;
              this.deferredZIndexContexts_[C] || (this.deferredZIndexContexts_[C] = []), this.deferredZIndexContexts_[C].push(w);
            }
          }
        }
      }
      this.renderedContext_ = t;
    }
    getDeferredZIndexContexts() {
      return this.deferredZIndexContexts_;
    }
    getRenderedContext() {
      return this.renderedContext_;
    }
    renderDeferred() {
      const t = this.deferredZIndexContexts_, e = Object.keys(t).map(Number).sort(Ki);
      for (let n = 0, s = e.length; n < s; ++n)
        t[e[n]].forEach((r) => {
          r.draw(this.renderedContext_), r.clear();
        }), t[e[n]].length = 0;
    }
  }
  const ol = {};
  function Ry(i) {
    if (ol[i] !== void 0)
      return ol[i];
    const t = i * 2 + 1, e = i * i, n = new Array(e + 1);
    for (let r = 0; r <= i; ++r)
      for (let a = 0; a <= i; ++a) {
        const o = r * r + a * a;
        if (o > e)
          break;
        let l = n[o];
        l || (l = [], n[o] = l), l.push(((i + r) * t + (i + a)) * 4 + 3), r > 0 && l.push(((i - r) * t + (i + a)) * 4 + 3), a > 0 && (l.push(((i + r) * t + (i - a)) * 4 + 3), r > 0 && l.push(((i - r) * t + (i - a)) * 4 + 3));
      }
    const s = [];
    for (let r = 0, a = n.length; r < a; ++r)
      n[r] && s.push(...n[r]);
    return ol[i] = s, s;
  }
  const Iy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Circle: zn,
    Fill: tn,
    Icon: Zr,
    IconImage: $h,
    Image: Xr,
    RegularShape: Yr,
    Stroke: Hi,
    Style: je,
    Text: Io
  }, Symbol.toStringTag, { value: "Module" })), ii = 0.5;
  function Ty(i, t, e, n, s, r, a, o, l) {
    const h = s, c = i[0] * ii, u = i[1] * ii, d = Kt(c, u);
    d.imageSmoothingEnabled = !1;
    const g = d.canvas, _ = new Wh(
      d,
      ii,
      s,
      null,
      a,
      o,
      null
    ), y = e.length, E = Math.floor((256 * 256 * 256 - 1) / y), M = {};
    for (let R = 1; R <= y; ++R) {
      const S = e[R - 1], C = S.getStyleFunction() || n;
      if (!C)
        continue;
      let T = C(S, r);
      if (!T)
        continue;
      Array.isArray(T) || (T = [T]);
      const A = (R * E).toString(16).padStart(7, "#00000");
      for (let O = 0, $ = T.length; O < $; ++O) {
        const q = T[O], Z = q.getGeometryFunction()(S);
        if (!Z || !he(h, Z.getExtent()))
          continue;
        const Q = q.clone(), X = Q.getFill();
        X && X.setColor(A);
        const mt = Q.getStroke();
        mt && (mt.setColor(A), mt.setLineDash(null)), Q.setText(void 0);
        const V = q.getImage();
        if (V) {
          const rt = V.getImageSize();
          if (!rt)
            continue;
          const tt = Kt(
            rt[0],
            rt[1],
            void 0,
            { alpha: !1 }
          ), D = tt.canvas;
          tt.fillStyle = A, tt.fillRect(0, 0, D.width, D.height), Q.setImage(
            new Zr({
              img: D,
              anchor: V.getAnchor(),
              anchorXUnits: "pixels",
              anchorYUnits: "pixels",
              offset: V.getOrigin(),
              opacity: 1,
              size: V.getSize(),
              scale: V.getScale(),
              rotation: V.getRotation(),
              rotateWithView: V.getRotateWithView()
            })
          );
        }
        const st = Q.getZIndex() || 0;
        let et = M[st];
        et || (et = {}, M[st] = et, et.Polygon = [], et.Circle = [], et.LineString = [], et.Point = []);
        const lt = Z.getType();
        if (lt === "GeometryCollection") {
          const rt = (
            /** @type {import("../../geom/GeometryCollection.js").default} */
            Z.getGeometriesArrayRecursive()
          );
          for (let tt = 0, D = rt.length; tt < D; ++tt) {
            const _t = rt[tt];
            et[_t.getType().replace("Multi", "")].push(
              _t,
              Q
            );
          }
        } else
          et[lt.replace("Multi", "")].push(Z, Q);
      }
    }
    const w = Object.keys(M).map(Number).sort(Ki);
    for (let R = 0, S = w.length; R < S; ++R) {
      const C = M[w[R]];
      for (const T in C) {
        const L = C[T];
        for (let A = 0, O = L.length; A < O; A += 2) {
          _.setStyle(L[A + 1]);
          for (let $ = 0, q = t.length; $ < q; ++$)
            _.setTransform(t[$]), _.drawGeometry(L[A]);
        }
      }
    }
    return d.getImageData(0, 0, g.width, g.height);
  }
  function Ay(i, t, e) {
    const n = [];
    if (e) {
      const s = Math.floor(Math.round(i[0]) * ii), r = Math.floor(Math.round(i[1]) * ii), a = (zt(s, 0, e.width - 1) + zt(r, 0, e.height - 1) * e.width) * 4, o = e.data[a], l = e.data[a + 1], c = e.data[a + 2] + 256 * (l + 256 * o), u = Math.floor((256 * 256 * 256 - 1) / t.length);
      c && c % u === 0 && n.push(t[c / u - 1]);
    }
    return n;
  }
  const by = 5;
  class Py extends kr {
    /**
     * @param {LayerType} layer Layer.
     */
    constructor(t) {
      super(), this.ready = !0, this.boundHandleImageChange_ = this.handleImageChange_.bind(this), this.layer_ = t, this.staleKeys_ = new Array(), this.maxStaleKeys = by;
    }
    /**
     * @return {Array<string>} Get the list of stale keys.
     */
    getStaleKeys() {
      return this.staleKeys_;
    }
    /**
     * @param {string} key The new stale key.
     */
    prependStaleKey(t) {
      this.staleKeys_.unshift(t), this.staleKeys_.length > this.maxStaleKeys && (this.staleKeys_.length = this.maxStaleKeys);
    }
    /**
     * Asynchronous layer level hit detection.
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
     * an array of features.
     */
    getFeatures(t) {
      return ct();
    }
    /**
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     */
    getData(t) {
      return null;
    }
    /**
     * Determine whether render should be called.
     * @abstract
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */
    prepareFrame(t) {
      return ct();
    }
    /**
     * Render the layer.
     * @abstract
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement|null} target Target that may be used to render content to.
     * @return {HTMLElement|null} The rendered element.
     */
    renderFrame(t, e) {
      return ct();
    }
    /**
     * @abstract
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
     * @return {T|undefined} Callback result.
     * @template T
     */
    forEachFeatureAtCoordinate(t, e, n, s, r) {
    }
    /**
     * @return {LayerType} Layer.
     */
    getLayer() {
      return this.layer_;
    }
    /**
     * Perform action necessary to get the layer rendered after new fonts have loaded
     * @abstract
     */
    handleFontsChanged() {
    }
    /**
     * Handle changes in image state.
     * @param {import("../events/Event.js").default} event Image change event.
     * @private
     */
    handleImageChange_(t) {
      const e = (
        /** @type {import("../Image.js").default} */
        t.target
      );
      (e.getState() === ut.LOADED || e.getState() === ut.ERROR) && this.renderIfReadyAndVisible();
    }
    /**
     * Load the image if not already loaded, and register the image change
     * listener if needed.
     * @param {import("../Image.js").default} image Image.
     * @return {boolean} `true` if the image is already loaded, `false` otherwise.
     * @protected
     */
    loadImage(t) {
      let e = t.getState();
      return e != ut.LOADED && e != ut.ERROR && t.addEventListener(at.CHANGE, this.boundHandleImageChange_), e == ut.IDLE && (t.load(), e = t.getState()), e == ut.LOADED;
    }
    /**
     * @protected
     */
    renderIfReadyAndVisible() {
      const t = this.getLayer();
      t && t.getVisible() && t.getSourceState() === "ready" && t.changed();
    }
    /**
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */
    renderDeferred(t) {
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      delete this.layer_, super.disposeInternal();
    }
  }
  const Cu = [];
  let ls = null;
  function Ly() {
    ls = Kt(1, 1, void 0, {
      willReadFrequently: !0
    });
  }
  class xf extends Py {
    /**
     * @param {LayerType} layer Layer.
     */
    constructor(t) {
      super(t), this.container = null, this.renderedResolution, this.tempTransform = $e(), this.pixelTransform = $e(), this.inversePixelTransform = $e(), this.context = null, this.deferredContext_ = null, this.containerReused = !1, this.frameState = null;
    }
    /**
     * @param {import('../../DataTile.js').ImageLike} image Image.
     * @param {number} col The column index.
     * @param {number} row The row index.
     * @return {Uint8ClampedArray|null} The image data.
     */
    getImageData(t, e, n) {
      ls || Ly(), ls.clearRect(0, 0, 1, 1);
      let s;
      try {
        ls.drawImage(t, e, n, 1, 1, 0, 0, 1, 1), s = ls.getImageData(0, 0, 1, 1).data;
      } catch {
        return ls = null, null;
      }
      return s;
    }
    /**
     * @param {import('../../Map.js').FrameState} frameState Frame state.
     * @return {string} Background color.
     */
    getBackground(t) {
      let n = this.getLayer().getBackground();
      return typeof n == "function" && (n = n(t.viewState.resolution)), n || void 0;
    }
    /**
     * Get a rendering container from an existing target, if compatible.
     * @param {HTMLElement} target Potential render target.
     * @param {string} transform CSS Transform.
     * @param {string} [backgroundColor] Background color.
     */
    useContainer(t, e, n) {
      const s = this.getLayer().getClassName();
      let r, a;
      if (t && t.className === s && (!n || t && t.style.backgroundColor && rn(
        Ls(t.style.backgroundColor),
        Ls(n)
      ))) {
        const o = t.firstElementChild;
        o instanceof HTMLCanvasElement && (a = o.getContext("2d"));
      }
      if (a && a.canvas.style.transform === e ? (this.container = t, this.context = a, this.containerReused = !0) : this.containerReused ? (this.container = null, this.context = null, this.containerReused = !1) : this.container && (this.container.style.backgroundColor = null), !this.container) {
        r = document.createElement("div"), r.className = s;
        let o = r.style;
        o.position = "absolute", o.width = "100%", o.height = "100%", a = Kt();
        const l = a.canvas;
        r.appendChild(l), o = l.style, o.position = "absolute", o.left = "0", o.transformOrigin = "top left", this.container = r, this.context = a;
      }
      !this.containerReused && n && !this.container.style.backgroundColor && (this.container.style.backgroundColor = n);
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {import("../../extent.js").Extent} extent Clip extent.
     * @protected
     */
    clipUnrotated(t, e, n) {
      const s = on(n), r = $r(n), a = zr(n), o = Gr(n);
      Xt(e.coordinateToPixelTransform, s), Xt(e.coordinateToPixelTransform, r), Xt(e.coordinateToPixelTransform, a), Xt(e.coordinateToPixelTransform, o);
      const l = this.inversePixelTransform;
      Xt(l, s), Xt(l, r), Xt(l, a), Xt(l, o), t.save(), t.beginPath(), t.moveTo(Math.round(s[0]), Math.round(s[1])), t.lineTo(Math.round(r[0]), Math.round(r[1])), t.lineTo(Math.round(a[0]), Math.round(a[1])), t.lineTo(Math.round(o[0]), Math.round(o[1])), t.clip();
    }
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target that may be used to render content to.
     * @protected
     */
    prepareContainer(t, e) {
      const n = t.extent, s = t.viewState.resolution, r = t.viewState.rotation, a = t.pixelRatio, o = Math.round(Mt(n) / s * a), l = Math.round(te(n) / s * a);
      Ci(
        this.pixelTransform,
        t.size[0] / 2,
        t.size[1] / 2,
        1 / a,
        1 / a,
        r,
        -o / 2,
        -l / 2
      ), bd(this.inversePixelTransform, this.pixelTransform);
      const h = Tm(this.pixelTransform);
      if (this.useContainer(e, h, this.getBackground(t)), !this.containerReused) {
        const c = this.context.canvas;
        c.width != o || c.height != l ? (c.width = o, c.height = l) : this.context.clearRect(0, 0, o, l), h !== c.style.transform && (c.style.transform = h);
      }
    }
    /**
     * @param {import("../../render/EventType.js").default} type Event type.
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @private
     */
    dispatchRenderEvent_(t, e, n) {
      const s = this.getLayer();
      if (s.hasListener(t)) {
        const r = new cf(
          t,
          this.inversePixelTransform,
          n,
          e
        );
        s.dispatchEvent(r);
      }
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    preRender(t, e) {
      this.frameState = e, !e.declutter && this.dispatchRenderEvent_(ke.PRERENDER, t, e);
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    postRender(t, e) {
      e.declutter || this.dispatchRenderEvent_(ke.POSTRENDER, t, e);
    }
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     */
    renderDeferredInternal(t) {
    }
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.
     */
    getRenderContext(t) {
      return t.declutter && !this.deferredContext_ && (this.deferredContext_ = new Ef()), t.declutter ? this.deferredContext_.getContext() : this.context;
    }
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @override
     */
    renderDeferred(t) {
      t.declutter && (this.dispatchRenderEvent_(
        ke.PRERENDER,
        this.context,
        t
      ), t.declutter && this.deferredContext_ && (this.deferredContext_.draw(this.context), this.deferredContext_.clear()), this.renderDeferredInternal(t), this.dispatchRenderEvent_(
        ke.POSTRENDER,
        this.context,
        t
      ));
    }
    /**
     * Creates a transform for rendering to an element that will be rotated after rendering.
     * @param {import("../../coordinate.js").Coordinate} center Center.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {number} pixelRatio Pixel ratio.
     * @param {number} width Width of the rendered element (in pixels).
     * @param {number} height Height of the rendered element (in pixels).
     * @param {number} offsetX Offset on the x-axis in view coordinates.
     * @protected
     * @return {!import("../../transform.js").Transform} Transform.
     */
    getRenderTransform(t, e, n, s, r, a, o) {
      const l = r / 2, h = a / 2, c = s / e, u = -c, d = -t[0] + o, g = -t[1];
      return Ci(
        this.tempTransform,
        l,
        h,
        c,
        u,
        -n,
        d,
        g
      );
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      delete this.frameState, super.disposeInternal();
    }
  }
  class Oy extends xf {
    /**
     * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
     */
    constructor(t) {
      super(t), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.animatingOrInteracting_, this.hitDetectionImageData_ = null, this.clipped_ = !1, this.renderedFeatures_ = null, this.renderedRevision_ = -1, this.renderedResolution_ = NaN, this.renderedExtent_ = Pe(), this.wrappedRenderedExtent_ = Pe(), this.renderedRotation_, this.renderedCenter_ = null, this.renderedProjection_ = null, this.renderedPixelRatio_ = 1, this.renderedRenderOrder_ = null, this.renderedFrameDeclutter_, this.replayGroup_ = null, this.replayGroupChanged = !0, this.clipping = !0, this.targetContext_ = null, this.opacity_ = 1;
    }
    /**
     * @param {ExecutorGroup} executorGroup Executor group.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {boolean} [declutterable] `true` to only render declutterable items,
     *     `false` to only render non-declutterable items, `undefined` to render all.
     */
    renderWorlds(t, e, n) {
      const s = e.extent, r = e.viewState, a = r.center, o = r.resolution, l = r.projection, h = r.rotation, c = l.getExtent(), u = this.getLayer().getSource(), d = this.getLayer().getDeclutter(), g = e.pixelRatio, _ = e.viewHints, y = !(_[oe.ANIMATING] || _[oe.INTERACTING]), E = this.context, M = Math.round(Mt(s) / o * g), w = Math.round(te(s) / o * g), R = u.getWrapX() && l.canWrapX(), S = R ? Mt(c) : null, C = R ? Math.ceil((s[2] - c[2]) / S) + 1 : 1;
      let T = R ? Math.floor((s[0] - c[0]) / S) : 0;
      do {
        let L = this.getRenderTransform(
          a,
          o,
          0,
          g,
          M,
          w,
          T * S
        );
        e.declutter && (L = L.slice(0)), t.execute(
          E,
          [E.canvas.width, E.canvas.height],
          L,
          h,
          y,
          n === void 0 ? us : n ? Mf : Sy,
          n ? d && e.declutter[d] : void 0
        );
      } while (++T < C);
    }
    /**
     * @private
     */
    setDrawContext_() {
      this.opacity_ !== 1 && (this.targetContext_ = this.context, this.context = Kt(
        this.context.canvas.width,
        this.context.canvas.height,
        Cu
      ));
    }
    /**
     * @private
     */
    resetDrawContext_() {
      if (this.opacity_ !== 1) {
        const t = this.targetContext_.globalAlpha;
        this.targetContext_.globalAlpha = this.opacity_, this.targetContext_.drawImage(this.context.canvas, 0, 0), this.targetContext_.globalAlpha = t, Co(this.context), Cu.push(this.context.canvas), this.context = this.targetContext_, this.targetContext_ = null;
      }
    }
    /**
     * Render declutter items for this layer
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     */
    renderDeclutter(t) {
      !this.replayGroup_ || !this.getLayer().getDeclutter() || this.renderWorlds(this.replayGroup_, t, !0);
    }
    /**
     * Render deferred instructions.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @override
     */
    renderDeferredInternal(t) {
      this.replayGroup_ && (this.replayGroup_.renderDeferred(), this.clipped_ && this.context.restore(), this.resetDrawContext_());
    }
    /**
     * Render the layer.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement|null} target Target that may be used to render content to.
     * @return {HTMLElement|null} The rendered element.
     * @override
     */
    renderFrame(t, e) {
      const n = t.layerStatesArray[t.layerIndex];
      this.opacity_ = n.opacity;
      const s = t.viewState;
      this.prepareContainer(t, e);
      const r = this.context, a = this.replayGroup_;
      let o = a && !a.isEmpty();
      if (!o && !(this.getLayer().hasListener(ke.PRERENDER) || this.getLayer().hasListener(ke.POSTRENDER)))
        return null;
      if (this.setDrawContext_(), this.preRender(r, t), s.projection, this.clipped_ = !1, o && n.extent && this.clipping) {
        const l = Wi(n.extent);
        o = he(l, t.extent), this.clipped_ = o && !Rn(l, t.extent), this.clipped_ && this.clipUnrotated(r, t, l);
      }
      return o && this.renderWorlds(
        a,
        t,
        this.getLayer().getDeclutter() ? !1 : void 0
      ), !t.declutter && this.clipped_ && r.restore(), this.postRender(r, t), this.renderedRotation_ !== s.rotation && (this.renderedRotation_ = s.rotation, this.hitDetectionImageData_ = null), t.declutter || this.resetDrawContext_(), this.container;
    }
    /**
     * Asynchronous layer level hit detection.
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../../Feature").default>>} Promise
     * that resolves with an array of features.
     * @override
     */
    getFeatures(t) {
      return new Promise((e) => {
        if (this.frameState && !this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
          const n = this.frameState.size.slice(), s = this.renderedCenter_, r = this.renderedResolution_, a = this.renderedRotation_, o = this.renderedProjection_, l = this.wrappedRenderedExtent_, h = this.getLayer(), c = [], u = n[0] * ii, d = n[1] * ii;
          c.push(
            this.getRenderTransform(
              s,
              r,
              a,
              ii,
              u,
              d,
              0
            ).slice()
          );
          const g = h.getSource(), _ = o.getExtent();
          if (g.getWrapX() && o.canWrapX() && !Rn(_, l)) {
            let y = l[0];
            const E = Mt(_);
            let M = 0, w;
            for (; y < _[0]; )
              --M, w = E * M, c.push(
                this.getRenderTransform(
                  s,
                  r,
                  a,
                  ii,
                  u,
                  d,
                  w
                ).slice()
              ), y += E;
            for (M = 0, y = l[2]; y > _[2]; )
              ++M, w = E * M, c.push(
                this.getRenderTransform(
                  s,
                  r,
                  a,
                  ii,
                  u,
                  d,
                  w
                ).slice()
              ), y -= E;
          }
          this.hitDetectionImageData_ = Ty(
            n,
            c,
            this.renderedFeatures_,
            h.getStyleFunction(),
            l,
            r,
            a,
            kl(r, this.renderedPixelRatio_)
          );
        }
        e(
          Ay(t, this.renderedFeatures_, this.hitDetectionImageData_)
        );
      });
    }
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
     * @return {T|undefined} Callback result.
     * @template T
     * @override
     */
    forEachFeatureAtCoordinate(t, e, n, s, r) {
      var d, g;
      if (!this.replayGroup_)
        return;
      const a = e.viewState.resolution, o = e.viewState.rotation, l = this.getLayer(), h = {}, c = function(_, y, E) {
        const M = Ct(_), w = h[M];
        if (w) {
          if (w !== !0 && E < w.distanceSq) {
            if (E === 0)
              return h[M] = !0, r.splice(r.lastIndexOf(w), 1), s(_, l, y);
            w.geometry = y, w.distanceSq = E;
          }
        } else {
          if (E === 0)
            return h[M] = !0, s(_, l, y);
          r.push(
            h[M] = {
              feature: _,
              layer: l,
              geometry: y,
              distanceSq: E,
              callback: s
            }
          );
        }
      }, u = this.getLayer().getDeclutter();
      return this.replayGroup_.forEachFeatureAtCoordinate(
        t,
        a,
        o,
        n,
        c,
        u ? (g = (d = e.declutter) == null ? void 0 : d[u]) == null ? void 0 : g.all().map((_) => _.value) : null
      );
    }
    /**
     * Perform action necessary to get the layer rendered after new fonts have loaded
     * @override
     */
    handleFontsChanged() {
      const t = this.getLayer();
      t.getVisible() && this.replayGroup_ && t.changed();
    }
    /**
     * Handle changes in image style state.
     * @param {import("../../events/Event.js").default} event Image style change event.
     * @private
     */
    handleStyleImageChange_(t) {
      this.renderIfReadyAndVisible();
    }
    /**
     * Determine whether render should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     * @override
     */
    prepareFrame(t) {
      const e = this.getLayer(), n = e.getSource();
      if (!n)
        return !1;
      const s = t.viewHints[oe.ANIMATING], r = t.viewHints[oe.INTERACTING], a = e.getUpdateWhileAnimating(), o = e.getUpdateWhileInteracting();
      if (this.ready && !a && s || !o && r)
        return this.animatingOrInteracting_ = !0, !0;
      this.animatingOrInteracting_ = !1;
      const l = t.extent, h = t.viewState, c = h.projection, u = h.resolution, d = t.pixelRatio, g = e.getRevision(), _ = e.getRenderBuffer();
      let y = e.getRenderOrder();
      y === void 0 && (y = Vp);
      const E = h.center.slice(), M = uo(
        l,
        _ * u
      ), w = M.slice(), R = [M.slice()], S = c.getExtent();
      if (n.getWrapX() && c.canWrapX() && !Rn(S, t.extent)) {
        const X = Mt(S), mt = Math.max(Mt(M) / 2, X);
        M[0] = S[0] - mt, M[2] = S[2] + mt, yd(E, c);
        const V = oh(R[0], c);
        V[0] < S[0] && V[2] < S[2] ? R.push([
          V[0] + X,
          V[1],
          V[2] + X,
          V[3]
        ]) : V[0] > S[0] && V[2] > S[2] && R.push([
          V[0] - X,
          V[1],
          V[2] - X,
          V[3]
        ]);
      }
      if (this.ready && this.renderedResolution_ == u && this.renderedRevision_ == g && this.renderedRenderOrder_ == y && this.renderedFrameDeclutter_ === !!t.declutter && Rn(this.wrappedRenderedExtent_, M))
        return rn(this.renderedExtent_, w) || (this.hitDetectionImageData_ = null, this.renderedExtent_ = w), this.renderedCenter_ = E, this.replayGroupChanged = !1, !0;
      this.replayGroup_ = null;
      const C = new Ey(
        _f(u, d),
        M,
        u,
        d
      );
      let T;
      for (let X = 0, mt = R.length; X < mt; ++X)
        n.loadFeatures(R[X], u, c);
      const L = kl(u, d);
      let A = !0;
      const O = (
        /**
         * @param {import("../../Feature.js").default} feature Feature.
         * @param {number} index Index.
         */
        (X, mt) => {
          let V;
          const st = X.getStyleFunction() || e.getStyleFunction();
          if (st && (V = st(X, u)), V) {
            const et = this.renderFeature(
              X,
              L,
              V,
              C,
              T,
              this.getLayer().getDeclutter(),
              mt
            );
            A = A && !et;
          }
        }
      ), $ = Td(M), q = n.getFeaturesInExtent($);
      y && q.sort(y);
      for (let X = 0, mt = q.length; X < mt; ++X)
        O(q[X], X);
      this.renderedFeatures_ = q, this.ready = A;
      const Z = C.finish(), Q = new Cy(
        M,
        u,
        d,
        n.getOverlaps(),
        Z,
        e.getRenderBuffer(),
        !!t.declutter
      );
      return this.renderedResolution_ = u, this.renderedRevision_ = g, this.renderedRenderOrder_ = y, this.renderedFrameDeclutter_ = !!t.declutter, this.renderedExtent_ = w, this.wrappedRenderedExtent_ = M, this.renderedCenter_ = E, this.renderedProjection_ = c, this.renderedPixelRatio_ = d, this.replayGroup_ = Q, this.hitDetectionImageData_ = null, this.replayGroupChanged = !0, !0;
    }
    /**
     * @param {import("../../Feature.js").default} feature Feature.
     * @param {number} squaredTolerance Squared render tolerance.
     * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
     * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
     * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
     * @param {boolean} [declutter] Enable decluttering.
     * @param {number} [index] Render order index.
     * @return {boolean} `true` if an image is loading.
     */
    renderFeature(t, e, n, s, r, a, o) {
      if (!n)
        return !1;
      let l = !1;
      if (Array.isArray(n))
        for (let h = 0, c = n.length; h < c; ++h)
          l = _u(
            s,
            t,
            n[h],
            e,
            this.boundHandleStyleImageChange_,
            r,
            a,
            o
          ) || l;
      else
        l = _u(
          s,
          t,
          n,
          e,
          this.boundHandleStyleImageChange_,
          r,
          a,
          o
        );
      return l;
    }
  }
  class Ny extends hf {
    /**
     * @param {Options<VectorSourceType, FeatureType>} [options] Options.
     */
    constructor(t) {
      super(t);
    }
    /**
     * @override
     */
    createRenderer() {
      return new Oy(this);
    }
  }
  class Xh extends ho {
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("./TileState.js").default} state State.
     * @param {Options} [options] Tile options.
     */
    constructor(t, e, n) {
      super(), n = n || {}, this.tileCoord = t, this.state = e, this.key = "", this.transition_ = n.transition === void 0 ? 250 : n.transition, this.transitionStarts_ = {}, this.interpolate = !!n.interpolate;
    }
    /**
     * @protected
     */
    changed() {
      this.dispatchEvent(at.CHANGE);
    }
    /**
     * Called by the tile cache when the tile is removed from the cache due to expiry
     */
    release() {
      this.setState(j.EMPTY);
    }
    /**
     * @return {string} Key.
     */
    getKey() {
      return this.key + "/" + this.tileCoord;
    }
    /**
     * Get the tile coordinate for this tile.
     * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
     * @api
     */
    getTileCoord() {
      return this.tileCoord;
    }
    /**
     * @return {import("./TileState.js").default} State.
     */
    getState() {
      return this.state;
    }
    /**
     * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
     * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
     * when the tile cannot be loaded. Otherwise the tile cannot be removed from
     * the tile queue and will block other requests.
     * @param {import("./TileState.js").default} state State.
     * @api
     */
    setState(t) {
      if (this.state !== j.EMPTY) {
        if (this.state !== j.ERROR && this.state > t)
          throw new Error("Tile load sequence violation");
        this.state = t, this.changed();
      }
    }
    /**
     * Load the image or retry if loading previously failed.
     * Loading is taken care of by the tile queue, and calling this method is
     * only needed for preloading or for reloading in case of an error.
     * @abstract
     * @api
     */
    load() {
      ct();
    }
    /**
     * Get the alpha value for rendering.
     * @param {string} id An id for the renderer.
     * @param {number} time The render frame time.
     * @return {number} A number between 0 and 1.
     */
    getAlpha(t, e) {
      if (!this.transition_)
        return 1;
      let n = this.transitionStarts_[t];
      if (!n)
        n = e, this.transitionStarts_[t] = n;
      else if (n === -1)
        return 1;
      const s = e - n + 1e3 / 60;
      return s >= this.transition_ ? 1 : Ed(s / this.transition_);
    }
    /**
     * Determine if a tile is in an alpha transition.  A tile is considered in
     * transition if tile.getAlpha() has not yet been called or has been called
     * and returned 1.
     * @param {string} id An id for the renderer.
     * @return {boolean} The tile is in transition.
     */
    inTransition(t) {
      return this.transition_ ? this.transitionStarts_[t] !== -1 : !1;
    }
    /**
     * Mark a transition as complete.
     * @param {string} id An id for the renderer.
     */
    endTransition(t) {
      this.transition_ && (this.transitionStarts_[t] = -1);
    }
    /**
     * @override
     */
    disposeInternal() {
      this.release(), super.disposeInternal();
    }
  }
  function Gl(i) {
    return i instanceof Image || i instanceof HTMLCanvasElement || i instanceof HTMLVideoElement || i instanceof ImageBitmap ? i : null;
  }
  const Fy = new Error("disposed"), Dy = [256, 256];
  class Ru extends Xh {
    /**
     * @param {Options} options Tile options.
     */
    constructor(t) {
      const e = j.IDLE;
      super(t.tileCoord, e, {
        transition: t.transition,
        interpolate: t.interpolate
      }), this.loader_ = t.loader, this.data_ = null, this.error_ = null, this.size_ = t.size || null, this.controller_ = t.controller || null;
    }
    /**
     * Get the tile size.
     * @return {import('./size.js').Size} Tile size.
     */
    getSize() {
      if (this.size_)
        return this.size_;
      const t = Gl(this.data_);
      return t ? [t.width, t.height] : Dy;
    }
    /**
     * Get the data for the tile.
     * @return {Data} Tile data.
     * @api
     */
    getData() {
      return this.data_;
    }
    /**
     * Get any loading error.
     * @return {Error} Loading error.
     * @api
     */
    getError() {
      return this.error_;
    }
    /**
     * Load the tile data.
     * @api
     * @override
     */
    load() {
      if (this.state !== j.IDLE && this.state !== j.ERROR)
        return;
      this.state = j.LOADING, this.changed();
      const t = this;
      this.loader_().then(function(e) {
        t.data_ = e, t.state = j.LOADED, t.changed();
      }).catch(function(e) {
        t.error_ = e, t.state = j.ERROR, t.changed();
      });
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.controller_ && (this.controller_.abort(Fy), this.controller_ = null), super.disposeInternal();
    }
  }
  class wf extends Xh {
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("./TileState.js").default} state State.
     * @param {string} src Image source URI.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
     * @param {import("./Tile.js").Options} [options] Tile options.
     */
    constructor(t, e, n, s, r, a) {
      super(t, e, a), this.crossOrigin_ = s, this.src_ = n, this.key = n, this.image_ = new Image(), s !== null && (this.image_.crossOrigin = s), this.unlisten_ = null, this.tileLoadFunction_ = r;
    }
    /**
     * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
     * @api
     */
    getImage() {
      return this.image_;
    }
    /**
     * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
     * @param {HTMLCanvasElement|HTMLImageElement} element Element.
     */
    setImage(t) {
      this.image_ = t, this.state = j.LOADED, this.unlistenImage_(), this.changed();
    }
    /**
     * Tracks loading or read errors.
     *
     * @private
     */
    handleImageError_() {
      this.state = j.ERROR, this.unlistenImage_(), this.image_ = ky(), this.changed();
    }
    /**
     * Tracks successful image load.
     *
     * @private
     */
    handleImageLoad_() {
      const t = (
        /** @type {HTMLImageElement} */
        this.image_
      );
      t.naturalWidth && t.naturalHeight ? this.state = j.LOADED : this.state = j.EMPTY, this.unlistenImage_(), this.changed();
    }
    /**
     * Load the image or retry if loading previously failed.
     * Loading is taken care of by the tile queue, and calling this method is
     * only needed for preloading or for reloading in case of an error.
     *
     * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
     * that checks for error status codes and reloads only when the status code is
     * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
     * made already:
     *
     * ```js
     * const retryCodes = [408, 429, 500, 502, 503, 504];
     * const retries = {};
     * source.setTileLoadFunction((tile, src) => {
     *   const image = tile.getImage();
     *   fetch(src)
     *     .then((response) => {
     *       if (retryCodes.includes(response.status)) {
     *         retries[src] = (retries[src] || 0) + 1;
     *         if (retries[src] <= 3) {
     *           setTimeout(() => tile.load(), retries[src] * 1000);
     *         }
     *         return Promise.reject();
     *       }
     *       return response.blob();
     *     })
     *     .then((blob) => {
     *       const imageUrl = URL.createObjectURL(blob);
     *       image.src = imageUrl;
     *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
     *     })
     *     .catch(() => tile.setState(3)); // error
     * });
     * ```
     * @api
     * @override
     */
    load() {
      this.state == j.ERROR && (this.state = j.IDLE, this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_)), this.state == j.IDLE && (this.state = j.LOADING, this.changed(), this.tileLoadFunction_(this, this.src_), this.unlisten_ = gp(
        this.image_,
        this.handleImageLoad_.bind(this),
        this.handleImageError_.bind(this)
      ));
    }
    /**
     * Discards event handlers which listen for load completion or errors.
     *
     * @private
     */
    unlistenImage_() {
      this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
    }
    /**
     * @override
     */
    disposeInternal() {
      this.unlistenImage_(), this.image_ = null, super.disposeInternal();
    }
  }
  function ky() {
    const i = Kt(1, 1);
    return i.fillStyle = "rgba(0,0,0,0)", i.fillRect(0, 0, 1, 1), i.canvas;
  }
  let ll;
  const vs = [];
  function Iu(i, t, e, n, s) {
    i.beginPath(), i.moveTo(0, 0), i.lineTo(t, e), i.lineTo(n, s), i.closePath(), i.save(), i.clip(), i.fillRect(0, 0, Math.max(t, n) + 1, Math.max(e, s)), i.restore();
  }
  function hl(i, t) {
    return Math.abs(i[t * 4] - 210) > 2 || Math.abs(i[t * 4 + 3] - 0.75 * 255) > 2;
  }
  function Gy() {
    if (ll === void 0) {
      const i = Kt(6, 6, vs);
      i.globalCompositeOperation = "lighter", i.fillStyle = "rgba(210, 0, 0, 0.75)", Iu(i, 4, 5, 4, 0), Iu(i, 4, 5, 0, 5);
      const t = i.getImageData(0, 0, 3, 3).data;
      ll = hl(t, 0) || hl(t, 4) || hl(t, 8), Co(i), vs.push(i.canvas);
    }
    return ll;
  }
  function Tu(i, t, e, n) {
    const s = Id(e, t, i);
    let r = Cl(
      t,
      n,
      e
    );
    const a = t.getMetersPerUnit();
    a !== void 0 && (r *= a);
    const o = i.getMetersPerUnit();
    o !== void 0 && (r /= o);
    const l = i.getExtent();
    if (!l || Fn(l, s)) {
      const h = Cl(i, r, s) / r;
      isFinite(h) && h > 0 && (r /= h);
    }
    return r;
  }
  function zy(i, t, e, n) {
    const s = Si(e);
    let r = Tu(
      i,
      t,
      s,
      n
    );
    return (!isFinite(r) || r <= 0) && _o(e, function(a) {
      return r = Tu(
        i,
        t,
        a,
        n
      ), isFinite(r) && r > 0;
    }), r;
  }
  function $y(i, t, e, n, s, r, a, o, l, h, c, u, d, g) {
    const _ = Kt(
      Math.round(e * i),
      Math.round(e * t),
      vs
    );
    if (u || (_.imageSmoothingEnabled = !1), l.length === 0)
      return _.canvas;
    _.scale(e, e);
    function y(C) {
      return Math.round(C * e) / e;
    }
    _.globalCompositeOperation = "lighter";
    const E = Pe();
    l.forEach(function(C, T, L) {
      mo(E, C.extent);
    });
    let M;
    const w = e / n, R = (u ? 1 : 1 + Math.pow(2, -24)) / w;
    M = Kt(
      Math.round(Mt(E) * w),
      Math.round(te(E) * w),
      vs
    ), u || (M.imageSmoothingEnabled = !1), l.forEach(function(C, T, L) {
      if (C.image.width > 0 && C.image.height > 0) {
        if (C.clipExtent) {
          M.save();
          const Z = (C.clipExtent[0] - E[0]) * w, Q = -(C.clipExtent[3] - E[3]) * w, X = Mt(C.clipExtent) * w, mt = te(C.clipExtent) * w;
          M.rect(
            u ? Z : Math.round(Z),
            u ? Q : Math.round(Q),
            u ? X : Math.round(Z + X) - Math.round(Z),
            u ? mt : Math.round(Q + mt) - Math.round(Q)
          ), M.clip();
        }
        const A = (C.extent[0] - E[0]) * w, O = -(C.extent[3] - E[3]) * w, $ = Mt(C.extent) * w, q = te(C.extent) * w;
        M.drawImage(
          C.image,
          h,
          h,
          C.image.width - 2 * h,
          C.image.height - 2 * h,
          u ? A : Math.round(A),
          u ? O : Math.round(O),
          u ? $ : Math.round(A + $) - Math.round(A),
          u ? q : Math.round(O + q) - Math.round(O)
        ), C.clipExtent && M.restore();
      }
    });
    const S = on(a);
    return o.getTriangles().forEach(function(C, T, L) {
      const A = C.source, O = C.target;
      let $ = A[0][0], q = A[0][1], Z = A[1][0], Q = A[1][1], X = A[2][0], mt = A[2][1];
      const V = y((O[0][0] - S[0]) / r), st = y(
        -(O[0][1] - S[1]) / r
      ), et = y((O[1][0] - S[0]) / r), lt = y(
        -(O[1][1] - S[1]) / r
      ), rt = y((O[2][0] - S[0]) / r), tt = y(
        -(O[2][1] - S[1]) / r
      ), D = $, _t = q;
      $ = 0, q = 0, Z -= D, Q -= _t, X -= D, mt -= _t;
      const U = [
        [Z, Q, 0, 0, et - V],
        [X, mt, 0, 0, rt - V],
        [0, 0, Z, Q, lt - st],
        [0, 0, X, mt, tt - st]
      ], dt = P0(U);
      if (!dt)
        return;
      if (_.save(), _.beginPath(), Gy() || !u) {
        _.moveTo(et, lt);
        const jt = 4, $t = V - et, hi = st - lt;
        for (let Ut = 0; Ut < jt; Ut++)
          _.lineTo(
            et + y((Ut + 1) * $t / jt),
            lt + y(Ut * hi / (jt - 1))
          ), Ut != jt - 1 && _.lineTo(
            et + y((Ut + 1) * $t / jt),
            lt + y((Ut + 1) * hi / (jt - 1))
          );
        _.lineTo(rt, tt);
      } else
        _.moveTo(et, lt), _.lineTo(V, st), _.lineTo(rt, tt);
      _.clip(), _.transform(
        dt[0],
        dt[2],
        dt[1],
        dt[3],
        V,
        st
      ), _.translate(
        E[0] - D,
        E[3] - _t
      );
      let Vt;
      if (M)
        Vt = M.canvas, _.scale(R, -R);
      else {
        const jt = l[0], $t = jt.extent;
        Vt = jt.image, _.scale(
          Mt($t) / Vt.width,
          -te($t) / Vt.height
        );
      }
      _.drawImage(Vt, 0, 0), _.restore();
    }), M && (Co(M), vs.push(M.canvas)), c && (_.save(), _.globalCompositeOperation = "source-over", _.strokeStyle = "black", _.lineWidth = 1, o.getTriangles().forEach(function(C, T, L) {
      const A = C.target, O = (A[0][0] - S[0]) / r, $ = -(A[0][1] - S[1]) / r, q = (A[1][0] - S[0]) / r, Z = -(A[1][1] - S[1]) / r, Q = (A[2][0] - S[0]) / r, X = -(A[2][1] - S[1]) / r;
      _.beginPath(), _.moveTo(q, Z), _.lineTo(O, $), _.lineTo(Q, X), _.closePath(), _.stroke();
    }), _.restore()), _.canvas;
  }
  const Uy = 10, Au = 0.25;
  class By {
    /**
     * @param {import("../proj/Projection.js").default} sourceProj Source projection.
     * @param {import("../proj/Projection.js").default} targetProj Target projection.
     * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
     * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
     * @param {number} errorThreshold Acceptable error (in source units).
     * @param {?number} destinationResolution The (optional) resolution of the destination.
     * @param {import("../transform.js").Transform} [sourceMatrix] Source transform matrix.
     */
    constructor(t, e, n, s, r, a, o) {
      this.sourceProj_ = t, this.targetProj_ = e;
      let l = {};
      const h = o ? Il(
        (R) => Xt(
          o,
          Id(R, this.targetProj_, this.sourceProj_)
        )
      ) : Ps(this.targetProj_, this.sourceProj_);
      this.transformInv_ = function(R) {
        const S = R[0] + "/" + R[1];
        return l[S] || (l[S] = h(R)), l[S];
      }, this.maxSourceExtent_ = s, this.errorThresholdSquared_ = r * r, this.triangles_ = [], this.wrapsXInSource_ = !1, this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!s && !!this.sourceProj_.getExtent() && Mt(s) >= Mt(this.sourceProj_.getExtent()), this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? Mt(this.sourceProj_.getExtent()) : null, this.targetWorldWidth_ = this.targetProj_.getExtent() ? Mt(this.targetProj_.getExtent()) : null;
      const c = on(n), u = $r(n), d = zr(n), g = Gr(n), _ = this.transformInv_(c), y = this.transformInv_(u), E = this.transformInv_(d), M = this.transformInv_(g), w = Uy + (a ? Math.max(
        0,
        Math.ceil(
          Math.log2(
            xr(n) / (a * a * 256 * 256)
          )
        )
      ) : 0);
      if (this.addQuad_(
        c,
        u,
        d,
        g,
        _,
        y,
        E,
        M,
        w
      ), this.wrapsXInSource_) {
        let R = 1 / 0;
        this.triangles_.forEach(function(S, C, T) {
          R = Math.min(
            R,
            S.source[0][0],
            S.source[1][0],
            S.source[2][0]
          );
        }), this.triangles_.forEach((S) => {
          if (Math.max(
            S.source[0][0],
            S.source[1][0],
            S.source[2][0]
          ) - R > this.sourceWorldWidth_ / 2) {
            const C = [
              [S.source[0][0], S.source[0][1]],
              [S.source[1][0], S.source[1][1]],
              [S.source[2][0], S.source[2][1]]
            ];
            C[0][0] - R > this.sourceWorldWidth_ / 2 && (C[0][0] -= this.sourceWorldWidth_), C[1][0] - R > this.sourceWorldWidth_ / 2 && (C[1][0] -= this.sourceWorldWidth_), C[2][0] - R > this.sourceWorldWidth_ / 2 && (C[2][0] -= this.sourceWorldWidth_);
            const T = Math.min(
              C[0][0],
              C[1][0],
              C[2][0]
            );
            Math.max(
              C[0][0],
              C[1][0],
              C[2][0]
            ) - T < this.sourceWorldWidth_ / 2 && (S.source = C);
          }
        });
      }
      l = {};
    }
    /**
     * Adds triangle to the triangulation.
     * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
     * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
     * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
     * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
     * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
     * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
     * @private
     */
    addTriangle_(t, e, n, s, r, a) {
      this.triangles_.push({
        source: [s, r, a],
        target: [t, e, n]
      });
    }
    /**
     * Adds quad (points in clock-wise order) to the triangulation
     * (and reprojects the vertices) if valid.
     * Performs quad subdivision if needed to increase precision.
     *
     * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
     * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
     * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
     * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
     * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
     * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
     * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
     * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
     * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
     * @private
     */
    addQuad_(t, e, n, s, r, a, o, l, h) {
      const c = xl([r, a, o, l]), u = this.sourceWorldWidth_ ? Mt(c) / this.sourceWorldWidth_ : null, d = (
        /** @type {number} */
        this.sourceWorldWidth_
      ), g = this.sourceProj_.canWrapX() && u > 0.5 && u < 1;
      let _ = !1;
      if (h > 0) {
        if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
          const E = xl([t, e, n, s]);
          _ = Mt(E) / this.targetWorldWidth_ > Au || _;
        }
        !g && this.sourceProj_.isGlobal() && u && (_ = u > Au || _);
      }
      if (!_ && this.maxSourceExtent_ && isFinite(c[0]) && isFinite(c[1]) && isFinite(c[2]) && isFinite(c[3]) && !he(c, this.maxSourceExtent_))
        return;
      let y = 0;
      if (!_ && (!isFinite(r[0]) || !isFinite(r[1]) || !isFinite(a[0]) || !isFinite(a[1]) || !isFinite(o[0]) || !isFinite(o[1]) || !isFinite(l[0]) || !isFinite(l[1]))) {
        if (h > 0)
          _ = !0;
        else if (y = (!isFinite(r[0]) || !isFinite(r[1]) ? 8 : 0) + (!isFinite(a[0]) || !isFinite(a[1]) ? 4 : 0) + (!isFinite(o[0]) || !isFinite(o[1]) ? 2 : 0) + (!isFinite(l[0]) || !isFinite(l[1]) ? 1 : 0), y != 1 && y != 2 && y != 4 && y != 8)
          return;
      }
      if (h > 0) {
        if (!_) {
          const E = [(t[0] + n[0]) / 2, (t[1] + n[1]) / 2], M = this.transformInv_(E);
          let w;
          g ? w = (_s(r[0], d) + _s(o[0], d)) / 2 - _s(M[0], d) : w = (r[0] + o[0]) / 2 - M[0];
          const R = (r[1] + o[1]) / 2 - M[1];
          _ = w * w + R * R > this.errorThresholdSquared_;
        }
        if (_) {
          if (Math.abs(t[0] - n[0]) <= Math.abs(t[1] - n[1])) {
            const E = [(e[0] + n[0]) / 2, (e[1] + n[1]) / 2], M = this.transformInv_(E), w = [(s[0] + t[0]) / 2, (s[1] + t[1]) / 2], R = this.transformInv_(w);
            this.addQuad_(
              t,
              e,
              E,
              w,
              r,
              a,
              M,
              R,
              h - 1
            ), this.addQuad_(
              w,
              E,
              n,
              s,
              R,
              M,
              o,
              l,
              h - 1
            );
          } else {
            const E = [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2], M = this.transformInv_(E), w = [(n[0] + s[0]) / 2, (n[1] + s[1]) / 2], R = this.transformInv_(w);
            this.addQuad_(
              t,
              E,
              w,
              s,
              r,
              M,
              R,
              l,
              h - 1
            ), this.addQuad_(
              E,
              e,
              n,
              w,
              M,
              a,
              o,
              R,
              h - 1
            );
          }
          return;
        }
      }
      if (g) {
        if (!this.canWrapXInSource_)
          return;
        this.wrapsXInSource_ = !0;
      }
      y & 11 || this.addTriangle_(t, n, s, r, o, l), y & 14 || this.addTriangle_(t, n, e, r, o, a), y && (y & 13 || this.addTriangle_(e, s, t, a, l, r), y & 7 || this.addTriangle_(e, s, n, a, l, o));
    }
    /**
     * Calculates extent of the `source` coordinates from all the triangles.
     *
     * @return {import("../extent.js").Extent} Calculated extent.
     */
    calculateSourceExtent() {
      const t = Pe();
      return this.triangles_.forEach(function(e, n, s) {
        const r = e.source;
        On(t, r[0]), On(t, r[1]), On(t, r[2]);
      }), t;
    }
    /**
     * @return {Array<Triangle>} Array of the calculated triangles.
     */
    getTriangles() {
      return this.triangles_;
    }
  }
  const Wy = 0.5;
  class Sf extends Xh {
    /**
     * @param {import("../proj/Projection.js").default} sourceProj Source projection.
     * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
     * @param {import("../proj/Projection.js").default} targetProj Target projection.
     * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
     * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
     * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
     * @param {number} pixelRatio Pixel ratio.
     * @param {number} gutter Gutter of the source tiles.
     * @param {FunctionType} getTileFunction
     *     Function returning source tiles (z, x, y, pixelRatio).
     * @param {number} [errorThreshold] Acceptable reprojection error (in px).
     * @param {boolean} [renderEdges] Render reprojection edges.
     * @param {import("../Tile.js").Options} [options] Tile options.
     */
    constructor(t, e, n, s, r, a, o, l, h, c, u, d) {
      super(r, j.IDLE, d), this.renderEdges_ = u !== void 0 ? u : !1, this.pixelRatio_ = o, this.gutter_ = l, this.canvas_ = null, this.sourceTileGrid_ = e, this.targetTileGrid_ = s, this.wrappedTileCoord_ = a || r, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0, this.clipExtent_ = t.canWrapX() ? t.getExtent() : void 0;
      const g = s.getTileCoordExtent(
        this.wrappedTileCoord_
      ), _ = this.targetTileGrid_.getExtent();
      let y = this.sourceTileGrid_.getExtent();
      const E = _ ? Mi(g, _) : g;
      if (xr(E) === 0) {
        this.state = j.EMPTY;
        return;
      }
      const M = t.getExtent();
      M && (y ? y = Mi(y, M) : y = M);
      const w = s.getResolution(
        this.wrappedTileCoord_[0]
      ), R = zy(
        t,
        n,
        E,
        w
      );
      if (!isFinite(R) || R <= 0) {
        this.state = j.EMPTY;
        return;
      }
      const S = c !== void 0 ? c : Wy;
      if (this.triangulation_ = new By(
        t,
        n,
        E,
        y,
        R * S,
        w
      ), this.triangulation_.getTriangles().length === 0) {
        this.state = j.EMPTY;
        return;
      }
      this.sourceZ_ = e.getZForResolution(R);
      let C = this.triangulation_.calculateSourceExtent();
      if (y && (t.canWrapX() ? (C[1] = zt(
        C[1],
        y[1],
        y[3]
      ), C[3] = zt(
        C[3],
        y[1],
        y[3]
      )) : C = Mi(C, y)), !xr(C))
        this.state = j.EMPTY;
      else {
        let T = 0, L = 0;
        t.canWrapX() && (T = Mt(M), L = Math.floor(
          (C[0] - M[0]) / T
        )), lh(
          C.slice(),
          t,
          !0
        ).forEach((O) => {
          const $ = e.getTileRangeForExtentAndZ(
            O,
            this.sourceZ_
          );
          for (let q = $.minX; q <= $.maxX; q++)
            for (let Z = $.minY; Z <= $.maxY; Z++) {
              const Q = h(this.sourceZ_, q, Z, o);
              if (Q) {
                const X = L * T;
                this.sourceTiles_.push({ tile: Q, offset: X });
              }
            }
          ++L;
        }), this.sourceTiles_.length === 0 && (this.state = j.EMPTY);
      }
    }
    /**
     * Get the HTML Canvas element for this tile.
     * @return {HTMLCanvasElement} Canvas.
     */
    getImage() {
      return this.canvas_;
    }
    /**
     * @private
     */
    reproject_() {
      const t = [];
      if (this.sourceTiles_.forEach((e) => {
        var s;
        const n = e.tile;
        if (n && n.getState() == j.LOADED) {
          const r = this.sourceTileGrid_.getTileCoordExtent(n.tileCoord);
          r[0] += e.offset, r[2] += e.offset;
          const a = (s = this.clipExtent_) == null ? void 0 : s.slice();
          a && (a[0] += e.offset, a[2] += e.offset), t.push({
            extent: r,
            clipExtent: a,
            image: n.getImage()
          });
        }
      }), this.sourceTiles_.length = 0, t.length === 0)
        this.state = j.ERROR;
      else {
        const e = this.wrappedTileCoord_[0], n = this.targetTileGrid_.getTileSize(e), s = typeof n == "number" ? n : n[0], r = typeof n == "number" ? n : n[1], a = this.targetTileGrid_.getResolution(e), o = this.sourceTileGrid_.getResolution(
          this.sourceZ_
        ), l = this.targetTileGrid_.getTileCoordExtent(
          this.wrappedTileCoord_
        );
        this.canvas_ = $y(
          s,
          r,
          this.pixelRatio_,
          o,
          this.sourceTileGrid_.getExtent(),
          a,
          l,
          this.triangulation_,
          t,
          this.gutter_,
          this.renderEdges_,
          this.interpolate
        ), this.state = j.LOADED;
      }
      this.changed();
    }
    /**
     * Load not yet loaded URI.
     * @override
     */
    load() {
      if (this.state == j.IDLE) {
        this.state = j.LOADING, this.changed();
        let t = 0;
        this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach(({ tile: e }) => {
          const n = e.getState();
          if (n == j.IDLE || n == j.LOADING) {
            t++;
            const s = vt(e, at.CHANGE, (r) => {
              const a = e.getState();
              (a == j.LOADED || a == j.ERROR || a == j.EMPTY) && (Pt(s), t--, t === 0 && (this.unlistenSources_(), this.reproject_()));
            });
            this.sourcesListenerKeys_.push(s);
          }
        }), t === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function({ tile: e }, n, s) {
          e.getState() == j.IDLE && e.load();
        });
      }
    }
    /**
     * @private
     */
    unlistenSources_() {
      this.sourcesListenerKeys_.forEach(Pt), this.sourcesListenerKeys_ = null;
    }
    /**
     * Remove from the cache due to expiry
     * @override
     */
    release() {
      this.canvas_ && (Co(this.canvas_.getContext("2d")), vs.push(this.canvas_), this.canvas_ = null), super.release();
    }
  }
  class Yh {
    /**
     * @param {number} minX Minimum X.
     * @param {number} maxX Maximum X.
     * @param {number} minY Minimum Y.
     * @param {number} maxY Maximum Y.
     */
    constructor(t, e, n, s) {
      this.minX = t, this.maxX = e, this.minY = n, this.maxY = s;
    }
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @return {boolean} Contains tile coordinate.
     */
    contains(t) {
      return this.containsXY(t[1], t[2]);
    }
    /**
     * @param {TileRange} tileRange Tile range.
     * @return {boolean} Contains.
     */
    containsTileRange(t) {
      return this.minX <= t.minX && t.maxX <= this.maxX && this.minY <= t.minY && t.maxY <= this.maxY;
    }
    /**
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @return {boolean} Contains coordinate.
     */
    containsXY(t, e) {
      return this.minX <= t && t <= this.maxX && this.minY <= e && e <= this.maxY;
    }
    /**
     * @param {TileRange} tileRange Tile range.
     * @return {boolean} Equals.
     */
    equals(t) {
      return this.minX == t.minX && this.minY == t.minY && this.maxX == t.maxX && this.maxY == t.maxY;
    }
    /**
     * @param {TileRange} tileRange Tile range.
     */
    extend(t) {
      t.minX < this.minX && (this.minX = t.minX), t.maxX > this.maxX && (this.maxX = t.maxX), t.minY < this.minY && (this.minY = t.minY), t.maxY > this.maxY && (this.maxY = t.maxY);
    }
    /**
     * @return {number} Height.
     */
    getHeight() {
      return this.maxY - this.minY + 1;
    }
    /**
     * @return {import("./size.js").Size} Size.
     */
    getSize() {
      return [this.getWidth(), this.getHeight()];
    }
    /**
     * @return {number} Width.
     */
    getWidth() {
      return this.maxX - this.minX + 1;
    }
    /**
     * @param {TileRange} tileRange Tile range.
     * @return {boolean} Intersects.
     */
    intersects(t) {
      return this.minX <= t.maxX && this.maxX >= t.minX && this.minY <= t.maxY && this.maxY >= t.minY;
    }
  }
  function is(i, t, e, n, s) {
    return s !== void 0 ? (s.minX = i, s.maxX = t, s.minY = e, s.maxY = n, s) : new Yh(i, t, e, n);
  }
  class Xy {
    /**
     * @param {number} [highWaterMark] High water mark.
     */
    constructor(t) {
      this.highWaterMark = t !== void 0 ? t : 2048, this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
    }
    deleteOldest() {
      const t = this.pop();
      t instanceof oo && t.dispose();
    }
    /**
     * @return {boolean} Can expire cache.
     */
    canExpireCache() {
      return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
    }
    /**
     * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},
     * the entry will be disposed.
     * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
     */
    expireCache(t) {
      for (; this.canExpireCache(); )
        this.deleteOldest();
    }
    /**
     * FIXME empty description for jsdoc
     */
    clear() {
      for (; this.oldest_; )
        this.deleteOldest();
    }
    /**
     * @param {string} key Key.
     * @return {boolean} Contains key.
     */
    containsKey(t) {
      return this.entries_.hasOwnProperty(t);
    }
    /**
     * @param {function(T, string, LRUCache<T>): ?} f The function
     *     to call for every entry from the oldest to the newer. This function takes
     *     3 arguments (the entry value, the entry key and the LRUCache object).
     *     The return value is ignored.
     */
    forEach(t) {
      let e = this.oldest_;
      for (; e; )
        t(e.value_, e.key_, this), e = e.newer;
    }
    /**
     * @param {string} key Key.
     * @param {*} [options] Options (reserved for subclasses).
     * @return {T} Value.
     */
    get(t, e) {
      const n = this.entries_[t];
      return xt(
        n !== void 0,
        "Tried to get a value for a key that does not exist in the cache"
      ), n === this.newest_ || (n === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
      this.oldest_.newer, this.oldest_.older = null) : (n.newer.older = n.older, n.older.newer = n.newer), n.newer = null, n.older = this.newest_, this.newest_.newer = n, this.newest_ = n), n.value_;
    }
    /**
     * Remove an entry from the cache.
     * @param {string} key The entry key.
     * @return {T} The removed entry.
     */
    remove(t) {
      const e = this.entries_[t];
      return xt(
        e !== void 0,
        "Tried to get a value for a key that does not exist in the cache"
      ), e === this.newest_ ? (this.newest_ = /** @type {Entry} */
      e.older, this.newest_ && (this.newest_.newer = null)) : e === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
      e.newer, this.oldest_ && (this.oldest_.older = null)) : (e.newer.older = e.older, e.older.newer = e.newer), delete this.entries_[t], --this.count_, e.value_;
    }
    /**
     * @return {number} Count.
     */
    getCount() {
      return this.count_;
    }
    /**
     * @return {Array<string>} Keys.
     */
    getKeys() {
      const t = new Array(this.count_);
      let e = 0, n;
      for (n = this.newest_; n; n = n.older)
        t[e++] = n.key_;
      return t;
    }
    /**
     * @return {Array<T>} Values.
     */
    getValues() {
      const t = new Array(this.count_);
      let e = 0, n;
      for (n = this.newest_; n; n = n.older)
        t[e++] = n.value_;
      return t;
    }
    /**
     * @return {T} Last value.
     */
    peekLast() {
      return this.oldest_.value_;
    }
    /**
     * @return {string} Last key.
     */
    peekLastKey() {
      return this.oldest_.key_;
    }
    /**
     * Get the key of the newest item in the cache.  Throws if the cache is empty.
     * @return {string} The newest key.
     */
    peekFirstKey() {
      return this.newest_.key_;
    }
    /**
     * Return an entry without updating least recently used time.
     * @param {string} key Key.
     * @return {T|undefined} Value.
     */
    peek(t) {
      var e;
      return (e = this.entries_[t]) == null ? void 0 : e.value_;
    }
    /**
     * @return {T} value Value.
     */
    pop() {
      const t = this.oldest_;
      return delete this.entries_[t.key_], t.newer && (t.newer.older = null), this.oldest_ = /** @type {Entry} */
      t.newer, this.oldest_ || (this.newest_ = null), --this.count_, t.value_;
    }
    /**
     * @param {string} key Key.
     * @param {T} value Value.
     */
    replace(t, e) {
      this.get(t), this.entries_[t].value_ = e;
    }
    /**
     * @param {string} key Key.
     * @param {T} value Value.
     */
    set(t, e) {
      xt(
        !(t in this.entries_),
        "Tried to set a value for a key that is used already"
      );
      const n = {
        key_: t,
        newer: null,
        older: this.newest_,
        value_: e
      };
      this.newest_ ? this.newest_.newer = n : this.oldest_ = n, this.newest_ = n, this.entries_[t] = n, ++this.count_;
    }
    /**
     * Set a maximum number of entries for the cache.
     * @param {number} size Cache size.
     * @api
     */
    setSize(t) {
      this.highWaterMark = t;
    }
  }
  function Ja(i, t, e, n) {
    return n !== void 0 ? (n[0] = i, n[1] = t, n[2] = e, n) : [i, t, e];
  }
  function Yy(i, t, e) {
    return i + "/" + t + "/" + e;
  }
  function Zy(i) {
    return qy(i[0], i[1], i[2]);
  }
  function qy(i, t, e) {
    return (t << i) + e;
  }
  function Ky(i, t) {
    const e = i[0], n = i[1], s = i[2];
    if (t.getMinZoom() > e || e > t.getMaxZoom())
      return !1;
    const r = t.getFullTileRange(e);
    return r ? r.containsXY(n, s) : !0;
  }
  function cl(i, t, e, n) {
    return `${i},${Yy(t, e, n)}`;
  }
  function ul(i, t, e) {
    if (!(e in i))
      return i[e] = /* @__PURE__ */ new Set([t]), !0;
    const n = i[e], s = n.has(t);
    return s || n.add(t), !s;
  }
  function Vy(i, t, e) {
    const n = i[e];
    return n ? n.delete(t) : !1;
  }
  function bu(i, t) {
    const e = i.layerStatesArray[i.layerIndex];
    e.extent && (t = Mi(
      t,
      Wi(e.extent, i.viewState.projection)
    ));
    const n = (
      /** @type {import("../../source/Tile.js").default} */
      e.layer.getRenderSource()
    );
    if (!n.getWrapX()) {
      const s = n.getTileGridForProjection(i.viewState.projection).getExtent();
      s && (t = Mi(t, s));
    }
    return t;
  }
  class jy extends xf {
    /**
     * @param {LayerType} tileLayer Tile layer.
     * @param {Options} [options] Options.
     */
    constructor(t, e) {
      super(t), e = e || {}, this.extentChanged = !0, this.renderComplete = !1, this.renderedExtent_ = null, this.renderedPixelRatio, this.renderedProjection = null, this.renderedRevision_, this.renderedTiles = [], this.renderedSourceKey_, this.renderedSourceRevision_, this.tempExtent = Pe(), this.tempTileRange_ = new Yh(0, 0, 0, 0), this.tempTileCoord_ = Ja(0, 0, 0);
      const n = e.cacheSize !== void 0 ? e.cacheSize : 512;
      this.tileCache_ = new Xy(n), this.maxStaleKeys = n * 0.5;
    }
    /**
     * @return {LRUCache} Tile cache.
     */
    getTileCache() {
      return this.tileCache_;
    }
    /**
     * Get a tile from the cache or create one if needed.
     *
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
     * @protected
     */
    getOrCreateTile(t, e, n, s) {
      const r = this.tileCache_, o = this.getLayer().getSource(), l = cl(o.getKey(), t, e, n);
      let h;
      if (r.containsKey(l))
        h = r.get(l);
      else {
        if (h = o.getTile(
          t,
          e,
          n,
          s.pixelRatio,
          s.viewState.projection
        ), !h)
          return null;
        r.set(l, h);
      }
      return h;
    }
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
     * @protected
     */
    getTile(t, e, n, s) {
      const r = this.getOrCreateTile(t, e, n, s);
      return r || null;
    }
    /**
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray} Data at the pixel location.
     * @override
     */
    getData(t) {
      const e = this.frameState;
      if (!e)
        return null;
      const n = this.getLayer(), s = Xt(
        e.pixelToCoordinateTransform,
        t.slice()
      ), r = n.getExtent();
      if (r && !Fn(r, s))
        return null;
      const a = e.viewState, o = n.getRenderSource(), l = o.getTileGridForProjection(a.projection), h = o.getTilePixelRatio(e.pixelRatio);
      for (let c = l.getZForResolution(a.resolution); c >= l.getMinZoom(); --c) {
        const u = l.getTileCoordForCoordAndZ(s, c), d = this.getTile(c, u[1], u[2], e);
        if (!d || d.getState() !== j.LOADED)
          continue;
        const g = l.getOrigin(c), _ = Ce(l.getTileSize(c)), y = l.getResolution(c);
        let E;
        if (d instanceof wf || d instanceof Sf)
          E = d.getImage();
        else if (d instanceof Ru) {
          if (E = Gl(d.getData()), !E)
            continue;
        } else
          continue;
        const M = Math.floor(
          h * ((s[0] - g[0]) / y - u[1] * _[0])
        ), w = Math.floor(
          h * ((g[1] - s[1]) / y - u[2] * _[1])
        ), R = Math.round(
          h * o.getGutterForProjection(a.projection)
        );
        return this.getImageData(E, M + R, w + R);
      }
      return null;
    }
    /**
     * Determine whether render should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     * @override
     */
    prepareFrame(t) {
      this.renderedProjection ? t.viewState.projection !== this.renderedProjection && (this.tileCache_.clear(), this.renderedProjection = t.viewState.projection) : this.renderedProjection = t.viewState.projection;
      const e = this.getLayer().getSource();
      if (!e)
        return !1;
      const n = e.getRevision();
      return this.renderedRevision_ ? this.renderedRevision_ !== n && (this.renderedRevision_ = n, this.renderedSourceKey_ === e.getKey() && this.tileCache_.clear()) : this.renderedRevision_ = n, !0;
    }
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {import("../../extent.js").Extent} extent The extent to be rendered.
     * @param {number} initialZ The zoom level.
     * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
     * @param {number} preload Number of additional levels to load.
     */
    enqueueTiles(t, e, n, s, r) {
      const a = t.viewState, o = this.getLayer(), l = o.getRenderSource(), h = l.getTileGridForProjection(a.projection), c = Ct(l);
      c in t.wantedTiles || (t.wantedTiles[c] = {});
      const u = t.wantedTiles[c], d = o.getMapInternal(), g = Math.max(
        n - r,
        h.getMinZoom(),
        h.getZForResolution(
          Math.min(
            o.getMaxResolution(),
            d ? d.getView().getResolutionForZoom(Math.max(o.getMinZoom(), 0)) : h.getResolution(0)
          ),
          l.zDirection
        )
      ), _ = a.rotation, y = _ ? ah(
        a.center,
        a.resolution,
        _,
        t.size
      ) : void 0;
      for (let E = n; E >= g; --E) {
        const M = h.getTileRangeForExtentAndZ(
          e,
          E,
          this.tempTileRange_
        ), w = h.getResolution(E);
        for (let R = M.minX; R <= M.maxX; ++R)
          for (let S = M.minY; S <= M.maxY; ++S) {
            if (_ && !h.tileCoordIntersectsViewport([E, R, S], y))
              continue;
            const C = this.getTile(E, R, S, t);
            if (!C || !ul(s, C, E))
              continue;
            const L = C.getKey();
            if (u[L] = !0, C.getState() === j.IDLE && !t.tileQueue.isKeyQueued(L)) {
              const A = Ja(E, R, S, this.tempTileCoord_);
              t.tileQueue.enqueue([
                C,
                c,
                h.getTileCoordCenter(A),
                w
              ]);
            }
          }
      }
    }
    /**
     * Look for tiles covering the provided tile coordinate at an alternate
     * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
     * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
     * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
     * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
     * @private
     */
    findStaleTile_(t, e) {
      const n = this.tileCache_, s = t[0], r = t[1], a = t[2], o = this.getStaleKeys();
      for (let l = 0; l < o.length; ++l) {
        const h = cl(o[l], s, r, a);
        if (n.containsKey(h)) {
          const c = n.peek(h);
          if (c.getState() === j.LOADED)
            return c.endTransition(Ct(this)), ul(e, c, s), !0;
        }
      }
      return !1;
    }
    /**
     * Look for tiles covering the provided tile coordinate at an alternate
     * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
     * @param {import("../../tilegrid/TileGrid.js").default} tileGrid The tile grid.
     * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
     * @param {number} altZ The alternate zoom level.
     * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
     * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
     * @private
     */
    findAltTiles_(t, e, n, s) {
      const r = t.getTileRangeForTileCoordAndZ(
        e,
        n,
        this.tempTileRange_
      );
      if (!r)
        return !1;
      let a = !0;
      const o = this.tileCache_, h = this.getLayer().getRenderSource().getKey();
      for (let c = r.minX; c <= r.maxX; ++c)
        for (let u = r.minY; u <= r.maxY; ++u) {
          const d = cl(h, n, c, u);
          let g = !1;
          if (o.containsKey(d)) {
            const _ = o.peek(d);
            _.getState() === j.LOADED && (ul(s, _, n), g = !0);
          }
          g || (a = !1);
        }
      return a;
    }
    /**
     * Render the layer.
     *
     * The frame rendering logic has three parts:
     *
     *  1. Enqueue tiles
     *  2. Find alt tiles for those that are not yet loaded
     *  3. Render loaded tiles
     *
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target that may be used to render content to.
     * @return {HTMLElement} The rendered element.
     * @override
     */
    renderFrame(t, e) {
      let n = !0;
      this.renderComplete = !0;
      const s = t.layerStatesArray[t.layerIndex], r = t.viewState, a = r.projection, o = r.resolution, l = r.center, h = t.pixelRatio, c = this.getLayer(), u = c.getSource(), d = u.getTileGridForProjection(a), g = d.getZForResolution(o, u.zDirection), _ = d.getResolution(g), y = u.getKey();
      this.renderedSourceKey_ ? this.renderedSourceKey_ !== y && (this.prependStaleKey(this.renderedSourceKey_), this.renderedSourceKey_ = y) : this.renderedSourceKey_ = y;
      let E = t.extent;
      const M = u.getTilePixelRatio(h);
      this.prepareContainer(t, e);
      const w = this.context.canvas.width, R = this.context.canvas.height, S = s.extent && Wi(s.extent);
      S && (E = Mi(
        E,
        Wi(s.extent)
      ));
      const C = _ * w / 2 / M, T = _ * R / 2 / M, L = [
        l[0] - C,
        l[1] - T,
        l[0] + C,
        l[1] + T
      ], A = {};
      this.renderedTiles.length = 0;
      const O = c.getPreload();
      if (t.nextExtent) {
        const lt = d.getZForResolution(
          r.nextResolution,
          u.zDirection
        ), rt = bu(t, t.nextExtent);
        this.enqueueTiles(t, rt, lt, A, O);
      }
      const $ = bu(t, E);
      if (this.enqueueTiles(t, $, g, A, 0), O > 0 && setTimeout(() => {
        this.enqueueTiles(
          t,
          $,
          g - 1,
          A,
          O - 1
        );
      }, 0), !(g in A))
        return this.container;
      const q = Ct(this), Z = t.time;
      for (const lt of A[g]) {
        const rt = lt.getState();
        if (rt === j.EMPTY)
          continue;
        const tt = lt.tileCoord;
        if (rt === j.LOADED && lt.getAlpha(q, Z) === 1) {
          lt.endTransition(q);
          continue;
        }
        if (rt !== j.IDLE && (n = !1), rt !== j.ERROR && (this.renderComplete = !1), this.findStaleTile_(tt, A)) {
          Vy(A, lt, g), t.animate = !0;
          continue;
        }
        if (this.findAltTiles_(
          d,
          tt,
          g + 1,
          A
        ))
          continue;
        const U = d.getMinZoom();
        for (let dt = g - 1; dt >= U && !this.findAltTiles_(
          d,
          tt,
          dt,
          A
        ); --dt)
          ;
      }
      const Q = _ / o * h / M, X = this.getRenderContext(t);
      Ci(
        this.tempTransform,
        w / 2,
        R / 2,
        Q,
        Q,
        0,
        -w / 2,
        -R / 2
      ), s.extent && this.clipUnrotated(X, t, S), u.getInterpolate() || (X.imageSmoothingEnabled = !1), this.preRender(X, t);
      const mt = Object.keys(A).map(Number);
      mt.sort(Ki);
      let V;
      const st = [], et = [];
      for (let lt = mt.length - 1; lt >= 0; --lt) {
        const rt = mt[lt], tt = u.getTilePixelSize(
          rt,
          h,
          a
        ), _t = d.getResolution(rt) / _, U = tt[0] * _t * Q, dt = tt[1] * _t * Q, Vt = d.getTileCoordForCoordAndZ(
          on(L),
          rt
        ), jt = d.getTileCoordExtent(Vt), $t = Xt(this.tempTransform, [
          M * (jt[0] - L[0]) / _,
          M * (L[3] - jt[3]) / _
        ]), hi = M * u.getGutterForProjection(a);
        for (const Ut of A[rt]) {
          if (Ut.getState() !== j.LOADED)
            continue;
          const hn = Ut.tileCoord, Wn = Vt[1] - hn[1], ci = Math.round($t[0] - (Wn - 1) * U), ti = Vt[2] - hn[2], cn = Math.round($t[1] - (ti - 1) * dt), Oe = Math.round($t[0] - Wn * U), Ne = Math.round($t[1] - ti * dt), Pi = ci - Oe, ui = cn - Ne, Be = mt.length === 1;
          let un = !1;
          V = [Oe, Ne, Oe + Pi, Ne, Oe + Pi, Ne + ui, Oe, Ne + ui];
          for (let We = 0, di = st.length; We < di; ++We)
            if (!Be && rt < et[We]) {
              const Yt = st[We];
              he(
                [Oe, Ne, Oe + Pi, Ne + ui],
                [Yt[0], Yt[3], Yt[4], Yt[7]]
              ) && (un || (X.save(), un = !0), X.beginPath(), X.moveTo(V[0], V[1]), X.lineTo(V[2], V[3]), X.lineTo(V[4], V[5]), X.lineTo(V[6], V[7]), X.moveTo(Yt[6], Yt[7]), X.lineTo(Yt[4], Yt[5]), X.lineTo(Yt[2], Yt[3]), X.lineTo(Yt[0], Yt[1]), X.clip());
            }
          st.push(V), et.push(rt), this.drawTile(Ut, t, Oe, Ne, Pi, ui, hi, Be), un && X.restore(), this.renderedTiles.unshift(Ut), this.updateUsedTiles(t.usedTiles, u, Ut);
        }
      }
      if (this.renderedResolution = _, this.extentChanged = !this.renderedExtent_ || !As(this.renderedExtent_, L), this.renderedExtent_ = L, this.renderedPixelRatio = h, this.postRender(this.context, t), s.extent && X.restore(), X.imageSmoothingEnabled = !0, this.renderComplete) {
        const lt = (rt, tt) => {
          const D = Ct(u), _t = tt.wantedTiles[D], U = _t ? Object.keys(_t).length : 0;
          this.updateCacheSize(U), this.tileCache_.expireCache();
        };
        t.postRenderFunctions.push(lt);
      }
      return !this.renderComplete && !n && (t.animate = !0), this.container;
    }
    /**
     * Increases the cache size if needed
     * @param {number} tileCount Minimum number of tiles needed.
     */
    updateCacheSize(t) {
      this.tileCache_.highWaterMark = Math.max(
        this.tileCache_.highWaterMark,
        t * 2
      );
    }
    /**
     * @param {import("../../Tile.js").default} tile Tile.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {number} x Left of the tile.
     * @param {number} y Top of the tile.
     * @param {number} w Width of the tile.
     * @param {number} h Height of the tile.
     * @param {number} gutter Tile gutter.
     * @param {boolean} transition Apply an alpha transition.
     * @protected
     */
    drawTile(t, e, n, s, r, a, o, l) {
      let h;
      if (t instanceof Ru) {
        if (h = Gl(t.getData()), !h)
          throw new Error("Rendering array data is not yet supported");
      } else
        h = this.getTileImage(
          /** @type {import("../../ImageTile.js").default} */
          t
        );
      if (!h)
        return;
      const c = this.getRenderContext(e), u = Ct(this), d = e.layerStatesArray[e.layerIndex], g = d.opacity * (l ? t.getAlpha(u, e.time) : 1), _ = g !== c.globalAlpha;
      _ && (c.save(), c.globalAlpha = g), c.drawImage(
        h,
        o,
        o,
        h.width - 2 * o,
        h.height - 2 * o,
        n,
        s,
        r,
        a
      ), _ && c.restore(), g !== d.opacity ? e.animate = !0 : l && t.endTransition(u);
    }
    /**
     * @return {HTMLCanvasElement} Image
     */
    getImage() {
      const t = this.context;
      return t ? t.canvas : null;
    }
    /**
     * Get the image from a tile.
     * @param {import("../../ImageTile.js").default} tile Tile.
     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
     * @protected
     */
    getTileImage(t) {
      return t.getImage();
    }
    /**
     * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
     * @param {import("../../source/Tile.js").default} tileSource Tile source.
     * @param {import('../../Tile.js').default} tile Tile.
     * @protected
     */
    updateUsedTiles(t, e, n) {
      const s = Ct(e);
      s in t || (t[s] = {}), t[s][n.getKey()] = !0;
    }
  }
  const Ma = {
    PRELOAD: "preload",
    USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
  };
  class Hy extends Ro {
    /**
     * @param {Options<TileSourceType>} [options] Tile layer options.
     */
    constructor(t) {
      t = t || {};
      const e = Object.assign({}, t), n = t.cacheSize;
      delete t.cacheSize, delete e.preload, delete e.useInterimTilesOnError, super(e), this.on, this.once, this.un, this.cacheSize_ = n, this.setPreload(t.preload !== void 0 ? t.preload : 0), this.setUseInterimTilesOnError(
        t.useInterimTilesOnError !== void 0 ? t.useInterimTilesOnError : !0
      );
    }
    /**
     * @return {number|undefined} The suggested cache size
     * @protected
     */
    getCacheSize() {
      return this.cacheSize_;
    }
    /**
     * Return the level as number to which we will preload tiles up to.
     * @return {number} The level to preload tiles up to.
     * @observable
     * @api
     */
    getPreload() {
      return (
        /** @type {number} */
        this.get(Ma.PRELOAD)
      );
    }
    /**
     * Set the level as number to which we will preload tiles up to.
     * @param {number} preload The level to preload tiles up to.
     * @observable
     * @api
     */
    setPreload(t) {
      this.set(Ma.PRELOAD, t);
    }
    /**
     * Deprecated.  Whether we use interim tiles on error.
     * @return {boolean} Use interim tiles on error.
     * @observable
     * @api
     */
    getUseInterimTilesOnError() {
      return (
        /** @type {boolean} */
        this.get(Ma.USE_INTERIM_TILES_ON_ERROR)
      );
    }
    /**
     * Deprecated.  Set whether we use interim tiles on error.
     * @param {boolean} useInterimTilesOnError Use interim tiles on error.
     * @observable
     * @api
     */
    setUseInterimTilesOnError(t) {
      this.set(Ma.USE_INTERIM_TILES_ON_ERROR, t);
    }
    /**
     * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
     * a four element RGBA array will be returned.  For data tiles, the array length will match the
     * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
     * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
     *
     * ```js
     * // display layer data on every pointer move
     * map.on('pointermove', (event) => {
     *   console.log(layer.getData(event.pixel));
     * });
     * ```
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     * @api
     * @override
     */
    getData(t) {
      return super.getData(t);
    }
  }
  class Pu extends Hy {
    /**
     * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
     */
    constructor(t) {
      super(t);
    }
    /**
     * @override
     */
    createRenderer() {
      return new jy(this, {
        cacheSize: this.getCacheSize()
      });
    }
  }
  const ns = [0, 0, 0], zi = 5;
  class Cf {
    /**
     * @param {Options} options Tile grid options.
     */
    constructor(t) {
      this.minZoom = t.minZoom !== void 0 ? t.minZoom : 0, this.resolutions_ = t.resolutions, xt(
        v0(
          this.resolutions_,
          /**
           * @param {number} a First resolution
           * @param {number} b Second resolution
           * @return {number} Comparison result
           */
          (s, r) => r - s
        ),
        "`resolutions` must be sorted in descending order"
      );
      let e;
      if (!t.origins) {
        for (let s = 0, r = this.resolutions_.length - 1; s < r; ++s)
          if (!e)
            e = this.resolutions_[s] / this.resolutions_[s + 1];
          else if (this.resolutions_[s] / this.resolutions_[s + 1] !== e) {
            e = void 0;
            break;
          }
      }
      this.zoomFactor_ = e, this.maxZoom = this.resolutions_.length - 1, this.origin_ = t.origin !== void 0 ? t.origin : null, this.origins_ = null, t.origins !== void 0 && (this.origins_ = t.origins, xt(
        this.origins_.length == this.resolutions_.length,
        "Number of `origins` and `resolutions` must be equal"
      ));
      const n = t.extent;
      n !== void 0 && !this.origin_ && !this.origins_ && (this.origin_ = on(n)), xt(
        !this.origin_ && this.origins_ || this.origin_ && !this.origins_,
        "Either `origin` or `origins` must be configured, never both"
      ), this.tileSizes_ = null, t.tileSizes !== void 0 && (this.tileSizes_ = t.tileSizes, xt(
        this.tileSizes_.length == this.resolutions_.length,
        "Number of `tileSizes` and `resolutions` must be equal"
      )), this.tileSize_ = t.tileSize !== void 0 ? t.tileSize : this.tileSizes_ ? null : Ah, xt(
        !this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_,
        "Either `tileSize` or `tileSizes` must be configured, never both"
      ), this.extent_ = n !== void 0 ? n : null, this.fullTileRanges_ = null, this.tmpSize_ = [0, 0], this.tmpExtent_ = [0, 0, 0, 0], t.sizes !== void 0 ? this.fullTileRanges_ = t.sizes.map((s, r) => {
        const a = new Yh(
          Math.min(0, s[0]),
          Math.max(s[0] - 1, -1),
          Math.min(0, s[1]),
          Math.max(s[1] - 1, -1)
        );
        if (n) {
          const o = this.getTileRangeForExtentAndZ(n, r);
          a.minX = Math.max(o.minX, a.minX), a.maxX = Math.min(o.maxX, a.maxX), a.minY = Math.max(o.minY, a.minY), a.maxY = Math.min(o.maxY, a.maxY);
        }
        return a;
      }) : n && this.calculateTileRanges_(n);
    }
    /**
     * Call a function with each tile coordinate for a given extent and zoom level.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} zoom Integer zoom level.
     * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
     * @api
     */
    forEachTileCoord(t, e, n) {
      const s = this.getTileRangeForExtentAndZ(t, e);
      for (let r = s.minX, a = s.maxX; r <= a; ++r)
        for (let o = s.minY, l = s.maxY; o <= l; ++o)
          n([e, r, o]);
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
     * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
     * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
     * @return {boolean} Callback succeeded.
     */
    forEachTileCoordParentTileRange(t, e, n, s) {
      let r, a, o, l = null, h = t[0] - 1;
      for (this.zoomFactor_ === 2 ? (a = t[1], o = t[2]) : l = this.getTileCoordExtent(t, s); h >= this.minZoom; ) {
        if (a !== void 0 && o !== void 0 ? (a = Math.floor(a / 2), o = Math.floor(o / 2), r = is(a, a, o, o, n)) : r = this.getTileRangeForExtentAndZ(
          l,
          h,
          n
        ), e(h, r))
          return !0;
        --h;
      }
      return !1;
    }
    /**
     * Get the extent for this tile grid, if it was configured.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getExtent() {
      return this.extent_;
    }
    /**
     * Get the maximum zoom level for the grid.
     * @return {number} Max zoom.
     * @api
     */
    getMaxZoom() {
      return this.maxZoom;
    }
    /**
     * Get the minimum zoom level for the grid.
     * @return {number} Min zoom.
     * @api
     */
    getMinZoom() {
      return this.minZoom;
    }
    /**
     * Get the origin for the grid at the given zoom level.
     * @param {number} z Integer zoom level.
     * @return {import("../coordinate.js").Coordinate} Origin.
     * @api
     */
    getOrigin(t) {
      return this.origin_ ? this.origin_ : this.origins_[t];
    }
    /**
     * Get the resolution for the given zoom level.
     * @param {number} z Integer zoom level.
     * @return {number} Resolution.
     * @api
     */
    getResolution(t) {
      return this.resolutions_[t];
    }
    /**
     * Get the list of resolutions for the tile grid.
     * @return {Array<number>} Resolutions.
     * @api
     */
    getResolutions() {
      return this.resolutions_;
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
     * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
     * @return {import("../TileRange.js").default|null} Tile range.
     */
    getTileCoordChildTileRange(t, e, n) {
      if (t[0] < this.maxZoom) {
        if (this.zoomFactor_ === 2) {
          const r = t[1] * 2, a = t[2] * 2;
          return is(
            r,
            r + 1,
            a,
            a + 1,
            e
          );
        }
        const s = this.getTileCoordExtent(
          t,
          n || this.tmpExtent_
        );
        return this.getTileRangeForExtentAndZ(
          s,
          t[0] + 1,
          e
        );
      }
      return null;
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {number} z Integer zoom level.
     * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
     * @return {import("../TileRange.js").default|null} Tile range.
     */
    getTileRangeForTileCoordAndZ(t, e, n) {
      if (e > this.maxZoom || e < this.minZoom)
        return null;
      const s = t[0], r = t[1], a = t[2];
      if (e === s)
        return is(
          r,
          a,
          r,
          a,
          n
        );
      if (this.zoomFactor_) {
        const l = Math.pow(this.zoomFactor_, e - s), h = Math.floor(r * l), c = Math.floor(a * l);
        if (e < s)
          return is(h, h, c, c, n);
        const u = Math.floor(l * (r + 1)) - 1, d = Math.floor(l * (a + 1)) - 1;
        return is(h, u, c, d, n);
      }
      const o = this.getTileCoordExtent(t, this.tmpExtent_);
      return this.getTileRangeForExtentAndZ(o, e, n);
    }
    /**
     * Get a tile range for the given extent and integer zoom level.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} z Integer zoom level.
     * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
     * @return {import("../TileRange.js").default} Tile range.
     */
    getTileRangeForExtentAndZ(t, e, n) {
      this.getTileCoordForXYAndZ_(t[0], t[3], e, !1, ns);
      const s = ns[1], r = ns[2];
      this.getTileCoordForXYAndZ_(t[2], t[1], e, !0, ns);
      const a = ns[1], o = ns[2];
      return is(s, a, r, o, n);
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @return {import("../coordinate.js").Coordinate} Tile center.
     */
    getTileCoordCenter(t) {
      const e = this.getOrigin(t[0]), n = this.getResolution(t[0]), s = Ce(this.getTileSize(t[0]), this.tmpSize_);
      return [
        e[0] + (t[1] + 0.5) * s[0] * n,
        e[1] - (t[2] + 0.5) * s[1] * n
      ];
    }
    /**
     * Get the extent of a tile coordinate.
     *
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getTileCoordExtent(t, e) {
      const n = this.getOrigin(t[0]), s = this.getResolution(t[0]), r = Ce(this.getTileSize(t[0]), this.tmpSize_), a = n[0] + t[1] * r[0] * s, o = n[1] - (t[2] + 1) * r[1] * s, l = a + r[0] * s, h = o + r[1] * s;
      return Le(a, o, l, h, e);
    }
    /**
     * Get the tile coordinate for the given map coordinate and resolution.  This
     * method considers that coordinates that intersect tile boundaries should be
     * assigned the higher tile coordinate.
     *
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @api
     */
    getTileCoordForCoordAndResolution(t, e, n) {
      return this.getTileCoordForXYAndResolution_(
        t[0],
        t[1],
        e,
        !1,
        n
      );
    }
    /**
     * Note that this method should not be called for resolutions that correspond
     * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
     * @param {number} x X.
     * @param {number} y Y.
     * @param {number} resolution Resolution (for a non-integer zoom level).
     * @param {boolean} reverseIntersectionPolicy Instead of letting edge
     *     intersections go to the higher tile coordinate, let edge intersections
     *     go to the lower tile coordinate.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @private
     */
    getTileCoordForXYAndResolution_(t, e, n, s, r) {
      const a = this.getZForResolution(n), o = n / this.getResolution(a), l = this.getOrigin(a), h = Ce(this.getTileSize(a), this.tmpSize_);
      let c = o * (t - l[0]) / n / h[0], u = o * (l[1] - e) / n / h[1];
      return s ? (c = fa(c, zi) - 1, u = fa(u, zi) - 1) : (c = da(c, zi), u = da(u, zi)), Ja(a, c, u, r);
    }
    /**
     * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
     * they should have separate implementations.  This method is for integer zoom
     * levels.  The other method should only be called for resolutions corresponding
     * to non-integer zoom levels.
     * @param {number} x Map x coordinate.
     * @param {number} y Map y coordinate.
     * @param {number} z Integer zoom level.
     * @param {boolean} reverseIntersectionPolicy Instead of letting edge
     *     intersections go to the higher tile coordinate, let edge intersections
     *     go to the lower tile coordinate.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @private
     */
    getTileCoordForXYAndZ_(t, e, n, s, r) {
      const a = this.getOrigin(n), o = this.getResolution(n), l = Ce(this.getTileSize(n), this.tmpSize_);
      let h = (t - a[0]) / o / l[0], c = (a[1] - e) / o / l[1];
      return s ? (h = fa(h, zi) - 1, c = fa(c, zi) - 1) : (h = da(h, zi), c = da(c, zi)), Ja(n, h, c, r);
    }
    /**
     * Get a tile coordinate given a map coordinate and zoom level.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @api
     */
    getTileCoordForCoordAndZ(t, e, n) {
      return this.getTileCoordForXYAndZ_(
        t[0],
        t[1],
        e,
        !1,
        n
      );
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @return {number} Tile resolution.
     */
    getTileCoordResolution(t) {
      return this.resolutions_[t[0]];
    }
    /**
     * Get the tile size for a zoom level. The type of the return value matches the
     * `tileSize` or `tileSizes` that the tile grid was configured with. To always
     * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
     * @param {number} z Z.
     * @return {number|import("../size.js").Size} Tile size.
     * @api
     */
    getTileSize(t) {
      return this.tileSize_ ? this.tileSize_ : this.tileSizes_[t];
    }
    /**
     * @param {number} z Zoom level.
     * @return {import("../TileRange.js").default|null} Extent tile range for the specified zoom level.
     */
    getFullTileRange(t) {
      return this.fullTileRanges_ ? this.fullTileRanges_[t] : this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, t) : null;
    }
    /**
     * @param {number} resolution Resolution.
     * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
     *     If 0, the nearest resolution will be used.
     *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
     *     nearest lower resolution (higher Z) will be used. Default is 0.
     *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
     *
     * For example to change tile Z at the midpoint of zoom levels
     * ```js
     * function(value, high, low) {
     *   return value - low * Math.sqrt(high / low);
     * }
     * ```
     * @return {number} Z.
     * @api
     */
    getZForResolution(t, e) {
      const n = jl(
        this.resolutions_,
        t,
        e || 0
      );
      return zt(n, this.minZoom, this.maxZoom);
    }
    /**
     * The tile with the provided tile coordinate intersects the given viewport.
     * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
     * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
     * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
     */
    tileCoordIntersectsViewport(t, e) {
      return Gd(
        e,
        0,
        e.length,
        2,
        this.getTileCoordExtent(t)
      );
    }
    /**
     * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
     * @private
     */
    calculateTileRanges_(t) {
      const e = this.resolutions_.length, n = new Array(e);
      for (let s = this.minZoom; s < e; ++s)
        n[s] = this.getTileRangeForExtentAndZ(t, s);
      this.fullTileRanges_ = n;
    }
  }
  class Lu extends Cf {
    /**
     * @param {Options} options WMTS options.
     */
    constructor(t) {
      super({
        extent: t.extent,
        origin: t.origin,
        origins: t.origins,
        resolutions: t.resolutions,
        tileSize: t.tileSize,
        tileSizes: t.tileSizes,
        sizes: t.sizes
      }), this.matrixIds_ = t.matrixIds;
    }
    /**
     * @param {number} z Z.
     * @return {string} MatrixId..
     */
    getMatrixId(t) {
      return this.matrixIds_[t];
    }
    /**
     * Get the list of matrix identifiers.
     * @return {Array<string>} MatrixIds.
     * @api
     */
    getMatrixIds() {
      return this.matrixIds_;
    }
  }
  function Rf(i) {
    let t = i.getDefaultTileGrid();
    return t || (t = e1(i), i.setDefaultTileGrid(t)), t;
  }
  function Jy(i, t, e) {
    const n = t[0], s = i.getTileCoordCenter(t), r = If(e);
    if (!Fn(r, s)) {
      const a = Mt(r), o = Math.ceil(
        (r[0] - s[0]) / a
      );
      return s[0] += a * o, i.getTileCoordForCoordAndZ(s, n);
    }
    return t;
  }
  function Qy(i, t, e, n) {
    n = n !== void 0 ? n : "top-left";
    const s = t1(i, t, e);
    return new Cf({
      extent: i,
      origin: gd(i, n),
      resolutions: s,
      tileSize: e
    });
  }
  function t1(i, t, e, n) {
    t = t !== void 0 ? t : Hm, e = Ce(e !== void 0 ? e : Ah);
    const s = te(i), r = Mt(i);
    n = n > 0 ? n : Math.max(r / e[0], s / e[1]);
    const a = t + 1, o = new Array(a);
    for (let l = 0; l < a; ++l)
      o[l] = n / Math.pow(2, l);
    return o;
  }
  function e1(i, t, e, n) {
    const s = If(i);
    return Qy(s, t, e, n);
  }
  function If(i) {
    i = At(i);
    let t = i.getExtent();
    if (!t) {
      const e = 180 * ch.degrees / i.getMetersPerUnit();
      t = Le(-e, -e, e, e);
    }
    return t;
  }
  function Ou(i, t) {
    const e = [];
    Object.keys(t).forEach(function(s) {
      t[s] !== null && t[s] !== void 0 && e.push(s + "=" + encodeURIComponent(t[s]));
    });
    const n = e.join("&");
    return i = i.replace(/[?&]$/, ""), i += i.includes("?") ? "&" : "?", i + n;
  }
  const i1 = /\{z\}/g, n1 = /\{x\}/g, s1 = /\{y\}/g, r1 = /\{-y\}/g;
  function a1(i, t, e, n, s) {
    return i.replace(i1, t.toString()).replace(n1, e.toString()).replace(s1, n.toString()).replace(r1, function() {
      if (s === void 0)
        throw new Error(
          "If the URL template has a {-y} placeholder, the grid extent must be known"
        );
      return (s - n).toString();
    });
  }
  function Tf(i) {
    const t = [];
    let e = /\{([a-z])-([a-z])\}/.exec(i);
    if (e) {
      const n = e[1].charCodeAt(0), s = e[2].charCodeAt(0);
      let r;
      for (r = n; r <= s; ++r)
        t.push(i.replace(e[0], String.fromCharCode(r)));
      return t;
    }
    if (e = /\{(\d+)-(\d+)\}/.exec(i), e) {
      const n = parseInt(e[2], 10);
      for (let s = parseInt(e[1], 10); s <= n; s++)
        t.push(i.replace(e[0], s.toString()));
      return t;
    }
    return t.push(i), t;
  }
  function o1(i, t) {
    return (
      /**
       * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("./proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      function(e, n, s) {
        if (!e)
          return;
        let r;
        const a = e[0];
        if (t) {
          const o = t.getFullTileRange(a);
          o && (r = o.getHeight() - 1);
        }
        return a1(i, a, e[1], e[2], r);
      }
    );
  }
  function l1(i, t) {
    const e = i.length, n = new Array(e);
    for (let s = 0; s < e; ++s)
      n[s] = o1(i[s], t);
    return zl(n);
  }
  function zl(i) {
    return i.length === 1 ? i[0] : (
      /**
       * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("./proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      function(t, e, n) {
        if (!t)
          return;
        const s = Zy(t), r = _s(s, i.length);
        return i[r](t, e, n);
      }
    );
  }
  class h1 extends vf {
    /**
     * @param {Options} options SourceTile source options.
     */
    constructor(t) {
      super({
        attributions: t.attributions,
        attributionsCollapsible: t.attributionsCollapsible,
        projection: t.projection,
        state: t.state,
        wrapX: t.wrapX,
        interpolate: t.interpolate
      }), this.on, this.once, this.un, this.tilePixelRatio_ = t.tilePixelRatio !== void 0 ? t.tilePixelRatio : 1, this.tileGrid = t.tileGrid !== void 0 ? t.tileGrid : null;
      const e = [256, 256];
      this.tileGrid && Ce(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), e), this.tmpSize = [0, 0], this.key_ = t.key || Ct(this), this.tileOptions = {
        transition: t.transition,
        interpolate: t.interpolate
      }, this.zDirection = t.zDirection ? t.zDirection : 0;
    }
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {number} Gutter.
     */
    getGutterForProjection(t) {
      return 0;
    }
    /**
     * Return the key to be used for all tiles in the source.
     * @return {string} The key for all tiles.
     */
    getKey() {
      return this.key_;
    }
    /**
     * Set the value to be used as the key for all tiles in the source.
     * @param {string} key The key for tiles.
     * @protected
     */
    setKey(t) {
      this.key_ !== t && (this.key_ = t, this.changed());
    }
    /**
     * @param {import("../proj/Projection").default} [projection] Projection.
     * @return {Array<number>|null} Resolutions.
     * @override
     */
    getResolutions(t) {
      const e = t ? this.getTileGridForProjection(t) : this.tileGrid;
      return e ? e.getResolutions() : null;
    }
    /**
     * @abstract
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {TileType|null} Tile.
     */
    getTile(t, e, n, s, r) {
      return ct();
    }
    /**
     * Return the tile grid of the tile source.
     * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
     * @api
     */
    getTileGrid() {
      return this.tileGrid;
    }
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
     */
    getTileGridForProjection(t) {
      return this.tileGrid ? this.tileGrid : Rf(t);
    }
    /**
     * Get the tile pixel ratio for this source. Subclasses may override this
     * method, which is meant to return a supported pixel ratio that matches the
     * provided `pixelRatio` as close as possible.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Tile pixel ratio.
     */
    getTilePixelRatio(t) {
      return this.tilePixelRatio_;
    }
    /**
     * @param {number} z Z.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../size.js").Size} Tile size.
     */
    getTilePixelSize(t, e, n) {
      const s = this.getTileGridForProjection(n), r = this.getTilePixelRatio(e), a = Ce(s.getTileSize(t), this.tmpSize);
      return r == 1 ? a : W_(a, r, this.tmpSize);
    }
    /**
     * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
     * is outside the resolution and extent range of the tile grid, `null` will be
     * returned.
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../proj/Projection.js").default} [projection] Projection.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
     *     null if no tile URL should be created for the passed `tileCoord`.
     */
    getTileCoordForTileUrlFunction(t, e) {
      const n = e !== void 0 ? e : this.getProjection(), s = e !== void 0 ? this.getTileGridForProjection(n) : this.tileGrid || this.getTileGridForProjection(n);
      return this.getWrapX() && n.isGlobal() && (t = Jy(s, t, n)), Ky(t, s) ? t : null;
    }
    /**
     * Remove all cached reprojected tiles from the source. The next render cycle will create new tiles.
     * @api
     */
    clear() {
    }
    /**
     * @override
     */
    refresh() {
      this.clear(), super.refresh();
    }
  }
  class c1 extends Ri {
    /**
     * @param {string} type Type.
     * @param {import("../Tile.js").default} tile The tile.
     */
    constructor(t, e) {
      super(t), this.tile = e;
    }
  }
  const dl = {
    /**
     * Triggered when a tile starts loading.
     * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
     * @api
     */
    TILELOADSTART: "tileloadstart",
    /**
     * Triggered when a tile finishes loading, either when its data is loaded,
     * or when loading was aborted because the tile is no longer needed.
     * @event module:ol/source/Tile.TileSourceEvent#tileloadend
     * @api
     */
    TILELOADEND: "tileloadend",
    /**
     * Triggered if tile loading results in an error. Note that this is not the
     * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
     * for details.
     * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
     * @api
     */
    TILELOADERROR: "tileloaderror"
  };
  class Zh extends h1 {
    /**
     * @param {Options} options Image tile options.
     */
    constructor(t) {
      super({
        attributions: t.attributions,
        cacheSize: t.cacheSize,
        projection: t.projection,
        state: t.state,
        tileGrid: t.tileGrid,
        tilePixelRatio: t.tilePixelRatio,
        wrapX: t.wrapX,
        transition: t.transition,
        interpolate: t.interpolate,
        key: t.key,
        attributionsCollapsible: t.attributionsCollapsible,
        zDirection: t.zDirection
      }), this.generateTileUrlFunction_ = this.tileUrlFunction === Zh.prototype.tileUrlFunction, this.tileLoadFunction = t.tileLoadFunction, t.tileUrlFunction && (this.tileUrlFunction = t.tileUrlFunction), this.urls = null, t.urls ? this.setUrls(t.urls) : t.url && this.setUrl(t.url), this.tileLoadingKeys_ = {};
    }
    /**
     * Deprecated.  Use an ImageTile source instead.
     * Return the tile load function of the source.
     * @return {import("../Tile.js").LoadFunction} TileLoadFunction
     * @api
     */
    getTileLoadFunction() {
      return this.tileLoadFunction;
    }
    /**
     * Deprecated.  Use an ImageTile source instead.
     * Return the tile URL function of the source.
     * @return {import("../Tile.js").UrlFunction} TileUrlFunction
     * @api
     */
    getTileUrlFunction() {
      return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
    }
    /**
     * Deprecated.  Use an ImageTile source instead.
     * Return the URLs used for this source.
     * When a tileUrlFunction is used instead of url or urls,
     * null will be returned.
     * @return {!Array<string>|null} URLs.
     * @api
     */
    getUrls() {
      return this.urls;
    }
    /**
     * Handle tile change events.
     * @param {import("../events/Event.js").default} event Event.
     * @protected
     */
    handleTileChange(t) {
      const e = (
        /** @type {import("../Tile.js").default} */
        t.target
      ), n = Ct(e), s = e.getState();
      let r;
      s == j.LOADING ? (this.tileLoadingKeys_[n] = !0, r = dl.TILELOADSTART) : n in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[n], r = s == j.ERROR ? dl.TILELOADERROR : s == j.LOADED ? dl.TILELOADEND : void 0), r != null && this.dispatchEvent(new c1(r, e));
    }
    /**
     * Deprecated.  Use an ImageTile source instead.
     * Set the tile load function of the source.
     * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
     * @api
     */
    setTileLoadFunction(t) {
      this.tileLoadFunction = t, this.changed();
    }
    /**
     * Deprecated.  Use an ImageTile source instead.
     * Set the tile URL function of the source.
     * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
     * @param {string} [key] Optional new tile key for the source.
     * @api
     */
    setTileUrlFunction(t, e) {
      this.tileUrlFunction = t, typeof e < "u" ? this.setKey(e) : this.changed();
    }
    /**
     * Set the URL to use for requests.
     * @param {string} url URL.
     * @api
     */
    setUrl(t) {
      const e = Tf(t);
      this.urls = e, this.setUrls(e);
    }
    /**
     * Deprecated.  Use an ImageTile source instead.
     * Set the URLs to use for requests.
     * @param {Array<string>} urls URLs.
     * @api
     */
    setUrls(t) {
      this.urls = t;
      const e = t.join(`
`);
      this.generateTileUrlFunction_ ? this.setTileUrlFunction(l1(t, this.tileGrid), e) : this.setKey(e);
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    tileUrlFunction(t, e, n) {
    }
  }
  class u1 extends Zh {
    /**
     * @param {!Options} options Image tile options.
     */
    constructor(t) {
      super({
        attributions: t.attributions,
        cacheSize: t.cacheSize,
        projection: t.projection,
        state: t.state,
        tileGrid: t.tileGrid,
        tileLoadFunction: t.tileLoadFunction ? t.tileLoadFunction : d1,
        tilePixelRatio: t.tilePixelRatio,
        tileUrlFunction: t.tileUrlFunction,
        url: t.url,
        urls: t.urls,
        wrapX: t.wrapX,
        transition: t.transition,
        interpolate: t.interpolate !== void 0 ? t.interpolate : !0,
        key: t.key,
        attributionsCollapsible: t.attributionsCollapsible,
        zDirection: t.zDirection
      }), this.crossOrigin = t.crossOrigin !== void 0 ? t.crossOrigin : null, this.tileClass = t.tileClass !== void 0 ? t.tileClass : wf, this.tileGridForProjection = {}, this.reprojectionErrorThreshold_ = t.reprojectionErrorThreshold, this.renderReprojectionEdges_ = !1;
    }
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {number} Gutter.
     * @override
     */
    getGutterForProjection(t) {
      return this.getProjection() && t && !dr(this.getProjection(), t) ? 0 : this.getGutter();
    }
    /**
     * @return {number} Gutter.
     */
    getGutter() {
      return 0;
    }
    /**
     * Return the key to be used for all tiles in the source.
     * @return {string} The key for all tiles.
     * @override
     */
    getKey() {
      let t = super.getKey();
      return this.getInterpolate() || (t += ":disable-interpolation"), t;
    }
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
     * @override
     */
    getTileGridForProjection(t) {
      const e = this.getProjection();
      if (this.tileGrid && (!e || dr(e, t)))
        return this.tileGrid;
      const n = Ct(t);
      return n in this.tileGridForProjection || (this.tileGridForProjection[n] = Rf(t)), this.tileGridForProjection[n];
    }
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {string} key The key set on the tile.
     * @return {!ImageTile} Tile.
     * @private
     */
    createTile_(t, e, n, s, r, a) {
      const o = [t, e, n], l = this.getTileCoordForTileUrlFunction(
        o,
        r
      ), h = l ? this.tileUrlFunction(l, s, r) : void 0, c = new this.tileClass(
        o,
        h !== void 0 ? j.IDLE : j.EMPTY,
        h !== void 0 ? h : "",
        this.crossOrigin,
        this.tileLoadFunction,
        this.tileOptions
      );
      return c.key = a, c.addEventListener(at.CHANGE, this.handleTileChange.bind(this)), c;
    }
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!(ImageTile|ReprojTile)} Tile.
     * @override
     */
    getTile(t, e, n, s, r) {
      const a = this.getProjection();
      if (!a || !r || dr(a, r))
        return this.getTileInternal(
          t,
          e,
          n,
          s,
          a || r
        );
      const o = [t, e, n], l = this.getKey(), h = this.getTileGridForProjection(a), c = this.getTileGridForProjection(r), u = this.getTileCoordForTileUrlFunction(
        o,
        r
      ), d = new Sf(
        a,
        h,
        r,
        c,
        o,
        u,
        this.getTilePixelRatio(s),
        this.getGutter(),
        (g, _, y, E) => this.getTileInternal(g, _, y, E, a),
        this.reprojectionErrorThreshold_,
        this.renderReprojectionEdges_,
        this.tileOptions
      );
      return d.key = l, d;
    }
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {!import("../proj/Projection.js").default} projection Projection.
     * @return {!ImageTile} Tile.
     * @protected
     */
    getTileInternal(t, e, n, s, r) {
      const a = this.getKey();
      return this.createTile_(t, e, n, s, r, a);
    }
    /**
     * Sets whether to render reprojection edges or not (usually for debugging).
     * @param {boolean} render Render the edges.
     * @api
     */
    setRenderReprojectionEdges(t) {
      this.renderReprojectionEdges_ != t && (this.renderReprojectionEdges_ = t, this.changed());
    }
    /**
     * Sets the tile grid to use when reprojecting the tiles to the given
     * projection instead of the default tile grid for the projection.
     *
     * This can be useful when the default tile grid cannot be created
     * (e.g. projection has no extent defined) or
     * for optimization reasons (custom tile size, resolutions, ...).
     *
     * @param {import("../proj.js").ProjectionLike} projection Projection.
     * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
     * @api
     */
    setTileGridForProjection(t, e) {
      const n = At(t);
      if (n) {
        const s = Ct(n);
        s in this.tileGridForProjection || (this.tileGridForProjection[s] = e);
      }
    }
  }
  function d1(i, t) {
    i.getImage().src = t;
  }
  function jr(i) {
    if (i.__esModule) return i;
    var t = i.default;
    if (typeof t == "function") {
      var e = function n() {
        return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
      };
      e.prototype = t.prototype;
    } else e = {};
    return Object.defineProperty(e, "__esModule", { value: !0 }), Object.keys(i).forEach(function(n) {
      var s = Object.getOwnPropertyDescriptor(i, n);
      Object.defineProperty(e, n, s.get ? s : {
        enumerable: !0,
        get: function() {
          return i[n];
        }
      });
    }), e;
  }
  class Nu extends u1 {
    /**
     * @param {Options} options WMTS options.
     */
    constructor(t) {
      const e = t.requestEncoding !== void 0 ? t.requestEncoding : "KVP", n = t.tileGrid;
      let s = t.urls;
      s === void 0 && t.url !== void 0 && (s = Tf(t.url)), super({
        attributions: t.attributions,
        attributionsCollapsible: t.attributionsCollapsible,
        cacheSize: t.cacheSize,
        crossOrigin: t.crossOrigin,
        interpolate: t.interpolate,
        projection: t.projection,
        reprojectionErrorThreshold: t.reprojectionErrorThreshold,
        tileClass: t.tileClass,
        tileGrid: n,
        tileLoadFunction: t.tileLoadFunction,
        tilePixelRatio: t.tilePixelRatio,
        urls: s,
        wrapX: t.wrapX !== void 0 ? t.wrapX : !1,
        transition: t.transition,
        zDirection: t.zDirection
      }), this.version_ = t.version !== void 0 ? t.version : "1.0.0", this.format_ = t.format !== void 0 ? t.format : "image/jpeg", this.dimensions_ = t.dimensions !== void 0 ? t.dimensions : {}, this.layer_ = t.layer, this.matrixSet_ = t.matrixSet, this.style_ = t.style, this.requestEncoding_ = e, this.setKey(this.getKeyForDimensions_()), s && s.length > 0 && (this.tileUrlFunction = zl(
        s.map(this.createFromWMTSTemplate.bind(this))
      ));
    }
    /**
     * Set the URLs to use for requests.
     * URLs may contain OGC conform URL Template Variables: {TileMatrix}, {TileRow}, {TileCol}.
     * @param {Array<string>} urls URLs.
     * @override
     */
    setUrls(t) {
      this.urls = t;
      const e = t.join(`
`);
      this.setTileUrlFunction(
        zl(
          t.map(this.createFromWMTSTemplate.bind(this))
        ),
        e
      );
    }
    /**
     * Get the dimensions, i.e. those passed to the constructor through the
     * "dimensions" option, and possibly updated using the updateDimensions
     * method.
     * @return {!Object} Dimensions.
     * @api
     */
    getDimensions() {
      return this.dimensions_;
    }
    /**
     * Return the image format of the WMTS source.
     * @return {string} Format.
     * @api
     */
    getFormat() {
      return this.format_;
    }
    /**
     * Return the layer of the WMTS source.
     * @return {string} Layer.
     * @api
     */
    getLayer() {
      return this.layer_;
    }
    /**
     * Return the matrix set of the WMTS source.
     * @return {string} MatrixSet.
     * @api
     */
    getMatrixSet() {
      return this.matrixSet_;
    }
    /**
     * Return the request encoding, either "KVP" or "REST".
     * @return {RequestEncoding} Request encoding.
     * @api
     */
    getRequestEncoding() {
      return this.requestEncoding_;
    }
    /**
     * Return the style of the WMTS source.
     * @return {string} Style.
     * @api
     */
    getStyle() {
      return this.style_;
    }
    /**
     * Return the version of the WMTS source.
     * @return {string} Version.
     * @api
     */
    getVersion() {
      return this.version_;
    }
    /**
     * @private
     * @return {string} The key for the current dimensions.
     */
    getKeyForDimensions_() {
      const t = this.urls ? this.urls.slice(0) : [];
      for (const e in this.dimensions_)
        t.push(e + "-" + this.dimensions_[e]);
      return t.join("/");
    }
    /**
     * Update the dimensions.
     * @param {Object} dimensions Dimensions.
     * @api
     */
    updateDimensions(t) {
      Object.assign(this.dimensions_, t), this.setKey(this.getKeyForDimensions_());
    }
    /**
     * @param {string} template Template.
     * @return {import("../Tile.js").UrlFunction} Tile URL function.
     */
    createFromWMTSTemplate(t) {
      const e = this.requestEncoding_, n = {
        layer: this.layer_,
        style: this.style_,
        tilematrixset: this.matrixSet_
      };
      e == "KVP" && Object.assign(n, {
        Service: "WMTS",
        Request: "GetTile",
        Version: this.version_,
        Format: this.format_
      }), t = e == "KVP" ? Ou(t, n) : t.replace(/\{(\w+?)\}/g, function(a, o) {
        return o.toLowerCase() in n ? n[o.toLowerCase()] : a;
      });
      const s = (
        /** @type {import("../tilegrid/WMTS.js").default} */
        this.tileGrid
      ), r = this.dimensions_;
      return (
        /**
         * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
         * @param {number} pixelRatio Pixel ratio.
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @return {string|undefined} Tile URL.
         */
        function(a, o, l) {
          if (!a)
            return;
          const h = {
            TileMatrix: s.getMatrixId(a[0]),
            TileCol: a[1],
            TileRow: a[2]
          };
          Object.assign(h, r);
          let c = t;
          return e == "KVP" ? c = Ou(c, h) : c = c.replace(/\{(\w+?)\}/g, function(u, d) {
            return encodeURIComponent(h[d]);
          }), c;
        }
      );
    }
  }
  const f1 = "http://www.w3.org/2001/XMLSchema-instance";
  function Lt(i, t) {
    return Lf().createElementNS(i, t);
  }
  function Qa(i, t) {
    return Af(i, t, []).join("");
  }
  function Af(i, t, e) {
    if (i.nodeType == Node.CDATA_SECTION_NODE || i.nodeType == Node.TEXT_NODE)
      e.push(i.nodeValue);
    else {
      let n;
      for (n = i.firstChild; n; n = n.nextSibling)
        Af(n, t, e);
    }
    return e;
  }
  function xa(i) {
    return "documentElement" in i;
  }
  function g1(i, t, e) {
    return i.getAttributeNS(t, e) || "";
  }
  function wa(i) {
    return new DOMParser().parseFromString(i, "application/xml");
  }
  function bf(i, t) {
    return (
      /**
       * @param {Node} node Node.
       * @param {Array<*>} objectStack Object stack.
       * @this {*}
       */
      function(e, n) {
        const s = i.call(this, e, n);
        if (s !== void 0) {
          const r = (
            /** @type {Array<*>} */
            n[n.length - 1]
          );
          pe(r, s);
        }
      }
    );
  }
  function ot(i, t) {
    return (
      /**
       * @param {Element} node Node.
       * @param {Array<*>} objectStack Object stack.
       * @this {*}
       */
      function(e, n) {
        const s = i.call(t ?? this, e, n);
        s !== void 0 && /** @type {Array<*>} */
        n[n.length - 1].push(s);
      }
    );
  }
  function J(i, t) {
    return (
      /**
       * @param {Node} node Node.
       * @param {Array<*>} objectStack Object stack.
       * @this {*}
       */
      function(e, n) {
        const s = i.call(t ?? this, e, n);
        s !== void 0 && (n[n.length - 1] = s);
      }
    );
  }
  function Y(i, t) {
    return (
      /**
       * @param {Element} node Node.
       * @param {*} value Value to be written.
       * @param {Array<*>} objectStack Object stack.
       * @this {*}
       */
      function(e, n, s) {
        i.call(t ?? this, e, n, s), /** @type {NodeStackItem} */
        s[s.length - 1].node.appendChild(e);
      }
    );
  }
  function Es(i, t) {
    return (
      /**
       * @param {*} value Value.
       * @param {Array<*>} objectStack Object stack.
       * @param {string} [newNodeName] Node name.
       * @return {Node} Node.
       */
      function(e, n, s) {
        const a = /** @type {NodeStackItem} */ n[n.length - 1].node;
        let o = i;
        o === void 0 && (o = s);
        const l = t !== void 0 ? t : a.namespaceURI;
        return Lt(
          l,
          /** @type {string} */
          o
        );
      }
    );
  }
  const Pf = Es();
  function Ms(i, t, e, n) {
    let s;
    for (s = t.firstElementChild; s; s = s.nextElementSibling) {
      const r = i[s.namespaceURI];
      if (r !== void 0) {
        const a = r[s.localName];
        a !== void 0 && a.call(n, s, e);
      }
    }
  }
  function Ot(i, t, e, n, s) {
    return n.push(i), Ms(t, e, n, s), /** @type {T} */
    n.pop();
  }
  function m1(i, t, e, n, s, r) {
    const a = (s !== void 0 ? s : e).length;
    let o, l;
    for (let h = 0; h < a; ++h)
      o = e[h], o !== void 0 && (l = t.call(
        r,
        o,
        n,
        s !== void 0 ? s[h] : void 0
      ), l !== void 0 && i[l.namespaceURI][l.localName].call(
        r,
        l,
        o,
        n
      ));
  }
  function ge(i, t, e, n, s, r, a) {
    return s.push(i), m1(t, e, n, s, r, a), /** @type {O|undefined} */
    s.pop();
  }
  let fl;
  function _1() {
    return fl === void 0 && typeof XMLSerializer < "u" && (fl = new XMLSerializer()), fl;
  }
  let gl;
  function Lf() {
    return gl === void 0 && typeof document < "u" && (gl = document.implementation.createDocument("", "", null)), gl;
  }
  function Sa(i) {
    const t = /^\s*(\d+)\s*$/.exec(i);
    if (t)
      return parseInt(t[1], 10);
  }
  function Ue(i, t) {
    i.appendChild(Lf().createTextNode(t));
  }
  class p1 {
    constructor() {
      this.dataProjection = void 0, this.defaultFeatureProjection = void 0, this.featureClass = /** @type {FeatureToFeatureClass<FeatureType>} */
      bo, this.supportedMediaTypes = null;
    }
    /**
     * Adds the data projection to the read options.
     * @param {Document|Element|Object|string} source Source.
     * @param {ReadOptions} [options] Options.
     * @return {ReadOptions|undefined} Options.
     * @protected
     */
    getReadOptions(t, e) {
      if (e) {
        let n = e.dataProjection ? At(e.dataProjection) : this.readProjection(t);
        e.extent && n && n.getUnits() === "tile-pixels" && (n = At(n), n.setWorldExtent(e.extent)), e = {
          dataProjection: n,
          featureProjection: e.featureProjection
        };
      }
      return this.adaptOptions(e);
    }
    /**
     * Sets the `dataProjection` on the options, if no `dataProjection`
     * is set.
     * @param {WriteOptions|ReadOptions|undefined} options
     *     Options.
     * @protected
     * @return {WriteOptions|ReadOptions|undefined}
     *     Updated options.
     */
    adaptOptions(t) {
      return Object.assign(
        {
          dataProjection: this.dataProjection,
          featureProjection: this.defaultFeatureProjection,
          featureClass: this.featureClass
        },
        t
      );
    }
    /**
     * @abstract
     * @return {Type} The format type.
     */
    getType() {
      return ct();
    }
    /**
     * Read a single feature from a source.
     *
     * @abstract
     * @param {Document|Element|Object|string} source Source.
     * @param {ReadOptions} [options] Read options.
     * @return {FeatureType|Array<FeatureType>} Feature.
     */
    readFeature(t, e) {
      return ct();
    }
    /**
     * Read all features from a source.
     *
     * @abstract
     * @param {Document|Element|ArrayBuffer|Object|string} source Source.
     * @param {ReadOptions} [options] Read options.
     * @return {Array<FeatureType>} Features.
     */
    readFeatures(t, e) {
      return ct();
    }
    /**
     * Read a single geometry from a source.
     *
     * @abstract
     * @param {Document|Element|Object|string} source Source.
     * @param {ReadOptions} [options] Read options.
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    readGeometry(t, e) {
      return ct();
    }
    /**
     * Read the projection from a source.
     *
     * @abstract
     * @param {Document|Element|Object|string} source Source.
     * @return {import("../proj/Projection.js").default|undefined} Projection.
     */
    readProjection(t) {
      return ct();
    }
    /**
     * Encode a feature in this format.
     *
     * @abstract
     * @param {Feature} feature Feature.
     * @param {WriteOptions} [options] Write options.
     * @return {string|ArrayBuffer} Result.
     */
    writeFeature(t, e) {
      return ct();
    }
    /**
     * Encode an array of features in this format.
     *
     * @abstract
     * @param {Array<Feature>} features Features.
     * @param {WriteOptions} [options] Write options.
     * @return {string|ArrayBuffer} Result.
     */
    writeFeatures(t, e) {
      return ct();
    }
    /**
     * Write a single geometry in this format.
     *
     * @abstract
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {WriteOptions} [options] Write options.
     * @return {string|ArrayBuffer} Result.
     */
    writeGeometry(t, e) {
      return ct();
    }
  }
  function qh(i, t, e) {
    const n = e ? At(e.featureProjection) : null, s = e ? At(e.dataProjection) : null;
    let r = i;
    if (n && s && !dr(n, s)) {
      t && (r = /** @type {T} */
      i.clone());
      const a = t ? n : s, o = t ? s : n;
      a.getUnits() === "tile-pixels" ? r.transform(a, o) : r.applyTransform(Ps(a, o));
    }
    if (t && e && /** @type {WriteOptions} */
    e.decimals !== void 0) {
      const a = Math.pow(
        10,
        /** @type {WriteOptions} */
        e.decimals
      ), o = function(l) {
        for (let h = 0, c = l.length; h < c; ++h)
          l[h] = Math.round(l[h] * a) / a;
        return l;
      };
      r === i && (r = /** @type {T} */
      i.clone()), r.applyTransform(o);
    }
    return r;
  }
  function Kh(i, t) {
    const e = t ? At(t.featureProjection) : null, n = t ? At(t.dataProjection) : null;
    return e && n && !dr(e, n) ? Mm(i, n, e) : i;
  }
  class y1 extends p1 {
    constructor() {
      super(), this.xmlSerializer_ = _1();
    }
    /**
     * @return {import("./Feature.js").Type} Format.
     * @override
     */
    getType() {
      return "xml";
    }
    /**
     * Read a single feature.
     *
     * @param {Document|Element|Object|string} source Source.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @return {import("../Feature.js").default} Feature.
     * @api
     * @override
     */
    readFeature(t, e) {
      if (!t)
        return null;
      if (typeof t == "string") {
        const n = wa(t);
        return this.readFeatureFromDocument(n, e);
      }
      return xa(t) ? this.readFeatureFromDocument(
        /** @type {Document} */
        t,
        e
      ) : this.readFeatureFromNode(
        /** @type {Element} */
        t,
        e
      );
    }
    /**
     * @param {Document} doc Document.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @return {import("../Feature.js").default} Feature.
     */
    readFeatureFromDocument(t, e) {
      const n = this.readFeaturesFromDocument(t, e);
      return n.length > 0 ? n[0] : null;
    }
    /**
     * @param {Element} node Node.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @return {import("../Feature.js").default} Feature.
     */
    readFeatureFromNode(t, e) {
      return null;
    }
    /**
     * Read all features from a feature collection.
     *
     * @param {Document|Element|Object|string} source Source.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @return {Array<import("../Feature.js").default>} Features.
     * @api
     * @override
     */
    readFeatures(t, e) {
      if (!t)
        return [];
      if (typeof t == "string") {
        const n = wa(t);
        return this.readFeaturesFromDocument(n, e);
      }
      return xa(t) ? this.readFeaturesFromDocument(
        /** @type {Document} */
        t,
        e
      ) : this.readFeaturesFromNode(
        /** @type {Element} */
        t,
        e
      );
    }
    /**
     * @param {Document} doc Document.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @protected
     * @return {Array<import("../Feature.js").default>} Features.
     */
    readFeaturesFromDocument(t, e) {
      const n = [];
      for (let s = t.firstChild; s; s = s.nextSibling)
        s.nodeType == Node.ELEMENT_NODE && pe(
          n,
          this.readFeaturesFromNode(
            /** @type {Element} */
            s,
            e
          )
        );
      return n;
    }
    /**
     * @abstract
     * @param {Element} node Node.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @protected
     * @return {Array<import("../Feature.js").default>} Features.
     */
    readFeaturesFromNode(t, e) {
      return ct();
    }
    /**
     * Read a single geometry from a source.
     *
     * @param {Document|Element|Object|string} source Source.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @return {import("../geom/Geometry.js").default} Geometry.
     * @override
     */
    readGeometry(t, e) {
      if (!t)
        return null;
      if (typeof t == "string") {
        const n = wa(t);
        return this.readGeometryFromDocument(n, e);
      }
      return xa(t) ? this.readGeometryFromDocument(
        /** @type {Document} */
        t,
        e
      ) : this.readGeometryFromNode(
        /** @type {Element} */
        t,
        e
      );
    }
    /**
     * @param {Document} doc Document.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @protected
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    readGeometryFromDocument(t, e) {
      return null;
    }
    /**
     * @param {Element} node Node.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @protected
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    readGeometryFromNode(t, e) {
      return null;
    }
    /**
     * Read the projection from the source.
     *
     * @param {Document|Element|Object|string} source Source.
     * @return {import("../proj/Projection.js").default} Projection.
     * @api
     * @override
     */
    readProjection(t) {
      if (!t)
        return null;
      if (typeof t == "string") {
        const e = wa(t);
        return this.readProjectionFromDocument(e);
      }
      return xa(t) ? this.readProjectionFromDocument(
        /** @type {Document} */
        t
      ) : this.readProjectionFromNode(
        /** @type {Element} */
        t
      );
    }
    /**
     * @param {Document} doc Document.
     * @protected
     * @return {import("../proj/Projection.js").default} Projection.
     */
    readProjectionFromDocument(t) {
      return this.dataProjection;
    }
    /**
     * @param {Element} node Node.
     * @protected
     * @return {import("../proj/Projection.js").default} Projection.
     */
    readProjectionFromNode(t) {
      return this.dataProjection;
    }
    /**
     * Encode a feature as string.
     *
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {string} Encoded feature.
     * @override
     */
    writeFeature(t, e) {
      const n = this.writeFeatureNode(t, e);
      return this.xmlSerializer_.serializeToString(n);
    }
    /**
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("./Feature.js").WriteOptions} [options] Options.
     * @protected
     * @return {Node} Node.
     */
    writeFeatureNode(t, e) {
      return null;
    }
    /**
     * Encode an array of features as string.
     *
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {string} Result.
     * @api
     * @override
     */
    writeFeatures(t, e) {
      const n = this.writeFeaturesNode(t, e);
      return this.xmlSerializer_.serializeToString(n);
    }
    /**
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Options.
     * @return {Node} Node.
     */
    writeFeaturesNode(t, e) {
      return null;
    }
    /**
     * Encode a geometry as string.
     *
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {string} Encoded geometry.
     * @override
     */
    writeGeometry(t, e) {
      const n = this.writeGeometryNode(t, e);
      return this.xmlSerializer_.serializeToString(n);
    }
    /**
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [options] Options.
     * @return {Node} Node.
     */
    writeGeometryNode(t, e) {
      return null;
    }
  }
  const Lo = "http://www.opengis.net/gml", v1 = /^\s*$/;
  class K extends y1 {
    /**
     * @param {Options} [options] Optional configuration object.
     */
    constructor(t) {
      super(), t = t || {}, this.featureType = t.featureType, this.featureNS = t.featureNS, this.srsName = t.srsName, this.schemaLocation = "", this.FEATURE_COLLECTION_PARSERS = {}, this.FEATURE_COLLECTION_PARSERS[this.namespace] = {
        featureMember: ot(this.readFeaturesInternal),
        featureMembers: J(this.readFeaturesInternal)
      }, this.supportedMediaTypes = ["application/gml+xml"];
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<Feature> | undefined} Features.
     */
    readFeaturesInternal(t, e) {
      const n = t.localName;
      let s = null;
      if (n == "FeatureCollection")
        s = Ot(
          [],
          this.FEATURE_COLLECTION_PARSERS,
          t,
          e,
          this
        );
      else if (n == "featureMembers" || n == "featureMember" || n == "member") {
        const r = e[0];
        let a = r.featureType, o = r.featureNS;
        const l = "p", h = "p0";
        if (!a && t.childNodes) {
          a = [], o = {};
          for (let d = 0, g = t.childNodes.length; d < g; ++d) {
            const _ = (
              /** @type {Element} */
              t.childNodes[d]
            );
            if (_.nodeType === 1) {
              const y = _.nodeName.split(":").pop();
              if (!a.includes(y)) {
                let E = "", M = 0;
                const w = _.namespaceURI;
                for (const R in o) {
                  if (o[R] === w) {
                    E = R;
                    break;
                  }
                  ++M;
                }
                E || (E = l + M, o[E] = w), a.push(E + ":" + y);
              }
            }
          }
          n != "featureMember" && (r.featureType = a, r.featureNS = o);
        }
        if (typeof o == "string") {
          const d = o;
          o = {}, o[h] = d;
        }
        const c = {}, u = Array.isArray(a) ? a : [a];
        for (const d in o) {
          const g = {};
          for (let _ = 0, y = u.length; _ < y; ++_)
            (u[_].includes(":") ? u[_].split(":")[0] : h) === d && (g[u[_].split(":").pop()] = n == "featureMembers" ? ot(this.readFeatureElement, this) : J(this.readFeatureElement, this));
          c[o[d]] = g;
        }
        n == "featureMember" || n == "member" ? s = Ot(void 0, c, t, e) : s = Ot([], c, t, e);
      }
      return s === null && (s = []), s;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {import("../geom/Geometry.js").default|import("../extent.js").Extent|undefined} Geometry.
     */
    readGeometryOrExtent(t, e) {
      const n = (
        /** @type {Object} */
        e[0]
      );
      return n.srsName = t.firstElementChild.getAttribute("srsName"), n.srsDimension = t.firstElementChild.getAttribute("srsDimension"), Ot(
        null,
        this.GEOMETRY_PARSERS,
        t,
        e,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {import("../extent.js").Extent|undefined} Geometry.
     */
    readExtentElement(t, e) {
      const n = (
        /** @type {Object} */
        e[0]
      ), s = (
        /** @type {import("../extent.js").Extent} */
        this.readGeometryOrExtent(t, e)
      );
      return s ? Kh(s, n) : void 0;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {import("../geom/Geometry.js").default|undefined} Geometry.
     */
    readGeometryElement(t, e) {
      const n = (
        /** @type {Object} */
        e[0]
      ), s = (
        /** @type {import("../geom/Geometry.js").default} */
        this.readGeometryOrExtent(t, e)
      );
      return s ? qh(s, !1, n) : void 0;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @param {boolean} asFeature whether result should be wrapped as a feature.
     * @return {Feature|Object} Feature
     */
    readFeatureElementInternal(t, e, n) {
      let s;
      const r = {};
      for (let l = t.firstElementChild; l; l = l.nextElementSibling) {
        let h;
        const c = l.localName;
        l.childNodes.length === 0 || l.childNodes.length === 1 && (l.firstChild.nodeType === 3 || l.firstChild.nodeType === 4) ? (h = Qa(l, !1), v1.test(h) && (h = void 0)) : (n && (h = c === "boundedBy" ? this.readExtentElement(l, e) : this.readGeometryElement(l, e)), h ? c !== "boundedBy" && (s = c) : h = this.readFeatureElementInternal(l, e, !1));
        const u = l.attributes.length;
        if (u > 0 && !(h instanceof Eo)) {
          h = { _content_: h };
          for (let d = 0; d < u; d++) {
            const g = l.attributes[d].name;
            h[g] = l.attributes[d].value;
          }
        }
        r[c] ? (r[c] instanceof Array || (r[c] = [r[c]]), r[c].push(h)) : r[c] = h;
      }
      if (!n)
        return r;
      const a = new bo(r);
      s && a.setGeometryName(s);
      const o = t.getAttribute("fid") || g1(t, this.namespace, "id");
      return o && a.setId(o), a;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Feature} Feature.
     */
    readFeatureElement(t, e) {
      return this.readFeatureElementInternal(t, e, !0);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Point|undefined} Point.
     */
    readPoint(t, e) {
      const n = this.readFlatCoordinatesFromNode(t, e);
      if (n)
        return new Sr(n, "XYZ");
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {MultiPoint|undefined} MultiPoint.
     */
    readMultiPoint(t, e) {
      const n = Ot(
        [],
        this.MULTIPOINT_PARSERS,
        t,
        e,
        this
      );
      if (n)
        return new Kr(n);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {MultiLineString|undefined} MultiLineString.
     */
    readMultiLineString(t, e) {
      const n = Ot(
        [],
        this.MULTILINESTRING_PARSERS,
        t,
        e,
        this
      );
      if (n)
        return new Fs(n);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {MultiPolygon|undefined} MultiPolygon.
     */
    readMultiPolygon(t, e) {
      const n = Ot(
        [],
        this.MULTIPOLYGON_PARSERS,
        t,
        e,
        this
      );
      if (n)
        return new Ds(n);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    pointMemberParser(t, e) {
      Ms(this.POINTMEMBER_PARSERS, t, e, this);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    lineStringMemberParser(t, e) {
      Ms(this.LINESTRINGMEMBER_PARSERS, t, e, this);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    polygonMemberParser(t, e) {
      Ms(this.POLYGONMEMBER_PARSERS, t, e, this);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {LineString|undefined} LineString.
     */
    readLineString(t, e) {
      const n = this.readFlatCoordinatesFromNode(t, e);
      if (n)
        return new en(n, "XYZ");
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} LinearRing flat coordinates.
     */
    readFlatLinearRing(t, e) {
      const n = Ot(
        null,
        this.GEOMETRY_FLAT_COORDINATES_PARSERS,
        t,
        e,
        this
      );
      if (n)
        return n;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {LinearRing|undefined} LinearRing.
     */
    readLinearRing(t, e) {
      const n = this.readFlatCoordinatesFromNode(t, e);
      if (n)
        return new kn(n, "XYZ");
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Polygon|undefined} Polygon.
     */
    readPolygon(t, e) {
      const n = Ot(
        [null],
        this.FLAT_LINEAR_RINGS_PARSERS,
        t,
        e,
        this
      );
      if (n && n[0]) {
        const s = n[0], r = [s.length];
        let a, o;
        for (a = 1, o = n.length; a < o; ++a)
          pe(s, n[a]), r.push(s.length);
        return new oi(s, "XYZ", r);
      }
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>} Flat coordinates.
     */
    readFlatCoordinatesFromNode(t, e) {
      return Ot(
        null,
        this.GEOMETRY_FLAT_COORDINATES_PARSERS,
        t,
        e,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @protected
     * @return {import("../geom/Geometry.js").default} Geometry.
     * @override
     */
    readGeometryFromNode(t, e) {
      const n = this.readGeometryElement(t, [
        this.getReadOptions(t, e || {})
      ]);
      return n || null;
    }
    /**
     * @param {Element} node Node.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @return {Array<import("../Feature.js").default>} Features.
     * @override
     */
    readFeaturesFromNode(t, e) {
      const n = {
        featureType: this.featureType,
        featureNS: this.featureNS
      };
      return Object.assign(n, this.getReadOptions(t, e)), this.readFeaturesInternal(t, [n]) || [];
    }
    /**
     * @param {Element} node Node.
     * @return {import("../proj/Projection.js").default} Projection.
     * @override
     */
    readProjectionFromNode(t) {
      return At(
        this.srsName ? this.srsName : t.firstElementChild.getAttribute("srsName")
      );
    }
  }
  K.prototype.namespace = Lo;
  K.prototype.FLAT_LINEAR_RINGS_PARSERS = {
    "http://www.opengis.net/gml": {}
  };
  K.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
    "http://www.opengis.net/gml": {}
  };
  K.prototype.GEOMETRY_PARSERS = {
    "http://www.opengis.net/gml": {}
  };
  K.prototype.MULTIPOINT_PARSERS = {
    "http://www.opengis.net/gml": {
      pointMember: ot(K.prototype.pointMemberParser),
      pointMembers: ot(K.prototype.pointMemberParser)
    }
  };
  K.prototype.MULTILINESTRING_PARSERS = {
    "http://www.opengis.net/gml": {
      lineStringMember: ot(
        K.prototype.lineStringMemberParser
      ),
      lineStringMembers: ot(
        K.prototype.lineStringMemberParser
      )
    }
  };
  K.prototype.MULTIPOLYGON_PARSERS = {
    "http://www.opengis.net/gml": {
      polygonMember: ot(K.prototype.polygonMemberParser),
      polygonMembers: ot(K.prototype.polygonMemberParser)
    }
  };
  K.prototype.POINTMEMBER_PARSERS = {
    "http://www.opengis.net/gml": {
      Point: ot(K.prototype.readFlatCoordinatesFromNode)
    }
  };
  K.prototype.LINESTRINGMEMBER_PARSERS = {
    "http://www.opengis.net/gml": {
      LineString: ot(K.prototype.readLineString)
    }
  };
  K.prototype.POLYGONMEMBER_PARSERS = {
    "http://www.opengis.net/gml": {
      Polygon: ot(K.prototype.readPolygon)
    }
  };
  K.prototype.RING_PARSERS = {
    "http://www.opengis.net/gml": {
      LinearRing: J(K.prototype.readFlatLinearRing)
    }
  };
  const E1 = Lo + " http://schemas.opengis.net/gml/2.1.2/feature.xsd", M1 = {
    MultiLineString: "lineStringMember",
    MultiCurve: "curveMember",
    MultiPolygon: "polygonMember",
    MultiSurface: "surfaceMember"
  };
  class gt extends K {
    /**
     * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
     */
    constructor(t) {
      t = t || {}, super(t), this.FEATURE_COLLECTION_PARSERS[Lo].featureMember = ot(
        this.readFeaturesInternal
      ), this.schemaLocation = t.schemaLocation ? t.schemaLocation : E1;
    }
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} Flat coordinates.
     */
    readFlatCoordinates(t, e) {
      const n = Qa(t, !1).replace(/^\s*|\s*$/g, ""), r = /** @type {import("../xml.js").NodeStackItem} */ e[0].srsName;
      let a = "enu";
      if (r) {
        const h = At(r);
        h && (a = h.getAxisOrientation());
      }
      const o = n.trim().split(/\s+/), l = [];
      for (let h = 0, c = o.length; h < c; h++) {
        const u = o[h].split(/,+/), d = parseFloat(u[0]), g = parseFloat(u[1]), _ = u.length === 3 ? parseFloat(u[2]) : 0;
        a.startsWith("en") ? l.push(d, g, _) : l.push(g, d, _);
      }
      return l;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {import("../extent.js").Extent|undefined} Envelope.
     */
    readBox(t, e) {
      const n = Ot(
        [null],
        this.BOX_PARSERS_,
        t,
        e,
        this
      );
      return Le(
        n[1][0],
        n[1][1],
        n[1][3],
        n[1][4]
      );
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    innerBoundaryIsParser(t, e) {
      const n = Ot(
        void 0,
        this.RING_PARSERS,
        t,
        e,
        this
      );
      n && /** @type {Array<Array<number>>} */
      e[e.length - 1].push(n);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    outerBoundaryIsParser(t, e) {
      const n = Ot(
        void 0,
        this.RING_PARSERS,
        t,
        e,
        this
      );
      if (n) {
        const s = (
          /** @type {Array<Array<number>>} */
          e[e.length - 1]
        );
        s[0] = n;
      }
    }
    /**
     * @const
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [nodeName] Node name.
     * @return {Element|undefined} Node.
     * @private
     */
    GEOMETRY_NODE_FACTORY_(t, e, n) {
      const s = e[e.length - 1], r = s.multiSurface, a = s.surface, o = s.multiCurve;
      return Array.isArray(t) ? n = "Envelope" : (n = /** @type {import("../geom/Geometry.js").default} */
      t.getType(), n === "MultiPolygon" && r === !0 ? n = "MultiSurface" : n === "Polygon" && a === !0 ? n = "Surface" : n === "MultiLineString" && o === !0 && (n = "MultiCurve")), Lt("http://www.opengis.net/gml", n);
    }
    /**
     * @param {Element} node Node.
     * @param {import("../Feature.js").default} feature Feature.
     * @param {Array<*>} objectStack Node stack.
     */
    writeFeatureElement(t, e, n) {
      const s = e.getId();
      s && t.setAttribute(
        "fid",
        /** @type {string} */
        s
      );
      const r = (
        /** @type {Object} */
        n[n.length - 1]
      ), a = r.featureNS, o = e.getGeometryName();
      r.serializers || (r.serializers = {}, r.serializers[a] = {});
      const l = [], h = [];
      if (e.hasProperties()) {
        const u = e.getProperties();
        for (const d in u) {
          const g = u[d];
          g != null && (l.push(d), h.push(g), d == o || typeof /** @type {?} */
          g.getSimplifiedGeometry == "function" ? d in r.serializers[a] || (r.serializers[a][d] = Y(
            this.writeGeometryElement,
            this
          )) : d in r.serializers[a] || (r.serializers[a][d] = Y(Ue)));
        }
      }
      const c = Object.assign({}, r);
      c.node = t, ge(
        /** @type {import("../xml.js").NodeStackItem} */
        c,
        r.serializers,
        Es(void 0, a),
        h,
        n,
        l
      );
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LineString.js").default} geometry LineString geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeCurveOrLineString(t, e, n) {
      const r = n[n.length - 1].srsName;
      if (t.nodeName !== "LineStringSegment" && r && t.setAttribute("srsName", r), t.nodeName === "LineString" || t.nodeName === "LineStringSegment") {
        const a = this.createCoordinatesNode_(t.namespaceURI);
        t.appendChild(a), this.writeCoordinates_(a, e, n);
      } else if (t.nodeName === "Curve") {
        const a = Lt(t.namespaceURI, "segments");
        t.appendChild(a), this.writeCurveSegments_(a, e, n);
      }
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LineString.js").default} line LineString geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeLineStringOrCurveMember(t, e, n) {
      const s = this.GEOMETRY_NODE_FACTORY_(e, n);
      s && (t.appendChild(s), this.writeCurveOrLineString(s, e, n));
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/MultiLineString.js").default} geometry MultiLineString geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeMultiCurveOrLineString(t, e, n) {
      const s = n[n.length - 1], r = s.hasZ, a = s.srsName, o = s.curve;
      a && t.setAttribute("srsName", a);
      const l = e.getLineStrings();
      ge(
        { node: t, hasZ: r, srsName: a, curve: o },
        this.LINESTRINGORCURVEMEMBER_SERIALIZERS,
        this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
        l,
        n,
        void 0,
        this
      );
    }
    /**
     * @param {Node} node Node.
     * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeGeometryElement(t, e, n) {
      const s = (
        /** @type {import("./Feature.js").WriteOptions} */
        n[n.length - 1]
      ), r = Object.assign({}, s);
      r.node = t;
      let a;
      Array.isArray(e) ? a = Kh(
        /** @type {import("../extent.js").Extent} */
        e,
        s
      ) : a = qh(
        /** @type {import("../geom/Geometry.js").default} */
        e,
        !0,
        s
      ), ge(
        /** @type {import("../xml.js").NodeStackItem} */
        r,
        this.GEOMETRY_SERIALIZERS,
        this.GEOMETRY_NODE_FACTORY_,
        [a],
        n,
        void 0,
        this
      );
    }
    /**
     * @param {string} namespaceURI XML namespace.
     * @return {Element} coordinates node.
     * @private
     */
    createCoordinatesNode_(t) {
      const e = Lt(t, "coordinates");
      return e.setAttribute("decimal", "."), e.setAttribute("cs", ","), e.setAttribute("ts", " "), e;
    }
    /**
     * @param {Node} node Node.
     * @param {import("../geom/LineString.js").default|import("../geom/LinearRing.js").default} value Geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    writeCoordinates_(t, e, n) {
      const s = n[n.length - 1], r = s.hasZ, a = s.srsName, o = e.getCoordinates(), l = o.length, h = new Array(l);
      for (let c = 0; c < l; ++c) {
        const u = o[c];
        h[c] = this.getCoords_(u, a, r);
      }
      Ue(t, h.join(" "));
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LineString.js").default} line LineString geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    writeCurveSegments_(t, e, n) {
      const s = Lt(t.namespaceURI, "LineStringSegment");
      t.appendChild(s), this.writeCurveOrLineString(s, e, n);
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeSurfaceOrPolygon(t, e, n) {
      const s = n[n.length - 1], r = s.hasZ, a = s.srsName;
      if (t.nodeName !== "PolygonPatch" && a && t.setAttribute("srsName", a), t.nodeName === "Polygon" || t.nodeName === "PolygonPatch") {
        const o = e.getLinearRings();
        ge(
          { node: t, hasZ: r, srsName: a },
          this.RING_SERIALIZERS,
          this.RING_NODE_FACTORY_,
          o,
          n,
          void 0,
          this
        );
      } else if (t.nodeName === "Surface") {
        const o = Lt(t.namespaceURI, "patches");
        t.appendChild(o), this.writeSurfacePatches_(o, e, n);
      }
    }
    /**
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [nodeName] Node name.
     * @return {Node} Node.
     * @private
     */
    RING_NODE_FACTORY_(t, e, n) {
      const s = e[e.length - 1], r = s.node, a = s.exteriorWritten;
      return a === void 0 && (s.exteriorWritten = !0), Lt(
        r.namespaceURI,
        a !== void 0 ? "innerBoundaryIs" : "outerBoundaryIs"
      );
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    writeSurfacePatches_(t, e, n) {
      const s = Lt(t.namespaceURI, "PolygonPatch");
      t.appendChild(s), this.writeSurfaceOrPolygon(s, e, n);
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeRing(t, e, n) {
      const s = Lt(t.namespaceURI, "LinearRing");
      t.appendChild(s), this.writeLinearRing(s, e, n);
    }
    /**
     * @param {Array<number>} point Point geometry.
     * @param {string} [srsName] Optional srsName
     * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
     * @return {string} The coords string.
     * @private
     */
    getCoords_(t, e, n) {
      let r = (e ? At(e).getAxisOrientation() : "enu").startsWith("en") ? t[0] + "," + t[1] : t[1] + "," + t[0];
      if (n) {
        const a = t[2] || 0;
        r += "," + a;
      }
      return r;
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Point.js").default} geometry Point geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writePoint(t, e, n) {
      const s = n[n.length - 1], r = s.hasZ, a = s.srsName;
      a && t.setAttribute("srsName", a);
      const o = this.createCoordinatesNode_(t.namespaceURI);
      t.appendChild(o);
      const l = e.getCoordinates(), h = this.getCoords_(l, a, r);
      Ue(o, h);
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeMultiPoint(t, e, n) {
      const s = n[n.length - 1], r = s.hasZ, a = s.srsName;
      a && t.setAttribute("srsName", a);
      const o = e.getPoints();
      ge(
        { node: t, hasZ: r, srsName: a },
        this.POINTMEMBER_SERIALIZERS,
        Es("pointMember"),
        o,
        n,
        void 0,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Point.js").default} point Point geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writePointMember(t, e, n) {
      const s = Lt(t.namespaceURI, "Point");
      t.appendChild(s), this.writePoint(s, e, n);
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeLinearRing(t, e, n) {
      const r = n[n.length - 1].srsName;
      r && t.setAttribute("srsName", r);
      const a = this.createCoordinatesNode_(t.namespaceURI);
      t.appendChild(a), this.writeCoordinates_(a, e, n);
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeMultiSurfaceOrPolygon(t, e, n) {
      const s = n[n.length - 1], r = s.hasZ, a = s.srsName, o = s.surface;
      a && t.setAttribute("srsName", a);
      const l = e.getPolygons();
      ge(
        { node: t, hasZ: r, srsName: a, surface: o },
        this.SURFACEORPOLYGONMEMBER_SERIALIZERS,
        this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
        l,
        n,
        void 0,
        this
      );
    }
    /**
     * @param {Node} node Node.
     * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeSurfaceOrPolygonMember(t, e, n) {
      const s = this.GEOMETRY_NODE_FACTORY_(e, n);
      s && (t.appendChild(s), this.writeSurfaceOrPolygon(s, e, n));
    }
    /**
     * @param {Element} node Node.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {Array<*>} objectStack Node stack.
     */
    writeEnvelope(t, e, n) {
      const r = n[n.length - 1].srsName;
      r && t.setAttribute("srsName", r);
      const a = ["lowerCorner", "upperCorner"], o = [e[0] + " " + e[1], e[2] + " " + e[3]];
      ge(
        /** @type {import("../xml.js").NodeStackItem} */
        { node: t },
        this.ENVELOPE_SERIALIZERS,
        Pf,
        o,
        n,
        a,
        this
      );
    }
    /**
     * @const
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [nodeName] Node name.
     * @return {Node|undefined} Node.
     * @private
     */
    MULTIGEOMETRY_MEMBER_NODE_FACTORY_(t, e, n) {
      const s = e[e.length - 1].node;
      return Lt(
        "http://www.opengis.net/gml",
        M1[s.nodeName]
      );
    }
  }
  gt.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
    "http://www.opengis.net/gml": {
      coordinates: J(gt.prototype.readFlatCoordinates)
    }
  };
  gt.prototype.FLAT_LINEAR_RINGS_PARSERS = {
    "http://www.opengis.net/gml": {
      innerBoundaryIs: gt.prototype.innerBoundaryIsParser,
      outerBoundaryIs: gt.prototype.outerBoundaryIsParser
    }
  };
  gt.prototype.BOX_PARSERS_ = {
    "http://www.opengis.net/gml": {
      coordinates: ot(gt.prototype.readFlatCoordinates)
    }
  };
  gt.prototype.GEOMETRY_PARSERS = {
    "http://www.opengis.net/gml": {
      Point: J(K.prototype.readPoint),
      MultiPoint: J(K.prototype.readMultiPoint),
      LineString: J(K.prototype.readLineString),
      MultiLineString: J(K.prototype.readMultiLineString),
      LinearRing: J(K.prototype.readLinearRing),
      Polygon: J(K.prototype.readPolygon),
      MultiPolygon: J(K.prototype.readMultiPolygon),
      Box: J(gt.prototype.readBox)
    }
  };
  gt.prototype.GEOMETRY_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      Curve: Y(gt.prototype.writeCurveOrLineString),
      MultiCurve: Y(gt.prototype.writeMultiCurveOrLineString),
      Point: Y(gt.prototype.writePoint),
      MultiPoint: Y(gt.prototype.writeMultiPoint),
      LineString: Y(gt.prototype.writeCurveOrLineString),
      MultiLineString: Y(
        gt.prototype.writeMultiCurveOrLineString
      ),
      LinearRing: Y(gt.prototype.writeLinearRing),
      Polygon: Y(gt.prototype.writeSurfaceOrPolygon),
      MultiPolygon: Y(
        gt.prototype.writeMultiSurfaceOrPolygon
      ),
      Surface: Y(gt.prototype.writeSurfaceOrPolygon),
      MultiSurface: Y(
        gt.prototype.writeMultiSurfaceOrPolygon
      ),
      Envelope: Y(gt.prototype.writeEnvelope)
    }
  };
  gt.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      lineStringMember: Y(
        gt.prototype.writeLineStringOrCurveMember
      ),
      curveMember: Y(
        gt.prototype.writeLineStringOrCurveMember
      )
    }
  };
  gt.prototype.RING_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      outerBoundaryIs: Y(gt.prototype.writeRing),
      innerBoundaryIs: Y(gt.prototype.writeRing)
    }
  };
  gt.prototype.POINTMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      pointMember: Y(gt.prototype.writePointMember)
    }
  };
  gt.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      surfaceMember: Y(
        gt.prototype.writeSurfaceOrPolygonMember
      ),
      polygonMember: Y(
        gt.prototype.writeSurfaceOrPolygonMember
      )
    }
  };
  gt.prototype.ENVELOPE_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      lowerCorner: Y(Ue),
      upperCorner: Y(Ue)
    }
  };
  const x1 = Lo + " http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd", w1 = {
    MultiLineString: "lineStringMember",
    MultiCurve: "curveMember",
    MultiPolygon: "polygonMember",
    MultiSurface: "surfaceMember"
  };
  class F extends K {
    /**
     * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
     */
    constructor(t) {
      t = t || {}, super(t), this.surface_ = t.surface !== void 0 ? t.surface : !1, this.curve_ = t.curve !== void 0 ? t.curve : !1, this.multiCurve_ = t.multiCurve !== void 0 ? t.multiCurve : !0, this.multiSurface_ = t.multiSurface !== void 0 ? t.multiSurface : !0, this.schemaLocation = t.schemaLocation ? t.schemaLocation : x1, this.hasZ = t.hasZ !== void 0 ? t.hasZ : !1;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {MultiLineString|undefined} MultiLineString.
     */
    readMultiCurve(t, e) {
      const n = Ot(
        [],
        this.MULTICURVE_PARSERS,
        t,
        e,
        this
      );
      if (n)
        return new Fs(n);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} Polygon.
     */
    readFlatCurveRing(t, e) {
      const n = Ot(
        [],
        this.MULTICURVE_PARSERS,
        t,
        e,
        this
      ), s = [];
      for (let r = 0, a = n.length; r < a; ++r)
        pe(s, n[r].getFlatCoordinates());
      return s;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {MultiPolygon|undefined} MultiPolygon.
     */
    readMultiSurface(t, e) {
      const n = Ot(
        [],
        this.MULTISURFACE_PARSERS,
        t,
        e,
        this
      );
      if (n)
        return new Ds(n);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    curveMemberParser(t, e) {
      Ms(this.CURVEMEMBER_PARSERS, t, e, this);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    surfaceMemberParser(t, e) {
      Ms(this.SURFACEMEMBER_PARSERS, t, e, this);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<(Array<number>)>|undefined} flat coordinates.
     */
    readPatch(t, e) {
      return Ot(
        [null],
        this.PATCHES_PARSERS,
        t,
        e,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} flat coordinates.
     */
    readSegment(t, e) {
      return Ot([], this.SEGMENTS_PARSERS, t, e, this);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<(Array<number>)>|undefined} flat coordinates.
     */
    readPolygonPatch(t, e) {
      return Ot(
        [null],
        this.FLAT_LINEAR_RINGS_PARSERS,
        t,
        e,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} flat coordinates.
     */
    readLineStringSegment(t, e) {
      return Ot(
        [null],
        this.GEOMETRY_FLAT_COORDINATES_PARSERS,
        t,
        e,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    interiorParser(t, e) {
      const n = Ot(
        void 0,
        this.RING_PARSERS,
        t,
        e,
        this
      );
      n && /** @type {Array<Array<number>>} */
      e[e.length - 1].push(n);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    exteriorParser(t, e) {
      const n = Ot(
        void 0,
        this.RING_PARSERS,
        t,
        e,
        this
      );
      if (n) {
        const s = (
          /** @type {Array<Array<number>>} */
          e[e.length - 1]
        );
        s[0] = n;
      }
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Polygon|undefined} Polygon.
     */
    readSurface(t, e) {
      const n = Ot(
        [null],
        this.SURFACE_PARSERS,
        t,
        e,
        this
      );
      if (n && n[0]) {
        const s = n[0], r = [s.length];
        let a, o;
        for (a = 1, o = n.length; a < o; ++a)
          pe(s, n[a]), r.push(s.length);
        return new oi(s, "XYZ", r);
      }
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {LineString|undefined} LineString.
     */
    readCurve(t, e) {
      const n = Ot(
        [null],
        this.CURVE_PARSERS,
        t,
        e,
        this
      );
      if (n)
        return new en(n, "XYZ");
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {import("../extent.js").Extent|undefined} Envelope.
     */
    readEnvelope(t, e) {
      const n = Ot(
        [null],
        this.ENVELOPE_PARSERS,
        t,
        e,
        this
      );
      return Le(
        n[1][0],
        n[1][1],
        n[2][0],
        n[2][1]
      );
    }
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} Flat coordinates.
     */
    readFlatPos(t, e) {
      let n = Qa(t, !1);
      const s = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/, r = [];
      let a;
      for (; a = s.exec(n); )
        r.push(parseFloat(a[1])), n = n.substr(a[0].length);
      if (n !== "")
        return;
      const l = e[0].srsName;
      if ((l ? At(l).getAxisOrientation() : "enu") === "neu")
        for (let u = 0, d = r.length; u < d; u += 3) {
          const g = r[u], _ = r[u + 1];
          r[u] = _, r[u + 1] = g;
        }
      const c = r.length;
      if (c == 2 && r.push(0), c !== 0)
        return r;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} Flat coordinates.
     */
    readFlatPosList(t, e) {
      const n = Qa(t, !1).replace(/^\s*|\s*$/g, ""), s = e[0], r = s.srsName, a = s.srsDimension, o = r ? At(r).getAxisOrientation() : "enu", l = n.split(/\s+/);
      let h = 2;
      t.getAttribute("srsDimension") ? h = Sa(t.getAttribute("srsDimension")) : t.getAttribute("dimension") ? h = Sa(t.getAttribute("dimension")) : /** @type {Element} */ t.parentNode.getAttribute("srsDimension") ? h = Sa(
        /** @type {Element} */
        t.parentNode.getAttribute("srsDimension")
      ) : a && (h = Sa(a));
      const c = o.startsWith("en");
      let u, d, g;
      const _ = [];
      for (let y = 0, E = l.length; y < E; y += h)
        u = parseFloat(l[y]), d = parseFloat(l[y + 1]), g = h === 3 ? parseFloat(l[y + 2]) : 0, c ? _.push(u, d, g) : _.push(d, u, g);
      return _;
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Point.js").default} value Point geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    writePos_(t, e, n) {
      const s = n[n.length - 1], r = s.hasZ, a = r ? "3" : "2";
      t.setAttribute("srsDimension", a);
      const o = s.srsName, l = o ? At(o).getAxisOrientation() : "enu", h = e.getCoordinates();
      let c = l.startsWith("en") ? h[0] + " " + h[1] : h[1] + " " + h[0];
      if (r) {
        const u = h[2] || 0;
        c += " " + u;
      }
      Ue(t, c);
    }
    /**
     * @param {Array<number>} point Point geometry.
     * @param {string} [srsName] Optional srsName
     * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
     * @return {string} The coords string.
     * @private
     */
    getCoords_(t, e, n) {
      let r = (e ? At(e).getAxisOrientation() : "enu").startsWith("en") ? t[0] + " " + t[1] : t[1] + " " + t[0];
      if (n) {
        const a = t[2] || 0;
        r += " " + a;
      }
      return r;
    }
    /**
     * @param {Element} node Node.
     * @param {LineString|import("../geom/LinearRing.js").default} value Geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    writePosList_(t, e, n) {
      const s = n[n.length - 1], r = s.hasZ, a = r ? "3" : "2";
      t.setAttribute("srsDimension", a);
      const o = s.srsName, l = e.getCoordinates(), h = l.length, c = new Array(h);
      let u;
      for (let d = 0; d < h; ++d)
        u = l[d], c[d] = this.getCoords_(u, o, r);
      Ue(t, c.join(" "));
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Point.js").default} geometry Point geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writePoint(t, e, n) {
      const r = n[n.length - 1].srsName;
      r && t.setAttribute("srsName", r);
      const a = Lt(t.namespaceURI, "pos");
      t.appendChild(a), this.writePos_(a, e, n);
    }
    /**
     * @param {Element} node Node.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {Array<*>} objectStack Node stack.
     */
    writeEnvelope(t, e, n) {
      const r = n[n.length - 1].srsName;
      r && t.setAttribute("srsName", r);
      const a = ["lowerCorner", "upperCorner"], o = [e[0] + " " + e[1], e[2] + " " + e[3]];
      ge(
        /** @type {import("../xml.js").NodeStackItem} */
        { node: t },
        this.ENVELOPE_SERIALIZERS,
        Pf,
        o,
        n,
        a,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeLinearRing(t, e, n) {
      const r = n[n.length - 1].srsName;
      r && t.setAttribute("srsName", r);
      const a = Lt(t.namespaceURI, "posList");
      t.appendChild(a), this.writePosList_(a, e, n);
    }
    /**
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [nodeName] Node name.
     * @return {Node} Node.
     * @private
     */
    RING_NODE_FACTORY_(t, e, n) {
      const s = e[e.length - 1], r = s.node, a = s.exteriorWritten;
      return a === void 0 && (s.exteriorWritten = !0), Lt(
        r.namespaceURI,
        a !== void 0 ? "interior" : "exterior"
      );
    }
    /**
     * @param {Element} node Node.
     * @param {Polygon} geometry Polygon geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeSurfaceOrPolygon(t, e, n) {
      const s = n[n.length - 1], r = s.hasZ, a = s.srsName;
      if (t.nodeName !== "PolygonPatch" && a && t.setAttribute("srsName", a), t.nodeName === "Polygon" || t.nodeName === "PolygonPatch") {
        const o = e.getLinearRings();
        ge(
          { node: t, hasZ: r, srsName: a },
          this.RING_SERIALIZERS,
          this.RING_NODE_FACTORY_,
          o,
          n,
          void 0,
          this
        );
      } else if (t.nodeName === "Surface") {
        const o = Lt(t.namespaceURI, "patches");
        t.appendChild(o), this.writeSurfacePatches_(o, e, n);
      }
    }
    /**
     * @param {Element} node Node.
     * @param {LineString} geometry LineString geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeCurveOrLineString(t, e, n) {
      const r = n[n.length - 1].srsName;
      if (t.nodeName !== "LineStringSegment" && r && t.setAttribute("srsName", r), t.nodeName === "LineString" || t.nodeName === "LineStringSegment") {
        const a = Lt(t.namespaceURI, "posList");
        t.appendChild(a), this.writePosList_(a, e, n);
      } else if (t.nodeName === "Curve") {
        const a = Lt(t.namespaceURI, "segments");
        t.appendChild(a), this.writeCurveSegments_(a, e, n);
      }
    }
    /**
     * @param {Element} node Node.
     * @param {MultiPolygon} geometry MultiPolygon geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeMultiSurfaceOrPolygon(t, e, n) {
      const s = n[n.length - 1], r = s.hasZ, a = s.srsName, o = s.surface;
      a && t.setAttribute("srsName", a);
      const l = e.getPolygons();
      ge(
        { node: t, hasZ: r, srsName: a, surface: o },
        this.SURFACEORPOLYGONMEMBER_SERIALIZERS,
        this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
        l,
        n,
        void 0,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeMultiPoint(t, e, n) {
      const s = n[n.length - 1], r = s.srsName, a = s.hasZ;
      r && t.setAttribute("srsName", r);
      const o = e.getPoints();
      ge(
        { node: t, hasZ: a, srsName: r },
        this.POINTMEMBER_SERIALIZERS,
        Es("pointMember"),
        o,
        n,
        void 0,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {MultiLineString} geometry MultiLineString geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeMultiCurveOrLineString(t, e, n) {
      const s = n[n.length - 1], r = s.hasZ, a = s.srsName, o = s.curve;
      a && t.setAttribute("srsName", a);
      const l = e.getLineStrings();
      ge(
        { node: t, hasZ: r, srsName: a, curve: o },
        this.LINESTRINGORCURVEMEMBER_SERIALIZERS,
        this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
        l,
        n,
        void 0,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeRing(t, e, n) {
      const s = Lt(t.namespaceURI, "LinearRing");
      t.appendChild(s), this.writeLinearRing(s, e, n);
    }
    /**
     * @param {Node} node Node.
     * @param {Polygon} polygon Polygon geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeSurfaceOrPolygonMember(t, e, n) {
      const s = this.GEOMETRY_NODE_FACTORY_(e, n);
      s && (t.appendChild(s), this.writeSurfaceOrPolygon(s, e, n));
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Point.js").default} point Point geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writePointMember(t, e, n) {
      const s = Lt(t.namespaceURI, "Point");
      t.appendChild(s), this.writePoint(s, e, n);
    }
    /**
     * @param {Node} node Node.
     * @param {LineString} line LineString geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeLineStringOrCurveMember(t, e, n) {
      const s = this.GEOMETRY_NODE_FACTORY_(e, n);
      s && (t.appendChild(s), this.writeCurveOrLineString(s, e, n));
    }
    /**
     * @param {Element} node Node.
     * @param {Polygon} polygon Polygon geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    writeSurfacePatches_(t, e, n) {
      const s = Lt(t.namespaceURI, "PolygonPatch");
      t.appendChild(s), this.writeSurfaceOrPolygon(s, e, n);
    }
    /**
     * @param {Element} node Node.
     * @param {LineString} line LineString geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    writeCurveSegments_(t, e, n) {
      const s = Lt(t.namespaceURI, "LineStringSegment");
      t.appendChild(s), this.writeCurveOrLineString(s, e, n);
    }
    /**
     * @param {Node} node Node.
     * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeGeometryElement(t, e, n) {
      const s = (
        /** @type {import("./Feature.js").WriteOptions} */
        n[n.length - 1]
      ), r = Object.assign({}, s);
      r.node = t;
      let a;
      Array.isArray(e) ? a = Kh(
        /** @type {import("../extent.js").Extent} */
        e,
        s
      ) : a = qh(
        /** @type {import("../geom/Geometry.js").default} */
        e,
        !0,
        s
      ), ge(
        /** @type {import("../xml.js").NodeStackItem} */
        r,
        this.GEOMETRY_SERIALIZERS,
        this.GEOMETRY_NODE_FACTORY_,
        [a],
        n,
        void 0,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {import("../Feature.js").default} feature Feature.
     * @param {Array<*>} objectStack Node stack.
     */
    writeFeatureElement(t, e, n) {
      const s = e.getId();
      s && t.setAttribute(
        "fid",
        /** @type {string} */
        s
      );
      const r = (
        /** @type {Object} */
        n[n.length - 1]
      ), a = r.featureNS, o = e.getGeometryName();
      r.serializers || (r.serializers = {}, r.serializers[a] = {});
      const l = [], h = [];
      if (e.hasProperties()) {
        const u = e.getProperties();
        for (const d in u) {
          const g = u[d];
          g != null && (l.push(d), h.push(g), d == o || typeof /** @type {?} */
          g.getSimplifiedGeometry == "function" ? d in r.serializers[a] || (r.serializers[a][d] = Y(
            this.writeGeometryElement,
            this
          )) : d in r.serializers[a] || (r.serializers[a][d] = Y(Ue)));
        }
      }
      const c = Object.assign({}, r);
      c.node = t, ge(
        /** @type {import("../xml.js").NodeStackItem} */
        c,
        r.serializers,
        Es(void 0, a),
        h,
        n,
        l
      );
    }
    /**
     * @param {Node} node Node.
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    writeFeatureMembers_(t, e, n) {
      const s = (
        /** @type {Object} */
        n[n.length - 1]
      ), r = s.featureType, a = s.featureNS, o = {};
      o[a] = {}, o[a][r] = Y(
        this.writeFeatureElement,
        this
      );
      const l = Object.assign({}, s);
      l.node = t, ge(
        /** @type {import("../xml.js").NodeStackItem} */
        l,
        o,
        Es(r, a),
        e,
        n
      );
    }
    /**
     * @const
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [nodeName] Node name.
     * @return {Node|undefined} Node.
     * @private
     */
    MULTIGEOMETRY_MEMBER_NODE_FACTORY_(t, e, n) {
      const s = e[e.length - 1].node;
      return Lt(
        this.namespace,
        w1[s.nodeName]
      );
    }
    /**
     * @const
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [nodeName] Node name.
     * @return {Element|undefined} Node.
     * @private
     */
    GEOMETRY_NODE_FACTORY_(t, e, n) {
      const s = e[e.length - 1], r = s.multiSurface, a = s.surface, o = s.curve, l = s.multiCurve;
      return Array.isArray(t) ? n = "Envelope" : (n = /** @type {import("../geom/Geometry.js").default} */
      t.getType(), n === "MultiPolygon" && r === !0 ? n = "MultiSurface" : n === "Polygon" && a === !0 ? n = "Surface" : n === "LineString" && o === !0 ? n = "Curve" : n === "MultiLineString" && l === !0 && (n = "MultiCurve")), Lt(this.namespace, n);
    }
    /**
     * Encode a geometry in GML 3.1.1 Simple Features.
     *
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [options] Options.
     * @return {Node} Node.
     * @api
     * @override
     */
    writeGeometryNode(t, e) {
      e = this.adaptOptions(e);
      const n = Lt(this.namespace, "geom"), s = {
        node: n,
        hasZ: this.hasZ,
        srsName: this.srsName,
        curve: this.curve_,
        surface: this.surface_,
        multiSurface: this.multiSurface_,
        multiCurve: this.multiCurve_
      };
      return e && Object.assign(s, e), this.writeGeometryElement(n, t, [s]), n;
    }
    /**
     * Encode an array of features in the GML 3.1.1 format as an XML node.
     *
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Options.
     * @return {Element} Node.
     * @api
     * @override
     */
    writeFeaturesNode(t, e) {
      e = this.adaptOptions(e);
      const n = Lt(this.namespace, "featureMembers");
      n.setAttributeNS(
        f1,
        "xsi:schemaLocation",
        this.schemaLocation
      );
      const s = {
        srsName: this.srsName,
        hasZ: this.hasZ,
        curve: this.curve_,
        surface: this.surface_,
        multiSurface: this.multiSurface_,
        multiCurve: this.multiCurve_,
        featureNS: this.featureNS,
        featureType: this.featureType
      };
      return e && Object.assign(s, e), this.writeFeatureMembers_(n, t, [s]), n;
    }
  }
  F.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
    "http://www.opengis.net/gml": {
      pos: J(F.prototype.readFlatPos),
      posList: J(F.prototype.readFlatPosList),
      coordinates: J(gt.prototype.readFlatCoordinates)
    }
  };
  F.prototype.FLAT_LINEAR_RINGS_PARSERS = {
    "http://www.opengis.net/gml": {
      interior: F.prototype.interiorParser,
      exterior: F.prototype.exteriorParser
    }
  };
  F.prototype.GEOMETRY_PARSERS = {
    "http://www.opengis.net/gml": {
      Point: J(K.prototype.readPoint),
      MultiPoint: J(K.prototype.readMultiPoint),
      LineString: J(K.prototype.readLineString),
      MultiLineString: J(K.prototype.readMultiLineString),
      LinearRing: J(K.prototype.readLinearRing),
      Polygon: J(K.prototype.readPolygon),
      MultiPolygon: J(K.prototype.readMultiPolygon),
      Surface: J(F.prototype.readSurface),
      MultiSurface: J(F.prototype.readMultiSurface),
      Curve: J(F.prototype.readCurve),
      MultiCurve: J(F.prototype.readMultiCurve),
      Envelope: J(F.prototype.readEnvelope)
    }
  };
  F.prototype.MULTICURVE_PARSERS = {
    "http://www.opengis.net/gml": {
      curveMember: ot(F.prototype.curveMemberParser),
      curveMembers: ot(F.prototype.curveMemberParser)
    }
  };
  F.prototype.MULTISURFACE_PARSERS = {
    "http://www.opengis.net/gml": {
      surfaceMember: ot(F.prototype.surfaceMemberParser),
      surfaceMembers: ot(F.prototype.surfaceMemberParser)
    }
  };
  F.prototype.CURVEMEMBER_PARSERS = {
    "http://www.opengis.net/gml": {
      LineString: ot(K.prototype.readLineString),
      Curve: ot(F.prototype.readCurve)
    }
  };
  F.prototype.SURFACEMEMBER_PARSERS = {
    "http://www.opengis.net/gml": {
      Polygon: ot(K.prototype.readPolygon),
      Surface: ot(F.prototype.readSurface)
    }
  };
  F.prototype.SURFACE_PARSERS = {
    "http://www.opengis.net/gml": {
      patches: J(F.prototype.readPatch)
    }
  };
  F.prototype.CURVE_PARSERS = {
    "http://www.opengis.net/gml": {
      segments: J(F.prototype.readSegment)
    }
  };
  F.prototype.ENVELOPE_PARSERS = {
    "http://www.opengis.net/gml": {
      lowerCorner: ot(F.prototype.readFlatPosList),
      upperCorner: ot(F.prototype.readFlatPosList)
    }
  };
  F.prototype.PATCHES_PARSERS = {
    "http://www.opengis.net/gml": {
      PolygonPatch: J(F.prototype.readPolygonPatch)
    }
  };
  F.prototype.SEGMENTS_PARSERS = {
    "http://www.opengis.net/gml": {
      LineStringSegment: bf(
        F.prototype.readLineStringSegment
      )
    }
  };
  K.prototype.RING_PARSERS = {
    "http://www.opengis.net/gml": {
      LinearRing: J(K.prototype.readFlatLinearRing),
      Ring: J(F.prototype.readFlatCurveRing)
    }
  };
  F.prototype.RING_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      exterior: Y(F.prototype.writeRing),
      interior: Y(F.prototype.writeRing)
    }
  };
  F.prototype.ENVELOPE_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      lowerCorner: Y(Ue),
      upperCorner: Y(Ue)
    }
  };
  F.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      surfaceMember: Y(
        F.prototype.writeSurfaceOrPolygonMember
      ),
      polygonMember: Y(
        F.prototype.writeSurfaceOrPolygonMember
      )
    }
  };
  F.prototype.POINTMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      pointMember: Y(F.prototype.writePointMember)
    }
  };
  F.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      lineStringMember: Y(
        F.prototype.writeLineStringOrCurveMember
      ),
      curveMember: Y(
        F.prototype.writeLineStringOrCurveMember
      )
    }
  };
  F.prototype.GEOMETRY_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      Curve: Y(F.prototype.writeCurveOrLineString),
      MultiCurve: Y(F.prototype.writeMultiCurveOrLineString),
      Point: Y(F.prototype.writePoint),
      MultiPoint: Y(F.prototype.writeMultiPoint),
      LineString: Y(F.prototype.writeCurveOrLineString),
      MultiLineString: Y(
        F.prototype.writeMultiCurveOrLineString
      ),
      LinearRing: Y(F.prototype.writeLinearRing),
      Polygon: Y(F.prototype.writeSurfaceOrPolygon),
      MultiPolygon: Y(
        F.prototype.writeMultiSurfaceOrPolygon
      ),
      Surface: Y(F.prototype.writeSurfaceOrPolygon),
      MultiSurface: Y(
        F.prototype.writeMultiSurfaceOrPolygon
      ),
      Envelope: Y(F.prototype.writeEnvelope)
    }
  };
  class wt extends F {
    /**
     * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
     */
    constructor(t) {
      t = t || {}, super(t), this.schemaLocation = t.schemaLocation ? t.schemaLocation : this.namespace + " http://schemas.opengis.net/gml/3.2.1/gml.xsd";
    }
    /**
     * @param {Node} node Node.
     * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
     * @param {Array<*>} objectStack Node stack.
     * @override
     */
    writeGeometryElement(t, e, n) {
      const s = n[n.length - 1];
      n[n.length - 1] = Object.assign(
        { multiCurve: !0, multiSurface: !0 },
        s
      ), super.writeGeometryElement(t, e, n);
    }
  }
  wt.prototype.namespace = "http://www.opengis.net/gml/3.2";
  wt.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      pos: J(F.prototype.readFlatPos),
      posList: J(F.prototype.readFlatPosList),
      coordinates: J(gt.prototype.readFlatCoordinates)
    }
  };
  wt.prototype.FLAT_LINEAR_RINGS_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      interior: F.prototype.interiorParser,
      exterior: F.prototype.exteriorParser
    }
  };
  wt.prototype.GEOMETRY_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      Point: J(K.prototype.readPoint),
      MultiPoint: J(K.prototype.readMultiPoint),
      LineString: J(K.prototype.readLineString),
      MultiLineString: J(K.prototype.readMultiLineString),
      LinearRing: J(K.prototype.readLinearRing),
      Polygon: J(K.prototype.readPolygon),
      MultiPolygon: J(K.prototype.readMultiPolygon),
      Surface: J(wt.prototype.readSurface),
      MultiSurface: J(F.prototype.readMultiSurface),
      Curve: J(wt.prototype.readCurve),
      MultiCurve: J(F.prototype.readMultiCurve),
      Envelope: J(wt.prototype.readEnvelope)
    }
  };
  wt.prototype.MULTICURVE_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      curveMember: ot(F.prototype.curveMemberParser),
      curveMembers: ot(F.prototype.curveMemberParser)
    }
  };
  wt.prototype.MULTISURFACE_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      surfaceMember: ot(F.prototype.surfaceMemberParser),
      surfaceMembers: ot(F.prototype.surfaceMemberParser)
    }
  };
  wt.prototype.CURVEMEMBER_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      LineString: ot(K.prototype.readLineString),
      Curve: ot(F.prototype.readCurve)
    }
  };
  wt.prototype.SURFACEMEMBER_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      Polygon: ot(K.prototype.readPolygon),
      Surface: ot(F.prototype.readSurface)
    }
  };
  wt.prototype.SURFACE_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      patches: J(F.prototype.readPatch)
    }
  };
  wt.prototype.CURVE_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      segments: J(F.prototype.readSegment)
    }
  };
  wt.prototype.ENVELOPE_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      lowerCorner: ot(F.prototype.readFlatPosList),
      upperCorner: ot(F.prototype.readFlatPosList)
    }
  };
  wt.prototype.PATCHES_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      PolygonPatch: J(F.prototype.readPolygonPatch)
    }
  };
  wt.prototype.SEGMENTS_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      LineStringSegment: bf(
        F.prototype.readLineStringSegment
      )
    }
  };
  wt.prototype.MULTIPOINT_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      pointMember: ot(K.prototype.pointMemberParser),
      pointMembers: ot(K.prototype.pointMemberParser)
    }
  };
  wt.prototype.MULTILINESTRING_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      lineStringMember: ot(
        K.prototype.lineStringMemberParser
      ),
      lineStringMembers: ot(
        K.prototype.lineStringMemberParser
      )
    }
  };
  wt.prototype.MULTIPOLYGON_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      polygonMember: ot(K.prototype.polygonMemberParser),
      polygonMembers: ot(K.prototype.polygonMemberParser)
    }
  };
  wt.prototype.POINTMEMBER_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      Point: ot(K.prototype.readFlatCoordinatesFromNode)
    }
  };
  wt.prototype.LINESTRINGMEMBER_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      LineString: ot(K.prototype.readLineString)
    }
  };
  wt.prototype.POLYGONMEMBER_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      Polygon: ot(K.prototype.readPolygon)
    }
  };
  wt.prototype.RING_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      LinearRing: J(K.prototype.readFlatLinearRing),
      Ring: J(wt.prototype.readFlatCurveRing)
    }
  };
  wt.prototype.RING_SERIALIZERS = {
    "http://www.opengis.net/gml/3.2": {
      exterior: Y(F.prototype.writeRing),
      interior: Y(F.prototype.writeRing)
    }
  };
  wt.prototype.ENVELOPE_SERIALIZERS = {
    "http://www.opengis.net/gml/3.2": {
      lowerCorner: Y(Ue),
      upperCorner: Y(Ue)
    }
  };
  wt.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml/3.2": {
      surfaceMember: Y(
        F.prototype.writeSurfaceOrPolygonMember
      ),
      polygonMember: Y(
        F.prototype.writeSurfaceOrPolygonMember
      )
    }
  };
  wt.prototype.POINTMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml/3.2": {
      pointMember: Y(F.prototype.writePointMember)
    }
  };
  wt.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml/3.2": {
      lineStringMember: Y(
        F.prototype.writeLineStringOrCurveMember
      ),
      curveMember: Y(
        F.prototype.writeLineStringOrCurveMember
      )
    }
  };
  wt.prototype.GEOMETRY_SERIALIZERS = {
    "http://www.opengis.net/gml/3.2": {
      Curve: Y(F.prototype.writeCurveOrLineString),
      MultiCurve: Y(F.prototype.writeMultiCurveOrLineString),
      Point: Y(wt.prototype.writePoint),
      MultiPoint: Y(F.prototype.writeMultiPoint),
      LineString: Y(F.prototype.writeCurveOrLineString),
      MultiLineString: Y(
        F.prototype.writeMultiCurveOrLineString
      ),
      LinearRing: Y(F.prototype.writeLinearRing),
      Polygon: Y(F.prototype.writeSurfaceOrPolygon),
      MultiPolygon: Y(
        F.prototype.writeMultiSurfaceOrPolygon
      ),
      Surface: Y(F.prototype.writeSurfaceOrPolygon),
      MultiSurface: Y(
        F.prototype.writeMultiSurfaceOrPolygon
      ),
      Envelope: Y(F.prototype.writeEnvelope)
    }
  };
  function S1(i) {
    const t = Object.keys(i.defs), e = t.length;
    let n, s;
    for (n = 0; n < e; ++n) {
      const r = t[n];
      if (!Aa(r)) {
        const a = i.defs(r);
        let o = (
          /** @type {import("./Units.js").Units} */
          a.units
        );
        !o && a.projName === "longlat" && (o = "degrees"), Wa(
          new po({
            code: r,
            axisOrientation: a.axis,
            metersPerUnit: a.to_meter,
            units: o
          })
        );
      }
    }
    for (n = 0; n < e; ++n) {
      const r = t[n], a = Aa(r);
      for (s = 0; s < e; ++s) {
        const o = t[s], l = Aa(o);
        if (!ba(r, o))
          if (i.defs[r] === i.defs[o])
            Rl([a, l]);
          else {
            const h = i(r, o);
            Em(
              a,
              l,
              Uc(a, l, h.forward),
              Uc(l, a, h.inverse)
            );
          }
      }
    }
  }
  function C1(i) {
    i("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), i("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), i("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
    for (var t = 1; t <= 60; ++t)
      i("EPSG:" + (32600 + t), "+proj=utm +zone=" + t + " +datum=WGS84 +units=m"), i("EPSG:" + (32700 + t), "+proj=utm +zone=" + t + " +south +datum=WGS84 +units=m");
    i.WGS84 = i["EPSG:4326"], i["EPSG:3785"] = i["EPSG:3857"], i.GOOGLE = i["EPSG:3857"], i["EPSG:900913"] = i["EPSG:3857"], i["EPSG:102113"] = i["EPSG:3857"];
  }
  var $n = 1, Un = 2, xs = 3, R1 = 4, $l = 5, Fu = 6378137, I1 = 6356752314e-3, Du = 0.0066943799901413165, fr = 484813681109536e-20, N = Math.PI / 2, T1 = 0.16666666666666666, A1 = 0.04722222222222222, b1 = 0.022156084656084655, B = 1e-10, Jt = 0.017453292519943295, ri = 57.29577951308232, Rt = Math.PI / 4, Lr = Math.PI * 2, Qt = 3.14159265359, Re = {};
  Re.greenwich = 0;
  Re.lisbon = -9.131906111111;
  Re.paris = 2.337229166667;
  Re.bogota = -74.080916666667;
  Re.madrid = -3.687938888889;
  Re.rome = 12.452333333333;
  Re.bern = 7.439583333333;
  Re.jakarta = 106.807719444444;
  Re.ferro = -17.666666666667;
  Re.brussels = 4.367975;
  Re.stockholm = 18.058277777778;
  Re.athens = 23.7163375;
  Re.oslo = 10.722916666667;
  const P1 = {
    mm: { to_meter: 1e-3 },
    cm: { to_meter: 0.01 },
    ft: { to_meter: 0.3048 },
    "us-ft": { to_meter: 1200 / 3937 },
    fath: { to_meter: 1.8288 },
    kmi: { to_meter: 1852 },
    "us-ch": { to_meter: 20.1168402336805 },
    "us-mi": { to_meter: 1609.34721869444 },
    km: { to_meter: 1e3 },
    "ind-ft": { to_meter: 0.30479841 },
    "ind-yd": { to_meter: 0.91439523 },
    mi: { to_meter: 1609.344 },
    yd: { to_meter: 0.9144 },
    ch: { to_meter: 20.1168 },
    link: { to_meter: 0.201168 },
    dm: { to_meter: 0.01 },
    in: { to_meter: 0.0254 },
    "ind-ch": { to_meter: 20.11669506 },
    "us-in": { to_meter: 0.025400050800101 },
    "us-yd": { to_meter: 0.914401828803658 }
  };
  var ku = /[\s_\-\/\(\)]/g;
  function nn(i, t) {
    if (i[t])
      return i[t];
    for (var e = Object.keys(i), n = t.toLowerCase().replace(ku, ""), s = -1, r, a; ++s < e.length; )
      if (r = e[s], a = r.toLowerCase().replace(ku, ""), a === n)
        return i[r];
  }
  function Ul(i) {
    var t = {}, e = i.split("+").map(function(o) {
      return o.trim();
    }).filter(function(o) {
      return o;
    }).reduce(function(o, l) {
      var h = l.split("=");
      return h.push(!0), o[h[0].toLowerCase()] = h[1], o;
    }, {}), n, s, r, a = {
      proj: "projName",
      datum: "datumCode",
      rf: function(o) {
        t.rf = parseFloat(o);
      },
      lat_0: function(o) {
        t.lat0 = o * Jt;
      },
      lat_1: function(o) {
        t.lat1 = o * Jt;
      },
      lat_2: function(o) {
        t.lat2 = o * Jt;
      },
      lat_ts: function(o) {
        t.lat_ts = o * Jt;
      },
      lon_0: function(o) {
        t.long0 = o * Jt;
      },
      lon_1: function(o) {
        t.long1 = o * Jt;
      },
      lon_2: function(o) {
        t.long2 = o * Jt;
      },
      alpha: function(o) {
        t.alpha = parseFloat(o) * Jt;
      },
      gamma: function(o) {
        t.rectified_grid_angle = parseFloat(o);
      },
      lonc: function(o) {
        t.longc = o * Jt;
      },
      x_0: function(o) {
        t.x0 = parseFloat(o);
      },
      y_0: function(o) {
        t.y0 = parseFloat(o);
      },
      k_0: function(o) {
        t.k0 = parseFloat(o);
      },
      k: function(o) {
        t.k0 = parseFloat(o);
      },
      a: function(o) {
        t.a = parseFloat(o);
      },
      b: function(o) {
        t.b = parseFloat(o);
      },
      r: function(o) {
        t.a = t.b = parseFloat(o);
      },
      r_a: function() {
        t.R_A = !0;
      },
      zone: function(o) {
        t.zone = parseInt(o, 10);
      },
      south: function() {
        t.utmSouth = !0;
      },
      towgs84: function(o) {
        t.datum_params = o.split(",").map(function(l) {
          return parseFloat(l);
        });
      },
      to_meter: function(o) {
        t.to_meter = parseFloat(o);
      },
      units: function(o) {
        t.units = o;
        var l = nn(P1, o);
        l && (t.to_meter = l.to_meter);
      },
      from_greenwich: function(o) {
        t.from_greenwich = o * Jt;
      },
      pm: function(o) {
        var l = nn(Re, o);
        t.from_greenwich = (l || parseFloat(o)) * Jt;
      },
      nadgrids: function(o) {
        o === "@null" ? t.datumCode = "none" : t.nadgrids = o;
      },
      axis: function(o) {
        var l = "ewnsud";
        o.length === 3 && l.indexOf(o.substr(0, 1)) !== -1 && l.indexOf(o.substr(1, 1)) !== -1 && l.indexOf(o.substr(2, 1)) !== -1 && (t.axis = o);
      },
      approx: function() {
        t.approx = !0;
      }
    };
    for (n in e)
      s = e[n], n in a ? (r = a[n], typeof r == "function" ? r(s) : t[r] = s) : t[n] = s;
    return typeof t.datumCode == "string" && t.datumCode !== "WGS84" && (t.datumCode = t.datumCode.toLowerCase()), t;
  }
  var Or = 1, Of = 2, Nf = 3, to = 4, Ff = 5, Vh = -1, L1 = /\s/, O1 = /[A-Za-z]/, N1 = /[A-Za-z84_]/, Oo = /[,\]]/, Df = /[\d\.E\-\+]/;
  function bi(i) {
    if (typeof i != "string")
      throw new Error("not a string");
    this.text = i.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = Or;
  }
  bi.prototype.readCharicter = function() {
    var i = this.text[this.place++];
    if (this.state !== to)
      for (; L1.test(i); ) {
        if (this.place >= this.text.length)
          return;
        i = this.text[this.place++];
      }
    switch (this.state) {
      case Or:
        return this.neutral(i);
      case Of:
        return this.keyword(i);
      case to:
        return this.quoted(i);
      case Ff:
        return this.afterquote(i);
      case Nf:
        return this.number(i);
      case Vh:
        return;
    }
  };
  bi.prototype.afterquote = function(i) {
    if (i === '"') {
      this.word += '"', this.state = to;
      return;
    }
    if (Oo.test(i)) {
      this.word = this.word.trim(), this.afterItem(i);
      return;
    }
    throw new Error(`havn't handled "` + i + '" in afterquote yet, index ' + this.place);
  };
  bi.prototype.afterItem = function(i) {
    if (i === ",") {
      this.word !== null && this.currentObject.push(this.word), this.word = null, this.state = Or;
      return;
    }
    if (i === "]") {
      this.level--, this.word !== null && (this.currentObject.push(this.word), this.word = null), this.state = Or, this.currentObject = this.stack.pop(), this.currentObject || (this.state = Vh);
      return;
    }
  };
  bi.prototype.number = function(i) {
    if (Df.test(i)) {
      this.word += i;
      return;
    }
    if (Oo.test(i)) {
      this.word = parseFloat(this.word), this.afterItem(i);
      return;
    }
    throw new Error(`havn't handled "` + i + '" in number yet, index ' + this.place);
  };
  bi.prototype.quoted = function(i) {
    if (i === '"') {
      this.state = Ff;
      return;
    }
    this.word += i;
  };
  bi.prototype.keyword = function(i) {
    if (N1.test(i)) {
      this.word += i;
      return;
    }
    if (i === "[") {
      var t = [];
      t.push(this.word), this.level++, this.root === null ? this.root = t : this.currentObject.push(t), this.stack.push(this.currentObject), this.currentObject = t, this.state = Or;
      return;
    }
    if (Oo.test(i)) {
      this.afterItem(i);
      return;
    }
    throw new Error(`havn't handled "` + i + '" in keyword yet, index ' + this.place);
  };
  bi.prototype.neutral = function(i) {
    if (O1.test(i)) {
      this.word = i, this.state = Of;
      return;
    }
    if (i === '"') {
      this.word = "", this.state = to;
      return;
    }
    if (Df.test(i)) {
      this.word = i, this.state = Nf;
      return;
    }
    if (Oo.test(i)) {
      this.afterItem(i);
      return;
    }
    throw new Error(`havn't handled "` + i + '" in neutral yet, index ' + this.place);
  };
  bi.prototype.output = function() {
    for (; this.place < this.text.length; )
      this.readCharicter();
    if (this.state === Vh)
      return this.root;
    throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
  };
  function F1(i) {
    var t = new bi(i);
    return t.output();
  }
  function ml(i, t, e) {
    Array.isArray(t) && (e.unshift(t), t = null);
    var n = t ? {} : i, s = e.reduce(function(r, a) {
      return ds(a, r), r;
    }, n);
    t && (i[t] = s);
  }
  function ds(i, t) {
    if (!Array.isArray(i)) {
      t[i] = !0;
      return;
    }
    var e = i.shift();
    if (e === "PARAMETER" && (e = i.shift()), i.length === 1) {
      if (Array.isArray(i[0])) {
        t[e] = {}, ds(i[0], t[e]);
        return;
      }
      t[e] = i[0];
      return;
    }
    if (!i.length) {
      t[e] = !0;
      return;
    }
    if (e === "TOWGS84") {
      t[e] = i;
      return;
    }
    if (e === "AXIS") {
      e in t || (t[e] = []), t[e].push(i);
      return;
    }
    Array.isArray(e) || (t[e] = {});
    var n;
    switch (e) {
      case "UNIT":
      case "PRIMEM":
      case "VERT_DATUM":
        t[e] = {
          name: i[0].toLowerCase(),
          convert: i[1]
        }, i.length === 3 && ds(i[2], t[e]);
        return;
      case "SPHEROID":
      case "ELLIPSOID":
        t[e] = {
          name: i[0],
          a: i[1],
          rf: i[2]
        }, i.length === 4 && ds(i[3], t[e]);
        return;
      case "EDATUM":
      case "ENGINEERINGDATUM":
      case "LOCAL_DATUM":
      case "DATUM":
      case "VERT_CS":
      case "VERTCRS":
      case "VERTICALCRS":
        i[0] = ["name", i[0]], ml(t, e, i);
        return;
      case "COMPD_CS":
      case "COMPOUNDCRS":
      case "FITTED_CS":
      // the followings are the crs defined in
      // https://github.com/proj4js/proj4js/blob/1da4ed0b865d0fcb51c136090569210cdcc9019e/lib/parseCode.js#L11
      case "PROJECTEDCRS":
      case "PROJCRS":
      case "GEOGCS":
      case "GEOCCS":
      case "PROJCS":
      case "LOCAL_CS":
      case "GEODCRS":
      case "GEODETICCRS":
      case "GEODETICDATUM":
      case "ENGCRS":
      case "ENGINEERINGCRS":
        i[0] = ["name", i[0]], ml(t, e, i), t[e].type = e;
        return;
      default:
        for (n = -1; ++n < i.length; )
          if (!Array.isArray(i[n]))
            return ds(i, t[e]);
        return ml(t, e, i);
    }
  }
  var D1 = 0.017453292519943295, k1 = [
    "PROJECTEDCRS",
    "PROJCRS",
    "GEOGCS",
    "GEOCCS",
    "PROJCS",
    "LOCAL_CS",
    "GEODCRS",
    "GEODETICCRS",
    "GEODETICDATUM",
    "ENGCRS",
    "ENGINEERINGCRS"
  ];
  function G1(i, t) {
    var e = t[0], n = t[1];
    !(e in i) && n in i && (i[e] = i[n], t.length === 3 && (i[e] = t[2](i[e])));
  }
  function ei(i) {
    return i * D1;
  }
  function kf(i) {
    for (var t = Object.keys(i), e = 0, n = t.length; e < n; ++e) {
      var s = t[e];
      k1.indexOf(s) !== -1 && z1(i[s]), typeof i[s] == "object" && kf(i[s]);
    }
  }
  function z1(i) {
    if (i.AUTHORITY) {
      var t = Object.keys(i.AUTHORITY)[0];
      t && t in i.AUTHORITY && (i.title = t + ":" + i.AUTHORITY[t]);
    }
    if (i.type === "GEOGCS" ? i.projName = "longlat" : i.type === "LOCAL_CS" ? (i.projName = "identity", i.local = !0) : typeof i.PROJECTION == "object" ? i.projName = Object.keys(i.PROJECTION)[0] : i.projName = i.PROJECTION, i.AXIS) {
      for (var e = "", n = 0, s = i.AXIS.length; n < s; ++n) {
        var r = [i.AXIS[n][0].toLowerCase(), i.AXIS[n][1].toLowerCase()];
        r[0].indexOf("north") !== -1 || (r[0] === "y" || r[0] === "lat") && r[1] === "north" ? e += "n" : r[0].indexOf("south") !== -1 || (r[0] === "y" || r[0] === "lat") && r[1] === "south" ? e += "s" : r[0].indexOf("east") !== -1 || (r[0] === "x" || r[0] === "lon") && r[1] === "east" ? e += "e" : (r[0].indexOf("west") !== -1 || (r[0] === "x" || r[0] === "lon") && r[1] === "west") && (e += "w");
      }
      e.length === 2 && (e += "u"), e.length === 3 && (i.axis = e);
    }
    i.UNIT && (i.units = i.UNIT.name.toLowerCase(), i.units === "metre" && (i.units = "meter"), i.UNIT.convert && (i.type === "GEOGCS" ? i.DATUM && i.DATUM.SPHEROID && (i.to_meter = i.UNIT.convert * i.DATUM.SPHEROID.a) : i.to_meter = i.UNIT.convert));
    var a = i.GEOGCS;
    i.type === "GEOGCS" && (a = i), a && (a.DATUM ? i.datumCode = a.DATUM.name.toLowerCase() : i.datumCode = a.name.toLowerCase(), i.datumCode.slice(0, 2) === "d_" && (i.datumCode = i.datumCode.slice(2)), i.datumCode === "new_zealand_1949" && (i.datumCode = "nzgd49"), (i.datumCode === "wgs_1984" || i.datumCode === "world_geodetic_system_1984") && (i.PROJECTION === "Mercator_Auxiliary_Sphere" && (i.sphere = !0), i.datumCode = "wgs84"), i.datumCode === "belge_1972" && (i.datumCode = "rnb72"), a.DATUM && a.DATUM.SPHEROID && (i.ellps = a.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), i.ellps.toLowerCase().slice(0, 13) === "international" && (i.ellps = "intl"), i.a = a.DATUM.SPHEROID.a, i.rf = parseFloat(a.DATUM.SPHEROID.rf, 10)), a.DATUM && a.DATUM.TOWGS84 && (i.datum_params = a.DATUM.TOWGS84), ~i.datumCode.indexOf("osgb_1936") && (i.datumCode = "osgb36"), ~i.datumCode.indexOf("osni_1952") && (i.datumCode = "osni52"), (~i.datumCode.indexOf("tm65") || ~i.datumCode.indexOf("geodetic_datum_of_1965")) && (i.datumCode = "ire65"), i.datumCode === "ch1903+" && (i.datumCode = "ch1903"), ~i.datumCode.indexOf("israel") && (i.datumCode = "isr93")), i.b && !isFinite(i.b) && (i.b = i.a);
    function o(c) {
      var u = i.to_meter || 1;
      return c * u;
    }
    var l = function(c) {
      return G1(i, c);
    }, h = [
      ["standard_parallel_1", "Standard_Parallel_1"],
      ["standard_parallel_1", "Latitude of 1st standard parallel"],
      ["standard_parallel_2", "Standard_Parallel_2"],
      ["standard_parallel_2", "Latitude of 2nd standard parallel"],
      ["false_easting", "False_Easting"],
      ["false_easting", "False easting"],
      ["false-easting", "Easting at false origin"],
      ["false_northing", "False_Northing"],
      ["false_northing", "False northing"],
      ["false_northing", "Northing at false origin"],
      ["central_meridian", "Central_Meridian"],
      ["central_meridian", "Longitude of natural origin"],
      ["central_meridian", "Longitude of false origin"],
      ["latitude_of_origin", "Latitude_Of_Origin"],
      ["latitude_of_origin", "Central_Parallel"],
      ["latitude_of_origin", "Latitude of natural origin"],
      ["latitude_of_origin", "Latitude of false origin"],
      ["scale_factor", "Scale_Factor"],
      ["k0", "scale_factor"],
      ["latitude_of_center", "Latitude_Of_Center"],
      ["latitude_of_center", "Latitude_of_center"],
      ["lat0", "latitude_of_center", ei],
      ["longitude_of_center", "Longitude_Of_Center"],
      ["longitude_of_center", "Longitude_of_center"],
      ["longc", "longitude_of_center", ei],
      ["x0", "false_easting", o],
      ["y0", "false_northing", o],
      ["long0", "central_meridian", ei],
      ["lat0", "latitude_of_origin", ei],
      ["lat0", "standard_parallel_1", ei],
      ["lat1", "standard_parallel_1", ei],
      ["lat2", "standard_parallel_2", ei],
      ["azimuth", "Azimuth"],
      ["alpha", "azimuth", ei],
      ["srsCode", "name"]
    ];
    h.forEach(l), !i.long0 && i.longc && (i.projName === "Albers_Conic_Equal_Area" || i.projName === "Lambert_Azimuthal_Equal_Area") && (i.long0 = i.longc), !i.lat_ts && i.lat1 && (i.projName === "Stereographic_South_Pole" || i.projName === "Polar Stereographic (variant B)") ? (i.lat0 = ei(i.lat1 > 0 ? 90 : -90), i.lat_ts = i.lat1) : !i.lat_ts && i.lat0 && i.projName === "Polar_Stereographic" && (i.lat_ts = i.lat0, i.lat0 = ei(i.lat0 > 0 ? 90 : -90));
  }
  function Gf(i) {
    var t = F1(i), e = t[0], n = {};
    return ds(t, n), kf(n), n[e];
  }
  function fe(i) {
    var t = this;
    if (arguments.length === 2) {
      var e = arguments[1];
      typeof e == "string" ? e.charAt(0) === "+" ? fe[i] = Ul(arguments[1]) : fe[i] = Gf(arguments[1]) : fe[i] = e;
    } else if (arguments.length === 1) {
      if (Array.isArray(i))
        return i.map(function(n) {
          Array.isArray(n) ? fe.apply(t, n) : fe(n);
        });
      if (typeof i == "string") {
        if (i in fe)
          return fe[i];
      } else "EPSG" in i ? fe["EPSG:" + i.EPSG] = i : "ESRI" in i ? fe["ESRI:" + i.ESRI] = i : "IAU2000" in i ? fe["IAU2000:" + i.IAU2000] = i : console.log(i);
      return;
    }
  }
  C1(fe);
  function $1(i) {
    return typeof i == "string";
  }
  function U1(i) {
    return i in fe;
  }
  var B1 = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
  function W1(i) {
    return B1.some(function(t) {
      return i.indexOf(t) > -1;
    });
  }
  var X1 = ["3857", "900913", "3785", "102113"];
  function Y1(i) {
    var t = nn(i, "authority");
    if (t) {
      var e = nn(t, "epsg");
      return e && X1.indexOf(e) > -1;
    }
  }
  function Z1(i) {
    var t = nn(i, "extension");
    if (t)
      return nn(t, "proj4");
  }
  function q1(i) {
    return i[0] === "+";
  }
  function K1(i) {
    if ($1(i)) {
      if (U1(i))
        return fe[i];
      if (W1(i)) {
        var t = Gf(i);
        if (Y1(t))
          return fe["EPSG:3857"];
        var e = Z1(t);
        return e ? Ul(e) : t;
      }
      if (q1(i))
        return Ul(i);
    } else
      return i;
  }
  function Gu(i, t) {
    i = i || {};
    var e, n;
    if (!t)
      return i;
    for (n in t)
      e = t[n], e !== void 0 && (i[n] = e);
    return i;
  }
  function li(i, t, e) {
    var n = i * t;
    return e / Math.sqrt(1 - n * n);
  }
  function Hr(i) {
    return i < 0 ? -1 : 1;
  }
  function W(i) {
    return Math.abs(i) <= Qt ? i : i - Hr(i) * Lr;
  }
  function He(i, t, e) {
    var n = i * e, s = 0.5 * i;
    return n = Math.pow((1 - n) / (1 + n), s), Math.tan(0.5 * (N - t)) / n;
  }
  function Nr(i, t) {
    for (var e = 0.5 * i, n, s, r = N - 2 * Math.atan(t), a = 0; a <= 15; a++)
      if (n = i * Math.sin(r), s = N - 2 * Math.atan(t * Math.pow((1 - n) / (1 + n), e)) - r, r += s, Math.abs(s) <= 1e-10)
        return r;
    return -9999;
  }
  function V1() {
    var i = this.b / this.a;
    this.es = 1 - i * i, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = li(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
  }
  function j1(i) {
    var t = i.x, e = i.y;
    if (e * ri > 90 && e * ri < -90 && t * ri > 180 && t * ri < -180)
      return null;
    var n, s;
    if (Math.abs(Math.abs(e) - N) <= B)
      return null;
    if (this.sphere)
      n = this.x0 + this.a * this.k0 * W(t - this.long0), s = this.y0 + this.a * this.k0 * Math.log(Math.tan(Rt + 0.5 * e));
    else {
      var r = Math.sin(e), a = He(this.e, e, r);
      n = this.x0 + this.a * this.k0 * W(t - this.long0), s = this.y0 - this.a * this.k0 * Math.log(a);
    }
    return i.x = n, i.y = s, i;
  }
  function H1(i) {
    var t = i.x - this.x0, e = i.y - this.y0, n, s;
    if (this.sphere)
      s = N - 2 * Math.atan(Math.exp(-e / (this.a * this.k0)));
    else {
      var r = Math.exp(-e / (this.a * this.k0));
      if (s = Nr(this.e, r), s === -9999)
        return null;
    }
    return n = W(this.long0 + t / (this.a * this.k0)), i.x = n, i.y = s, i;
  }
  var J1 = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
  const Q1 = {
    init: V1,
    forward: j1,
    inverse: H1,
    names: J1
  };
  function tv() {
  }
  function zu(i) {
    return i;
  }
  var ev = ["longlat", "identity"];
  const iv = {
    init: tv,
    forward: zu,
    inverse: zu,
    names: ev
  };
  var nv = [Q1, iv], Pa = {}, eo = [];
  function zf(i, t) {
    var e = eo.length;
    return i.names ? (eo[e] = i, i.names.forEach(function(n) {
      Pa[n.toLowerCase()] = e;
    }), this) : (console.log(t), !0);
  }
  function sv(i) {
    if (!i)
      return !1;
    var t = i.toLowerCase();
    if (typeof Pa[t] < "u" && eo[Pa[t]])
      return eo[Pa[t]];
  }
  function rv() {
    nv.forEach(zf);
  }
  const av = {
    start: rv,
    add: zf,
    get: sv
  };
  var nt = {};
  nt.MERIT = {
    a: 6378137,
    rf: 298.257,
    ellipseName: "MERIT 1983"
  };
  nt.SGS85 = {
    a: 6378136,
    rf: 298.257,
    ellipseName: "Soviet Geodetic System 85"
  };
  nt.GRS80 = {
    a: 6378137,
    rf: 298.257222101,
    ellipseName: "GRS 1980(IUGG, 1980)"
  };
  nt.IAU76 = {
    a: 6378140,
    rf: 298.257,
    ellipseName: "IAU 1976"
  };
  nt.airy = {
    a: 6377563396e-3,
    b: 635625691e-2,
    ellipseName: "Airy 1830"
  };
  nt.APL4 = {
    a: 6378137,
    rf: 298.25,
    ellipseName: "Appl. Physics. 1965"
  };
  nt.NWL9D = {
    a: 6378145,
    rf: 298.25,
    ellipseName: "Naval Weapons Lab., 1965"
  };
  nt.mod_airy = {
    a: 6377340189e-3,
    b: 6356034446e-3,
    ellipseName: "Modified Airy"
  };
  nt.andrae = {
    a: 637710443e-2,
    rf: 300,
    ellipseName: "Andrae 1876 (Den., Iclnd.)"
  };
  nt.aust_SA = {
    a: 6378160,
    rf: 298.25,
    ellipseName: "Australian Natl & S. Amer. 1969"
  };
  nt.GRS67 = {
    a: 6378160,
    rf: 298.247167427,
    ellipseName: "GRS 67(IUGG 1967)"
  };
  nt.bessel = {
    a: 6377397155e-3,
    rf: 299.1528128,
    ellipseName: "Bessel 1841"
  };
  nt.bess_nam = {
    a: 6377483865e-3,
    rf: 299.1528128,
    ellipseName: "Bessel 1841 (Namibia)"
  };
  nt.clrk66 = {
    a: 63782064e-1,
    b: 63565838e-1,
    ellipseName: "Clarke 1866"
  };
  nt.clrk80 = {
    a: 6378249145e-3,
    rf: 293.4663,
    ellipseName: "Clarke 1880 mod."
  };
  nt.clrk80ign = {
    a: 63782492e-1,
    b: 6356515,
    rf: 293.4660213,
    ellipseName: "Clarke 1880 (IGN)"
  };
  nt.clrk58 = {
    a: 6378293645208759e-9,
    rf: 294.2606763692654,
    ellipseName: "Clarke 1858"
  };
  nt.CPM = {
    a: 63757387e-1,
    rf: 334.29,
    ellipseName: "Comm. des Poids et Mesures 1799"
  };
  nt.delmbr = {
    a: 6376428,
    rf: 311.5,
    ellipseName: "Delambre 1810 (Belgium)"
  };
  nt.engelis = {
    a: 637813605e-2,
    rf: 298.2566,
    ellipseName: "Engelis 1985"
  };
  nt.evrst30 = {
    a: 6377276345e-3,
    rf: 300.8017,
    ellipseName: "Everest 1830"
  };
  nt.evrst48 = {
    a: 6377304063e-3,
    rf: 300.8017,
    ellipseName: "Everest 1948"
  };
  nt.evrst56 = {
    a: 6377301243e-3,
    rf: 300.8017,
    ellipseName: "Everest 1956"
  };
  nt.evrst69 = {
    a: 6377295664e-3,
    rf: 300.8017,
    ellipseName: "Everest 1969"
  };
  nt.evrstSS = {
    a: 6377298556e-3,
    rf: 300.8017,
    ellipseName: "Everest (Sabah & Sarawak)"
  };
  nt.fschr60 = {
    a: 6378166,
    rf: 298.3,
    ellipseName: "Fischer (Mercury Datum) 1960"
  };
  nt.fschr60m = {
    a: 6378155,
    rf: 298.3,
    ellipseName: "Fischer 1960"
  };
  nt.fschr68 = {
    a: 6378150,
    rf: 298.3,
    ellipseName: "Fischer 1968"
  };
  nt.helmert = {
    a: 6378200,
    rf: 298.3,
    ellipseName: "Helmert 1906"
  };
  nt.hough = {
    a: 6378270,
    rf: 297,
    ellipseName: "Hough"
  };
  nt.intl = {
    a: 6378388,
    rf: 297,
    ellipseName: "International 1909 (Hayford)"
  };
  nt.kaula = {
    a: 6378163,
    rf: 298.24,
    ellipseName: "Kaula 1961"
  };
  nt.lerch = {
    a: 6378139,
    rf: 298.257,
    ellipseName: "Lerch 1979"
  };
  nt.mprts = {
    a: 6397300,
    rf: 191,
    ellipseName: "Maupertius 1738"
  };
  nt.new_intl = {
    a: 63781575e-1,
    b: 63567722e-1,
    ellipseName: "New International 1967"
  };
  nt.plessis = {
    a: 6376523,
    rf: 6355863,
    ellipseName: "Plessis 1817 (France)"
  };
  nt.krass = {
    a: 6378245,
    rf: 298.3,
    ellipseName: "Krassovsky, 1942"
  };
  nt.SEasia = {
    a: 6378155,
    b: 63567733205e-4,
    ellipseName: "Southeast Asia"
  };
  nt.walbeck = {
    a: 6376896,
    b: 63558348467e-4,
    ellipseName: "Walbeck"
  };
  nt.WGS60 = {
    a: 6378165,
    rf: 298.3,
    ellipseName: "WGS 60"
  };
  nt.WGS66 = {
    a: 6378145,
    rf: 298.25,
    ellipseName: "WGS 66"
  };
  nt.WGS7 = {
    a: 6378135,
    rf: 298.26,
    ellipseName: "WGS 72"
  };
  var ov = nt.WGS84 = {
    a: 6378137,
    rf: 298.257223563,
    ellipseName: "WGS 84"
  };
  nt.sphere = {
    a: 6370997,
    b: 6370997,
    ellipseName: "Normal Sphere (r=6370997)"
  };
  function lv(i, t, e, n) {
    var s = i * i, r = t * t, a = (s - r) / s, o = 0;
    n ? (i *= 1 - a * (T1 + a * (A1 + a * b1)), s = i * i, a = 0) : o = Math.sqrt(a);
    var l = (s - r) / r;
    return {
      es: a,
      e: o,
      ep2: l
    };
  }
  function hv(i, t, e, n, s) {
    if (!i) {
      var r = nn(nt, n);
      r || (r = ov), i = r.a, t = r.b, e = r.rf;
    }
    return e && !t && (t = (1 - 1 / e) * i), (e === 0 || Math.abs(i - t) < B) && (s = !0, t = i), {
      a: i,
      b: t,
      rf: e,
      sphere: s
    };
  }
  var La = {
    wgs84: {
      towgs84: "0,0,0",
      ellipse: "WGS84",
      datumName: "WGS84"
    },
    ch1903: {
      towgs84: "674.374,15.056,405.346",
      ellipse: "bessel",
      datumName: "swiss"
    },
    ggrs87: {
      towgs84: "-199.87,74.79,246.62",
      ellipse: "GRS80",
      datumName: "Greek_Geodetic_Reference_System_1987"
    },
    nad83: {
      towgs84: "0,0,0",
      ellipse: "GRS80",
      datumName: "North_American_Datum_1983"
    },
    nad27: {
      nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
      ellipse: "clrk66",
      datumName: "North_American_Datum_1927"
    },
    potsdam: {
      towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
      ellipse: "bessel",
      datumName: "Potsdam Rauenberg 1950 DHDN"
    },
    carthage: {
      towgs84: "-263.0,6.0,431.0",
      ellipse: "clark80",
      datumName: "Carthage 1934 Tunisia"
    },
    hermannskogel: {
      towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
      ellipse: "bessel",
      datumName: "Hermannskogel"
    },
    mgi: {
      towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
      ellipse: "bessel",
      datumName: "Militar-Geographische Institut"
    },
    osni52: {
      towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
      ellipse: "airy",
      datumName: "Irish National"
    },
    ire65: {
      towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
      ellipse: "mod_airy",
      datumName: "Ireland 1965"
    },
    rassadiran: {
      towgs84: "-133.63,-157.5,-158.62",
      ellipse: "intl",
      datumName: "Rassadiran"
    },
    nzgd49: {
      towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
      ellipse: "intl",
      datumName: "New Zealand Geodetic Datum 1949"
    },
    osgb36: {
      towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
      ellipse: "airy",
      datumName: "Ordnance Survey of Great Britain 1936"
    },
    s_jtsk: {
      towgs84: "589,76,480",
      ellipse: "bessel",
      datumName: "S-JTSK (Ferro)"
    },
    beduaram: {
      towgs84: "-106,-87,188",
      ellipse: "clrk80",
      datumName: "Beduaram"
    },
    gunung_segara: {
      towgs84: "-403,684,41",
      ellipse: "bessel",
      datumName: "Gunung Segara Jakarta"
    },
    rnb72: {
      towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
      ellipse: "intl",
      datumName: "Reseau National Belge 1972"
    }
  };
  for (var cv in La) {
    var $u = La[cv];
    La[$u.datumName] = $u;
  }
  function uv(i, t, e, n, s, r, a) {
    var o = {};
    return i === void 0 || i === "none" ? o.datum_type = $l : o.datum_type = R1, t && (o.datum_params = t.map(parseFloat), (o.datum_params[0] !== 0 || o.datum_params[1] !== 0 || o.datum_params[2] !== 0) && (o.datum_type = $n), o.datum_params.length > 3 && (o.datum_params[3] !== 0 || o.datum_params[4] !== 0 || o.datum_params[5] !== 0 || o.datum_params[6] !== 0) && (o.datum_type = Un, o.datum_params[3] *= fr, o.datum_params[4] *= fr, o.datum_params[5] *= fr, o.datum_params[6] = o.datum_params[6] / 1e6 + 1)), a && (o.datum_type = xs, o.grids = a), o.a = e, o.b = n, o.es = s, o.ep2 = r, o;
  }
  var $f = {};
  function dv(i, t) {
    var e = new DataView(t), n = mv(e), s = _v(e, n), r = pv(e, s, n), a = { header: s, subgrids: r };
    return $f[i] = a, a;
  }
  function fv(i) {
    if (i === void 0)
      return null;
    var t = i.split(",");
    return t.map(gv);
  }
  function gv(i) {
    if (i.length === 0)
      return null;
    var t = i[0] === "@";
    return t && (i = i.slice(1)), i === "null" ? { name: "null", mandatory: !t, grid: null, isNull: !0 } : {
      name: i,
      mandatory: !t,
      grid: $f[i] || null,
      isNull: !1
    };
  }
  function fs(i) {
    return i / 3600 * Math.PI / 180;
  }
  function mv(i) {
    var t = i.getInt32(8, !1);
    return t === 11 ? !1 : (t = i.getInt32(8, !0), t !== 11 && console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian"), !0);
  }
  function _v(i, t) {
    return {
      nFields: i.getInt32(8, t),
      nSubgridFields: i.getInt32(24, t),
      nSubgrids: i.getInt32(40, t),
      shiftType: Bl(i, 56, 64).trim(),
      fromSemiMajorAxis: i.getFloat64(120, t),
      fromSemiMinorAxis: i.getFloat64(136, t),
      toSemiMajorAxis: i.getFloat64(152, t),
      toSemiMinorAxis: i.getFloat64(168, t)
    };
  }
  function Bl(i, t, e) {
    return String.fromCharCode.apply(null, new Uint8Array(i.buffer.slice(t, e)));
  }
  function pv(i, t, e) {
    for (var n = 176, s = [], r = 0; r < t.nSubgrids; r++) {
      var a = vv(i, n, e), o = Ev(i, n, a, e), l = Math.round(
        1 + (a.upperLongitude - a.lowerLongitude) / a.longitudeInterval
      ), h = Math.round(
        1 + (a.upperLatitude - a.lowerLatitude) / a.latitudeInterval
      );
      s.push({
        ll: [fs(a.lowerLongitude), fs(a.lowerLatitude)],
        del: [fs(a.longitudeInterval), fs(a.latitudeInterval)],
        lim: [l, h],
        count: a.gridNodeCount,
        cvs: yv(o)
      }), n += 176 + a.gridNodeCount * 16;
    }
    return s;
  }
  function yv(i) {
    return i.map(function(t) {
      return [fs(t.longitudeShift), fs(t.latitudeShift)];
    });
  }
  function vv(i, t, e) {
    return {
      name: Bl(i, t + 8, t + 16).trim(),
      parent: Bl(i, t + 24, t + 24 + 8).trim(),
      lowerLatitude: i.getFloat64(t + 72, e),
      upperLatitude: i.getFloat64(t + 88, e),
      lowerLongitude: i.getFloat64(t + 104, e),
      upperLongitude: i.getFloat64(t + 120, e),
      latitudeInterval: i.getFloat64(t + 136, e),
      longitudeInterval: i.getFloat64(t + 152, e),
      gridNodeCount: i.getInt32(t + 168, e)
    };
  }
  function Ev(i, t, e, n) {
    for (var s = t + 176, r = 16, a = [], o = 0; o < e.gridNodeCount; o++) {
      var l = {
        latitudeShift: i.getFloat32(s + o * r, n),
        longitudeShift: i.getFloat32(s + o * r + 4, n),
        latitudeAccuracy: i.getFloat32(s + o * r + 8, n),
        longitudeAccuracy: i.getFloat32(s + o * r + 12, n)
      };
      a.push(l);
    }
    return a;
  }
  function ai(i, t) {
    if (!(this instanceof ai))
      return new ai(i);
    t = t || function(h) {
      if (h)
        throw h;
    };
    var e = K1(i);
    if (typeof e != "object") {
      t("Could not parse to valid json: " + i);
      return;
    }
    var n = ai.projections.get(e.projName);
    if (!n) {
      t("Could not get projection name from: " + i);
      return;
    }
    if (e.datumCode && e.datumCode !== "none") {
      var s = nn(La, e.datumCode);
      s && (e.datum_params = e.datum_params || (s.towgs84 ? s.towgs84.split(",") : null), e.ellps = s.ellipse, e.datumName = s.datumName ? s.datumName : e.datumCode);
    }
    e.k0 = e.k0 || 1, e.axis = e.axis || "enu", e.ellps = e.ellps || "wgs84", e.lat1 = e.lat1 || e.lat0;
    var r = hv(e.a, e.b, e.rf, e.ellps, e.sphere), a = lv(r.a, r.b, r.rf, e.R_A), o = fv(e.nadgrids), l = e.datum || uv(
      e.datumCode,
      e.datum_params,
      r.a,
      r.b,
      a.es,
      a.ep2,
      o
    );
    Gu(this, e), Gu(this, n), this.a = r.a, this.b = r.b, this.rf = r.rf, this.sphere = r.sphere, this.es = a.es, this.e = a.e, this.ep2 = a.ep2, this.datum = l, this.init(), t(null, this);
  }
  ai.projections = av;
  ai.projections.start();
  function Mv(i, t) {
    return i.datum_type !== t.datum_type || i.a !== t.a || Math.abs(i.es - t.es) > 5e-11 ? !1 : i.datum_type === $n ? i.datum_params[0] === t.datum_params[0] && i.datum_params[1] === t.datum_params[1] && i.datum_params[2] === t.datum_params[2] : i.datum_type === Un ? i.datum_params[0] === t.datum_params[0] && i.datum_params[1] === t.datum_params[1] && i.datum_params[2] === t.datum_params[2] && i.datum_params[3] === t.datum_params[3] && i.datum_params[4] === t.datum_params[4] && i.datum_params[5] === t.datum_params[5] && i.datum_params[6] === t.datum_params[6] : !0;
  }
  function Uf(i, t, e) {
    var n = i.x, s = i.y, r = i.z ? i.z : 0, a, o, l, h;
    if (s < -N && s > -1.001 * N)
      s = -N;
    else if (s > N && s < 1.001 * N)
      s = N;
    else {
      if (s < -N)
        return { x: -1 / 0, y: -1 / 0, z: i.z };
      if (s > N)
        return { x: 1 / 0, y: 1 / 0, z: i.z };
    }
    return n > Math.PI && (n -= 2 * Math.PI), o = Math.sin(s), h = Math.cos(s), l = o * o, a = e / Math.sqrt(1 - t * l), {
      x: (a + r) * h * Math.cos(n),
      y: (a + r) * h * Math.sin(n),
      z: (a * (1 - t) + r) * o
    };
  }
  function Bf(i, t, e, n) {
    var s = 1e-12, r = s * s, a = 30, o, l, h, c, u, d, g, _, y, E, M, w, R, S = i.x, C = i.y, T = i.z ? i.z : 0, L, A, O;
    if (o = Math.sqrt(S * S + C * C), l = Math.sqrt(S * S + C * C + T * T), o / e < s) {
      if (L = 0, l / e < s)
        return A = N, O = -n, {
          x: i.x,
          y: i.y,
          z: i.z
        };
    } else
      L = Math.atan2(C, S);
    h = T / l, c = o / l, u = 1 / Math.sqrt(1 - t * (2 - t) * c * c), _ = c * (1 - t) * u, y = h * u, R = 0;
    do
      R++, g = e / Math.sqrt(1 - t * y * y), O = o * _ + T * y - g * (1 - t * y * y), d = t * g / (g + O), u = 1 / Math.sqrt(1 - d * (2 - d) * c * c), E = c * (1 - d) * u, M = h * u, w = M * _ - E * y, _ = E, y = M;
    while (w * w > r && R < a);
    return A = Math.atan(M / Math.abs(E)), {
      x: L,
      y: A,
      z: O
    };
  }
  function xv(i, t, e) {
    if (t === $n)
      return {
        x: i.x + e[0],
        y: i.y + e[1],
        z: i.z + e[2]
      };
    if (t === Un) {
      var n = e[0], s = e[1], r = e[2], a = e[3], o = e[4], l = e[5], h = e[6];
      return {
        x: h * (i.x - l * i.y + o * i.z) + n,
        y: h * (l * i.x + i.y - a * i.z) + s,
        z: h * (-o * i.x + a * i.y + i.z) + r
      };
    }
  }
  function wv(i, t, e) {
    if (t === $n)
      return {
        x: i.x - e[0],
        y: i.y - e[1],
        z: i.z - e[2]
      };
    if (t === Un) {
      var n = e[0], s = e[1], r = e[2], a = e[3], o = e[4], l = e[5], h = e[6], c = (i.x - n) / h, u = (i.y - s) / h, d = (i.z - r) / h;
      return {
        x: c + l * u - o * d,
        y: -l * c + u + a * d,
        z: o * c - a * u + d
      };
    }
  }
  function Ca(i) {
    return i === $n || i === Un;
  }
  function Sv(i, t, e) {
    if (Mv(i, t) || i.datum_type === $l || t.datum_type === $l)
      return e;
    var n = i.a, s = i.es;
    if (i.datum_type === xs) {
      var r = Uu(i, !1, e);
      if (r !== 0)
        return;
      n = Fu, s = Du;
    }
    var a = t.a, o = t.b, l = t.es;
    if (t.datum_type === xs && (a = Fu, o = I1, l = Du), s === l && n === a && !Ca(i.datum_type) && !Ca(t.datum_type))
      return e;
    if (e = Uf(e, s, n), Ca(i.datum_type) && (e = xv(e, i.datum_type, i.datum_params)), Ca(t.datum_type) && (e = wv(e, t.datum_type, t.datum_params)), e = Bf(e, l, a, o), t.datum_type === xs) {
      var h = Uu(t, !0, e);
      if (h !== 0)
        return;
    }
    return e;
  }
  function Uu(i, t, e) {
    if (i.grids === null || i.grids.length === 0)
      return console.log("Grid shift grids not found"), -1;
    var n = { x: -e.x, y: e.y }, s = { x: Number.NaN, y: Number.NaN }, r = [];
    t:
      for (var a = 0; a < i.grids.length; a++) {
        var o = i.grids[a];
        if (r.push(o.name), o.isNull) {
          s = n;
          break;
        }
        if (o.mandatory, o.grid === null) {
          if (o.mandatory)
            return console.log("Unable to find mandatory grid '" + o.name + "'"), -1;
          continue;
        }
        for (var l = o.grid.subgrids, h = 0, c = l.length; h < c; h++) {
          var u = l[h], d = (Math.abs(u.del[1]) + Math.abs(u.del[0])) / 1e4, g = u.ll[0] - d, _ = u.ll[1] - d, y = u.ll[0] + (u.lim[0] - 1) * u.del[0] + d, E = u.ll[1] + (u.lim[1] - 1) * u.del[1] + d;
          if (!(_ > n.y || g > n.x || E < n.y || y < n.x) && (s = Cv(n, t, u), !isNaN(s.x)))
            break t;
        }
      }
    return isNaN(s.x) ? (console.log("Failed to find a grid shift table for location '" + -n.x * ri + " " + n.y * ri + " tried: '" + r + "'"), -1) : (e.x = -s.x, e.y = s.y, 0);
  }
  function Cv(i, t, e) {
    var n = { x: Number.NaN, y: Number.NaN };
    if (isNaN(i.x))
      return n;
    var s = { x: i.x, y: i.y };
    s.x -= e.ll[0], s.y -= e.ll[1], s.x = W(s.x - Math.PI) + Math.PI;
    var r = Bu(s, e);
    if (t) {
      if (isNaN(r.x))
        return n;
      r.x = s.x - r.x, r.y = s.y - r.y;
      var a = 9, o = 1e-12, l, h;
      do {
        if (h = Bu(r, e), isNaN(h.x)) {
          console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
          break;
        }
        l = { x: s.x - (h.x + r.x), y: s.y - (h.y + r.y) }, r.x += l.x, r.y += l.y;
      } while (a-- && Math.abs(l.x) > o && Math.abs(l.y) > o);
      if (a < 0)
        return console.log("Inverse grid shift iterator failed to converge."), n;
      n.x = W(r.x + e.ll[0]), n.y = r.y + e.ll[1];
    } else
      isNaN(r.x) || (n.x = i.x + r.x, n.y = i.y + r.y);
    return n;
  }
  function Bu(i, t) {
    var e = { x: i.x / t.del[0], y: i.y / t.del[1] }, n = { x: Math.floor(e.x), y: Math.floor(e.y) }, s = { x: e.x - 1 * n.x, y: e.y - 1 * n.y }, r = { x: Number.NaN, y: Number.NaN }, a;
    if (n.x < 0 || n.x >= t.lim[0] || n.y < 0 || n.y >= t.lim[1])
      return r;
    a = n.y * t.lim[0] + n.x;
    var o = { x: t.cvs[a][0], y: t.cvs[a][1] };
    a++;
    var l = { x: t.cvs[a][0], y: t.cvs[a][1] };
    a += t.lim[0];
    var h = { x: t.cvs[a][0], y: t.cvs[a][1] };
    a--;
    var c = { x: t.cvs[a][0], y: t.cvs[a][1] }, u = s.x * s.y, d = s.x * (1 - s.y), g = (1 - s.x) * (1 - s.y), _ = (1 - s.x) * s.y;
    return r.x = g * o.x + d * l.x + _ * c.x + u * h.x, r.y = g * o.y + d * l.y + _ * c.y + u * h.y, r;
  }
  function Wu(i, t, e) {
    var n = e.x, s = e.y, r = e.z || 0, a, o, l, h = {};
    for (l = 0; l < 3; l++)
      if (!(t && l === 2 && e.z === void 0))
        switch (l === 0 ? (a = n, "ew".indexOf(i.axis[l]) !== -1 ? o = "x" : o = "y") : l === 1 ? (a = s, "ns".indexOf(i.axis[l]) !== -1 ? o = "y" : o = "x") : (a = r, o = "z"), i.axis[l]) {
          case "e":
            h[o] = a;
            break;
          case "w":
            h[o] = -a;
            break;
          case "n":
            h[o] = a;
            break;
          case "s":
            h[o] = -a;
            break;
          case "u":
            e[o] !== void 0 && (h.z = a);
            break;
          case "d":
            e[o] !== void 0 && (h.z = -a);
            break;
          default:
            return null;
        }
    return h;
  }
  function Wf(i) {
    var t = {
      x: i[0],
      y: i[1]
    };
    return i.length > 2 && (t.z = i[2]), i.length > 3 && (t.m = i[3]), t;
  }
  function Rv(i) {
    Xu(i.x), Xu(i.y);
  }
  function Xu(i) {
    if (typeof Number.isFinite == "function") {
      if (Number.isFinite(i))
        return;
      throw new TypeError("coordinates must be finite numbers");
    }
    if (typeof i != "number" || i !== i || !isFinite(i))
      throw new TypeError("coordinates must be finite numbers");
  }
  function Iv(i, t) {
    return (i.datum.datum_type === $n || i.datum.datum_type === Un || i.datum.datum_type === xs) && t.datumCode !== "WGS84" || (t.datum.datum_type === $n || t.datum.datum_type === Un || t.datum.datum_type === xs) && i.datumCode !== "WGS84";
  }
  function io(i, t, e, n) {
    var s;
    Array.isArray(e) ? e = Wf(e) : e = {
      x: e.x,
      y: e.y,
      z: e.z,
      m: e.m
    };
    var r = e.z !== void 0;
    if (Rv(e), i.datum && t.datum && Iv(i, t) && (s = new ai("WGS84"), e = io(i, s, e, n), i = s), n && i.axis !== "enu" && (e = Wu(i, !1, e)), i.projName === "longlat")
      e = {
        x: e.x * Jt,
        y: e.y * Jt,
        z: e.z || 0
      };
    else if (i.to_meter && (e = {
      x: e.x * i.to_meter,
      y: e.y * i.to_meter,
      z: e.z || 0
    }), e = i.inverse(e), !e)
      return;
    if (i.from_greenwich && (e.x += i.from_greenwich), e = Sv(i.datum, t.datum, e), !!e)
      return t.from_greenwich && (e = {
        x: e.x - t.from_greenwich,
        y: e.y,
        z: e.z || 0
      }), t.projName === "longlat" ? e = {
        x: e.x * ri,
        y: e.y * ri,
        z: e.z || 0
      } : (e = t.forward(e), t.to_meter && (e = {
        x: e.x / t.to_meter,
        y: e.y / t.to_meter,
        z: e.z || 0
      })), n && t.axis !== "enu" ? Wu(t, !0, e) : (e && !r && delete e.z, e);
  }
  var Yu = ai("WGS84");
  function _l(i, t, e, n) {
    var s, r, a;
    return Array.isArray(e) ? (s = io(i, t, e, n) || { x: NaN, y: NaN }, e.length > 2 ? typeof i.name < "u" && i.name === "geocent" || typeof t.name < "u" && t.name === "geocent" ? typeof s.z == "number" ? [s.x, s.y, s.z].concat(e.slice(3)) : [s.x, s.y, e[2]].concat(e.slice(3)) : [s.x, s.y].concat(e.slice(2)) : [s.x, s.y]) : (r = io(i, t, e, n), a = Object.keys(e), a.length === 2 || a.forEach(function(o) {
      if (typeof i.name < "u" && i.name === "geocent" || typeof t.name < "u" && t.name === "geocent") {
        if (o === "x" || o === "y" || o === "z")
          return;
      } else if (o === "x" || o === "y")
        return;
      r[o] = e[o];
    }), r);
  }
  function Zu(i) {
    return i instanceof ai ? i : i.oProj ? i.oProj : ai(i);
  }
  function ue(i, t, e) {
    i = Zu(i);
    var n = !1, s;
    return typeof t > "u" ? (t = i, i = Yu, n = !0) : (typeof t.x < "u" || Array.isArray(t)) && (e = t, t = i, i = Yu, n = !0), t = Zu(t), e ? _l(i, t, e) : (s = {
      forward: function(r, a) {
        return _l(i, t, r, a);
      },
      inverse: function(r, a) {
        return _l(t, i, r, a);
      }
    }, n && (s.oProj = t), s);
  }
  var qu = 6, Xf = "AJSAJS", Yf = "AFAFAF", gs = 65, ve = 73, De = 79, ar = 86, or = 90;
  const Tv = {
    forward: Zf,
    inverse: Av,
    toPoint: qf
  };
  function Zf(i, t) {
    return t = t || 5, Lv(bv({
      lat: i[1],
      lon: i[0]
    }), t);
  }
  function Av(i) {
    var t = jh(Vf(i.toUpperCase()));
    return t.lat && t.lon ? [t.lon, t.lat, t.lon, t.lat] : [t.left, t.bottom, t.right, t.top];
  }
  function qf(i) {
    var t = jh(Vf(i.toUpperCase()));
    return t.lat && t.lon ? [t.lon, t.lat] : [(t.left + t.right) / 2, (t.top + t.bottom) / 2];
  }
  function pl(i) {
    return i * (Math.PI / 180);
  }
  function Ku(i) {
    return 180 * (i / Math.PI);
  }
  function bv(i) {
    var t = i.lat, e = i.lon, n = 6378137, s = 669438e-8, r = 0.9996, a, o, l, h, c, u, d, g = pl(t), _ = pl(e), y, E;
    E = Math.floor((e + 180) / 6) + 1, e === 180 && (E = 60), t >= 56 && t < 64 && e >= 3 && e < 12 && (E = 32), t >= 72 && t < 84 && (e >= 0 && e < 9 ? E = 31 : e >= 9 && e < 21 ? E = 33 : e >= 21 && e < 33 ? E = 35 : e >= 33 && e < 42 && (E = 37)), a = (E - 1) * 6 - 180 + 3, y = pl(a), o = s / (1 - s), l = n / Math.sqrt(1 - s * Math.sin(g) * Math.sin(g)), h = Math.tan(g) * Math.tan(g), c = o * Math.cos(g) * Math.cos(g), u = Math.cos(g) * (_ - y), d = n * ((1 - s / 4 - 3 * s * s / 64 - 5 * s * s * s / 256) * g - (3 * s / 8 + 3 * s * s / 32 + 45 * s * s * s / 1024) * Math.sin(2 * g) + (15 * s * s / 256 + 45 * s * s * s / 1024) * Math.sin(4 * g) - 35 * s * s * s / 3072 * Math.sin(6 * g));
    var M = r * l * (u + (1 - h + c) * u * u * u / 6 + (5 - 18 * h + h * h + 72 * c - 58 * o) * u * u * u * u * u / 120) + 5e5, w = r * (d + l * Math.tan(g) * (u * u / 2 + (5 - h + 9 * c + 4 * c * c) * u * u * u * u / 24 + (61 - 58 * h + h * h + 600 * c - 330 * o) * u * u * u * u * u * u / 720));
    return t < 0 && (w += 1e7), {
      northing: Math.round(w),
      easting: Math.round(M),
      zoneNumber: E,
      zoneLetter: Pv(t)
    };
  }
  function jh(i) {
    var t = i.northing, e = i.easting, n = i.zoneLetter, s = i.zoneNumber;
    if (s < 0 || s > 60)
      return null;
    var r = 0.9996, a = 6378137, o = 669438e-8, l, h = (1 - Math.sqrt(1 - o)) / (1 + Math.sqrt(1 - o)), c, u, d, g, _, y, E, M, w, R = e - 5e5, S = t;
    n < "N" && (S -= 1e7), E = (s - 1) * 6 - 180 + 3, l = o / (1 - o), y = S / r, M = y / (a * (1 - o / 4 - 3 * o * o / 64 - 5 * o * o * o / 256)), w = M + (3 * h / 2 - 27 * h * h * h / 32) * Math.sin(2 * M) + (21 * h * h / 16 - 55 * h * h * h * h / 32) * Math.sin(4 * M) + 151 * h * h * h / 96 * Math.sin(6 * M), c = a / Math.sqrt(1 - o * Math.sin(w) * Math.sin(w)), u = Math.tan(w) * Math.tan(w), d = l * Math.cos(w) * Math.cos(w), g = a * (1 - o) / Math.pow(1 - o * Math.sin(w) * Math.sin(w), 1.5), _ = R / (c * r);
    var C = w - c * Math.tan(w) / g * (_ * _ / 2 - (5 + 3 * u + 10 * d - 4 * d * d - 9 * l) * _ * _ * _ * _ / 24 + (61 + 90 * u + 298 * d + 45 * u * u - 252 * l - 3 * d * d) * _ * _ * _ * _ * _ * _ / 720);
    C = Ku(C);
    var T = (_ - (1 + 2 * u + d) * _ * _ * _ / 6 + (5 - 2 * d + 28 * u - 3 * d * d + 8 * l + 24 * u * u) * _ * _ * _ * _ * _ / 120) / Math.cos(w);
    T = E + Ku(T);
    var L;
    if (i.accuracy) {
      var A = jh({
        northing: i.northing + i.accuracy,
        easting: i.easting + i.accuracy,
        zoneLetter: i.zoneLetter,
        zoneNumber: i.zoneNumber
      });
      L = {
        top: A.lat,
        right: A.lon,
        bottom: C,
        left: T
      };
    } else
      L = {
        lat: C,
        lon: T
      };
    return L;
  }
  function Pv(i) {
    var t = "Z";
    return 84 >= i && i >= 72 ? t = "X" : 72 > i && i >= 64 ? t = "W" : 64 > i && i >= 56 ? t = "V" : 56 > i && i >= 48 ? t = "U" : 48 > i && i >= 40 ? t = "T" : 40 > i && i >= 32 ? t = "S" : 32 > i && i >= 24 ? t = "R" : 24 > i && i >= 16 ? t = "Q" : 16 > i && i >= 8 ? t = "P" : 8 > i && i >= 0 ? t = "N" : 0 > i && i >= -8 ? t = "M" : -8 > i && i >= -16 ? t = "L" : -16 > i && i >= -24 ? t = "K" : -24 > i && i >= -32 ? t = "J" : -32 > i && i >= -40 ? t = "H" : -40 > i && i >= -48 ? t = "G" : -48 > i && i >= -56 ? t = "F" : -56 > i && i >= -64 ? t = "E" : -64 > i && i >= -72 ? t = "D" : -72 > i && i >= -80 && (t = "C"), t;
  }
  function Lv(i, t) {
    var e = "00000" + i.easting, n = "00000" + i.northing;
    return i.zoneNumber + i.zoneLetter + Ov(i.easting, i.northing, i.zoneNumber) + e.substr(e.length - 5, t) + n.substr(n.length - 5, t);
  }
  function Ov(i, t, e) {
    var n = Kf(e), s = Math.floor(i / 1e5), r = Math.floor(t / 1e5) % 20;
    return Nv(s, r, n);
  }
  function Kf(i) {
    var t = i % qu;
    return t === 0 && (t = qu), t;
  }
  function Nv(i, t, e) {
    var n = e - 1, s = Xf.charCodeAt(n), r = Yf.charCodeAt(n), a = s + i - 1, o = r + t, l = !1;
    a > or && (a = a - or + gs - 1, l = !0), (a === ve || s < ve && a > ve || (a > ve || s < ve) && l) && a++, (a === De || s < De && a > De || (a > De || s < De) && l) && (a++, a === ve && a++), a > or && (a = a - or + gs - 1), o > ar ? (o = o - ar + gs - 1, l = !0) : l = !1, (o === ve || r < ve && o > ve || (o > ve || r < ve) && l) && o++, (o === De || r < De && o > De || (o > De || r < De) && l) && (o++, o === ve && o++), o > ar && (o = o - ar + gs - 1);
    var h = String.fromCharCode(a) + String.fromCharCode(o);
    return h;
  }
  function Vf(i) {
    if (i && i.length === 0)
      throw "MGRSPoint coverting from nothing";
    for (var t = i.length, e = null, n = "", s, r = 0; !/[A-Z]/.test(s = i.charAt(r)); ) {
      if (r >= 2)
        throw "MGRSPoint bad conversion from: " + i;
      n += s, r++;
    }
    var a = parseInt(n, 10);
    if (r === 0 || r + 3 > t)
      throw "MGRSPoint bad conversion from: " + i;
    var o = i.charAt(r++);
    if (o <= "A" || o === "B" || o === "Y" || o >= "Z" || o === "I" || o === "O")
      throw "MGRSPoint zone letter " + o + " not handled: " + i;
    e = i.substring(r, r += 2);
    for (var l = Kf(a), h = Fv(e.charAt(0), l), c = Dv(e.charAt(1), l); c < kv(o); )
      c += 2e6;
    var u = t - r;
    if (u % 2 !== 0)
      throw `MGRSPoint has to have an even number 
of digits after the zone letter and two 100km letters - front 
half for easting meters, second half for 
northing meters` + i;
    var d = u / 2, g = 0, _ = 0, y, E, M, w, R;
    return d > 0 && (y = 1e5 / Math.pow(10, d), E = i.substring(r, r + d), g = parseFloat(E) * y, M = i.substring(r + d), _ = parseFloat(M) * y), w = g + h, R = _ + c, {
      easting: w,
      northing: R,
      zoneLetter: o,
      zoneNumber: a,
      accuracy: y
    };
  }
  function Fv(i, t) {
    for (var e = Xf.charCodeAt(t - 1), n = 1e5, s = !1; e !== i.charCodeAt(0); ) {
      if (e++, e === ve && e++, e === De && e++, e > or) {
        if (s)
          throw "Bad character: " + i;
        e = gs, s = !0;
      }
      n += 1e5;
    }
    return n;
  }
  function Dv(i, t) {
    if (i > "V")
      throw "MGRSPoint given invalid Northing " + i;
    for (var e = Yf.charCodeAt(t - 1), n = 0, s = !1; e !== i.charCodeAt(0); ) {
      if (e++, e === ve && e++, e === De && e++, e > ar) {
        if (s)
          throw "Bad character: " + i;
        e = gs, s = !0;
      }
      n += 1e5;
    }
    return n;
  }
  function kv(i) {
    var t;
    switch (i) {
      case "C":
        t = 11e5;
        break;
      case "D":
        t = 2e6;
        break;
      case "E":
        t = 28e5;
        break;
      case "F":
        t = 37e5;
        break;
      case "G":
        t = 46e5;
        break;
      case "H":
        t = 55e5;
        break;
      case "J":
        t = 64e5;
        break;
      case "K":
        t = 73e5;
        break;
      case "L":
        t = 82e5;
        break;
      case "M":
        t = 91e5;
        break;
      case "N":
        t = 0;
        break;
      case "P":
        t = 8e5;
        break;
      case "Q":
        t = 17e5;
        break;
      case "R":
        t = 26e5;
        break;
      case "S":
        t = 35e5;
        break;
      case "T":
        t = 44e5;
        break;
      case "U":
        t = 53e5;
        break;
      case "V":
        t = 62e5;
        break;
      case "W":
        t = 7e6;
        break;
      case "X":
        t = 79e5;
        break;
      default:
        t = -1;
    }
    if (t >= 0)
      return t;
    throw "Invalid zone letter: " + i;
  }
  function ks(i, t, e) {
    if (!(this instanceof ks))
      return new ks(i, t, e);
    if (Array.isArray(i))
      this.x = i[0], this.y = i[1], this.z = i[2] || 0;
    else if (typeof i == "object")
      this.x = i.x, this.y = i.y, this.z = i.z || 0;
    else if (typeof i == "string" && typeof t > "u") {
      var n = i.split(",");
      this.x = parseFloat(n[0], 10), this.y = parseFloat(n[1], 10), this.z = parseFloat(n[2], 10) || 0;
    } else
      this.x = i, this.y = t, this.z = e || 0;
    console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
  }
  ks.fromMGRS = function(i) {
    return new ks(qf(i));
  };
  ks.prototype.toMGRS = function(i) {
    return Zf([this.x, this.y], i);
  };
  var Gv = 1, zv = 0.25, Vu = 0.046875, ju = 0.01953125, Hu = 0.01068115234375, $v = 0.75, Uv = 0.46875, Bv = 0.013020833333333334, Wv = 0.007120768229166667, Xv = 0.3645833333333333, Yv = 0.005696614583333333, Zv = 0.3076171875;
  function Hh(i) {
    var t = [];
    t[0] = Gv - i * (zv + i * (Vu + i * (ju + i * Hu))), t[1] = i * ($v - i * (Vu + i * (ju + i * Hu)));
    var e = i * i;
    return t[2] = e * (Uv - i * (Bv + i * Wv)), e *= i, t[3] = e * (Xv - i * Yv), t[4] = e * i * Zv, t;
  }
  function Bs(i, t, e, n) {
    return e *= t, t *= t, n[0] * i - e * (n[1] + t * (n[2] + t * (n[3] + t * n[4])));
  }
  var qv = 20;
  function Jh(i, t, e) {
    for (var n = 1 / (1 - t), s = i, r = qv; r; --r) {
      var a = Math.sin(s), o = 1 - t * a * a;
      if (o = (Bs(s, a, Math.cos(s), e) - i) * (o * Math.sqrt(o)) * n, s -= o, Math.abs(o) < B)
        return s;
    }
    return s;
  }
  function Kv() {
    this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.es && (this.en = Hh(this.es), this.ml0 = Bs(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
  }
  function Vv(i) {
    var t = i.x, e = i.y, n = W(t - this.long0), s, r, a, o = Math.sin(e), l = Math.cos(e);
    if (this.es) {
      var c = l * n, u = Math.pow(c, 2), d = this.ep2 * Math.pow(l, 2), g = Math.pow(d, 2), _ = Math.abs(l) > B ? Math.tan(e) : 0, y = Math.pow(_, 2), E = Math.pow(y, 2);
      s = 1 - this.es * Math.pow(o, 2), c = c / Math.sqrt(s);
      var M = Bs(e, o, l, this.en);
      r = this.a * (this.k0 * c * (1 + u / 6 * (1 - y + d + u / 20 * (5 - 18 * y + E + 14 * d - 58 * y * d + u / 42 * (61 + 179 * E - E * y - 479 * y))))) + this.x0, a = this.a * (this.k0 * (M - this.ml0 + o * n * c / 2 * (1 + u / 12 * (5 - y + 9 * d + 4 * g + u / 30 * (61 + E - 58 * y + 270 * d - 330 * y * d + u / 56 * (1385 + 543 * E - E * y - 3111 * y)))))) + this.y0;
    } else {
      var h = l * Math.sin(n);
      if (Math.abs(Math.abs(h) - 1) < B)
        return 93;
      if (r = 0.5 * this.a * this.k0 * Math.log((1 + h) / (1 - h)) + this.x0, a = l * Math.cos(n) / Math.sqrt(1 - Math.pow(h, 2)), h = Math.abs(a), h >= 1) {
        if (h - 1 > B)
          return 93;
        a = 0;
      } else
        a = Math.acos(a);
      e < 0 && (a = -a), a = this.a * this.k0 * (a - this.lat0) + this.y0;
    }
    return i.x = r, i.y = a, i;
  }
  function jv(i) {
    var t, e, n, s, r = (i.x - this.x0) * (1 / this.a), a = (i.y - this.y0) * (1 / this.a);
    if (this.es)
      if (t = this.ml0 + a / this.k0, e = Jh(t, this.es, this.en), Math.abs(e) < N) {
        var u = Math.sin(e), d = Math.cos(e), g = Math.abs(d) > B ? Math.tan(e) : 0, _ = this.ep2 * Math.pow(d, 2), y = Math.pow(_, 2), E = Math.pow(g, 2), M = Math.pow(E, 2);
        t = 1 - this.es * Math.pow(u, 2);
        var w = r * Math.sqrt(t) / this.k0, R = Math.pow(w, 2);
        t = t * g, n = e - t * R / (1 - this.es) * 0.5 * (1 - R / 12 * (5 + 3 * E - 9 * _ * E + _ - 4 * y - R / 30 * (61 + 90 * E - 252 * _ * E + 45 * M + 46 * _ - R / 56 * (1385 + 3633 * E + 4095 * M + 1574 * M * E)))), s = W(this.long0 + w * (1 - R / 6 * (1 + 2 * E + _ - R / 20 * (5 + 28 * E + 24 * M + 8 * _ * E + 6 * _ - R / 42 * (61 + 662 * E + 1320 * M + 720 * M * E)))) / d);
      } else
        n = N * Hr(a), s = 0;
    else {
      var o = Math.exp(r / this.k0), l = 0.5 * (o - 1 / o), h = this.lat0 + a / this.k0, c = Math.cos(h);
      t = Math.sqrt((1 - Math.pow(c, 2)) / (1 + Math.pow(l, 2))), n = Math.asin(t), a < 0 && (n = -n), l === 0 && c === 0 ? s = 0 : s = W(Math.atan2(l, c) + this.long0);
    }
    return i.x = s, i.y = n, i;
  }
  var Hv = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
  const Oa = {
    init: Kv,
    forward: Vv,
    inverse: jv,
    names: Hv
  };
  function jf(i) {
    var t = Math.exp(i);
    return t = (t - 1 / t) / 2, t;
  }
  function Se(i, t) {
    i = Math.abs(i), t = Math.abs(t);
    var e = Math.max(i, t), n = Math.min(i, t) / (e || 1);
    return e * Math.sqrt(1 + Math.pow(n, 2));
  }
  function Jv(i) {
    var t = 1 + i, e = t - 1;
    return e === 0 ? i : i * Math.log(t) / e;
  }
  function Qv(i) {
    var t = Math.abs(i);
    return t = Jv(t * (1 + t / (Se(1, t) + 1))), i < 0 ? -t : t;
  }
  function Qh(i, t) {
    for (var e = 2 * Math.cos(2 * t), n = i.length - 1, s = i[n], r = 0, a; --n >= 0; )
      a = -r + e * s + i[n], r = s, s = a;
    return t + a * Math.sin(2 * t);
  }
  function tE(i, t) {
    for (var e = 2 * Math.cos(t), n = i.length - 1, s = i[n], r = 0, a; --n >= 0; )
      a = -r + e * s + i[n], r = s, s = a;
    return Math.sin(t) * a;
  }
  function eE(i) {
    var t = Math.exp(i);
    return t = (t + 1 / t) / 2, t;
  }
  function Hf(i, t, e) {
    for (var n = Math.sin(t), s = Math.cos(t), r = jf(e), a = eE(e), o = 2 * s * a, l = -2 * n * r, h = i.length - 1, c = i[h], u = 0, d = 0, g = 0, _, y; --h >= 0; )
      _ = d, y = u, d = c, u = g, c = -_ + o * d - l * u + i[h], g = -y + l * d + o * u;
    return o = n * a, l = s * r, [o * c - l * g, o * g + l * c];
  }
  function iE() {
    if (!this.approx && (isNaN(this.es) || this.es <= 0))
      throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
    this.approx && (Oa.init.apply(this), this.forward = Oa.forward, this.inverse = Oa.inverse), this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
    var i = this.es / (1 + Math.sqrt(1 - this.es)), t = i / (2 - i), e = t;
    this.cgb[0] = t * (2 + t * (-2 / 3 + t * (-2 + t * (116 / 45 + t * (26 / 45 + t * (-2854 / 675)))))), this.cbg[0] = t * (-2 + t * (2 / 3 + t * (4 / 3 + t * (-82 / 45 + t * (32 / 45 + t * (4642 / 4725)))))), e = e * t, this.cgb[1] = e * (7 / 3 + t * (-8 / 5 + t * (-227 / 45 + t * (2704 / 315 + t * (2323 / 945))))), this.cbg[1] = e * (5 / 3 + t * (-16 / 15 + t * (-13 / 9 + t * (904 / 315 + t * (-1522 / 945))))), e = e * t, this.cgb[2] = e * (56 / 15 + t * (-136 / 35 + t * (-1262 / 105 + t * (73814 / 2835)))), this.cbg[2] = e * (-26 / 15 + t * (34 / 21 + t * (8 / 5 + t * (-12686 / 2835)))), e = e * t, this.cgb[3] = e * (4279 / 630 + t * (-332 / 35 + t * (-399572 / 14175))), this.cbg[3] = e * (1237 / 630 + t * (-12 / 5 + t * (-24832 / 14175))), e = e * t, this.cgb[4] = e * (4174 / 315 + t * (-144838 / 6237)), this.cbg[4] = e * (-734 / 315 + t * (109598 / 31185)), e = e * t, this.cgb[5] = e * (601676 / 22275), this.cbg[5] = e * (444337 / 155925), e = Math.pow(t, 2), this.Qn = this.k0 / (1 + t) * (1 + e * (1 / 4 + e * (1 / 64 + e / 256))), this.utg[0] = t * (-0.5 + t * (2 / 3 + t * (-37 / 96 + t * (1 / 360 + t * (81 / 512 + t * (-96199 / 604800)))))), this.gtu[0] = t * (0.5 + t * (-2 / 3 + t * (5 / 16 + t * (41 / 180 + t * (-127 / 288 + t * (7891 / 37800)))))), this.utg[1] = e * (-1 / 48 + t * (-1 / 15 + t * (437 / 1440 + t * (-46 / 105 + t * (1118711 / 3870720))))), this.gtu[1] = e * (13 / 48 + t * (-3 / 5 + t * (557 / 1440 + t * (281 / 630 + t * (-1983433 / 1935360))))), e = e * t, this.utg[2] = e * (-17 / 480 + t * (37 / 840 + t * (209 / 4480 + t * (-5569 / 90720)))), this.gtu[2] = e * (61 / 240 + t * (-103 / 140 + t * (15061 / 26880 + t * (167603 / 181440)))), e = e * t, this.utg[3] = e * (-4397 / 161280 + t * (11 / 504 + t * (830251 / 7257600))), this.gtu[3] = e * (49561 / 161280 + t * (-179 / 168 + t * (6601661 / 7257600))), e = e * t, this.utg[4] = e * (-4583 / 161280 + t * (108847 / 3991680)), this.gtu[4] = e * (34729 / 80640 + t * (-3418889 / 1995840)), e = e * t, this.utg[5] = e * (-20648693 / 638668800), this.gtu[5] = e * (212378941 / 319334400);
    var n = Qh(this.cbg, this.lat0);
    this.Zb = -this.Qn * (n + tE(this.gtu, 2 * n));
  }
  function nE(i) {
    var t = W(i.x - this.long0), e = i.y;
    e = Qh(this.cbg, e);
    var n = Math.sin(e), s = Math.cos(e), r = Math.sin(t), a = Math.cos(t);
    e = Math.atan2(n, a * s), t = Math.atan2(r * s, Se(n, s * a)), t = Qv(Math.tan(t));
    var o = Hf(this.gtu, 2 * e, 2 * t);
    e = e + o[0], t = t + o[1];
    var l, h;
    return Math.abs(t) <= 2.623395162778 ? (l = this.a * (this.Qn * t) + this.x0, h = this.a * (this.Qn * e + this.Zb) + this.y0) : (l = 1 / 0, h = 1 / 0), i.x = l, i.y = h, i;
  }
  function sE(i) {
    var t = (i.x - this.x0) * (1 / this.a), e = (i.y - this.y0) * (1 / this.a);
    e = (e - this.Zb) / this.Qn, t = t / this.Qn;
    var n, s;
    if (Math.abs(t) <= 2.623395162778) {
      var r = Hf(this.utg, 2 * e, 2 * t);
      e = e + r[0], t = t + r[1], t = Math.atan(jf(t));
      var a = Math.sin(e), o = Math.cos(e), l = Math.sin(t), h = Math.cos(t);
      e = Math.atan2(a * h, Se(l, h * o)), t = Math.atan2(l, h * o), n = W(t + this.long0), s = Qh(this.cgb, e);
    } else
      n = 1 / 0, s = 1 / 0;
    return i.x = n, i.y = s, i;
  }
  var rE = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "Gauss Kruger", "Gauss_Kruger", "tmerc"];
  const Na = {
    init: iE,
    forward: nE,
    inverse: sE,
    names: rE
  };
  function aE(i, t) {
    if (i === void 0) {
      if (i = Math.floor((W(t) + Math.PI) * 30 / Math.PI) + 1, i < 0)
        return 0;
      if (i > 60)
        return 60;
    }
    return i;
  }
  var oE = "etmerc";
  function lE() {
    var i = aE(this.zone, this.long0);
    if (i === void 0)
      throw new Error("unknown utm zone");
    this.lat0 = 0, this.long0 = (6 * Math.abs(i) - 183) * Jt, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, Na.init.apply(this), this.forward = Na.forward, this.inverse = Na.inverse;
  }
  var hE = ["Universal Transverse Mercator System", "utm"];
  const cE = {
    init: lE,
    names: hE,
    dependsOn: oE
  };
  function tc(i, t) {
    return Math.pow((1 - i) / (1 + i), t);
  }
  var uE = 20;
  function dE() {
    var i = Math.sin(this.lat0), t = Math.cos(this.lat0);
    t *= t, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * i * i), this.C = Math.sqrt(1 + this.es * t * t / (1 - this.es)), this.phic0 = Math.asin(i / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + Rt) / (Math.pow(Math.tan(0.5 * this.lat0 + Rt), this.C) * tc(this.e * i, this.ratexp));
  }
  function fE(i) {
    var t = i.x, e = i.y;
    return i.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * e + Rt), this.C) * tc(this.e * Math.sin(e), this.ratexp)) - N, i.x = this.C * t, i;
  }
  function gE(i) {
    for (var t = 1e-14, e = i.x / this.C, n = i.y, s = Math.pow(Math.tan(0.5 * n + Rt) / this.K, 1 / this.C), r = uE; r > 0 && (n = 2 * Math.atan(s * tc(this.e * Math.sin(i.y), -0.5 * this.e)) - N, !(Math.abs(n - i.y) < t)); --r)
      i.y = n;
    return r ? (i.x = e, i.y = n, i) : null;
  }
  var mE = ["gauss"];
  const ec = {
    init: dE,
    forward: fE,
    inverse: gE,
    names: mE
  };
  function _E() {
    ec.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
  }
  function pE(i) {
    var t, e, n, s;
    return i.x = W(i.x - this.long0), ec.forward.apply(this, [i]), t = Math.sin(i.y), e = Math.cos(i.y), n = Math.cos(i.x), s = this.k0 * this.R2 / (1 + this.sinc0 * t + this.cosc0 * e * n), i.x = s * e * Math.sin(i.x), i.y = s * (this.cosc0 * t - this.sinc0 * e * n), i.x = this.a * i.x + this.x0, i.y = this.a * i.y + this.y0, i;
  }
  function yE(i) {
    var t, e, n, s, r;
    if (i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a, i.x /= this.k0, i.y /= this.k0, r = Se(i.x, i.y)) {
      var a = 2 * Math.atan2(r, this.R2);
      t = Math.sin(a), e = Math.cos(a), s = Math.asin(e * this.sinc0 + i.y * t * this.cosc0 / r), n = Math.atan2(i.x * t, r * this.cosc0 * e - i.y * this.sinc0 * t);
    } else
      s = this.phic0, n = 0;
    return i.x = n, i.y = s, ec.inverse.apply(this, [i]), i.x = W(i.x + this.long0), i;
  }
  var vE = ["Stereographic_North_Pole", "Oblique_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
  const EE = {
    init: _E,
    forward: pE,
    inverse: yE,
    names: vE
  };
  function ME(i, t, e) {
    return t *= e, Math.tan(0.5 * (N + i)) * Math.pow((1 - t) / (1 + t), 0.5 * e);
  }
  function xE() {
    this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= B && (this.k0 = 0.5 * (1 + Hr(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= B && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= B && Math.abs(Math.cos(this.lat_ts)) > B && (this.k0 = 0.5 * this.cons * li(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / He(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = li(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - N, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
  }
  function wE(i) {
    var t = i.x, e = i.y, n = Math.sin(e), s = Math.cos(e), r, a, o, l, h, c, u = W(t - this.long0);
    return Math.abs(Math.abs(t - this.long0) - Math.PI) <= B && Math.abs(e + this.lat0) <= B ? (i.x = NaN, i.y = NaN, i) : this.sphere ? (r = 2 * this.k0 / (1 + this.sinlat0 * n + this.coslat0 * s * Math.cos(u)), i.x = this.a * r * s * Math.sin(u) + this.x0, i.y = this.a * r * (this.coslat0 * n - this.sinlat0 * s * Math.cos(u)) + this.y0, i) : (a = 2 * Math.atan(this.ssfn_(e, n, this.e)) - N, l = Math.cos(a), o = Math.sin(a), Math.abs(this.coslat0) <= B ? (h = He(this.e, e * this.con, this.con * n), c = 2 * this.a * this.k0 * h / this.cons, i.x = this.x0 + c * Math.sin(t - this.long0), i.y = this.y0 - this.con * c * Math.cos(t - this.long0), i) : (Math.abs(this.sinlat0) < B ? (r = 2 * this.a * this.k0 / (1 + l * Math.cos(u)), i.y = r * o) : (r = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * o + this.cosX0 * l * Math.cos(u))), i.y = r * (this.cosX0 * o - this.sinX0 * l * Math.cos(u)) + this.y0), i.x = r * l * Math.sin(u) + this.x0, i));
  }
  function SE(i) {
    i.x -= this.x0, i.y -= this.y0;
    var t, e, n, s, r, a = Math.sqrt(i.x * i.x + i.y * i.y);
    if (this.sphere) {
      var o = 2 * Math.atan(a / (2 * this.a * this.k0));
      return t = this.long0, e = this.lat0, a <= B ? (i.x = t, i.y = e, i) : (e = Math.asin(Math.cos(o) * this.sinlat0 + i.y * Math.sin(o) * this.coslat0 / a), Math.abs(this.coslat0) < B ? this.lat0 > 0 ? t = W(this.long0 + Math.atan2(i.x, -1 * i.y)) : t = W(this.long0 + Math.atan2(i.x, i.y)) : t = W(this.long0 + Math.atan2(i.x * Math.sin(o), a * this.coslat0 * Math.cos(o) - i.y * this.sinlat0 * Math.sin(o))), i.x = t, i.y = e, i);
    } else if (Math.abs(this.coslat0) <= B) {
      if (a <= B)
        return e = this.lat0, t = this.long0, i.x = t, i.y = e, i;
      i.x *= this.con, i.y *= this.con, n = a * this.cons / (2 * this.a * this.k0), e = this.con * Nr(this.e, n), t = this.con * W(this.con * this.long0 + Math.atan2(i.x, -1 * i.y));
    } else
      s = 2 * Math.atan(a * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), t = this.long0, a <= B ? r = this.X0 : (r = Math.asin(Math.cos(s) * this.sinX0 + i.y * Math.sin(s) * this.cosX0 / a), t = W(this.long0 + Math.atan2(i.x * Math.sin(s), a * this.cosX0 * Math.cos(s) - i.y * this.sinX0 * Math.sin(s)))), e = -1 * Nr(this.e, Math.tan(0.5 * (N + r)));
    return i.x = t, i.y = e, i;
  }
  var CE = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)", "Polar_Stereographic"];
  const RE = {
    init: xE,
    forward: wE,
    inverse: SE,
    names: CE,
    ssfn_: ME
  };
  function IE() {
    var i = this.lat0;
    this.lambda0 = this.long0;
    var t = Math.sin(i), e = this.a, n = this.rf, s = 1 / n, r = 2 * s - Math.pow(s, 2), a = this.e = Math.sqrt(r);
    this.R = this.k0 * e * Math.sqrt(1 - r) / (1 - r * Math.pow(t, 2)), this.alpha = Math.sqrt(1 + r / (1 - r) * Math.pow(Math.cos(i), 4)), this.b0 = Math.asin(t / this.alpha);
    var o = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), l = Math.log(Math.tan(Math.PI / 4 + i / 2)), h = Math.log((1 + a * t) / (1 - a * t));
    this.K = o - this.alpha * l + this.alpha * a / 2 * h;
  }
  function TE(i) {
    var t = Math.log(Math.tan(Math.PI / 4 - i.y / 2)), e = this.e / 2 * Math.log((1 + this.e * Math.sin(i.y)) / (1 - this.e * Math.sin(i.y))), n = -this.alpha * (t + e) + this.K, s = 2 * (Math.atan(Math.exp(n)) - Math.PI / 4), r = this.alpha * (i.x - this.lambda0), a = Math.atan(Math.sin(r) / (Math.sin(this.b0) * Math.tan(s) + Math.cos(this.b0) * Math.cos(r))), o = Math.asin(Math.cos(this.b0) * Math.sin(s) - Math.sin(this.b0) * Math.cos(s) * Math.cos(r));
    return i.y = this.R / 2 * Math.log((1 + Math.sin(o)) / (1 - Math.sin(o))) + this.y0, i.x = this.R * a + this.x0, i;
  }
  function AE(i) {
    for (var t = i.x - this.x0, e = i.y - this.y0, n = t / this.R, s = 2 * (Math.atan(Math.exp(e / this.R)) - Math.PI / 4), r = Math.asin(Math.cos(this.b0) * Math.sin(s) + Math.sin(this.b0) * Math.cos(s) * Math.cos(n)), a = Math.atan(Math.sin(n) / (Math.cos(this.b0) * Math.cos(n) - Math.sin(this.b0) * Math.tan(s))), o = this.lambda0 + a / this.alpha, l = 0, h = r, c = -1e3, u = 0; Math.abs(h - c) > 1e-7; ) {
      if (++u > 20)
        return;
      l = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + r / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(h)) / 2)), c = h, h = 2 * Math.atan(Math.exp(l)) - Math.PI / 2;
    }
    return i.x = o, i.y = h, i;
  }
  var bE = ["somerc"];
  const PE = {
    init: IE,
    forward: TE,
    inverse: AE,
    names: bE
  };
  var hs = 1e-7;
  function LE(i) {
    var t = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"], e = typeof i.PROJECTION == "object" ? Object.keys(i.PROJECTION)[0] : i.PROJECTION;
    return "no_uoff" in i || "no_off" in i || t.indexOf(e) !== -1;
  }
  function OE() {
    var i, t, e, n, s, r, a, o, l, h, c = 0, u, d = 0, g = 0, _ = 0, y = 0, E = 0, M = 0;
    this.no_off = LE(this), this.no_rot = "no_rot" in this;
    var w = !1;
    "alpha" in this && (w = !0);
    var R = !1;
    if ("rectified_grid_angle" in this && (R = !0), w && (M = this.alpha), R && (c = this.rectified_grid_angle * Jt), w || R)
      d = this.longc;
    else if (g = this.long1, y = this.lat1, _ = this.long2, E = this.lat2, Math.abs(y - E) <= hs || (i = Math.abs(y)) <= hs || Math.abs(i - N) <= hs || Math.abs(Math.abs(this.lat0) - N) <= hs || Math.abs(Math.abs(E) - N) <= hs)
      throw new Error();
    var S = 1 - this.es;
    t = Math.sqrt(S), Math.abs(this.lat0) > B ? (o = Math.sin(this.lat0), e = Math.cos(this.lat0), i = 1 - this.es * o * o, this.B = e * e, this.B = Math.sqrt(1 + this.es * this.B * this.B / S), this.A = this.B * this.k0 * t / i, n = this.B * t / (e * Math.sqrt(i)), s = n * n - 1, s <= 0 ? s = 0 : (s = Math.sqrt(s), this.lat0 < 0 && (s = -s)), this.E = s += n, this.E *= Math.pow(He(this.e, this.lat0, o), this.B)) : (this.B = 1 / t, this.A = this.k0, this.E = n = s = 1), w || R ? (w ? (u = Math.asin(Math.sin(M) / n), R || (c = M)) : (u = c, M = Math.asin(n * Math.sin(u))), this.lam0 = d - Math.asin(0.5 * (s - 1 / s) * Math.tan(u)) / this.B) : (r = Math.pow(He(this.e, y, Math.sin(y)), this.B), a = Math.pow(He(this.e, E, Math.sin(E)), this.B), s = this.E / r, l = (a - r) / (a + r), h = this.E * this.E, h = (h - a * r) / (h + a * r), i = g - _, i < -Math.pi ? _ -= Lr : i > Math.pi && (_ += Lr), this.lam0 = W(0.5 * (g + _) - Math.atan(h * Math.tan(0.5 * this.B * (g - _)) / l) / this.B), u = Math.atan(2 * Math.sin(this.B * W(g - this.lam0)) / (s - 1 / s)), c = M = Math.asin(n * Math.sin(u))), this.singam = Math.sin(u), this.cosgam = Math.cos(u), this.sinrot = Math.sin(c), this.cosrot = Math.cos(c), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.A * this.B, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(n * n - 1) / Math.cos(M))), this.lat0 < 0 && (this.u_0 = -this.u_0)), s = 0.5 * u, this.v_pole_n = this.ArB * Math.log(Math.tan(Rt - s)), this.v_pole_s = this.ArB * Math.log(Math.tan(Rt + s));
  }
  function NE(i) {
    var t = {}, e, n, s, r, a, o, l, h;
    if (i.x = i.x - this.lam0, Math.abs(Math.abs(i.y) - N) > B) {
      if (a = this.E / Math.pow(He(this.e, i.y, Math.sin(i.y)), this.B), o = 1 / a, e = 0.5 * (a - o), n = 0.5 * (a + o), r = Math.sin(this.B * i.x), s = (e * this.singam - r * this.cosgam) / n, Math.abs(Math.abs(s) - 1) < B)
        throw new Error();
      h = 0.5 * this.ArB * Math.log((1 - s) / (1 + s)), o = Math.cos(this.B * i.x), Math.abs(o) < hs ? l = this.A * i.x : l = this.ArB * Math.atan2(e * this.cosgam + r * this.singam, o);
    } else
      h = i.y > 0 ? this.v_pole_n : this.v_pole_s, l = this.ArB * i.y;
    return this.no_rot ? (t.x = l, t.y = h) : (l -= this.u_0, t.x = h * this.cosrot + l * this.sinrot, t.y = l * this.cosrot - h * this.sinrot), t.x = this.a * t.x + this.x0, t.y = this.a * t.y + this.y0, t;
  }
  function FE(i) {
    var t, e, n, s, r, a, o, l = {};
    if (i.x = (i.x - this.x0) * (1 / this.a), i.y = (i.y - this.y0) * (1 / this.a), this.no_rot ? (e = i.y, t = i.x) : (e = i.x * this.cosrot - i.y * this.sinrot, t = i.y * this.cosrot + i.x * this.sinrot + this.u_0), n = Math.exp(-this.BrA * e), s = 0.5 * (n - 1 / n), r = 0.5 * (n + 1 / n), a = Math.sin(this.BrA * t), o = (a * this.cosgam + s * this.singam) / r, Math.abs(Math.abs(o) - 1) < B)
      l.x = 0, l.y = o < 0 ? -N : N;
    else {
      if (l.y = this.E / Math.sqrt((1 + o) / (1 - o)), l.y = Nr(this.e, Math.pow(l.y, 1 / this.B)), l.y === 1 / 0)
        throw new Error();
      l.x = -this.rB * Math.atan2(s * this.cosgam - a * this.singam, Math.cos(this.BrA * t));
    }
    return l.x += this.lam0, l;
  }
  var DE = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
  const kE = {
    init: OE,
    forward: NE,
    inverse: FE,
    names: DE
  };
  function GE() {
    if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < B)) {
      var i = this.b / this.a;
      this.e = Math.sqrt(1 - i * i);
      var t = Math.sin(this.lat1), e = Math.cos(this.lat1), n = li(this.e, t, e), s = He(this.e, this.lat1, t), r = Math.sin(this.lat2), a = Math.cos(this.lat2), o = li(this.e, r, a), l = He(this.e, this.lat2, r), h = He(this.e, this.lat0, Math.sin(this.lat0));
      Math.abs(this.lat1 - this.lat2) > B ? this.ns = Math.log(n / o) / Math.log(s / l) : this.ns = t, isNaN(this.ns) && (this.ns = t), this.f0 = n / (this.ns * Math.pow(s, this.ns)), this.rh = this.a * this.f0 * Math.pow(h, this.ns), this.title || (this.title = "Lambert Conformal Conic");
    }
  }
  function zE(i) {
    var t = i.x, e = i.y;
    Math.abs(2 * Math.abs(e) - Math.PI) <= B && (e = Hr(e) * (N - 2 * B));
    var n = Math.abs(Math.abs(e) - N), s, r;
    if (n > B)
      s = He(this.e, e, Math.sin(e)), r = this.a * this.f0 * Math.pow(s, this.ns);
    else {
      if (n = e * this.ns, n <= 0)
        return null;
      r = 0;
    }
    var a = this.ns * W(t - this.long0);
    return i.x = this.k0 * (r * Math.sin(a)) + this.x0, i.y = this.k0 * (this.rh - r * Math.cos(a)) + this.y0, i;
  }
  function $E(i) {
    var t, e, n, s, r, a = (i.x - this.x0) / this.k0, o = this.rh - (i.y - this.y0) / this.k0;
    this.ns > 0 ? (t = Math.sqrt(a * a + o * o), e = 1) : (t = -Math.sqrt(a * a + o * o), e = -1);
    var l = 0;
    if (t !== 0 && (l = Math.atan2(e * a, e * o)), t !== 0 || this.ns > 0) {
      if (e = 1 / this.ns, n = Math.pow(t / (this.a * this.f0), e), s = Nr(this.e, n), s === -9999)
        return null;
    } else
      s = -N;
    return r = W(l / this.ns + this.long0), i.x = r, i.y = s, i;
  }
  var UE = [
    "Lambert Tangential Conformal Conic Projection",
    "Lambert_Conformal_Conic",
    "Lambert_Conformal_Conic_1SP",
    "Lambert_Conformal_Conic_2SP",
    "lcc",
    "Lambert Conic Conformal (1SP)",
    "Lambert Conic Conformal (2SP)"
  ];
  const BE = {
    init: GE,
    forward: zE,
    inverse: $E,
    names: UE
  };
  function WE() {
    this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.7417649320975901 - 0.308341501185665), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
  }
  function XE(i) {
    var t, e, n, s, r, a, o, l = i.x, h = i.y, c = W(l - this.long0);
    return t = Math.pow((1 + this.e * Math.sin(h)) / (1 - this.e * Math.sin(h)), this.alfa * this.e / 2), e = 2 * (Math.atan(this.k * Math.pow(Math.tan(h / 2 + this.s45), this.alfa) / t) - this.s45), n = -c * this.alfa, s = Math.asin(Math.cos(this.ad) * Math.sin(e) + Math.sin(this.ad) * Math.cos(e) * Math.cos(n)), r = Math.asin(Math.cos(e) * Math.sin(n) / Math.cos(s)), a = this.n * r, o = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n), i.y = o * Math.cos(a) / 1, i.x = o * Math.sin(a) / 1, this.czech || (i.y *= -1, i.x *= -1), i;
  }
  function YE(i) {
    var t, e, n, s, r, a, o, l, h = i.x;
    i.x = i.y, i.y = h, this.czech || (i.y *= -1, i.x *= -1), a = Math.sqrt(i.x * i.x + i.y * i.y), r = Math.atan2(i.y, i.x), s = r / Math.sin(this.s0), n = 2 * (Math.atan(Math.pow(this.ro0 / a, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), t = Math.asin(Math.cos(this.ad) * Math.sin(n) - Math.sin(this.ad) * Math.cos(n) * Math.cos(s)), e = Math.asin(Math.cos(n) * Math.sin(s) / Math.cos(t)), i.x = this.long0 - e / this.alfa, o = t, l = 0;
    var c = 0;
    do
      i.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(t / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(o)) / (1 - this.e * Math.sin(o)), this.e / 2)) - this.s45), Math.abs(o - i.y) < 1e-10 && (l = 1), o = i.y, c += 1;
    while (l === 0 && c < 15);
    return c >= 15 ? null : i;
  }
  var ZE = ["Krovak", "krovak"];
  const qE = {
    init: WE,
    forward: XE,
    inverse: YE,
    names: ZE
  };
  function _e(i, t, e, n, s) {
    return i * s - t * Math.sin(2 * s) + e * Math.sin(4 * s) - n * Math.sin(6 * s);
  }
  function Jr(i) {
    return 1 - 0.25 * i * (1 + i / 16 * (3 + 1.25 * i));
  }
  function Qr(i) {
    return 0.375 * i * (1 + 0.25 * i * (1 + 0.46875 * i));
  }
  function ta(i) {
    return 0.05859375 * i * i * (1 + 0.75 * i);
  }
  function ea(i) {
    return i * i * i * (35 / 3072);
  }
  function Gs(i, t, e) {
    var n = t * e;
    return i / Math.sqrt(1 - n * n);
  }
  function ln(i) {
    return Math.abs(i) < N ? i : i - Hr(i) * Math.PI;
  }
  function no(i, t, e, n, s) {
    var r, a;
    r = i / t;
    for (var o = 0; o < 15; o++)
      if (a = (i - (t * r - e * Math.sin(2 * r) + n * Math.sin(4 * r) - s * Math.sin(6 * r))) / (t - 2 * e * Math.cos(2 * r) + 4 * n * Math.cos(4 * r) - 6 * s * Math.cos(6 * r)), r += a, Math.abs(a) <= 1e-10)
        return r;
    return NaN;
  }
  function KE() {
    this.sphere || (this.e0 = Jr(this.es), this.e1 = Qr(this.es), this.e2 = ta(this.es), this.e3 = ea(this.es), this.ml0 = this.a * _e(this.e0, this.e1, this.e2, this.e3, this.lat0));
  }
  function VE(i) {
    var t, e, n = i.x, s = i.y;
    if (n = W(n - this.long0), this.sphere)
      t = this.a * Math.asin(Math.cos(s) * Math.sin(n)), e = this.a * (Math.atan2(Math.tan(s), Math.cos(n)) - this.lat0);
    else {
      var r = Math.sin(s), a = Math.cos(s), o = Gs(this.a, this.e, r), l = Math.tan(s) * Math.tan(s), h = n * Math.cos(s), c = h * h, u = this.es * a * a / (1 - this.es), d = this.a * _e(this.e0, this.e1, this.e2, this.e3, s);
      t = o * h * (1 - c * l * (1 / 6 - (8 - l + 8 * u) * c / 120)), e = d - this.ml0 + o * r / a * c * (0.5 + (5 - l + 6 * u) * c / 24);
    }
    return i.x = t + this.x0, i.y = e + this.y0, i;
  }
  function jE(i) {
    i.x -= this.x0, i.y -= this.y0;
    var t = i.x / this.a, e = i.y / this.a, n, s;
    if (this.sphere) {
      var r = e + this.lat0;
      n = Math.asin(Math.sin(r) * Math.cos(t)), s = Math.atan2(Math.tan(t), Math.cos(r));
    } else {
      var a = this.ml0 / this.a + e, o = no(a, this.e0, this.e1, this.e2, this.e3);
      if (Math.abs(Math.abs(o) - N) <= B)
        return i.x = this.long0, i.y = N, e < 0 && (i.y *= -1), i;
      var l = Gs(this.a, this.e, Math.sin(o)), h = l * l * l / this.a / this.a * (1 - this.es), c = Math.pow(Math.tan(o), 2), u = t * this.a / l, d = u * u;
      n = o - l * Math.tan(o) / h * u * u * (0.5 - (1 + 3 * c) * u * u / 24), s = u * (1 - d * (c / 3 + (1 + 3 * c) * c * d / 15)) / Math.cos(o);
    }
    return i.x = W(s + this.long0), i.y = ln(n), i;
  }
  var HE = ["Cassini", "Cassini_Soldner", "cass"];
  const JE = {
    init: KE,
    forward: VE,
    inverse: jE,
    names: HE
  };
  function Ji(i, t) {
    var e;
    return i > 1e-7 ? (e = i * t, (1 - i * i) * (t / (1 - e * e) - 0.5 / i * Math.log((1 - e) / (1 + e)))) : 2 * t;
  }
  var QE = 1, tM = 2, eM = 3, iM = 4;
  function nM() {
    var i = Math.abs(this.lat0);
    if (Math.abs(i - N) < B ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(i) < B ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) {
      var t;
      switch (this.qp = Ji(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = dM(this.es), this.mode) {
        case this.N_POLE:
          this.dd = 1;
          break;
        case this.S_POLE:
          this.dd = 1;
          break;
        case this.EQUIT:
          this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
          break;
        case this.OBLIQ:
          this.rq = Math.sqrt(0.5 * this.qp), t = Math.sin(this.lat0), this.sinb1 = Ji(this.e, t) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * t * t) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
          break;
      }
    } else
      this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
  }
  function sM(i) {
    var t, e, n, s, r, a, o, l, h, c, u = i.x, d = i.y;
    if (u = W(u - this.long0), this.sphere) {
      if (r = Math.sin(d), c = Math.cos(d), n = Math.cos(u), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        if (e = this.mode === this.EQUIT ? 1 + c * n : 1 + this.sinph0 * r + this.cosph0 * c * n, e <= B)
          return null;
        e = Math.sqrt(2 / e), t = e * c * Math.sin(u), e *= this.mode === this.EQUIT ? r : this.cosph0 * r - this.sinph0 * c * n;
      } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
        if (this.mode === this.N_POLE && (n = -n), Math.abs(d + this.lat0) < B)
          return null;
        e = Rt - d * 0.5, e = 2 * (this.mode === this.S_POLE ? Math.cos(e) : Math.sin(e)), t = e * Math.sin(u), e *= n;
      }
    } else {
      switch (o = 0, l = 0, h = 0, n = Math.cos(u), s = Math.sin(u), r = Math.sin(d), a = Ji(this.e, r), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (o = a / this.qp, l = Math.sqrt(1 - o * o)), this.mode) {
        case this.OBLIQ:
          h = 1 + this.sinb1 * o + this.cosb1 * l * n;
          break;
        case this.EQUIT:
          h = 1 + l * n;
          break;
        case this.N_POLE:
          h = N + d, a = this.qp - a;
          break;
        case this.S_POLE:
          h = d - N, a = this.qp + a;
          break;
      }
      if (Math.abs(h) < B)
        return null;
      switch (this.mode) {
        case this.OBLIQ:
        case this.EQUIT:
          h = Math.sqrt(2 / h), this.mode === this.OBLIQ ? e = this.ymf * h * (this.cosb1 * o - this.sinb1 * l * n) : e = (h = Math.sqrt(2 / (1 + l * n))) * o * this.ymf, t = this.xmf * h * l * s;
          break;
        case this.N_POLE:
        case this.S_POLE:
          a >= 0 ? (t = (h = Math.sqrt(a)) * s, e = n * (this.mode === this.S_POLE ? h : -h)) : t = e = 0;
          break;
      }
    }
    return i.x = this.a * t + this.x0, i.y = this.a * e + this.y0, i;
  }
  function rM(i) {
    i.x -= this.x0, i.y -= this.y0;
    var t = i.x / this.a, e = i.y / this.a, n, s, r, a, o, l, h;
    if (this.sphere) {
      var c = 0, u, d = 0;
      if (u = Math.sqrt(t * t + e * e), s = u * 0.5, s > 1)
        return null;
      switch (s = 2 * Math.asin(s), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (d = Math.sin(s), c = Math.cos(s)), this.mode) {
        case this.EQUIT:
          s = Math.abs(u) <= B ? 0 : Math.asin(e * d / u), t *= d, e = c * u;
          break;
        case this.OBLIQ:
          s = Math.abs(u) <= B ? this.lat0 : Math.asin(c * this.sinph0 + e * d * this.cosph0 / u), t *= d * this.cosph0, e = (c - Math.sin(s) * this.sinph0) * u;
          break;
        case this.N_POLE:
          e = -e, s = N - s;
          break;
        case this.S_POLE:
          s -= N;
          break;
      }
      n = e === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(t, e);
    } else {
      if (h = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        if (t /= this.dd, e *= this.dd, l = Math.sqrt(t * t + e * e), l < B)
          return i.x = this.long0, i.y = this.lat0, i;
        a = 2 * Math.asin(0.5 * l / this.rq), r = Math.cos(a), t *= a = Math.sin(a), this.mode === this.OBLIQ ? (h = r * this.sinb1 + e * a * this.cosb1 / l, o = this.qp * h, e = l * this.cosb1 * r - e * this.sinb1 * a) : (h = e * a / l, o = this.qp * h, e = l * r);
      } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
        if (this.mode === this.N_POLE && (e = -e), o = t * t + e * e, !o)
          return i.x = this.long0, i.y = this.lat0, i;
        h = 1 - o / this.qp, this.mode === this.S_POLE && (h = -h);
      }
      n = Math.atan2(t, e), s = fM(Math.asin(h), this.apa);
    }
    return i.x = W(this.long0 + n), i.y = s, i;
  }
  var aM = 0.3333333333333333, oM = 0.17222222222222222, lM = 0.10257936507936508, hM = 0.06388888888888888, cM = 0.0664021164021164, uM = 0.016415012942191543;
  function dM(i) {
    var t, e = [];
    return e[0] = i * aM, t = i * i, e[0] += t * oM, e[1] = t * hM, t *= i, e[0] += t * lM, e[1] += t * cM, e[2] = t * uM, e;
  }
  function fM(i, t) {
    var e = i + i;
    return i + t[0] * Math.sin(e) + t[1] * Math.sin(e + e) + t[2] * Math.sin(e + e + e);
  }
  var gM = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
  const mM = {
    init: nM,
    forward: sM,
    inverse: rM,
    names: gM,
    S_POLE: QE,
    N_POLE: tM,
    EQUIT: eM,
    OBLIQ: iM
  };
  function sn(i) {
    return Math.abs(i) > 1 && (i = i > 1 ? 1 : -1), Math.asin(i);
  }
  function _M() {
    Math.abs(this.lat1 + this.lat2) < B || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = li(this.e3, this.sin_po, this.cos_po), this.qs1 = Ji(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = li(this.e3, this.sin_po, this.cos_po), this.qs2 = Ji(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = Ji(this.e3, this.sin_po), Math.abs(this.lat1 - this.lat2) > B ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
  }
  function pM(i) {
    var t = i.x, e = i.y;
    this.sin_phi = Math.sin(e), this.cos_phi = Math.cos(e);
    var n = Ji(this.e3, this.sin_phi), s = this.a * Math.sqrt(this.c - this.ns0 * n) / this.ns0, r = this.ns0 * W(t - this.long0), a = s * Math.sin(r) + this.x0, o = this.rh - s * Math.cos(r) + this.y0;
    return i.x = a, i.y = o, i;
  }
  function yM(i) {
    var t, e, n, s, r, a;
    return i.x -= this.x0, i.y = this.rh - i.y + this.y0, this.ns0 >= 0 ? (t = Math.sqrt(i.x * i.x + i.y * i.y), n = 1) : (t = -Math.sqrt(i.x * i.x + i.y * i.y), n = -1), s = 0, t !== 0 && (s = Math.atan2(n * i.x, n * i.y)), n = t * this.ns0 / this.a, this.sphere ? a = Math.asin((this.c - n * n) / (2 * this.ns0)) : (e = (this.c - n * n) / this.ns0, a = this.phi1z(this.e3, e)), r = W(s / this.ns0 + this.long0), i.x = r, i.y = a, i;
  }
  function vM(i, t) {
    var e, n, s, r, a, o = sn(0.5 * t);
    if (i < B)
      return o;
    for (var l = i * i, h = 1; h <= 25; h++)
      if (e = Math.sin(o), n = Math.cos(o), s = i * e, r = 1 - s * s, a = 0.5 * r * r / n * (t / (1 - l) - e / r + 0.5 / i * Math.log((1 - s) / (1 + s))), o = o + a, Math.abs(a) <= 1e-7)
        return o;
    return null;
  }
  var EM = ["Albers_Conic_Equal_Area", "Albers", "aea"];
  const MM = {
    init: _M,
    forward: pM,
    inverse: yM,
    names: EM,
    phi1z: vM
  };
  function xM() {
    this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
  }
  function wM(i) {
    var t, e, n, s, r, a, o, l, h = i.x, c = i.y;
    return n = W(h - this.long0), t = Math.sin(c), e = Math.cos(c), s = Math.cos(n), a = this.sin_p14 * t + this.cos_p14 * e * s, r = 1, a > 0 || Math.abs(a) <= B ? (o = this.x0 + this.a * r * e * Math.sin(n) / a, l = this.y0 + this.a * r * (this.cos_p14 * t - this.sin_p14 * e * s) / a) : (o = this.x0 + this.infinity_dist * e * Math.sin(n), l = this.y0 + this.infinity_dist * (this.cos_p14 * t - this.sin_p14 * e * s)), i.x = o, i.y = l, i;
  }
  function SM(i) {
    var t, e, n, s, r, a;
    return i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a, i.x /= this.k0, i.y /= this.k0, (t = Math.sqrt(i.x * i.x + i.y * i.y)) ? (s = Math.atan2(t, this.rc), e = Math.sin(s), n = Math.cos(s), a = sn(n * this.sin_p14 + i.y * e * this.cos_p14 / t), r = Math.atan2(i.x * e, t * this.cos_p14 * n - i.y * this.sin_p14 * e), r = W(this.long0 + r)) : (a = this.phic0, r = 0), i.x = r, i.y = a, i;
  }
  var CM = ["gnom"];
  const RM = {
    init: xM,
    forward: wM,
    inverse: SM,
    names: CM
  };
  function IM(i, t) {
    var e = 1 - (1 - i * i) / (2 * i) * Math.log((1 - i) / (1 + i));
    if (Math.abs(Math.abs(t) - e) < 1e-6)
      return t < 0 ? -1 * N : N;
    for (var n = Math.asin(0.5 * t), s, r, a, o, l = 0; l < 30; l++)
      if (r = Math.sin(n), a = Math.cos(n), o = i * r, s = Math.pow(1 - o * o, 2) / (2 * a) * (t / (1 - i * i) - r / (1 - o * o) + 0.5 / i * Math.log((1 - o) / (1 + o))), n += s, Math.abs(s) <= 1e-10)
        return n;
    return NaN;
  }
  function TM() {
    this.sphere || (this.k0 = li(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
  }
  function AM(i) {
    var t = i.x, e = i.y, n, s, r = W(t - this.long0);
    if (this.sphere)
      n = this.x0 + this.a * r * Math.cos(this.lat_ts), s = this.y0 + this.a * Math.sin(e) / Math.cos(this.lat_ts);
    else {
      var a = Ji(this.e, Math.sin(e));
      n = this.x0 + this.a * this.k0 * r, s = this.y0 + this.a * a * 0.5 / this.k0;
    }
    return i.x = n, i.y = s, i;
  }
  function bM(i) {
    i.x -= this.x0, i.y -= this.y0;
    var t, e;
    return this.sphere ? (t = W(this.long0 + i.x / this.a / Math.cos(this.lat_ts)), e = Math.asin(i.y / this.a * Math.cos(this.lat_ts))) : (e = IM(this.e, 2 * i.y * this.k0 / this.a), t = W(this.long0 + i.x / (this.a * this.k0))), i.x = t, i.y = e, i;
  }
  var PM = ["cea"];
  const LM = {
    init: TM,
    forward: AM,
    inverse: bM,
    names: PM
  };
  function OM() {
    this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
  }
  function NM(i) {
    var t = i.x, e = i.y, n = W(t - this.long0), s = ln(e - this.lat0);
    return i.x = this.x0 + this.a * n * this.rc, i.y = this.y0 + this.a * s, i;
  }
  function FM(i) {
    var t = i.x, e = i.y;
    return i.x = W(this.long0 + (t - this.x0) / (this.a * this.rc)), i.y = ln(this.lat0 + (e - this.y0) / this.a), i;
  }
  var DM = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
  const kM = {
    init: OM,
    forward: NM,
    inverse: FM,
    names: DM
  };
  var Ju = 20;
  function GM() {
    this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Jr(this.es), this.e1 = Qr(this.es), this.e2 = ta(this.es), this.e3 = ea(this.es), this.ml0 = this.a * _e(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
  function zM(i) {
    var t = i.x, e = i.y, n, s, r, a = W(t - this.long0);
    if (r = a * Math.sin(e), this.sphere)
      Math.abs(e) <= B ? (n = this.a * a, s = -1 * this.a * this.lat0) : (n = this.a * Math.sin(r) / Math.tan(e), s = this.a * (ln(e - this.lat0) + (1 - Math.cos(r)) / Math.tan(e)));
    else if (Math.abs(e) <= B)
      n = this.a * a, s = -1 * this.ml0;
    else {
      var o = Gs(this.a, this.e, Math.sin(e)) / Math.tan(e);
      n = o * Math.sin(r), s = this.a * _e(this.e0, this.e1, this.e2, this.e3, e) - this.ml0 + o * (1 - Math.cos(r));
    }
    return i.x = n + this.x0, i.y = s + this.y0, i;
  }
  function $M(i) {
    var t, e, n, s, r, a, o, l, h;
    if (n = i.x - this.x0, s = i.y - this.y0, this.sphere)
      if (Math.abs(s + this.a * this.lat0) <= B)
        t = W(n / this.a + this.long0), e = 0;
      else {
        a = this.lat0 + s / this.a, o = n * n / this.a / this.a + a * a, l = a;
        var c;
        for (r = Ju; r; --r)
          if (c = Math.tan(l), h = -1 * (a * (l * c + 1) - l - 0.5 * (l * l + o) * c) / ((l - a) / c - 1), l += h, Math.abs(h) <= B) {
            e = l;
            break;
          }
        t = W(this.long0 + Math.asin(n * Math.tan(l) / this.a) / Math.sin(e));
      }
    else if (Math.abs(s + this.ml0) <= B)
      e = 0, t = W(this.long0 + n / this.a);
    else {
      a = (this.ml0 + s) / this.a, o = n * n / this.a / this.a + a * a, l = a;
      var u, d, g, _, y;
      for (r = Ju; r; --r)
        if (y = this.e * Math.sin(l), u = Math.sqrt(1 - y * y) * Math.tan(l), d = this.a * _e(this.e0, this.e1, this.e2, this.e3, l), g = this.e0 - 2 * this.e1 * Math.cos(2 * l) + 4 * this.e2 * Math.cos(4 * l) - 6 * this.e3 * Math.cos(6 * l), _ = d / this.a, h = (a * (u * _ + 1) - _ - 0.5 * u * (_ * _ + o)) / (this.es * Math.sin(2 * l) * (_ * _ + o - 2 * a * _) / (4 * u) + (a - _) * (u * g - 2 / Math.sin(2 * l)) - g), l -= h, Math.abs(h) <= B) {
          e = l;
          break;
        }
      u = Math.sqrt(1 - this.es * Math.pow(Math.sin(e), 2)) * Math.tan(e), t = W(this.long0 + Math.asin(n * u / this.a) / Math.sin(e));
    }
    return i.x = t, i.y = e, i;
  }
  var UM = ["Polyconic", "poly"];
  const BM = {
    init: GM,
    forward: zM,
    inverse: $M,
    names: UM
  };
  function WM() {
    this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
  }
  function XM(i) {
    var t, e = i.x, n = i.y, s = n - this.lat0, r = e - this.long0, a = s / fr * 1e-5, o = r, l = 1, h = 0;
    for (t = 1; t <= 10; t++)
      l = l * a, h = h + this.A[t] * l;
    var c = h, u = o, d = 1, g = 0, _, y, E = 0, M = 0;
    for (t = 1; t <= 6; t++)
      _ = d * c - g * u, y = g * c + d * u, d = _, g = y, E = E + this.B_re[t] * d - this.B_im[t] * g, M = M + this.B_im[t] * d + this.B_re[t] * g;
    return i.x = M * this.a + this.x0, i.y = E * this.a + this.y0, i;
  }
  function YM(i) {
    var t, e = i.x, n = i.y, s = e - this.x0, r = n - this.y0, a = r / this.a, o = s / this.a, l = 1, h = 0, c, u, d = 0, g = 0;
    for (t = 1; t <= 6; t++)
      c = l * a - h * o, u = h * a + l * o, l = c, h = u, d = d + this.C_re[t] * l - this.C_im[t] * h, g = g + this.C_im[t] * l + this.C_re[t] * h;
    for (var _ = 0; _ < this.iterations; _++) {
      var y = d, E = g, M, w, R = a, S = o;
      for (t = 2; t <= 6; t++)
        M = y * d - E * g, w = E * d + y * g, y = M, E = w, R = R + (t - 1) * (this.B_re[t] * y - this.B_im[t] * E), S = S + (t - 1) * (this.B_im[t] * y + this.B_re[t] * E);
      y = 1, E = 0;
      var C = this.B_re[1], T = this.B_im[1];
      for (t = 2; t <= 6; t++)
        M = y * d - E * g, w = E * d + y * g, y = M, E = w, C = C + t * (this.B_re[t] * y - this.B_im[t] * E), T = T + t * (this.B_im[t] * y + this.B_re[t] * E);
      var L = C * C + T * T;
      d = (R * C + S * T) / L, g = (S * C - R * T) / L;
    }
    var A = d, O = g, $ = 1, q = 0;
    for (t = 1; t <= 9; t++)
      $ = $ * A, q = q + this.D[t] * $;
    var Z = this.lat0 + q * fr * 1e5, Q = this.long0 + O;
    return i.x = Q, i.y = Z, i;
  }
  var ZM = ["New_Zealand_Map_Grid", "nzmg"];
  const qM = {
    init: WM,
    forward: XM,
    inverse: YM,
    names: ZM
  };
  function KM() {
  }
  function VM(i) {
    var t = i.x, e = i.y, n = W(t - this.long0), s = this.x0 + this.a * n, r = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + e / 2.5)) * 1.25;
    return i.x = s, i.y = r, i;
  }
  function jM(i) {
    i.x -= this.x0, i.y -= this.y0;
    var t = W(this.long0 + i.x / this.a), e = 2.5 * (Math.atan(Math.exp(0.8 * i.y / this.a)) - Math.PI / 4);
    return i.x = t, i.y = e, i;
  }
  var HM = ["Miller_Cylindrical", "mill"];
  const JM = {
    init: KM,
    forward: VM,
    inverse: jM,
    names: HM
  };
  var QM = 20;
  function tx() {
    this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = Hh(this.es);
  }
  function ex(i) {
    var t, e, n = i.x, s = i.y;
    if (n = W(n - this.long0), this.sphere) {
      if (!this.m)
        s = this.n !== 1 ? Math.asin(this.n * Math.sin(s)) : s;
      else
        for (var r = this.n * Math.sin(s), a = QM; a; --a) {
          var o = (this.m * s + Math.sin(s) - r) / (this.m + Math.cos(s));
          if (s -= o, Math.abs(o) < B)
            break;
        }
      t = this.a * this.C_x * n * (this.m + Math.cos(s)), e = this.a * this.C_y * s;
    } else {
      var l = Math.sin(s), h = Math.cos(s);
      e = this.a * Bs(s, l, h, this.en), t = this.a * n * h / Math.sqrt(1 - this.es * l * l);
    }
    return i.x = t, i.y = e, i;
  }
  function ix(i) {
    var t, e, n, s;
    return i.x -= this.x0, n = i.x / this.a, i.y -= this.y0, t = i.y / this.a, this.sphere ? (t /= this.C_y, n = n / (this.C_x * (this.m + Math.cos(t))), this.m ? t = sn((this.m * t + Math.sin(t)) / this.n) : this.n !== 1 && (t = sn(Math.sin(t) / this.n)), n = W(n + this.long0), t = ln(t)) : (t = Jh(i.y / this.a, this.es, this.en), s = Math.abs(t), s < N ? (s = Math.sin(t), e = this.long0 + i.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(t)), n = W(e)) : s - B < N && (n = this.long0)), i.x = n, i.y = t, i;
  }
  var nx = ["Sinusoidal", "sinu"];
  const sx = {
    init: tx,
    forward: ex,
    inverse: ix,
    names: nx
  };
  function rx() {
  }
  function ax(i) {
    for (var t = i.x, e = i.y, n = W(t - this.long0), s = e, r = Math.PI * Math.sin(e); ; ) {
      var a = -(s + Math.sin(s) - r) / (1 + Math.cos(s));
      if (s += a, Math.abs(a) < B)
        break;
    }
    s /= 2, Math.PI / 2 - Math.abs(e) < B && (n = 0);
    var o = 0.900316316158 * this.a * n * Math.cos(s) + this.x0, l = 1.4142135623731 * this.a * Math.sin(s) + this.y0;
    return i.x = o, i.y = l, i;
  }
  function ox(i) {
    var t, e;
    i.x -= this.x0, i.y -= this.y0, e = i.y / (1.4142135623731 * this.a), Math.abs(e) > 0.999999999999 && (e = 0.999999999999), t = Math.asin(e);
    var n = W(this.long0 + i.x / (0.900316316158 * this.a * Math.cos(t)));
    n < -Math.PI && (n = -Math.PI), n > Math.PI && (n = Math.PI), e = (2 * t + Math.sin(2 * t)) / Math.PI, Math.abs(e) > 1 && (e = 1);
    var s = Math.asin(e);
    return i.x = n, i.y = s, i;
  }
  var lx = ["Mollweide", "moll"];
  const hx = {
    init: rx,
    forward: ax,
    inverse: ox,
    names: lx
  };
  function cx() {
    Math.abs(this.lat1 + this.lat2) < B || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Jr(this.es), this.e1 = Qr(this.es), this.e2 = ta(this.es), this.e3 = ea(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = li(this.e, this.sinphi, this.cosphi), this.ml1 = _e(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < B ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = li(this.e, this.sinphi, this.cosphi), this.ml2 = _e(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = _e(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
  }
  function ux(i) {
    var t = i.x, e = i.y, n;
    if (this.sphere)
      n = this.a * (this.g - e);
    else {
      var s = _e(this.e0, this.e1, this.e2, this.e3, e);
      n = this.a * (this.g - s);
    }
    var r = this.ns * W(t - this.long0), a = this.x0 + n * Math.sin(r), o = this.y0 + this.rh - n * Math.cos(r);
    return i.x = a, i.y = o, i;
  }
  function dx(i) {
    i.x -= this.x0, i.y = this.rh - i.y + this.y0;
    var t, e, n, s;
    this.ns >= 0 ? (e = Math.sqrt(i.x * i.x + i.y * i.y), t = 1) : (e = -Math.sqrt(i.x * i.x + i.y * i.y), t = -1);
    var r = 0;
    if (e !== 0 && (r = Math.atan2(t * i.x, t * i.y)), this.sphere)
      return s = W(this.long0 + r / this.ns), n = ln(this.g - e / this.a), i.x = s, i.y = n, i;
    var a = this.g - e / this.a;
    return n = no(a, this.e0, this.e1, this.e2, this.e3), s = W(this.long0 + r / this.ns), i.x = s, i.y = n, i;
  }
  var fx = ["Equidistant_Conic", "eqdc"];
  const gx = {
    init: cx,
    forward: ux,
    inverse: dx,
    names: fx
  };
  function mx() {
    this.R = this.a;
  }
  function _x(i) {
    var t = i.x, e = i.y, n = W(t - this.long0), s, r;
    Math.abs(e) <= B && (s = this.x0 + this.R * n, r = this.y0);
    var a = sn(2 * Math.abs(e / Math.PI));
    (Math.abs(n) <= B || Math.abs(Math.abs(e) - N) <= B) && (s = this.x0, e >= 0 ? r = this.y0 + Math.PI * this.R * Math.tan(0.5 * a) : r = this.y0 + Math.PI * this.R * -Math.tan(0.5 * a));
    var o = 0.5 * Math.abs(Math.PI / n - n / Math.PI), l = o * o, h = Math.sin(a), c = Math.cos(a), u = c / (h + c - 1), d = u * u, g = u * (2 / h - 1), _ = g * g, y = Math.PI * this.R * (o * (u - _) + Math.sqrt(l * (u - _) * (u - _) - (_ + l) * (d - _))) / (_ + l);
    n < 0 && (y = -y), s = this.x0 + y;
    var E = l + u;
    return y = Math.PI * this.R * (g * E - o * Math.sqrt((_ + l) * (l + 1) - E * E)) / (_ + l), e >= 0 ? r = this.y0 + y : r = this.y0 - y, i.x = s, i.y = r, i;
  }
  function px(i) {
    var t, e, n, s, r, a, o, l, h, c, u, d, g;
    return i.x -= this.x0, i.y -= this.y0, u = Math.PI * this.R, n = i.x / u, s = i.y / u, r = n * n + s * s, a = -Math.abs(s) * (1 + r), o = a - 2 * s * s + n * n, l = -2 * a + 1 + 2 * s * s + r * r, g = s * s / l + (2 * o * o * o / l / l / l - 9 * a * o / l / l) / 27, h = (a - o * o / 3 / l) / l, c = 2 * Math.sqrt(-h / 3), u = 3 * g / h / c, Math.abs(u) > 1 && (u >= 0 ? u = 1 : u = -1), d = Math.acos(u) / 3, i.y >= 0 ? e = (-c * Math.cos(d + Math.PI / 3) - o / 3 / l) * Math.PI : e = -(-c * Math.cos(d + Math.PI / 3) - o / 3 / l) * Math.PI, Math.abs(n) < B ? t = this.long0 : t = W(this.long0 + Math.PI * (r - 1 + Math.sqrt(1 + 2 * (n * n - s * s) + r * r)) / 2 / n), i.x = t, i.y = e, i;
  }
  var yx = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
  const vx = {
    init: mx,
    forward: _x,
    inverse: px,
    names: yx
  };
  function Ex() {
    this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0);
  }
  function Mx(i) {
    var t = i.x, e = i.y, n = Math.sin(i.y), s = Math.cos(i.y), r = W(t - this.long0), a, o, l, h, c, u, d, g, _, y, E, M, w, R, S, C, T, L, A, O, $, q, Z;
    return this.sphere ? Math.abs(this.sin_p12 - 1) <= B ? (i.x = this.x0 + this.a * (N - e) * Math.sin(r), i.y = this.y0 - this.a * (N - e) * Math.cos(r), i) : Math.abs(this.sin_p12 + 1) <= B ? (i.x = this.x0 + this.a * (N + e) * Math.sin(r), i.y = this.y0 + this.a * (N + e) * Math.cos(r), i) : (L = this.sin_p12 * n + this.cos_p12 * s * Math.cos(r), C = Math.acos(L), T = C ? C / Math.sin(C) : 1, i.x = this.x0 + this.a * T * s * Math.sin(r), i.y = this.y0 + this.a * T * (this.cos_p12 * n - this.sin_p12 * s * Math.cos(r)), i) : (a = Jr(this.es), o = Qr(this.es), l = ta(this.es), h = ea(this.es), Math.abs(this.sin_p12 - 1) <= B ? (c = this.a * _e(a, o, l, h, N), u = this.a * _e(a, o, l, h, e), i.x = this.x0 + (c - u) * Math.sin(r), i.y = this.y0 - (c - u) * Math.cos(r), i) : Math.abs(this.sin_p12 + 1) <= B ? (c = this.a * _e(a, o, l, h, N), u = this.a * _e(a, o, l, h, e), i.x = this.x0 + (c + u) * Math.sin(r), i.y = this.y0 + (c + u) * Math.cos(r), i) : (d = n / s, g = Gs(this.a, this.e, this.sin_p12), _ = Gs(this.a, this.e, n), y = Math.atan((1 - this.es) * d + this.es * g * this.sin_p12 / (_ * s)), E = Math.atan2(Math.sin(r), this.cos_p12 * Math.tan(y) - this.sin_p12 * Math.cos(r)), E === 0 ? A = Math.asin(this.cos_p12 * Math.sin(y) - this.sin_p12 * Math.cos(y)) : Math.abs(Math.abs(E) - Math.PI) <= B ? A = -Math.asin(this.cos_p12 * Math.sin(y) - this.sin_p12 * Math.cos(y)) : A = Math.asin(Math.sin(r) * Math.cos(y) / Math.sin(E)), M = this.e * this.sin_p12 / Math.sqrt(1 - this.es), w = this.e * this.cos_p12 * Math.cos(E) / Math.sqrt(1 - this.es), R = M * w, S = w * w, O = A * A, $ = O * A, q = $ * A, Z = q * A, C = g * A * (1 - O * S * (1 - S) / 6 + $ / 8 * R * (1 - 2 * S) + q / 120 * (S * (4 - 7 * S) - 3 * M * M * (1 - 7 * S)) - Z / 48 * R), i.x = this.x0 + C * Math.sin(E), i.y = this.y0 + C * Math.cos(E), i));
  }
  function xx(i) {
    i.x -= this.x0, i.y -= this.y0;
    var t, e, n, s, r, a, o, l, h, c, u, d, g, _, y, E, M, w, R, S, C, T, L, A;
    return this.sphere ? (t = Math.sqrt(i.x * i.x + i.y * i.y), t > 2 * N * this.a ? void 0 : (e = t / this.a, n = Math.sin(e), s = Math.cos(e), r = this.long0, Math.abs(t) <= B ? a = this.lat0 : (a = sn(s * this.sin_p12 + i.y * n * this.cos_p12 / t), o = Math.abs(this.lat0) - N, Math.abs(o) <= B ? this.lat0 >= 0 ? r = W(this.long0 + Math.atan2(i.x, -i.y)) : r = W(this.long0 - Math.atan2(-i.x, i.y)) : r = W(this.long0 + Math.atan2(i.x * n, t * this.cos_p12 * s - i.y * this.sin_p12 * n))), i.x = r, i.y = a, i)) : (l = Jr(this.es), h = Qr(this.es), c = ta(this.es), u = ea(this.es), Math.abs(this.sin_p12 - 1) <= B ? (d = this.a * _e(l, h, c, u, N), t = Math.sqrt(i.x * i.x + i.y * i.y), g = d - t, a = no(g / this.a, l, h, c, u), r = W(this.long0 + Math.atan2(i.x, -1 * i.y)), i.x = r, i.y = a, i) : Math.abs(this.sin_p12 + 1) <= B ? (d = this.a * _e(l, h, c, u, N), t = Math.sqrt(i.x * i.x + i.y * i.y), g = t - d, a = no(g / this.a, l, h, c, u), r = W(this.long0 + Math.atan2(i.x, i.y)), i.x = r, i.y = a, i) : (t = Math.sqrt(i.x * i.x + i.y * i.y), E = Math.atan2(i.x, i.y), _ = Gs(this.a, this.e, this.sin_p12), M = Math.cos(E), w = this.e * this.cos_p12 * M, R = -w * w / (1 - this.es), S = 3 * this.es * (1 - R) * this.sin_p12 * this.cos_p12 * M / (1 - this.es), C = t / _, T = C - R * (1 + R) * Math.pow(C, 3) / 6 - S * (1 + 3 * R) * Math.pow(C, 4) / 24, L = 1 - R * T * T / 2 - C * T * T * T / 6, y = Math.asin(this.sin_p12 * Math.cos(T) + this.cos_p12 * Math.sin(T) * M), r = W(this.long0 + Math.asin(Math.sin(E) * Math.sin(T) / Math.cos(y))), A = Math.sin(y), a = Math.atan2((A - this.es * L * this.sin_p12) * Math.tan(y), A * (1 - this.es)), i.x = r, i.y = a, i));
  }
  var wx = ["Azimuthal_Equidistant", "aeqd"];
  const Sx = {
    init: Ex,
    forward: Mx,
    inverse: xx,
    names: wx
  };
  function Cx() {
    this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
  }
  function Rx(i) {
    var t, e, n, s, r, a, o, l, h = i.x, c = i.y;
    return n = W(h - this.long0), t = Math.sin(c), e = Math.cos(c), s = Math.cos(n), a = this.sin_p14 * t + this.cos_p14 * e * s, r = 1, (a > 0 || Math.abs(a) <= B) && (o = this.a * r * e * Math.sin(n), l = this.y0 + this.a * r * (this.cos_p14 * t - this.sin_p14 * e * s)), i.x = o, i.y = l, i;
  }
  function Ix(i) {
    var t, e, n, s, r, a, o;
    return i.x -= this.x0, i.y -= this.y0, t = Math.sqrt(i.x * i.x + i.y * i.y), e = sn(t / this.a), n = Math.sin(e), s = Math.cos(e), a = this.long0, Math.abs(t) <= B ? (o = this.lat0, i.x = a, i.y = o, i) : (o = sn(s * this.sin_p14 + i.y * n * this.cos_p14 / t), r = Math.abs(this.lat0) - N, Math.abs(r) <= B ? (this.lat0 >= 0 ? a = W(this.long0 + Math.atan2(i.x, -i.y)) : a = W(this.long0 - Math.atan2(-i.x, i.y)), i.x = a, i.y = o, i) : (a = W(this.long0 + Math.atan2(i.x * n, t * this.cos_p14 * s - i.y * this.sin_p14 * n)), i.x = a, i.y = o, i));
  }
  var Tx = ["ortho"];
  const Ax = {
    init: Cx,
    forward: Rx,
    inverse: Ix,
    names: Tx
  };
  var kt = {
    FRONT: 1,
    RIGHT: 2,
    BACK: 3,
    LEFT: 4,
    TOP: 5,
    BOTTOM: 6
  }, It = {
    AREA_0: 1,
    AREA_1: 2,
    AREA_2: 3,
    AREA_3: 4
  };
  function bx() {
    this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= N - Rt / 2 ? this.face = kt.TOP : this.lat0 <= -(N - Rt / 2) ? this.face = kt.BOTTOM : Math.abs(this.long0) <= Rt ? this.face = kt.FRONT : Math.abs(this.long0) <= N + Rt ? this.face = this.long0 > 0 ? kt.RIGHT : kt.LEFT : this.face = kt.BACK, this.es !== 0 && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
  }
  function Px(i) {
    var t = { x: 0, y: 0 }, e, n, s, r, a, o, l = { value: 0 };
    if (i.x -= this.long0, this.es !== 0 ? e = Math.atan(this.one_minus_f_squared * Math.tan(i.y)) : e = i.y, n = i.x, this.face === kt.TOP)
      r = N - e, n >= Rt && n <= N + Rt ? (l.value = It.AREA_0, s = n - N) : n > N + Rt || n <= -(N + Rt) ? (l.value = It.AREA_1, s = n > 0 ? n - Qt : n + Qt) : n > -(N + Rt) && n <= -Rt ? (l.value = It.AREA_2, s = n + N) : (l.value = It.AREA_3, s = n);
    else if (this.face === kt.BOTTOM)
      r = N + e, n >= Rt && n <= N + Rt ? (l.value = It.AREA_0, s = -n + N) : n < Rt && n >= -Rt ? (l.value = It.AREA_1, s = -n) : n < -Rt && n >= -(N + Rt) ? (l.value = It.AREA_2, s = -n - N) : (l.value = It.AREA_3, s = n > 0 ? -n + Qt : -n - Qt);
    else {
      var h, c, u, d, g, _, y;
      this.face === kt.RIGHT ? n = ws(n, +N) : this.face === kt.BACK ? n = ws(n, 3.14159265359) : this.face === kt.LEFT && (n = ws(n, -N)), d = Math.sin(e), g = Math.cos(e), _ = Math.sin(n), y = Math.cos(n), h = g * y, c = g * _, u = d, this.face === kt.FRONT ? (r = Math.acos(h), s = Ra(r, u, c, l)) : this.face === kt.RIGHT ? (r = Math.acos(c), s = Ra(r, u, -h, l)) : this.face === kt.BACK ? (r = Math.acos(-h), s = Ra(r, u, -c, l)) : this.face === kt.LEFT ? (r = Math.acos(-c), s = Ra(r, u, h, l)) : (r = s = 0, l.value = It.AREA_0);
    }
    return o = Math.atan(12 / Qt * (s + Math.acos(Math.sin(s) * Math.cos(Rt)) - N)), a = Math.sqrt((1 - Math.cos(r)) / (Math.cos(o) * Math.cos(o)) / (1 - Math.cos(Math.atan(1 / Math.cos(s))))), l.value === It.AREA_1 ? o += N : l.value === It.AREA_2 ? o += Qt : l.value === It.AREA_3 && (o += 1.5 * Qt), t.x = a * Math.cos(o), t.y = a * Math.sin(o), t.x = t.x * this.a + this.x0, t.y = t.y * this.a + this.y0, i.x = t.x, i.y = t.y, i;
  }
  function Lx(i) {
    var t = { lam: 0, phi: 0 }, e, n, s, r, a, o, l, h, c, u = { value: 0 };
    if (i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a, n = Math.atan(Math.sqrt(i.x * i.x + i.y * i.y)), e = Math.atan2(i.y, i.x), i.x >= 0 && i.x >= Math.abs(i.y) ? u.value = It.AREA_0 : i.y >= 0 && i.y >= Math.abs(i.x) ? (u.value = It.AREA_1, e -= N) : i.x < 0 && -i.x >= Math.abs(i.y) ? (u.value = It.AREA_2, e = e < 0 ? e + Qt : e - Qt) : (u.value = It.AREA_3, e += N), c = Qt / 12 * Math.tan(e), a = Math.sin(c) / (Math.cos(c) - 1 / Math.sqrt(2)), o = Math.atan(a), s = Math.cos(e), r = Math.tan(n), l = 1 - s * s * r * r * (1 - Math.cos(Math.atan(1 / Math.cos(o)))), l < -1 ? l = -1 : l > 1 && (l = 1), this.face === kt.TOP)
      h = Math.acos(l), t.phi = N - h, u.value === It.AREA_0 ? t.lam = o + N : u.value === It.AREA_1 ? t.lam = o < 0 ? o + Qt : o - Qt : u.value === It.AREA_2 ? t.lam = o - N : t.lam = o;
    else if (this.face === kt.BOTTOM)
      h = Math.acos(l), t.phi = h - N, u.value === It.AREA_0 ? t.lam = -o + N : u.value === It.AREA_1 ? t.lam = -o : u.value === It.AREA_2 ? t.lam = -o - N : t.lam = o < 0 ? -o - Qt : -o + Qt;
    else {
      var d, g, _;
      d = l, c = d * d, c >= 1 ? _ = 0 : _ = Math.sqrt(1 - c) * Math.sin(o), c += _ * _, c >= 1 ? g = 0 : g = Math.sqrt(1 - c), u.value === It.AREA_1 ? (c = g, g = -_, _ = c) : u.value === It.AREA_2 ? (g = -g, _ = -_) : u.value === It.AREA_3 && (c = g, g = _, _ = -c), this.face === kt.RIGHT ? (c = d, d = -g, g = c) : this.face === kt.BACK ? (d = -d, g = -g) : this.face === kt.LEFT && (c = d, d = g, g = -c), t.phi = Math.acos(-_) - N, t.lam = Math.atan2(g, d), this.face === kt.RIGHT ? t.lam = ws(t.lam, -N) : this.face === kt.BACK ? t.lam = ws(t.lam, -3.14159265359) : this.face === kt.LEFT && (t.lam = ws(t.lam, +N));
    }
    if (this.es !== 0) {
      var y, E, M;
      y = t.phi < 0 ? 1 : 0, E = Math.tan(t.phi), M = this.b / Math.sqrt(E * E + this.one_minus_f_squared), t.phi = Math.atan(Math.sqrt(this.a * this.a - M * M) / (this.one_minus_f * M)), y && (t.phi = -t.phi);
    }
    return t.lam += this.long0, i.x = t.lam, i.y = t.phi, i;
  }
  function Ra(i, t, e, n) {
    var s;
    return i < B ? (n.value = It.AREA_0, s = 0) : (s = Math.atan2(t, e), Math.abs(s) <= Rt ? n.value = It.AREA_0 : s > Rt && s <= N + Rt ? (n.value = It.AREA_1, s -= N) : s > N + Rt || s <= -(N + Rt) ? (n.value = It.AREA_2, s = s >= 0 ? s - Qt : s + Qt) : (n.value = It.AREA_3, s += N)), s;
  }
  function ws(i, t) {
    var e = i + t;
    return e < -3.14159265359 ? e += Lr : e > 3.14159265359 && (e -= Lr), e;
  }
  var Ox = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
  const Nx = {
    init: bx,
    forward: Px,
    inverse: Lx,
    names: Ox
  };
  var Wl = [
    [1, 22199e-21, -715515e-10, 31103e-10],
    [0.9986, -482243e-9, -24897e-9, -13309e-10],
    [0.9954, -83103e-8, -448605e-10, -986701e-12],
    [0.99, -135364e-8, -59661e-9, 36777e-10],
    [0.9822, -167442e-8, -449547e-11, -572411e-11],
    [0.973, -214868e-8, -903571e-10, 18736e-12],
    [0.96, -305085e-8, -900761e-10, 164917e-11],
    [0.9427, -382792e-8, -653386e-10, -26154e-10],
    [0.9216, -467746e-8, -10457e-8, 481243e-11],
    [0.8962, -536223e-8, -323831e-10, -543432e-11],
    [0.8679, -609363e-8, -113898e-9, 332484e-11],
    [0.835, -698325e-8, -640253e-10, 934959e-12],
    [0.7986, -755338e-8, -500009e-10, 935324e-12],
    [0.7597, -798324e-8, -35971e-9, -227626e-11],
    [0.7186, -851367e-8, -701149e-10, -86303e-10],
    [0.6732, -986209e-8, -199569e-9, 191974e-10],
    [0.6213, -0.010418, 883923e-10, 624051e-11],
    [0.5722, -906601e-8, 182e-6, 624051e-11],
    [0.5322, -677797e-8, 275608e-9, 624051e-11]
  ], lr = [
    [-520417e-23, 0.0124, 121431e-23, -845284e-16],
    [0.062, 0.0124, -126793e-14, 422642e-15],
    [0.124, 0.0124, 507171e-14, -160604e-14],
    [0.186, 0.0123999, -190189e-13, 600152e-14],
    [0.248, 0.0124002, 710039e-13, -224e-10],
    [0.31, 0.0123992, -264997e-12, 835986e-13],
    [0.372, 0.0124029, 988983e-12, -311994e-12],
    [0.434, 0.0123893, -369093e-11, -435621e-12],
    [0.4958, 0.0123198, -102252e-10, -345523e-12],
    [0.5571, 0.0121916, -154081e-10, -582288e-12],
    [0.6176, 0.0119938, -241424e-10, -525327e-12],
    [0.6769, 0.011713, -320223e-10, -516405e-12],
    [0.7346, 0.0113541, -397684e-10, -609052e-12],
    [0.7903, 0.0109107, -489042e-10, -104739e-11],
    [0.8435, 0.0103431, -64615e-9, -140374e-14],
    [0.8936, 969686e-8, -64636e-9, -8547e-9],
    [0.9394, 840947e-8, -192841e-9, -42106e-10],
    [0.9761, 616527e-8, -256e-6, -42106e-10],
    [1, 328947e-8, -319159e-9, -42106e-10]
  ], Jf = 0.8487, Qf = 1.3523, tg = ri / 5, Fx = 1 / tg, ms = 18, so = function(i, t) {
    return i[0] + t * (i[1] + t * (i[2] + t * i[3]));
  }, Dx = function(i, t) {
    return i[1] + t * (2 * i[2] + t * 3 * i[3]);
  };
  function kx(i, t, e, n) {
    for (var s = t; n; --n) {
      var r = i(s);
      if (s -= r, Math.abs(r) < e)
        break;
    }
    return s;
  }
  function Gx() {
    this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
  }
  function zx(i) {
    var t = W(i.x - this.long0), e = Math.abs(i.y), n = Math.floor(e * tg);
    n < 0 ? n = 0 : n >= ms && (n = ms - 1), e = ri * (e - Fx * n);
    var s = {
      x: so(Wl[n], e) * t,
      y: so(lr[n], e)
    };
    return i.y < 0 && (s.y = -s.y), s.x = s.x * this.a * Jf + this.x0, s.y = s.y * this.a * Qf + this.y0, s;
  }
  function $x(i) {
    var t = {
      x: (i.x - this.x0) / (this.a * Jf),
      y: Math.abs(i.y - this.y0) / (this.a * Qf)
    };
    if (t.y >= 1)
      t.x /= Wl[ms][0], t.y = i.y < 0 ? -N : N;
    else {
      var e = Math.floor(t.y * ms);
      for (e < 0 ? e = 0 : e >= ms && (e = ms - 1); ; )
        if (lr[e][0] > t.y)
          --e;
        else if (lr[e + 1][0] <= t.y)
          ++e;
        else
          break;
      var n = lr[e], s = 5 * (t.y - n[0]) / (lr[e + 1][0] - n[0]);
      s = kx(function(r) {
        return (so(n, r) - t.y) / Dx(n, r);
      }, s, B, 100), t.x /= so(Wl[e], s), t.y = (5 * e + s) * Jt, i.y < 0 && (t.y = -t.y);
    }
    return t.x = W(t.x + this.long0), t;
  }
  var Ux = ["Robinson", "robin"];
  const Bx = {
    init: Gx,
    forward: zx,
    inverse: $x,
    names: Ux
  };
  function Wx() {
    this.name = "geocent";
  }
  function Xx(i) {
    var t = Uf(i, this.es, this.a);
    return t;
  }
  function Yx(i) {
    var t = Bf(i, this.es, this.a, this.b);
    return t;
  }
  var Zx = ["Geocentric", "geocentric", "geocent", "Geocent"];
  const qx = {
    init: Wx,
    forward: Xx,
    inverse: Yx,
    names: Zx
  };
  var le = {
    N_POLE: 0,
    S_POLE: 1,
    EQUIT: 2,
    OBLIQ: 3
  }, Qs = {
    h: { def: 1e5, num: !0 },
    // default is Karman line, no default in PROJ.7
    azi: { def: 0, num: !0, degrees: !0 },
    // default is North
    tilt: { def: 0, num: !0, degrees: !0 },
    // default is Nadir
    long0: { def: 0, num: !0 },
    // default is Greenwich, conversion to rad is automatic
    lat0: { def: 0, num: !0 }
    // default is Equator, conversion to rad is automatic
  };
  function Kx() {
    if (Object.keys(Qs).forEach((function(e) {
      if (typeof this[e] > "u")
        this[e] = Qs[e].def;
      else {
        if (Qs[e].num && isNaN(this[e]))
          throw new Error("Invalid parameter value, must be numeric " + e + " = " + this[e]);
        Qs[e].num && (this[e] = parseFloat(this[e]));
      }
      Qs[e].degrees && (this[e] = this[e] * Jt);
    }).bind(this)), Math.abs(Math.abs(this.lat0) - N) < B ? this.mode = this.lat0 < 0 ? le.S_POLE : le.N_POLE : Math.abs(this.lat0) < B ? this.mode = le.EQUIT : (this.mode = le.OBLIQ, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10)
      throw new Error("Invalid height");
    this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
    var i = this.tilt, t = this.azi;
    this.cg = Math.cos(t), this.sg = Math.sin(t), this.cw = Math.cos(i), this.sw = Math.sin(i);
  }
  function Vx(i) {
    i.x -= this.long0;
    var t = Math.sin(i.y), e = Math.cos(i.y), n = Math.cos(i.x), s, r;
    switch (this.mode) {
      case le.OBLIQ:
        r = this.sinph0 * t + this.cosph0 * e * n;
        break;
      case le.EQUIT:
        r = e * n;
        break;
      case le.S_POLE:
        r = -t;
        break;
      case le.N_POLE:
        r = t;
        break;
    }
    switch (r = this.pn1 / (this.p - r), s = r * e * Math.sin(i.x), this.mode) {
      case le.OBLIQ:
        r *= this.cosph0 * t - this.sinph0 * e * n;
        break;
      case le.EQUIT:
        r *= t;
        break;
      case le.N_POLE:
        r *= -(e * n);
        break;
      case le.S_POLE:
        r *= e * n;
        break;
    }
    var a, o;
    return a = r * this.cg + s * this.sg, o = 1 / (a * this.sw * this.h1 + this.cw), s = (s * this.cg - r * this.sg) * this.cw * o, r = a * o, i.x = s * this.a, i.y = r * this.a, i;
  }
  function jx(i) {
    i.x /= this.a, i.y /= this.a;
    var t = { x: i.x, y: i.y }, e, n, s;
    s = 1 / (this.pn1 - i.y * this.sw), e = this.pn1 * i.x * s, n = this.pn1 * i.y * this.cw * s, i.x = e * this.cg + n * this.sg, i.y = n * this.cg - e * this.sg;
    var r = Se(i.x, i.y);
    if (Math.abs(r) < B)
      t.x = 0, t.y = i.y;
    else {
      var a, o;
      switch (o = 1 - r * r * this.pfact, o = (this.p - Math.sqrt(o)) / (this.pn1 / r + r / this.pn1), a = Math.sqrt(1 - o * o), this.mode) {
        case le.OBLIQ:
          t.y = Math.asin(a * this.sinph0 + i.y * o * this.cosph0 / r), i.y = (a - this.sinph0 * Math.sin(t.y)) * r, i.x *= o * this.cosph0;
          break;
        case le.EQUIT:
          t.y = Math.asin(i.y * o / r), i.y = a * r, i.x *= o;
          break;
        case le.N_POLE:
          t.y = Math.asin(a), i.y = -i.y;
          break;
        case le.S_POLE:
          t.y = -Math.asin(a);
          break;
      }
      t.x = Math.atan2(i.x, i.y);
    }
    return i.x = t.x + this.long0, i.y = t.y, i;
  }
  var Hx = ["Tilted_Perspective", "tpers"];
  const Jx = {
    init: Kx,
    forward: Vx,
    inverse: jx,
    names: Hx
  };
  function Qx() {
    if (this.flip_axis = this.sweep === "x" ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10)
      throw new Error();
    if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, this.es !== 0) {
      var i = 1 - this.es, t = 1 / i;
      this.radius_p = Math.sqrt(i), this.radius_p2 = i, this.radius_p_inv2 = t, this.shape = "ellipse";
    } else
      this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
    this.title || (this.title = "Geostationary Satellite View");
  }
  function t2(i) {
    var t = i.x, e = i.y, n, s, r, a;
    if (t = t - this.long0, this.shape === "ellipse") {
      e = Math.atan(this.radius_p2 * Math.tan(e));
      var o = this.radius_p / Se(this.radius_p * Math.cos(e), Math.sin(e));
      if (s = o * Math.cos(t) * Math.cos(e), r = o * Math.sin(t) * Math.cos(e), a = o * Math.sin(e), (this.radius_g - s) * s - r * r - a * a * this.radius_p_inv2 < 0)
        return i.x = Number.NaN, i.y = Number.NaN, i;
      n = this.radius_g - s, this.flip_axis ? (i.x = this.radius_g_1 * Math.atan(r / Se(a, n)), i.y = this.radius_g_1 * Math.atan(a / n)) : (i.x = this.radius_g_1 * Math.atan(r / n), i.y = this.radius_g_1 * Math.atan(a / Se(r, n)));
    } else this.shape === "sphere" && (n = Math.cos(e), s = Math.cos(t) * n, r = Math.sin(t) * n, a = Math.sin(e), n = this.radius_g - s, this.flip_axis ? (i.x = this.radius_g_1 * Math.atan(r / Se(a, n)), i.y = this.radius_g_1 * Math.atan(a / n)) : (i.x = this.radius_g_1 * Math.atan(r / n), i.y = this.radius_g_1 * Math.atan(a / Se(r, n))));
    return i.x = i.x * this.a, i.y = i.y * this.a, i;
  }
  function e2(i) {
    var t = -1, e = 0, n = 0, s, r, a, o;
    if (i.x = i.x / this.a, i.y = i.y / this.a, this.shape === "ellipse") {
      this.flip_axis ? (n = Math.tan(i.y / this.radius_g_1), e = Math.tan(i.x / this.radius_g_1) * Se(1, n)) : (e = Math.tan(i.x / this.radius_g_1), n = Math.tan(i.y / this.radius_g_1) * Se(1, e));
      var l = n / this.radius_p;
      if (s = e * e + l * l + t * t, r = 2 * this.radius_g * t, a = r * r - 4 * s * this.C, a < 0)
        return i.x = Number.NaN, i.y = Number.NaN, i;
      o = (-r - Math.sqrt(a)) / (2 * s), t = this.radius_g + o * t, e *= o, n *= o, i.x = Math.atan2(e, t), i.y = Math.atan(n * Math.cos(i.x) / t), i.y = Math.atan(this.radius_p_inv2 * Math.tan(i.y));
    } else if (this.shape === "sphere") {
      if (this.flip_axis ? (n = Math.tan(i.y / this.radius_g_1), e = Math.tan(i.x / this.radius_g_1) * Math.sqrt(1 + n * n)) : (e = Math.tan(i.x / this.radius_g_1), n = Math.tan(i.y / this.radius_g_1) * Math.sqrt(1 + e * e)), s = e * e + n * n + t * t, r = 2 * this.radius_g * t, a = r * r - 4 * s * this.C, a < 0)
        return i.x = Number.NaN, i.y = Number.NaN, i;
      o = (-r - Math.sqrt(a)) / (2 * s), t = this.radius_g + o * t, e *= o, n *= o, i.x = Math.atan2(e, t), i.y = Math.atan(n * Math.cos(i.x) / t);
    }
    return i.x = i.x + this.long0, i;
  }
  var i2 = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
  const n2 = {
    init: Qx,
    forward: t2,
    inverse: e2,
    names: i2
  };
  var gr = 1.340264, mr = -0.081106, _r = 893e-6, pr = 3796e-6, ro = Math.sqrt(3) / 2;
  function s2() {
    this.es = 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0;
  }
  function r2(i) {
    var t = W(i.x - this.long0), e = i.y, n = Math.asin(ro * Math.sin(e)), s = n * n, r = s * s * s;
    return i.x = t * Math.cos(n) / (ro * (gr + 3 * mr * s + r * (7 * _r + 9 * pr * s))), i.y = n * (gr + mr * s + r * (_r + pr * s)), i.x = this.a * i.x + this.x0, i.y = this.a * i.y + this.y0, i;
  }
  function a2(i) {
    i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a;
    var t = 1e-9, e = 12, n = i.y, s, r, a, o, l, h;
    for (h = 0; h < e && (s = n * n, r = s * s * s, a = n * (gr + mr * s + r * (_r + pr * s)) - i.y, o = gr + 3 * mr * s + r * (7 * _r + 9 * pr * s), n -= l = a / o, !(Math.abs(l) < t)); ++h)
      ;
    return s = n * n, r = s * s * s, i.x = ro * i.x * (gr + 3 * mr * s + r * (7 * _r + 9 * pr * s)) / Math.cos(n), i.y = Math.asin(Math.sin(n) / ro), i.x = W(i.x + this.long0), i;
  }
  var o2 = ["eqearth", "Equal Earth", "Equal_Earth"];
  const l2 = {
    init: s2,
    forward: r2,
    inverse: a2,
    names: o2
  };
  var Fr = 1e-10;
  function h2() {
    var i;
    if (this.phi1 = this.lat1, Math.abs(this.phi1) < Fr)
      throw new Error();
    this.es ? (this.en = Hh(this.es), this.m1 = Bs(
      this.phi1,
      this.am1 = Math.sin(this.phi1),
      i = Math.cos(this.phi1),
      this.en
    ), this.am1 = i / (Math.sqrt(1 - this.es * this.am1 * this.am1) * this.am1), this.inverse = u2, this.forward = c2) : (Math.abs(this.phi1) + Fr >= N ? this.cphi1 = 0 : this.cphi1 = 1 / Math.tan(this.phi1), this.inverse = f2, this.forward = d2);
  }
  function c2(i) {
    var t = W(i.x - (this.long0 || 0)), e = i.y, n, s, r;
    return n = this.am1 + this.m1 - Bs(e, s = Math.sin(e), r = Math.cos(e), this.en), s = r * t / (n * Math.sqrt(1 - this.es * s * s)), i.x = n * Math.sin(s), i.y = this.am1 - n * Math.cos(s), i.x = this.a * i.x + (this.x0 || 0), i.y = this.a * i.y + (this.y0 || 0), i;
  }
  function u2(i) {
    i.x = (i.x - (this.x0 || 0)) / this.a, i.y = (i.y - (this.y0 || 0)) / this.a;
    var t, e, n, s;
    if (e = Se(i.x, i.y = this.am1 - i.y), s = Jh(this.am1 + this.m1 - e, this.es, this.en), (t = Math.abs(s)) < N)
      t = Math.sin(s), n = e * Math.atan2(i.x, i.y) * Math.sqrt(1 - this.es * t * t) / Math.cos(s);
    else if (Math.abs(t - N) <= Fr)
      n = 0;
    else
      throw new Error();
    return i.x = W(n + (this.long0 || 0)), i.y = ln(s), i;
  }
  function d2(i) {
    var t = W(i.x - (this.long0 || 0)), e = i.y, n, s;
    return s = this.cphi1 + this.phi1 - e, Math.abs(s) > Fr ? (i.x = s * Math.sin(n = t * Math.cos(e) / s), i.y = this.cphi1 - s * Math.cos(n)) : i.x = i.y = 0, i.x = this.a * i.x + (this.x0 || 0), i.y = this.a * i.y + (this.y0 || 0), i;
  }
  function f2(i) {
    i.x = (i.x - (this.x0 || 0)) / this.a, i.y = (i.y - (this.y0 || 0)) / this.a;
    var t, e, n = Se(i.x, i.y = this.cphi1 - i.y);
    if (e = this.cphi1 + this.phi1 - n, Math.abs(e) > N)
      throw new Error();
    return Math.abs(Math.abs(e) - N) <= Fr ? t = 0 : t = n * Math.atan2(i.x, i.y) / Math.cos(e), i.x = W(t + (this.long0 || 0)), i.y = ln(e), i;
  }
  var g2 = ["bonne", "Bonne (Werner lat_1=90)"];
  const m2 = {
    init: h2,
    names: g2
  };
  function _2(i) {
    i.Proj.projections.add(Oa), i.Proj.projections.add(Na), i.Proj.projections.add(cE), i.Proj.projections.add(EE), i.Proj.projections.add(RE), i.Proj.projections.add(PE), i.Proj.projections.add(kE), i.Proj.projections.add(BE), i.Proj.projections.add(qE), i.Proj.projections.add(JE), i.Proj.projections.add(mM), i.Proj.projections.add(MM), i.Proj.projections.add(RM), i.Proj.projections.add(LM), i.Proj.projections.add(kM), i.Proj.projections.add(BM), i.Proj.projections.add(qM), i.Proj.projections.add(JM), i.Proj.projections.add(sx), i.Proj.projections.add(hx), i.Proj.projections.add(gx), i.Proj.projections.add(vx), i.Proj.projections.add(Sx), i.Proj.projections.add(Ax), i.Proj.projections.add(Nx), i.Proj.projections.add(Bx), i.Proj.projections.add(qx), i.Proj.projections.add(Jx), i.Proj.projections.add(n2), i.Proj.projections.add(l2), i.Proj.projections.add(m2);
  }
  ue.defaultDatum = "WGS84";
  ue.Proj = ai;
  ue.WGS84 = new ue.Proj("WGS84");
  ue.Point = ks;
  ue.toPoint = Wf;
  ue.defs = fe;
  ue.nadgrid = dv;
  ue.transform = io;
  ue.mgrs = Tv;
  ue.version = "__VERSION__";
  _2(ue);
  const re = {
    ELEMENT: "element",
    MAP: "map",
    OFFSET: "offset",
    POSITION: "position",
    POSITIONING: "positioning"
  };
  class p2 extends Qe {
    /**
     * @param {Options} options Overlay options.
     */
    constructor(t) {
      super(), this.on, this.once, this.un, this.options = t, this.id = t.id, this.insertFirst = t.insertFirst !== void 0 ? t.insertFirst : !0, this.stopEvent = t.stopEvent !== void 0 ? t.stopEvent : !0, this.element = document.createElement("div"), this.element.className = t.className !== void 0 ? t.className : "ol-overlay-container " + i_, this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.autoPan = t.autoPan === !0 ? {} : t.autoPan || void 0, this.rendered = {
        transform_: "",
        visible: !0
      }, this.mapPostrenderListenerKey = null, this.addChangeListener(re.ELEMENT, this.handleElementChanged), this.addChangeListener(re.MAP, this.handleMapChanged), this.addChangeListener(re.OFFSET, this.handleOffsetChanged), this.addChangeListener(re.POSITION, this.handlePositionChanged), this.addChangeListener(re.POSITIONING, this.handlePositioningChanged), t.element !== void 0 && this.setElement(t.element), this.setOffset(t.offset !== void 0 ? t.offset : [0, 0]), this.setPositioning(t.positioning || "top-left"), t.position !== void 0 && this.setPosition(t.position);
    }
    /**
     * Get the DOM element of this overlay.
     * @return {HTMLElement|undefined} The Element containing the overlay.
     * @observable
     * @api
     */
    getElement() {
      return (
        /** @type {HTMLElement|undefined} */
        this.get(re.ELEMENT)
      );
    }
    /**
     * Get the overlay identifier which is set on constructor.
     * @return {number|string|undefined} Id.
     * @api
     */
    getId() {
      return this.id;
    }
    /**
     * Get the map associated with this overlay.
     * @return {import("./Map.js").default|null} The map that the
     * overlay is part of.
     * @observable
     * @api
     */
    getMap() {
      return (
        /** @type {import("./Map.js").default|null} */
        this.get(re.MAP) || null
      );
    }
    /**
     * Get the offset of this overlay.
     * @return {Array<number>} The offset.
     * @observable
     * @api
     */
    getOffset() {
      return (
        /** @type {Array<number>} */
        this.get(re.OFFSET)
      );
    }
    /**
     * Get the current position of this overlay.
     * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
     *     anchored at.
     * @observable
     * @api
     */
    getPosition() {
      return (
        /** @type {import("./coordinate.js").Coordinate|undefined} */
        this.get(re.POSITION)
      );
    }
    /**
     * Get the current positioning of this overlay.
     * @return {Positioning} How the overlay is positioned
     *     relative to its point on the map.
     * @observable
     * @api
     */
    getPositioning() {
      return (
        /** @type {Positioning} */
        this.get(re.POSITIONING)
      );
    }
    /**
     * @protected
     */
    handleElementChanged() {
      Bd(this.element);
      const t = this.getElement();
      t && this.element.appendChild(t);
    }
    /**
     * @protected
     */
    handleMapChanged() {
      var e;
      this.mapPostrenderListenerKey && ((e = this.element) == null || e.remove(), Pt(this.mapPostrenderListenerKey), this.mapPostrenderListenerKey = null);
      const t = this.getMap();
      if (t) {
        this.mapPostrenderListenerKey = vt(
          t,
          vi.POSTRENDER,
          this.render,
          this
        ), this.updatePixelPosition();
        const n = this.stopEvent ? t.getOverlayContainerStopEvent() : t.getOverlayContainer();
        this.insertFirst ? n.insertBefore(this.element, n.childNodes[0] || null) : n.appendChild(this.element), this.performAutoPan();
      }
    }
    /**
     * @protected
     */
    render() {
      this.updatePixelPosition();
    }
    /**
     * @protected
     */
    handleOffsetChanged() {
      this.updatePixelPosition();
    }
    /**
     * @protected
     */
    handlePositionChanged() {
      this.updatePixelPosition(), this.performAutoPan();
    }
    /**
     * @protected
     */
    handlePositioningChanged() {
      this.updatePixelPosition();
    }
    /**
     * Set the DOM element to be associated with this overlay.
     * @param {HTMLElement|undefined} element The Element containing the overlay.
     * @observable
     * @api
     */
    setElement(t) {
      this.set(re.ELEMENT, t);
    }
    /**
     * Set the map to be associated with this overlay.
     * @param {import("./Map.js").default|null} map The map that the
     * overlay is part of. Pass `null` to just remove the overlay from the current map.
     * @observable
     * @api
     */
    setMap(t) {
      this.set(re.MAP, t);
    }
    /**
     * Set the offset for this overlay.
     * @param {Array<number>} offset Offset.
     * @observable
     * @api
     */
    setOffset(t) {
      this.set(re.OFFSET, t);
    }
    /**
     * Set the position for this overlay. If the position is `undefined` the
     * overlay is hidden.
     * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
     *     is anchored at.
     * @observable
     * @api
     */
    setPosition(t) {
      this.set(re.POSITION, t);
    }
    /**
     * Pan the map so that the overlay is entirely visible in the current viewport
     * (if necessary) using the configured autoPan parameters
     * @protected
     */
    performAutoPan() {
      this.autoPan && this.panIntoView(this.autoPan);
    }
    /**
     * Pan the map so that the overlay is entirely visible in the current viewport
     * (if necessary).
     * @param {PanIntoViewOptions} [panIntoViewOptions] Options for the pan action
     * @api
     */
    panIntoView(t) {
      const e = this.getMap();
      if (!e || !e.getTargetElement() || !this.get(re.POSITION))
        return;
      const n = this.getRect(e.getTargetElement(), e.getSize()), s = this.getElement(), r = this.getRect(s, [
        s_(s),
        r_(s)
      ]);
      t = t || {};
      const a = t.margin === void 0 ? 20 : t.margin;
      if (!Rn(n, r)) {
        const o = r[0] - n[0], l = n[2] - r[2], h = r[1] - n[1], c = n[3] - r[3], u = [0, 0];
        if (o < 0 ? u[0] = o - a : l < 0 && (u[0] = Math.abs(l) + a), h < 0 ? u[1] = h - a : c < 0 && (u[1] = Math.abs(c) + a), u[0] !== 0 || u[1] !== 0) {
          const d = (
            /** @type {import("./coordinate.js").Coordinate} */
            e.getView().getCenterInternal()
          ), g = e.getPixelFromCoordinateInternal(d);
          if (!g)
            return;
          const _ = [g[0] + u[0], g[1] + u[1]], y = t.animation || {};
          e.getView().animateInternal({
            center: e.getCoordinateFromPixelInternal(_),
            duration: y.duration,
            easing: y.easing
          });
        }
      }
    }
    /**
     * Get the extent of an element relative to the document
     * @param {HTMLElement} element The element.
     * @param {import("./size.js").Size} size The size of the element.
     * @return {import("./extent.js").Extent} The extent.
     * @protected
     */
    getRect(t, e) {
      const n = t.getBoundingClientRect(), s = n.left + window.pageXOffset, r = n.top + window.pageYOffset;
      return [s, r, s + e[0], r + e[1]];
    }
    /**
     * Set the positioning for this overlay.
     * @param {Positioning} positioning how the overlay is
     *     positioned relative to its point on the map.
     * @observable
     * @api
     */
    setPositioning(t) {
      this.set(re.POSITIONING, t);
    }
    /**
     * Modify the visibility of the element.
     * @param {boolean} visible Element visibility.
     * @protected
     */
    setVisible(t) {
      this.rendered.visible !== t && (this.element.style.display = t ? "" : "none", this.rendered.visible = t);
    }
    /**
     * Update pixel position.
     * @protected
     */
    updatePixelPosition() {
      const t = this.getMap(), e = this.getPosition();
      if (!t || !t.isRendered() || !e) {
        this.setVisible(!1);
        return;
      }
      const n = t.getPixelFromCoordinate(e), s = t.getSize();
      this.updateRenderedPosition(n, s);
    }
    /**
     * @param {import("./pixel.js").Pixel} pixel The pixel location.
     * @param {import("./size.js").Size|undefined} mapSize The map size.
     * @protected
     */
    updateRenderedPosition(t, e) {
      const n = this.element.style, s = this.getOffset(), r = this.getPositioning();
      this.setVisible(!0);
      const a = Math.round(t[0] + s[0]) + "px", o = Math.round(t[1] + s[1]) + "px";
      let l = "0%", h = "0%";
      r == "bottom-right" || r == "center-right" || r == "top-right" ? l = "-100%" : (r == "bottom-center" || r == "center-center" || r == "top-center") && (l = "-50%"), r == "bottom-left" || r == "bottom-center" || r == "bottom-right" ? h = "-100%" : (r == "center-left" || r == "center-center" || r == "center-right") && (h = "-50%");
      const c = `translate(${l}, ${h}) translate(${a}, ${o})`;
      this.rendered.transform_ != c && (this.rendered.transform_ = c, n.transform = c);
    }
    /**
     * returns the options this Overlay has been created with
     * @return {Options} overlay options
     */
    getOptions() {
      return this.options;
    }
  }
  var hr = { exports: {} };
  const y2 = /* @__PURE__ */ jr(Iy), v2 = /* @__PURE__ */ jr(ly), E2 = /* @__PURE__ */ jr(dy), M2 = /* @__PURE__ */ jr(B0), x2 = /* @__PURE__ */ jr(C0);
  var w2 = hr.exports, Qu;
  function S2() {
    return Qu || (Qu = 1, function(i, t) {
      (function(e, n) {
        n(t, y2, v2, E2, M2, x2);
      })(w2, function(e, n, s, r, a, o) {
        var l = "comparison", h = [
          "PropertyIsEqualTo",
          "PropertyIsNotEqualTo",
          "PropertyIsLessThan",
          "PropertyIsLessThanOrEqualTo",
          "PropertyIsGreaterThan",
          "PropertyIsGreaterThanOrEqualTo"
        ], c = h.concat([
          "PropertyIsLike",
          "PropertyIsNull",
          "PropertyIsBetween"
        ]);
        function u(f) {
          return c.includes(f.localName);
        }
        function d(f) {
          return ["or", "and"].includes(f.localName.toLowerCase());
        }
        function g(f, m) {
          if (h.includes(f.localName))
            return _(f, m);
          if (f.localName === "PropertyIsBetween")
            return M(f, m);
          if (f.localName === "PropertyIsNull")
            return E(f, m);
          if (f.localName === "PropertyIsLike")
            return y(f, m);
          throw new Error("Unknown comparison element " + f.localName);
        }
        function _(f, m) {
          var p = {
            type: l,
            operator: f.localName.toLowerCase(),
            // Match case attribute is true by default, so only make it false if the attribute value equals 'false'.
            matchcase: f.getAttribute("matchCase") !== "false"
          }, v = {};
          return m(f, v, "expressions", {
            concatenateLiterals: !1
          }), v.expressions && v.expressions.children && (p.expression1 = v.expressions.children[0], p.expression2 = v.expressions.children[1]), p;
        }
        function y(f, m) {
          var p = _(f, m);
          return Object.assign(
            {},
            p,
            {
              wildcard: f.getAttribute("wildCard"),
              singlechar: f.getAttribute("singleChar"),
              escapechar: f.getAttribute("escapeChar")
            }
          );
        }
        function E(f, m) {
          var p = {};
          return m(f, p, "expressions", {
            concatenateLiterals: !1
          }), {
            type: l,
            operator: f.localName.toLowerCase(),
            expression: p.expressions
          };
        }
        function M(f, m) {
          var p = {
            type: l,
            operator: f.localName.toLowerCase(),
            // Match case attribute is true by default, so only make it false if the attribute value equals 'false'.
            matchcase: f.getAttribute("matchCase") !== "false"
          }, v = {};
          return m(f, v, "expressions", {
            concatenateLiterals: !1
          }), v.expressions && v.expressions.children && (p.expression = v.expressions.children[0], p.lowerboundary = v.expressions.children[1], p.upperboundary = v.expressions.children[2]), p;
        }
        function w(f, m) {
          for (var p = [], v = f.firstElementChild; v; v = v.nextElementSibling)
            v && u(v) && p.push(g(v, m)), v && d(v) && p.push(w(v, m)), v && v.localName.toLowerCase() === "not" && p.push(R(v, m));
          return {
            type: f.localName.toLowerCase(),
            predicates: p
          };
        }
        function R(f, m) {
          var p = null, v = f.firstElementChild;
          return v && u(v) && (p = g(v, m)), v && d(v) && (p = w(v, m)), v && v.localName.toLowerCase() === "not" && (p = R(v, m)), {
            type: f.localName.toLowerCase(),
            predicate: p
          };
        }
        function S(f, m) {
          for (var p = {}, v = f.firstElementChild; v; v = v.nextElementSibling)
            u(v) && (p = g(v, m)), d(v) && (p = w(v, m)), v.localName.toLowerCase() === "not" && (p = R(v, m)), v.localName.toLowerCase() === "featureid" && (p.type = "featureid", p.fids = p.fids || [], p.fids.push(v.getAttribute("fid")));
          return p;
        }
        var C = /* @__PURE__ */ new Set([
          "strokeWidth",
          "strokeOpacity",
          "strokeDashoffset",
          "fillOpacity",
          "fontSize"
        ]);
        function T(f, m, p) {
          var v = p.toLowerCase();
          m[v] = m[v] || [];
          var x = {};
          et(f, x), m[v].push(x);
        }
        function L(f, m, p) {
          var v = p.toLowerCase();
          m[v] = {}, et(f, m[v]);
        }
        function A(f, m, p, v) {
          v === void 0 && (v = !1);
          var x = p.toLowerCase();
          v ? m[x] = f.textContent.trim() : m[x] = f.textContent;
        }
        function O(f, m, p) {
          var v = p.toLowerCase(), x = parseFloat(f.textContent.trim());
          m[v] = x;
        }
        function $(f, m, p) {
          if (!Array.isArray(f))
            return f;
          var v = f.map(function(I) {
            return I.type === "literal" ? I.value : I;
          }).filter(function(I) {
            return I !== "";
          });
          if (p) {
            var x = v.every(
              function(I) {
                return typeof I != "object" || I === null;
              }
            );
            if (x)
              return v.join("");
          }
          return v.length === 1 ? v[0] : {
            type: "expression",
            typeHint: m,
            children: v
          };
        }
        function q(f, m, p, v) {
          v === void 0 && (v = {});
          for (var x = {
            skipEmptyNodes: !0,
            forceLowerCase: !0,
            typeHint: "string",
            concatenateLiterals: !0
          }, I = Object.assign(
            {},
            x,
            v
          ), P = [], z = 0; z < f.childNodes.length; z += 1) {
            var k = f.childNodes[z], G = {};
            if (k.namespaceURI === "http://www.opengis.net/ogc" && k.localName === "PropertyName")
              G.type = "propertyname", G.typeHint = I.typeHint, G.value = k.textContent.trim();
            else if (k.namespaceURI === "http://www.opengis.net/ogc" && k.localName === "Function") {
              var ft = k.getAttribute("name"), Et = k.getAttribute("fallbackValue") || null;
              G.type = "function", G.name = ft, G.fallbackValue = Et;
              var pt = {};
              q(k, pt, "params", {
                concatenateLiterals: !1
              }), Array.isArray(pt.params.children) ? G.params = pt.params.children : G.params = [pt.params];
            } else if (k.localName === "Add" || k.localName === "Sub" || k.localName === "Mul" || k.localName === "Div") {
              G.type = "function", G.name = "__fe:" + k.localName + "__", G.typeHint = "number";
              var Ft = {};
              q(k, Ft, "params", {
                concatenateLiterals: !1
              }), Array.isArray(Ft.params.children) ? G.params = Ft.params.children : G.params = [Ft.params];
            } else k.nodeName === "#cdata-section" ? (G.type = "literal", G.typeHint = I.typeHint, G.value = k.textContent) : k.nodeType !== Node.COMMENT_NODE && (G.type = "literal", G.typeHint = I.typeHint, G.value = k.textContent.trim());
            G.type === "literal" && I.skipEmptyNodes ? G.value.trim() && P.push(G) : P.push(G);
          }
          var bt = I.forceLowerCase ? p.toLowerCase() : p, Dt = $(
            P,
            I.typeHint,
            I.concatenateLiterals
          );
          typeof Dt == "string" && I.typeHint === "number" && (Dt = parseFloat(Dt)), m[bt] = Dt;
        }
        function Z(f, m, p, v) {
          v === void 0 && (v = {}), q(f, m, p, Object.assign({}, v, { typeHint: "number" }));
        }
        function Q(f, m) {
          var p = f.getElementsByTagNameNS(
            "http://www.opengis.net/sld",
            m
          );
          return p.length ? !!p.item(0).textContent : !1;
        }
        function X(f, m, p, v) {
          m[v] = m[v] || {};
          var x = f.getAttribute("name").toLowerCase().replace(/-(.)/g, function(P, z) {
            return z.toUpperCase();
          }), I = "string";
          v === "styling" && C.has(x) && (I = "number"), q(f, m[v], x, {
            skipEmptyNodes: !0,
            forceLowerCase: !1,
            typeHint: I
          });
        }
        var mt = {
          Filter: function(f, m) {
            m.filter = S(f, q);
          },
          ElseFilter: function(f, m) {
            m.elsefilter = !0;
          }
        }, V = {
          PolygonSymbolizer: T,
          LineSymbolizer: T,
          PointSymbolizer: T,
          TextSymbolizer: T,
          Fill: L,
          Stroke: L,
          GraphicStroke: L,
          GraphicFill: L,
          Graphic: L,
          ExternalGraphic: L,
          Gap: Z,
          InitialGap: Z,
          Mark: L,
          Label: function(f, m, p) {
            return q(f, m, p, { skipEmptyNodes: !1 });
          },
          Halo: L,
          Font: L,
          Radius: Z,
          LabelPlacement: L,
          PointPlacement: L,
          LinePlacement: L,
          PerpendicularOffset: Z,
          AnchorPoint: L,
          AnchorPointX: Z,
          AnchorPointY: Z,
          Opacity: Z,
          Rotation: Z,
          Displacement: L,
          DisplacementX: Z,
          DisplacementY: Z,
          Size: Z,
          WellKnownName: A,
          MarkIndex: O,
          VendorOption: function(f, m, p) {
            return X(f, m, p, "vendoroptions");
          },
          OnlineResource: function(f, m) {
            m.onlineresource = f.getAttribute("xlink:href");
          },
          CssParameter: function(f, m, p) {
            return X(f, m, p, "styling");
          },
          SvgParameter: function(f, m, p) {
            return X(f, m, p, "styling");
          }
        }, st = Object.assign(
          {},
          {
            NamedLayer: function(f, m) {
              T(f, m, "layers");
            },
            UserLayer: function(f, m) {
              T(f, m, "layers");
            },
            UserStyle: function(f, m) {
              m.styles = m.styles || [];
              var p = {
                default: Q(f, "IsDefault"),
                featuretypestyles: []
              };
              et(f, p), m.styles.push(p);
            },
            FeatureTypeStyle: function(f, m) {
              m.featuretypestyle = m.featuretypestyle || [];
              var p = {
                rules: []
              };
              et(f, p), m.featuretypestyles.push(p);
            },
            Rule: function(f, m) {
              var p = {};
              et(f, p), m.rules.push(p);
            },
            Name: A,
            Title: A,
            Abstract: A,
            Description: et,
            MaxScaleDenominator: O,
            MinScaleDenominator: O
          },
          mt,
          V
        );
        function et(f, m) {
          for (var p = f.firstElementChild; p; p = p.nextElementSibling)
            st[p.localName] && st[p.localName](p, m, p.localName);
        }
        function lt(f) {
          var m = {}, p = new DOMParser(), v = p.parseFromString(f, "application/xml"), x = v.documentElement;
          return m.version = x.getAttribute("version"), et(x, m), m;
        }
        var rt = /* @__PURE__ */ new Map();
        function tt(f, m) {
          if (typeof m != "function")
            throw new Error("Function implementation is not a function");
          rt[f] = m;
        }
        function D(f) {
          return rt[f] || null;
        }
        function _t(f) {
          switch ((f || {}).type) {
            case "expression":
              return !0;
            case "literal":
              return !1;
            case "propertyname":
              return !0;
            case "function":
              return !0;
            default:
              return !1;
          }
        }
        function U(f, m, p, v) {
          v === void 0 && (v = null);
          var x = null, I = typeof f;
          if (I === "string" || I === "number" || I === "undefined" || I === "boolean" || f === null)
            x = f;
          else if (f.type === "literal")
            x = f.value;
          else if (f.type === "propertyname") {
            var P = f.value;
            m ? typeof m.getGeometryName == "function" && P === m.getGeometryName() ? x = m.getGeometry() : x = p(m, P) : x = v;
          } else if (f.type === "expression")
            if (f.children.length === 1)
              x = U(
                f.children[0],
                m,
                p,
                v
              );
            else {
              for (var z = [], k = 0; k < f.children.length; k += 1)
                z.push(
                  // Do not use default values when evaluating children. Only apply default is
                  // the concatenated result is empty.
                  U(f.children[k], m, p, null)
                );
              x = z.join("");
            }
          else if (f.type === "function") {
            var G = D(f.name);
            if (!G)
              x = f.fallbackValue;
            else
              try {
                var ft = f.params.map(
                  function(Et) {
                    return U(Et, m, p);
                  }
                );
                x = G.apply(void 0, ft);
              } catch {
                x = f.fallbackValue;
              }
          }
          return x === 0 ? x : x === null || typeof x > "u" || x === "" || Number.isNaN(x) || f && f.typeHint === "number" && (x = Number(x), Number.isNaN(x)) ? v : x;
        }
        function dt(f) {
          return f == null;
        }
        function Vt(f, m) {
          return f < m ? -1 : f === m ? 0 : 1;
        }
        function jt(f) {
          return f === "" ? NaN : Number(f);
        }
        function $t(f, m, p) {
          var v = jt(f), x = jt(m);
          if (!(Number.isNaN(v) || Number.isNaN(x)))
            return Vt(v, x);
          var I = f.toString(), P = m.toString();
          return p ? I.localeCompare(P) : I.toLowerCase().localeCompare(P.toLowerCase());
        }
        function hi(f, m, p) {
          var v = U(f.expression, m, p);
          return dt(v);
        }
        function Ut(f, m, p) {
          var v = U(f.expression1, m, p);
          if (dt(v))
            return !1;
          var x = U(f.expression2, m, p);
          return dt(x) ? !1 : $t(v, x) < 0;
        }
        function hn(f, m, p) {
          var v = U(f.expression1, m, p);
          if (dt(v))
            return !1;
          var x = U(f.expression2, m, p);
          return dt(x) ? !1 : $t(v, x) > 0;
        }
        function Wn(f, m, p) {
          var v = U(f.expression, m, p);
          if (dt(v))
            return !1;
          var x = U(
            f.lowerboundary,
            m,
            p
          );
          if (dt(x))
            return !1;
          var I = U(
            f.upperboundary,
            m,
            p
          );
          return dt(I) ? !1 : $t(x, v) <= 0 && $t(I, v) >= 0;
        }
        function ci(f, m, p) {
          var v = U(f.expression1, m, p);
          if (dt(v))
            return !1;
          var x = U(f.expression2, m, p);
          return dt(x) ? !1 : !f.matchcase || typeof v == "boolean" || typeof x == "boolean" ? $t(v, x, !1) === 0 : v == x;
        }
        function ti(f, m, p) {
          var v = U(f.expression1, m, p);
          if (dt(v))
            return !1;
          var x = U(f.expression2, m, p);
          return dt(x) ? !1 : !ci(f, m, p);
        }
        function cn(f, m, p) {
          var v = U(f.expression1, m, p);
          if (dt(v))
            return !1;
          var x = U(f.expression2, m, p);
          if (dt(x))
            return !1;
          var I = f.wildcard, P = f.singlechar, z = f.escapechar, k = f.matchcase, G = x.replace(new RegExp("[" + I + "]", "g"), ".*");
          G = G.replace(
            new RegExp("[" + P + "]", "g"),
            "."
          ), z !== "\\" && (G = G.replace(
            new RegExp("[" + z + "]", "g"),
            "\\"
          )), G = "^" + G + "$";
          var ft = k === !1 ? new RegExp(G, "i") : new RegExp(G);
          return ft.test(v);
        }
        function Oe(f, m, p) {
          switch (f.operator) {
            case "propertyislessthan":
              return Ut(f, m, p);
            case "propertyisequalto":
              return ci(f, m, p);
            case "propertyislessthanorequalto":
              return ci(f, m, p) || Ut(f, m, p);
            case "propertyisnotequalto":
              return ti(f, m, p);
            case "propertyisgreaterthan":
              return hn(f, m, p);
            case "propertyisgreaterthanorequalto":
              return ci(f, m, p) || hn(f, m, p);
            case "propertyisbetween":
              return Wn(f, m, p);
            case "propertyisnull":
              return hi(f, m, p);
            case "propertyislike":
              return cn(f, m, p);
            default:
              throw new Error("Unkown comparison operator " + f.operator);
          }
        }
        function Ne(f, m) {
          for (var p = 0; p < f.length; p += 1)
            if (f[p] === m)
              return !0;
          return !1;
        }
        function Pi(f, m) {
          return f.properties[m];
        }
        function ui(f) {
          return f.id;
        }
        function Be(f, m, p) {
          p === void 0 && (p = {});
          var v = typeof p.getProperty == "function" ? p.getProperty : Pi, x = typeof p.getFeatureId == "function" ? p.getFeatureId : ui, I = f.type;
          switch (I) {
            case "featureid":
              return Ne(f.fids, x(m));
            case "comparison":
              return Oe(f, m, v);
            case "and": {
              if (!f.predicates)
                throw new Error("And filter must have predicates array.");
              return f.predicates.length === 0 ? !1 : f.predicates.every(
                function(P) {
                  return Be(P, m, p);
                }
              );
            }
            case "or": {
              if (!f.predicates)
                throw new Error("Or filter must have predicates array.");
              return f.predicates.some(
                function(P) {
                  return Be(P, m, p);
                }
              );
            }
            case "not": {
              if (!f.predicate)
                throw new Error("Not filter must have predicate.");
              return !Be(f.predicate, m, p);
            }
            default:
              throw new Error("Unknown filter type: " + I);
          }
        }
        function un(f, m) {
          return f.maxscaledenominator !== void 0 && f.minscaledenominator !== void 0 ? m / 28e-5 < f.maxscaledenominator && m / 28e-5 > f.minscaledenominator : f.maxscaledenominator !== void 0 ? m / 28e-5 < f.maxscaledenominator : f.minscaledenominator !== void 0 ? m / 28e-5 > f.minscaledenominator : !0;
        }
        function We(f) {
          return f.layers.map(function(m) {
            return m.name;
          });
        }
        function di(f, m) {
          return m ? f.layers.find(function(p) {
            return p.name === m;
          }) : f.layers[0];
        }
        function Yt(f) {
          return f.styles.map(function(m) {
            return m.name;
          });
        }
        function Ws(f, m) {
          if (m)
            return f.styles.find(function(v) {
              return v.name === m;
            });
          var p = f.styles.find(function(v) {
            return v.default;
          });
          return p || f.styles[0];
        }
        function dn(f, m, p, v) {
          v === void 0 && (v = {});
          for (var x = [], I = 0, P = 0; P < f.rules.length; P += 1) {
            var z = f.rules[P];
            un(z, p) && (z.elsefilter ? (x.push(z), I += 1) : z.filter ? Be(z.filter, m, v) && x.push(z) : x.push(z));
          }
          return I === x.length ? x : x.filter(function(k) {
            return !k.elsefilter;
          });
        }
        function fn(f) {
          var m = (f.polygonsymbolizer || []).concat(
            f.linesymbolizer || [],
            f.pointsymbolizer || [],
            f.textsymbolizer || []
          );
          return m;
        }
        function Xs(f, m) {
          if (f) {
            for (var p = f, v = (m || "").split("."), x = 0; x < v.length; x += 1) {
              var I = v[x];
              if (!(I in p))
                return;
              p = p[I];
            }
            return p;
          }
        }
        function Xn(f) {
          var m = {
            polygonSymbolizers: [],
            lineSymbolizers: [],
            pointSymbolizers: [],
            textSymbolizers: []
          };
          return (f || []).forEach(function(p) {
            p.polygonsymbolizer && (m.polygonSymbolizers = m.polygonSymbolizers.concat(p.polygonsymbolizer)), p.linesymbolizer && (m.lineSymbolizers = m.lineSymbolizers.concat(p.linesymbolizer)), p.pointsymbolizer && (m.pointSymbolizers = m.pointSymbolizers.concat(p.pointsymbolizer)), p.textsymbolizer && (m.textSymbolizers = m.textSymbolizers.concat(p.textsymbolizer));
          }), m;
        }
        var gn = "IMAGE_LOADING", mn = "IMAGE_LOADED", Ys = "IMAGE_ERROR", _n = 6, ia = 16, na = "PLACEMENT_DEFAULT", Yn = "PLACEMENT_FIRSTPOINT", Zs = "PLACEMENT_LASTPOINT", qs = [
          "graphic.externalgraphic",
          "stroke.graphicstroke.graphic.externalgraphic",
          "fill.graphicfill.graphic.externalgraphic"
        ], Zn = {};
        function pn(f, m) {
          Zn[f] = m;
        }
        function Li(f) {
          return Zn[f];
        }
        var Oi = {};
        function qn(f, m) {
          Oi[f] = m;
        }
        function Kn(f) {
          return Oi[f];
        }
        var de = {};
        function fi(f) {
          return de[f];
        }
        function ye(f, m) {
          de[f] = m;
        }
        function Ie(f, m) {
          for (var p = 0; p < qs.length; p += 1) {
            var v = qs[p], x = Xs(f, v);
            x && x.onlineresource === m && (f.__invalidated = !0, v.indexOf("graphicstroke") > -1 && (f.stroke.graphicstroke.__invalidated = !0));
          }
        }
        function ie(f, m) {
          if (f)
            if (!Array.isArray(f))
              Ie(f, m);
            else
              for (var p = 0; p < f.length; p += 1)
                Ie(f[p], m);
        }
        function Te(f, m) {
          f.rules && f.rules.forEach(function(p) {
            ie(p.pointsymbolizer, m), ie(p.linesymbolizer, m), ie(p.polygonsymbolizer, m);
          });
        }
        function Xe(f) {
          var m = fi(f);
          return m || (m = new Promise(function(p, v) {
            var x = new Image();
            x.onload = function() {
              pn(f, {
                url: f,
                image: x,
                width: x.naturalWidth,
                height: x.naturalHeight
              }), qn(f, mn), p(f);
            }, x.onerror = function() {
              qn(f, Ys), v();
            }, x.src = f;
          }), qn(f, gn), ye(f, m), m);
        }
        function Nt(f, m, p) {
          Te(m, f), Xe(f).then(function() {
            Te(m, f), typeof p == "function" && p(f);
          }).catch(function() {
            Te(m, f), typeof p == "function" && p();
          });
        }
        function Ht(f, m, p, v) {
          f.forEach(function(x) {
            var I = fn(x);
            I.forEach(function(P) {
              qs.forEach(function(z) {
                var k = Xs(P, z);
                if (k) {
                  var G = k.onlineresource, ft = Kn(G);
                  (!ft || ft === gn) && (v[G] || (v[G] = !0, Nt(
                    G,
                    m,
                    p
                  )));
                }
              });
            });
          });
        }
        function Ye(f, m, p) {
          p === void 0 && (p = 0);
          var v = Li(f), x = v.image, I = v.width, P = v.height;
          return new n.Style({
            image: new n.Icon({
              img: x,
              imgSize: [I, P],
              // According to SLD spec, if size is given, image height should equal the given size.
              scale: m / P || 1,
              rotation: Math.PI * p / 180
            })
          });
        }
        var sa = new n.Style({}), sg = new n.Style({
          image: new n.Circle({
            radius: 8,
            fill: new n.Fill({
              color: "blue",
              fillOpacity: 0.7
            })
          })
        }), ic = new n.Style({
          image: new n.Circle({
            radius: 5,
            fill: new n.Fill({
              color: "#DDDDDD"
            }),
            stroke: new n.Stroke({
              width: 1,
              color: "#888888"
            })
          })
        }), nc = new n.Style({
          fill: new n.Fill({
            color: "#DDDDDD"
          }),
          stroke: new n.Stroke({
            color: "#888888",
            width: 1
          })
        }), rg = new n.Style({
          image: new n.RegularShape({
            angle: Math.PI / 4,
            fill: new n.Fill({
              color: "red"
            }),
            points: 4,
            radius: 8,
            radius2: 0,
            stroke: new n.Stroke({
              color: "red",
              width: 4
            })
          })
        }), ag = new n.Style({
          fill: new n.Fill({
            color: "red"
          }),
          stroke: new n.Stroke({
            color: "red",
            width: 1
          })
        });
        function ra(f) {
          var m = /* @__PURE__ */ new WeakMap();
          return function(p) {
            var v = m.get(p);
            return (!v || p.__invalidated) && (v = f(p), p.__invalidated = !1, m.set(p, v)), v;
          };
        }
        function og(f, m) {
          var p = parseInt(f.slice(1, 3), 16), v = parseInt(f.slice(3, 5), 16), x = parseInt(f.slice(5, 7), 16);
          return m || m === 0 ? "rgba(" + p + ", " + v + ", " + x + ", " + m + ")" : "rgb(" + p + ", " + v + ", " + x + ")";
        }
        function Vn(f, m) {
          return m !== null && m < 1 && f.startsWith("#") ? og(f, m) : f;
        }
        function lg(f, m) {
          var p = f.stroke, v = p.graphicstroke, x = p.styling;
          if ("gap" in v)
            return v.gap + m;
          var I = 1;
          if (x && x.strokeDasharray) {
            var P = x.strokeDasharray.split(" ");
            P.length >= 2 && P[0] !== 0 && (I = P[1] / P[0] + 1);
          }
          return I * m;
        }
        function hg(f) {
          var m = f.stroke, p = m.graphicstroke;
          return p.initialgap || 0;
        }
        function aa(f, m, p, v, x) {
          x === void 0 && (x = 0);
          var I = m / 2, P = Math.PI * x / 180, z;
          switch (v && v.getColor() && (z = v.getColor()), f) {
            case "circle":
              return new n.Circle({
                fill: v,
                radius: I,
                stroke: p
              });
            case "triangle":
              return new n.RegularShape({
                fill: v,
                points: 3,
                radius: I,
                stroke: p,
                rotation: P
              });
            case "star":
              return new n.RegularShape({
                fill: v,
                points: 5,
                radius: I,
                radius2: I / 2.5,
                stroke: p,
                rotation: P
              });
            case "cross":
              return new n.RegularShape({
                fill: v,
                points: 4,
                radius: I,
                radius2: 0,
                stroke: p || new n.Stroke({
                  color: z,
                  width: I / 2
                }),
                rotation: P
              });
            case "hexagon":
              return new n.RegularShape({
                fill: v,
                points: 6,
                radius: I,
                stroke: p || new n.Stroke({
                  color: z,
                  width: I / 2
                }),
                rotation: P
              });
            case "octagon":
              return new n.RegularShape({
                angle: Math.PI / 8,
                fill: v,
                points: 8,
                radius: I / Math.cos(Math.PI / 8),
                stroke: p || new n.Stroke({
                  color: z,
                  width: I / 2
                }),
                rotation: P
              });
            case "cross2":
            // cross2 is used by QGIS for the x symbol.
            case "x":
              return new n.RegularShape({
                angle: Math.PI / 4,
                fill: v,
                points: 4,
                radius: Math.sqrt(2) * I,
                radius2: 0,
                stroke: p || new n.Stroke({
                  color: z,
                  width: I / 2
                }),
                rotation: P
              });
            case "diamond":
              return new n.RegularShape({
                fill: v,
                points: 4,
                radius: I,
                stroke: p,
                rotation: P
              });
            case "horline":
              return new n.RegularShape({
                fill: v,
                points: 2,
                radius: I,
                angle: Math.PI / 2,
                stroke: p,
                rotation: P
              });
            case "line":
              return new n.RegularShape({
                fill: v,
                points: 2,
                radius: I,
                angle: 0,
                stroke: p,
                rotation: P
              });
            case "backslash":
              return new n.RegularShape({
                fill: v,
                points: 2,
                radius: I * Math.sqrt(2),
                angle: -Math.PI / 4,
                stroke: p,
                rotation: P
              });
            case "slash":
              return new n.RegularShape({
                fill: v,
                points: 2,
                radius: I * Math.sqrt(2),
                angle: Math.PI / 4,
                stroke: p,
                rotation: P
              });
            default:
              return new n.RegularShape({
                angle: Math.PI / 4,
                fill: v,
                points: 4,
                // For square, scale radius so the height of the square equals the given size.
                radius: I * Math.sqrt(2),
                stroke: p,
                rotation: P
              });
          }
        }
        function oa(f) {
          if (f) {
            var m = f.styling || {}, p = U(m.stroke, null, null, "#000000"), v = U(m.strokeOpacity, null, null, 1), x = U(m.strokeWidth, null, null, 1), I = U(
              m.strokeDashoffset,
              null,
              null,
              0
            ), P = {
              color: Vn(p, v),
              width: x,
              lineDashOffset: I
            }, z = U(m.strokeLinejoin, null, null);
            z !== null && (P.lineJoin = z);
            var k = U(m.strokeLinecap, null, null);
            k !== null && (P.lineCap = k);
            var G = U(m.strokeDasharray, null, null);
            return G !== null && (P.lineDash = G.split(" ")), new n.Stroke(P);
          }
        }
        function No(f) {
          if (f) {
            var m = f.styling || {}, p = U(m.fill, null, null, "#808080"), v = U(m.fillOpacity, null, null, 1);
            return new n.Fill({ color: Vn(p, v) });
          }
        }
        function Fo(f, m, p, v) {
          var x = f.getFill();
          if (!x || typeof v != "function")
            return !1;
          var I = !1, P = m.fill || {}, z = P.styling || {};
          if (_t(z.fill) || _t(z.fillOpacity)) {
            var k = U(z.fill, p, v, "#808080"), G = U(
              z.fillOpacity,
              p,
              v,
              1
            );
            x.setColor(Vn(k, G)), I = !0;
          }
          return I;
        }
        function la(f, m, p, v) {
          var x = f.getStroke();
          if (!x || typeof v != "function")
            return !1;
          var I = !1, P = m.stroke || {}, z = P.styling || {};
          if (_t(z.strokeWidth)) {
            var k = U(
              z.strokeWidth,
              p,
              v,
              1
            );
            x.setWidth(k), I = !0;
          }
          if (_t(z.stroke) || _t(z.strokeOpacity)) {
            var G = U(
              z.stroke,
              p,
              v,
              "#000000"
            ), ft = U(
              z.strokeOpacity,
              p,
              v,
              1
            );
            x.setColor(Vn(G, ft)), I = !0;
          }
          return I;
        }
        function cg(f, m, p, v) {
          var x = f.getText();
          if (!x || typeof v != "function")
            return !1;
          if (m.fill && m.fill.styling && (_t(m.fill.styling.fill) || _t(m.fill.styling.fillOpacity))) {
            var I = {
              stroke: {
                styling: {
                  stroke: m.fill.styling.fill,
                  strokeOpacity: m.fill.styling.fillOpacity
                }
              }
            };
            la(
              x,
              I,
              p,
              v
            );
          }
          if (m.halo && m.halo.fill && m.halo.fill.styling && (_t(m.halo.fill.styling.fill) || _t(m.halo.fill.styling.fillOpacity)) && Fo(x, m.halo, p, v), m.halo && _t(m.halo.radius)) {
            var P = U(
              m.halo.radius,
              p,
              v,
              1
            ), z = x.getStroke();
            if (z) {
              var k = (P === 2 || P === 4 ? P - 1e-5 : P) * 2;
              z.setWidth(k);
            }
          }
          return !1;
        }
        var ug = No({ styling: { fill: "#888888" } }), dg = oa({ styling: { stroke: {} } });
        function fg(f) {
          var m = f.graphic, p = U(m.size, null, null, _n), v = U(m.rotation, null, null, 0);
          if (m.externalgraphic && m.externalgraphic.onlineresource) {
            m.size || (p = null);
            var x = m.externalgraphic.onlineresource;
            switch (Kn(x)) {
              case mn:
                return Ye(
                  x,
                  p,
                  v
                );
              case gn:
                return ic;
              case Ys:
                return rg;
              default:
                return ic;
            }
          }
          if (m.mark) {
            var I = m.mark, P = I.wellknownname, z = No(m.mark.fill), k = oa(m.mark.stroke);
            return new n.Style({
              // Note: size will be set dynamically later.
              image: aa(
                P,
                p,
                k,
                z,
                v
              )
            });
          }
          return new n.Style({
            image: aa(
              "square",
              p,
              dg,
              ug,
              v
            )
          });
        }
        var gg = ra(fg);
        function yn(f, m, p) {
          if (!(f && f.graphic))
            return sa;
          var v = gg(f);
          v.setGeometry(null);
          var x = v.getImage(), I = f.graphic, P = I.size, z = I.rotation, k = Number(U(P, m, p)) || _n, G = Number(U(z, m, p)) || 0;
          if (_t(P))
            if (I.externalgraphic && I.externalgraphic.onlineresource) {
              var ft = x.getSize()[1], Et = k / ft || 1;
              x.setScale(Et);
            } else I.mark && I.mark.wellknownname === "circle" ? x.setRadius(k * 0.5) : (x = aa(
              I.mark && I.mark.wellknownname || "square",
              k,
              // Note: re-use stroke and fill instances for a (small?) performance gain.
              x.getStroke(),
              x.getFill(),
              G
            ), v.setImage(x));
          if (_t(z)) {
            var pt = Math.PI * G / 180;
            x.setRotation(pt);
          }
          if (I.mark) {
            var Ft = la(
              x,
              I.mark,
              m,
              p
            ), bt = Fo(
              x,
              I.mark,
              m,
              p
            );
            (Ft || bt) && (x = aa(
              I.mark && I.mark.wellknownname || "square",
              k,
              x.getStroke(),
              x.getFill(),
              G
            ), v.setImage(x));
          }
          var Dt = I.displacement;
          if (Dt) {
            var Bt = Dt.displacementx, ne = Dt.displacementy;
            if (typeof Bt < "u" || typeof ne < "u") {
              var se = U(Bt, m, p) || 0, Ae = U(ne, m, p) || 0;
              (se !== 0 || Ae !== 0) && x.setDisplacement([se, Ae]);
            }
          }
          return v;
        }
        function sc(f, m) {
          var p = f[0] - m[0], v = f[1] - m[1];
          return Math.sqrt(p * p + v * v);
        }
        function mg(f, m, p) {
          var v = sc(f, m), x = p / v, I = f[0] + (m[0] - f[0]) * x, P = f[1] + (m[1] - f[1]) * x;
          return [I, P];
        }
        function Do(f, m, p) {
          var v = m[0] - f[0], x = m[1] - f[1], I = -Math.atan2(p ? -x : x, v);
          return I;
        }
        function rc(f, m, p) {
          p === void 0 && (p = {});
          var v = {
            minimumGraphicSpacing: 0
          }, x = Object.assign(v, p), I = f.getCoordinates();
          if (I.length === 0)
            return [];
          if (I.length === 1)
            return [I[0].concat([0])];
          if (x.placement === Yn) {
            var P = I[0], z = I[1];
            return [[P[0], P[1], Do(P, z, x.invertY)]];
          }
          if (x.placement === Zs) {
            var k = I[I.length - 2], G = I[I.length - 1];
            return [[G[0], G[1], Do(k, G, x.invertY)]];
          }
          for (var ft = f.getLength(), Et = Math.max(m, x.minimumGraphicSpacing), pt = x.initialGap || 0, Ft = 0, bt = [].concat(I[0]), Dt = [].concat(I[1]), Bt = 0, ne = []; pt <= ft; ) {
            var se = sc(
              bt,
              Dt
            );
            if (Bt + se < pt) {
              if (Ft === I.length - 2)
                break;
              bt[0] = Dt[0], bt[1] = Dt[1], Dt[0] = I[Ft + 2][0], Dt[1] = I[Ft + 2][1], Ft += 1, Bt += se;
            } else {
              var Ae = pt - Bt, Ni = mg(
                bt,
                Dt,
                Ae
              ), jn = Do(
                bt,
                Dt,
                x.invertY
              );
              (!x.extent || a.containsCoordinate(x.extent, Ni)) && (Ni.push(jn), ne.push(Ni)), pt += Et;
            }
          }
          return ne;
        }
        function ac(f) {
          var m = rc(f, f.getLength() / 2), p = m[1], v = p[0], x = p[1];
          return [v, x];
        }
        var oc = !1;
        function _g(f) {
          if (!oc) {
            var m = Object.getPrototypeOf(f);
            m.setImageStyle2 = function(p, v) {
              m.setImageStyle.call(this, p), this.image_ && (this.imageRotation_ = v);
            }, oc = !0;
          }
        }
        function lc(f, m, p, v, x, I) {
          if (m) {
            if (Array.isArray(m[0][0])) {
              m.forEach(function(k) {
                lc(
                  f,
                  k,
                  p,
                  v,
                  x,
                  I
                );
              });
              return;
            }
            if (!(m.length < 2)) {
              var P = v.getImage();
              if (P) {
                var z = rc(
                  new r.LineString(m),
                  p * x,
                  {
                    invertY: !0,
                    // Pixel y-coordinates increase downwards in screen space.
                    extent: f.extent_,
                    placement: I.placement,
                    initialGap: I.initialGap,
                    // Use graphic spacing of at least 0.1 px to prevent an infinite number of split points happening by accident.
                    minimumGraphicSpacing: 0.1
                  }
                );
                z.forEach(function(k) {
                  var G = P.getRotation() + k[2];
                  f.setImageStyle2(P, G), f.drawPoint(new r.Point([k[0] / x, k[1] / x]));
                });
              }
            }
          }
        }
        function hc(f, m) {
          if (!(f.stroke && f.stroke.graphicstroke))
            throw new Error(
              "getGraphicStrokeRenderer error: symbolizer.stroke.graphicstroke null or undefined."
            );
          var p = f.stroke, v = p.graphicstroke, x = {
            placement: na
          };
          return f.vendoroptions && (f.vendoroptions.placement === "firstPoint" ? x.placement = Yn : f.vendoroptions.placement === "lastPoint" && (x.placement = Zs)), function(I, P) {
            var z = P.feature.getGeometry().getType();
            if (!(z === "Point" || z === "MultiPoint")) {
              var k = P.pixelRatio || 1, G = s.toContext(P.context);
              _g(G);
              var ft = _n;
              v.graphic && v.graphic.externalgraphic && (ft = ia);
              var Et = yn(
                v,
                P.feature,
                m
              ), pt = v.graphic && v.graphic.size || ft, Ft = Number(
                U(
                  pt,
                  P.feature,
                  m,
                  ft
                )
              ), bt = lg(f, Ft);
              x.initialGap = hg(f), lc(
                G,
                I,
                bt,
                Et,
                k,
                x
              );
            }
          };
        }
        function pg(f, m) {
          if (!(f.stroke && f.stroke.graphicstroke))
            throw new Error(
              "getGraphicStrokeStyle error: linesymbolizer.stroke.graphicstroke null or undefined."
            );
          return new n.Style({
            renderer: hc(f, m)
          });
        }
        function yg(f) {
          return f.stroke && f.stroke.graphicstroke ? pg(f) : new n.Style({
            stroke: oa(f.stroke)
          });
        }
        var vg = ra(yg);
        function cc(f, m, p) {
          var v = vg(f);
          return la(v, f, m, p), v;
        }
        var uc = [[1, 1]], dc = [
          [0, 0],
          [2, 2]
        ], fc = [
          [0, 0],
          [1, 1],
          [2, 2],
          [3, 3],
          [2, 0],
          [0, 2]
        ], Eg = [
          [0, 0],
          [1, 1]
        ];
        function Mg(f, m) {
          m.forEach(function(p) {
            var v = p[0], x = p[1];
            f.fillRect(v, x, 1, 1);
          });
        }
        function xg(f, m) {
          m.forEach(function(p) {
            var v = p[0], x = p[1];
            f.clearRect(v, x, 1, 1);
          });
        }
        function gc(f) {
          var m = f.getContext("2d");
          if (o.DEVICE_PIXEL_RATIO === 1)
            return m.createPattern(f, "repeat");
          var p = document.createElement("canvas");
          p.width = f.width * o.DEVICE_PIXEL_RATIO, p.height = f.height * o.DEVICE_PIXEL_RATIO;
          var v = p.getContext("2d");
          return v.imageSmoothingEnabled = !1, v.drawImage(
            f,
            0,
            0,
            f.width,
            f.height,
            0,
            0,
            p.width,
            p.height
          ), v.createPattern(p, "repeat");
        }
        function ha(f, m, p) {
          var v = document.createElement("canvas");
          v.width = f, v.height = f;
          var x = v.getContext("2d");
          return x.fillStyle = m, Mg(x, p), gc(v);
        }
        function ko(f, m, p) {
          var v = document.createElement("canvas");
          v.width = f, v.height = f;
          var x = v.getContext("2d");
          return x.fillStyle = m, x.fillRect(0, 0, f, f), xg(x, p), gc(v);
        }
        function wg(f, m) {
          var p = null;
          switch (f) {
            case "brush://dense1":
              p = new n.Fill({
                color: ko(4, m, uc)
              });
              break;
            case "brush://dense2":
              p = new n.Fill({
                color: ko(4, m, dc)
              });
              break;
            case "brush://dense3":
              p = new n.Fill({
                color: ko(4, m, fc)
              });
              break;
            case "brush://dense4":
              p = new n.Fill({
                color: ha(2, m, Eg)
              });
              break;
            case "brush://dense5":
              p = new n.Fill({
                color: ha(4, m, fc)
              });
              break;
            case "brush://dense6":
              p = new n.Fill({
                color: ha(4, m, dc)
              });
              break;
            case "brush://dense7":
              p = new n.Fill({
                color: ha(4, m, uc)
              });
              break;
            default:
              p = new n.Fill({ color: m });
              break;
          }
          return p;
        }
        function Sg(f) {
          var m = Li(
            f.externalgraphic.onlineresource
          ), p = m.image, v = m.width, x = m.height, I = document.createElement("canvas"), P = I.getContext("2d"), z = o.DEVICE_PIXEL_RATIO;
          if (f.size && x !== f.size && (z *= f.size / x), z === 1)
            return P.createPattern(p, "repeat");
          var k = document.createElement("canvas"), G = k.getContext("2d");
          return k.width = v * z, k.height = x * z, G.drawImage(
            p,
            0,
            0,
            v,
            x,
            0,
            0,
            v * z,
            x * z
          ), P.createPattern(k, "repeat");
        }
        function Cg(f) {
          var m = f.fill.graphicfill, p = m.graphic, v = p.externalgraphic.onlineresource;
          switch (Kn(v)) {
            case mn:
              return new n.Fill({
                color: Sg(f.fill.graphicfill.graphic)
              });
            case gn:
              return nc.getFill();
            case Ys:
              return ag.getFill();
            default:
              return nc.getFill();
          }
        }
        function Rg(f, m) {
          if (!f.graphic)
            return f;
          var p = JSON.parse(JSON.stringify(f)), v = p.graphic, x = Number(v.size) || _n;
          v.size = m * x;
          var I = v.mark;
          if (I && I.stroke) {
            I.stroke.styling || (I.stroke.styling = {
              stroke: "#000000",
              strokeWidth: 1
            }), I.stroke.styling.strokeWidth || (I.stroke.styling.strokeWidth = Number(I.stroke.styling.strokeWidth) || 1);
            var P = I.stroke.styling.strokeWidth;
            P > 1 && (I.stroke.styling.strokeWidth = m * P);
          }
          return p;
        }
        function Ig(f) {
          var m = f.fill, p = m.graphicfill, v = p.graphic, x = v.mark, I = x || {}, P = I.wellknownname;
          if (P && P.indexOf("brush://") === 0) {
            var z = "#000000";
            return x.fill && x.fill.styling && x.fill.styling.fill && (z = x.fill.styling.fill), wg(P, z);
          }
          var k = Number(v.size) || _n, G = k * o.DEVICE_PIXEL_RATIO, ft = null, Et = 2;
          try {
            var pt = document.createElement("canvas");
            pt.width = G * Et, pt.height = G * Et;
            var Ft = pt.getContext("2d"), bt = Rg(p, Et), Dt = yn(bt), Bt = s.toContext(Ft, {
              size: [k * Et, k * Et]
            });
            Ft.imageSmoothingEnabled = !1, Bt.setStyle(Dt);
            var ne = Et * (k / 2), se = Et * (k / 2);
            Bt.drawGeometry(new r.Point([ne, se])), P && P.indexOf("slash") > -1 && (Bt.drawGeometry(
              new r.Point([ne - Et * k, se])
            ), Bt.drawGeometry(
              new r.Point([ne + Et * k, se])
            ), Bt.drawGeometry(
              new r.Point([ne, se - Et * k])
            ), Bt.drawGeometry(
              new r.Point([ne, se + Et * k])
            ));
            var Ae = document.createElement("canvas");
            Ae.width = G, Ae.height = G;
            var Ni = Ae.getContext("2d");
            Ni.drawImage(
              pt,
              0,
              0,
              G * Et,
              G * Et,
              0,
              0,
              G,
              G
            );
            var jn = Ni.createPattern(Ae, "repeat");
            ft = new n.Fill({
              color: jn
            });
          } catch {
            ft = new n.Fill({
              color: "#000000"
            });
          }
          return ft;
        }
        function Tg(f) {
          var m = f.fill && f.fill.graphicfill && f.fill.graphicfill.graphic && f.fill.graphicfill.graphic.externalgraphic && f.fill.graphicfill.graphic.externalgraphic.onlineresource, p = f.fill && f.fill.graphicfill && f.fill.graphicfill.graphic && f.fill.graphicfill.graphic.mark, v = null;
          if (m ? v = Cg(f) : p ? v = Ig(f) : v = No(f.fill), f.stroke && f.stroke.graphicstroke) {
            var x = hc(f);
            return new n.Style({
              renderer: function(P, z) {
                if (v) {
                  var k = z.feature, G = z.context, ft = s.toContext(G);
                  ft.setFillStrokeStyle(v, void 0);
                  var Et = k.getGeometry().getType();
                  Et === "Polygon" ? ft.drawPolygon(new r.Polygon(P)) : Et === "MultiPolygon" && ft.drawMultiPolygon(new r.MultiPolygon(P));
                }
                x(P, z);
              }
            });
          }
          var I = oa(f.stroke);
          return new n.Style({
            fill: v,
            stroke: I
          });
        }
        var Ag = ra(Tg);
        function bg(f, m, p) {
          var v = Ag(f);
          return Fo(v, f, m, p), la(v, f, m, p), v;
        }
        function Pg(f) {
          if (!(f && f.label))
            return sa;
          var m = U(f.label, null, null, ""), p = f.font ? f.font.styling || {} : {}, v = U(p.fontFamily, null, null, "sans-serif"), x = U(p.fontSize, null, null, 10), I = U(p.fontStyle, null, null, ""), P = U(p.fontWeight, null, null, ""), z = I + " " + P + " " + x + "px " + v, k = f && f.labelplacement && f.labelplacement.pointplacement ? f.labelplacement.pointplacement : {}, G = U(
            k.rotation,
            null,
            null,
            0
          ), ft = k && k.displacement ? k.displacement : {}, Et = U(ft.displacementx, null, null, 0), pt = -U(ft.displacementy, null, null, 0), Ft = k && k.anchorpoint || {}, bt = "center", Dt = U(Ft.anchorpointx, null, null, NaN);
          Dt < 0.25 ? bt = "left" : Dt > 0.75 && (bt = "right");
          var Bt = "middle", ne = U(Ft.anchorpointy, null, null, NaN);
          ne < 0.25 ? Bt = "bottom" : ne > 0.75 && (Bt = "top");
          var se = f.fill ? f.fill.styling : {}, Ae = U(se.fill, null, null, "#000000"), Ni = U(se.fillOpacity, null, null, 1), jn = {
            text: m,
            font: z,
            offsetX: Et,
            offsetY: pt,
            rotation: Math.PI * G / 180,
            textAlign: bt,
            textBaseline: Bt,
            fill: new n.Fill({
              color: Vn(Ae, Ni)
            })
          };
          if (f.halo) {
            var Uo = f.halo && f.halo.fill ? f.halo.fill.styling : {}, Zg = U(Uo.fill, null, null, "#FFFFFF"), qg = U(Uo.fillOpacity, null, null, 1), ca = U(f.halo.radius, null, null, 1);
            jn.stroke = new n.Stroke({
              color: Vn(Zg, qg),
              // wrong position width radius equal to 2 or 4
              width: (ca === 2 || ca === 4 ? ca - 1e-5 : ca) * 2
            });
          }
          return new n.Style({
            text: new n.Text(jn)
          });
        }
        var Lg = ra(Pg);
        function Go(f, m, p) {
          var v = Lg(f), x = v.getText();
          if (!x)
            return v;
          var I = f.label, P = f.labelplacement;
          if (_t(I)) {
            var z = U(I, m, p, "");
            x.setText(z.toString());
          }
          if (P) {
            var k = P.pointplacement && P.pointplacement.rotation || 0;
            if (_t(k)) {
              var G = U(
                k,
                m,
                p,
                0
              );
              x.setRotation(Math.PI * G / 180);
            }
          }
          var ft = m.getGeometry ? m.getGeometry() : m.geometry, Et = ft.getType ? ft.getType() : ft.type, pt = f && f.labelplacement && f.labelplacement.lineplacement ? f.labelplacement.lineplacement : null, Ft = Et !== "point" && pt ? "line" : "point";
          if (x.setPlacement(Ft), cg(v, f, m, p), f.font && f.font.styling) {
            var bt = f.font.styling || {};
            if (_t(bt.fontFamily) || _t(bt.fontStyle) || _t(bt.fontWeight) || _t(bt.fontSize)) {
              var Dt = U(
                bt.fontFamily,
                m,
                p,
                "sans-serif"
              ), Bt = U(
                bt.fontStyle,
                m,
                p,
                ""
              ), ne = U(
                bt.fontWeight,
                m,
                p,
                ""
              ), se = U(bt.fontSize, m, p, 10), Ae = Bt + " " + ne + " " + se + "px " + Dt;
              x.setFont(Ae);
            }
          }
          return v;
        }
        function Og(f, m) {
          if (typeof m.getGeometry != "function")
            return null;
          var p = m.getGeometry();
          if (!p)
            return null;
          var v = null, x = p.getType();
          if (x === "LineString")
            v = yn(f, m), v.setGeometry(new r.Point(ac(p)));
          else if (x === "MultiLineString") {
            var I = p.getLineStrings(), P = I.map(ac);
            v = yn(f, m), v.setGeometry(new r.MultiPoint(P));
          }
          return v;
        }
        function mc(f) {
          var m = f.getInteriorPoint().getCoordinates(), p = m[0], v = m[1];
          return [p, v];
        }
        function Ng(f, m) {
          if (typeof m.getGeometry != "function")
            return null;
          var p = m.getGeometry();
          if (!p)
            return null;
          var v = null, x = p.getType();
          if (x === "Polygon")
            v = yn(f, m), v.setGeometry(new r.Point(mc(p)));
          else if (x === "MultiPolygon") {
            var I = p.getPolygons(), P = I.map(mc);
            v = yn(f, m), v.setGeometry(new r.MultiPoint(P));
          }
          return v;
        }
        var Fg = [sg];
        function gi(f, m, p, v, x) {
          (m || []).forEach(function(I) {
            var P = v(I, p, x);
            P && f.push(P);
          });
        }
        function zo(f, m, p, v) {
          v === void 0 && (v = {});
          var x = f.polygonSymbolizers, I = f.lineSymbolizers, P = f.pointSymbolizers, z = f.textSymbolizers, k = {
            strictGeometryMatch: !1,
            useFallbackStyles: !0
          }, G = Object.assign({}, k, v), ft = m.getGeometry ? m.getGeometry() : m.geometry, Et = ft.getType ? ft.getType() : ft.type, pt = [];
          switch (Et) {
            case "Point":
            case "MultiPoint":
              gi(
                pt,
                P,
                m,
                yn,
                p
              ), gi(pt, z, m, Go, p);
              break;
            case "LineString":
            case "MultiLineString":
              gi(pt, I, m, cc, p), G.strictGeometryMatch || gi(
                pt,
                P,
                m,
                Og,
                p
              ), gi(pt, z, m, Go, p);
              break;
            case "Polygon":
            case "MultiPolygon":
              gi(
                pt,
                x,
                m,
                bg,
                p
              ), G.strictGeometryMatch || gi(
                pt,
                I,
                m,
                cc,
                p
              ), gi(
                pt,
                P,
                m,
                Ng,
                p
              ), gi(pt, z, m, Go, p);
              break;
            default:
              G.useFallbackStyles && (pt = Fg);
          }
          return pt.forEach(function(Ft, bt) {
            return Ft.setZIndex(bt);
          }), pt;
        }
        function Dg(f) {
          return f.getId();
        }
        function kg(f, m) {
          return f.get(m);
        }
        function Gg(f, m) {
          m === void 0 && (m = {});
          var p = m.imageLoadedCallback || function() {
          }, v = {};
          return function(x, I) {
            var P = typeof m.convertResolution == "function" ? m.convertResolution(I) : I, z = typeof m.getProperty == "function" ? m.getProperty : kg, k = dn(f, x, P, {
              getProperty: z,
              getFeatureId: Dg
            });
            Ht(
              k,
              f,
              p,
              v
            );
            var G = Xn(k), ft = zo(G, x, z);
            return ft;
          };
        }
        function zg(f, m) {
          var p = Xn([f]), v = zo(
            p,
            { geometry: { type: m } },
            function() {
              return null;
            },
            { strictGeometryMatch: !0, useFallbackStyles: !1 }
          );
          return v.filter(function(x) {
            return x !== null;
          });
        }
        function vn(f) {
          if (f === null)
            return "";
          var m = typeof f;
          switch (m) {
            case "string":
              return f;
            case "number":
            case "bigint":
            case "boolean":
              return f.toString();
            case "undefined":
              return "";
            default:
              return m;
          }
        }
        function _c(f) {
          return vn(f).toLowerCase();
        }
        function pc(f) {
          return vn(f).toUpperCase();
        }
        function $g(f, m, p) {
          var v = Number(m), x = Number(p);
          if (Number.isNaN(v))
            return "";
          var I = vn(f);
          return Number.isNaN(x) ? v > 0 ? I.slice(v - 1) : I.slice(v) : x === 0 ? "" : v > 0 ? x > 0 ? I.slice(v - 1, v - 1 + x) : I.slice(v - 1, x) : x > 0 ? v + x < 0 ? I.slice(v, v + x) : I.slice(v) : I.slice(v, x);
        }
        function Ug(f, m, p) {
          var v = vn(f), x = Number(m), I = Number(p);
          return Number.isNaN(x) || Number.isNaN(I) ? "" : v.slice(x, I);
        }
        function Bg(f, m) {
          var p = vn(f), v = Number(m);
          return Number.isNaN(v) ? "" : p.slice(v);
        }
        function $o(f) {
          return f && typeof f.getType == "function" ? f.getType() : "Unknown";
        }
        function Wg(f) {
          switch ($o(f)) {
            case "Point":
            case "MultiPoint":
              return 0;
            case "LineString":
            case "LinearRing":
            case "Circle":
            case "MultiLineString":
              return 1;
            case "Polygon":
            case "MultiPolygon":
              return 2;
            default:
              return 0;
          }
        }
        function Xg(f) {
          switch ($o(f)) {
            case "Point":
            case "MultiPoint":
              return "Point";
            case "LineString":
            case "LinearRing":
            case "Circle":
            case "MultiLineString":
              return "Line";
            case "Polygon":
            case "MultiPolygon":
              return "Polygon";
            default:
              return "Unknown";
          }
        }
        function yc() {
          for (var f = [], m = arguments.length; m--; ) f[m] = arguments[m];
          var p = f[0], v = f.slice(1), x = vn(p);
          return v.some(function(I) {
            return vn(I) === x;
          });
        }
        function Yg() {
          tt("lower", _c), tt("upper", pc), tt("geometry_type", Xg), tt("substr", $g), tt("strToLowerCase", _c), tt("strToUpperCase", pc), tt("strSubstring", Ug), tt("strSubstringStart", Bg), tt("geometryType", $o), tt("dimension", Wg), tt("in", yc);
          for (var f = 2; f <= 10; f += 1)
            tt("in" + f, yc);
          tt("__fe:Add__", function(m, p) {
            return Number(m) + Number(p);
          }), tt("__fe:Sub__", function(m, p) {
            return Number(m) - Number(p);
          }), tt("__fe:Mul__", function(m, p) {
            return Number(m) * Number(p);
          }), tt("__fe:Div__", function(m, p) {
            return Number(m) / Number(p);
          });
        }
        Yg(), e.OlStyler = zo, e.Reader = lt, e.categorizeSymbolizers = Xn, e.createOlStyle = zg, e.createOlStyleFunction = Gg, e.getByPath = Xs, e.getFunction = D, e.getLayer = di, e.getLayerNames = We, e.getRuleSymbolizers = fn, e.getRules = dn, e.getStyle = Ws, e.getStyleNames = Yt, e.registerFunction = tt;
      });
    }(hr, hr.exports)), hr.exports;
  }
  var Ia = S2();
  ue.defs("EPSG:25832", "+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs +axis=enu");
  ue.defs("http://www.opengis.net/def/crs/EPSG/0/25832", ue.defs("EPSG:25832"));
  S1(ue);
  const yl = At("EPSG:25832");
  class Xl extends qi {
    // Initialize custom properties
    constructor() {
      super(), this.vectorLayers = [], this.styles = {
        fillColor: "#ffffff",
        strokeColor: "#000000",
        strokeWidth: 1
      }, this.gmlFile = null, this.sldFile = null, this.xmlFile = null;
    }
    /**
     * Called when the component is added to the DOM. Retrieve the GML, SLD and metadata
     * files and pass them to the respective loading functions.
     */
    connectedCallback() {
      super.connectedCallback(), this.gmlFile && fetch(this.gmlFile).then((t) => t.text()).then((t) => {
        if (this.sldFile)
          return fetch(this.sldFile).then((e) => e.text()).then((e) => {
            this.loadGML(t, e);
          });
        this.loadGML(t, null);
      }).catch((t) => console.error("Error loading GML or SLD:", t)), this.xmlFile && fetch(this.xmlFile).then((t) => t.text()).then((t) => {
        this.loadMetadata(t);
      }).catch((t) => console.error("Error loading XML:", t));
    }
    firstUpdated() {
      this.initMaps(), this.initHoverPopup();
    }
    // Initialize the map
    initMaps() {
      this.baseLayer1 = new Pu({
        visible: !0,
        type: "base",
        size: [256, 256],
        source: new Nu({
          url: "https://services.datafordeler.dk/DKskaermkort/topo_skaermkort_daempet/1.0.0/wmts?username=QKJBQATHVS&password=ytxCA8UGM5n0Z*zi",
          layer: "topo_skaermkort_daempet",
          matrixSet: "View1",
          format: "image/jpeg",
          style: "default",
          tileGrid: new Lu({
            extent: [12e4, 59e5, 1e6, 65e5],
            resolutions: [1638.4, 819.2, 409.6, 204.8, 102.4, 51.2, 25.6, 12.8, 6.4, 3.2, 1.6, 0.8, 0.4, 0.2],
            matrixIds: ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13"]
          })
        }),
        view: new Ke({
          maxZoom: 14,
          minZoom: 0
        })
      }), this.baseLayer2 = new Pu({
        visible: !1,
        // Initially hidden
        source: new Nu({
          url: "https://services.datafordeler.dk/GeoDanmarkOrto/orto_foraar_wmts/1.0.0/wmts?username=RNIOENOTLD&password=LaKage!7562Hesten",
          layer: "orto_foraar_wmts",
          matrixSet: "KortforsyningTilingDK",
          style: "default",
          format: "image/jpeg",
          tileGrid: new Lu({
            extent: [12e4, 59e5, 1e6, 65e5],
            resolutions: [1638.4, 819.2, 409.6, 204.8, 102.4, 51.2, 25.6, 12.8, 6.4, 3.2, 1.6, 0.8, 0.4, 0.2],
            matrixIds: ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13"]
          })
        })
      }), this.map = new Xp({
        target: this.shadowRoot.getElementById("map"),
        layers: [this.baseLayer1, this.baseLayer2],
        view: new Ke({
          center: [6e5, 6225e3],
          zoom: 9,
          projection: yl
        }),
        controls: []
      }), this.updateComplete.then(() => {
        const t = this.shadowRoot.getElementById("layer-switcher"), e = this.shadowRoot.querySelector(".radio-options");
        t && e ? (t.addEventListener("click", (n) => {
          n.target.closest("svg") && (e.style.display = e.style.display === "none" || !e.style.display ? "block" : "none");
        }), t.addEventListener("change", (n) => {
          if (n.target.name === "base-layer") {
            const s = n.target.value;
            this.baseLayer1.setVisible(s === "1"), this.baseLayer2.setVisible(s === "2");
          }
        })) : console.error("Layer switcher element or radio options not found");
      });
    }
    initHoverPopup() {
      const t = document.createElement("div");
      t.id = "popup", t.style.cssText = `
      background: white;
      border: 1px solid black;
      padding: 0.5rem;
      border-radius: 1rem;
      font-size: 12px;
      box-shadow: 0px 2px 10px rgba(0, 0, 0, 0.2);
      pointer-events: none;
      position: absolute;
      display: none;
      width: max-content;
    `, this.shadowRoot.appendChild(t), this.overlay = new p2({
        element: t,
        offset: [10, 10],
        positioning: "center-left"
      }), this.map.addOverlay(this.overlay), this.map.on("pointermove", (e) => {
        const n = this.map.forEachFeatureAtPixel(e.pixel, (s) => s);
        if (n) {
          const s = n.get("navn"), r = n.get("type");
          let a = "";
          s && (a += `<strong>${s}</strong><br/>`), r && (a += `Type: ${r}`), a ? (t.innerHTML = a, t.style.display = "block", this.overlay.setPosition(e.coordinate)) : t.style.display = "none";
        } else
          t.style.display = "none";
      });
    }
    // Zoom in on map
    zoomIn() {
      const t = this.map.getView();
      t.setZoom(t.getZoom() + 1);
    }
    // Zoom out on map
    zoomOut() {
      const t = this.map.getView();
      t.setZoom(t.getZoom() - 1);
    }
    /**
     * Uploads the given files to the map.
     * @param {Event} event The event containing the files.
     */
    uploadFiles(t) {
      const e = [...t.target.files], n = e.find((o) => o.name.endsWith(".gml")), s = e.find((o) => o.name.endsWith(".sld")), r = e.find((o) => o.name.endsWith(".geojson")), a = e.find((o) => o.name.endsWith(".xml"));
      if (n) {
        const o = new FileReader();
        o.onload = () => {
          if (s) {
            const l = new FileReader();
            l.onload = () => {
              this.loadGML(o.result, l.result);
            }, l.readAsText(s);
          } else
            this.loadGML(o.result, null);
        }, o.readAsText(n);
      }
      if (r) {
        const o = new FileReader();
        o.onload = () => {
          this.loadMetadata(JSON.parse(o.result));
        }, o.readAsText(r);
      }
      if (a) {
        const o = new FileReader();
        o.onload = () => {
          this.loadMetadata(o.result);
        }, o.readAsText(a);
      }
    }
    /**
     * Loads metadata from a given string or object.
     *
     * If the metadata is a string, it is assumed to be in XML format and is parsed using a DOMParser.
     * If the metadata is an object, it is assumed to have a 'properties' property that contains the metadata.
     *
     * The metadata is then displayed on the map or in a designated UI element.
     *
     * @param {string|object} metadata - The metadata to load.
     */
    loadMetadata(t) {
      let e;
      if (typeof t == "string") {
        const h = new DOMParser().parseFromString(t, "application/xml");
        e = Array.from(h.documentElement.children).reduce((c, u) => (c[u.tagName] = u.textContent, c), {});
      } else if (t.properties)
        e = t.properties;
      else {
        console.warn("Unsupported metadata format.");
        return;
      }
      const n = this.shadowRoot.querySelector("#map-container");
      if (!n) {
        console.error("Map container not found");
        return;
      }
      let s = n.querySelector("#metadata-box");
      s || (s = document.createElement("div"), s.id = "metadata-box", s.style.cssText = `
      position: absolute;
      top: 1rem;
      left: 1rem;
      background: rgba(255, 255, 255, 0.95);
      padding: 1rem;
      border-radius: 0.5rem;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      max-height: 52rem;
      overflow-y: auto;
      max-width: 25rem;
      z-index: 10;
    `, n.appendChild(s));
      let r = "";
      for (const [l, h] of Object.entries(e)) {
        const c = l.replace(/^mdb:/i, "").replace(/([A-Z])/g, " $1").trim(), u = c.charAt(0).toUpperCase() + c.slice(1);
        r += `<div style="margin-bottom: 8px;"><strong>${u}:</strong> ${h}</div>`;
      }
      s.innerHTML = `
    <button id="toggle-metadata" style="background:none; border:none; font-size:1rem; cursor:pointer;">
        Metadata 
    </button>
    <div id="metadata-content" style="display:none; margin-top:10px;">
        ${r}
    </div>
  `;
      const a = s.querySelector("#toggle-metadata"), o = s.querySelector("#metadata-content");
      a.addEventListener("click", () => {
        const l = o.style.display === "block";
        o.style.display = l ? "none" : "block", a.textContent = l ? "Metadata " : "Metadata ";
      });
    }
    /**
     * Loads GML data from a given string and applies it to the map.
     *
     * The GML data is parsed using a DOMParser and then grouped by feature type.
     * The feature groups are then applied to the map using the applyFeatureGroupsToMap method.
     *
     * @param {string} gmlString - The GML data to load.
     * @param {string} [sldString] - The SLD data to use for styling.
     */
    loadGML(t, e = null) {
      this.shadowRoot.getElementById("map-legend").style.display = "block";
      const { features: n, xmlDoc: s } = this.parseGML(t), r = this.groupFeaturesByType(n, s);
      this.resetLayers(), this.applyFeatureGroupsToMap(r, e);
      const a = n.length > 0 ? n[0].getGeometry().getExtent().slice() : null;
      n.forEach((o) => {
        const l = o.getGeometry().getExtent();
        a && mo(a, l);
      }), a && this.map.getView().fit(a, {
        size: this.map.getSize(),
        padding: [50, 50, 50, 50],
        maxZoom: 18
      });
    }
    /**
     * Removes all vector layers from the map and resets the data toggle.
     *
     * This function is called when a new GML file is selected and we want to remove all the
     * previously added vector layers from the map and reset the data toggle.
     */
    resetLayers() {
      this.vectorLayers.forEach((e) => {
        this.map.removeLayer(e);
      }), this.vectorLayers = [];
      const t = this.shadowRoot.getElementById("map-legend");
      t.innerHTML = "Vlg Lag:";
    }
    /**
     * Parses GML data from a given string, returning features and the XML document.
     *
     * This function attempts to parse the provided GML string using the GML32 format.
     * It returns an object containing the parsed features and the XML document.
     *
     * @param {string} gmlString - The GML data to parse.
     * @returns {Object} An object with 'features' array and 'xmlDoc' XML document.
     */
    parseGML(t) {
      try {
        const e = new wt();
        let s = new DOMParser().parseFromString(t, "application/xml");
        const a = new XMLSerializer().serializeToString(s).replace(/<rgeo:/g, "<gml:").replace(/<\/rgeo:/g, "</gml:");
        return { features: e.readFeatures(a, {
          featureProjection: yl,
          dataProjection: yl
        }), xmlDoc: s };
      } catch (e) {
        return console.error("Failed to parse GML file:", e), { features: [], xmlDoc: null };
      }
    }
    /**
     * Applies SLD styles to the map.
     *
     * This function takes an SLD object, a feature type and the view projection as input and
     * applies the SLD styles to the map. If the SLD object is null, null is returned. If the
     * feature type is not found in the SLD object, a warning is logged and null is returned. If
     * the feature type is found but the style is not found, a warning is logged and null is
     * returned.
     *
     * @param {Object} sldObject - The SLD object to apply styles from.
     * @param {string} type - The feature type to apply the styles to.
     * @param {ol/proj/Projection} viewProjection - The view projection of the map.
     * @returns {ol/style/StyleFunction} The style function to apply to the map.
     */
    applySLDStyles(t, e, n) {
      if (!t) return null;
      const s = Ia.getLayer(t, e);
      if (!s)
        return console.warn("No named layer found for " + e), null;
      const r = Ia.getStyle(s);
      if (!r)
        return console.warn("No style found for layer " + s), null;
      const a = r.featuretypestyles[0];
      return Ia.createOlStyleFunction(a, {
        convertResolution: (o) => {
          const l = this.map.getView().getCenter();
          return Cl(n, o, l);
        },
        imageLoadedCallback: () => {
          this.map.changed();
        }
      });
    }
    /**
     * Gets the style for the given geometry type
     * @param {string} geometryType The type of geometry (Polygon, MultiPolygon, LineString, Point)
     * @param {Style} [sldStyle] The SLD style to use (optional)
     * @returns {Style} The style for the given geometry type
     */
    getStyle(t, e = null) {
      if (e)
        return e;
      const { fillColor: n, strokeColor: s, strokeWidth: r } = this.styles;
      switch (t) {
        case "Polygon":
        case "MultiPolygon":
          return new je({
            fill: new tn({ color: n }),
            stroke: new Hi({ color: s, width: r })
          });
        case "LineString":
          return new je({
            stroke: new Hi({ color: s, width: r })
          });
        case "Point":
          return new je({
            image: new zn({
              radius: 5,
              fill: new tn({ color: n }),
              stroke: new Hi({ color: s, width: 1 })
            })
          });
        default:
          return console.warn(`No style found for geometry type: ${t}`), null;
      }
    }
    /**
     * Applies feature groups to the map, optionally using SLD styles for styling.
     *
     * This function iterates over the feature groups and adds them to the map with appropriate styles.
     * If SLD data is provided, it will attempt to apply the SLD styles to the features.
     *
     * @param {Object} featureGroups - An object containing groups of features categorized by type.
     * @param {string} [sldString] - The SLD data to use for styling the features.
     */
    applyFeatureGroupsToMap(t, e) {
      const n = this.map.getView().getProjection(), s = e ? Ia.Reader(e) : null;
      Object.keys(t).forEach((r) => {
        const a = new fy({ features: t[r] }), o = this.applySLDStyles(s, r, n);
        this.addLayerWithControls(r, a, o || this.getStyle(r));
      }), this.map.render(), this.requestUpdate();
    }
    /**
     * Groups features by their feature type.
     *
     * This function takes the parsed features and an XML document as input and
     * groups the features by their feature type. The feature type is determined by
     * the local name of the first child element of the feature member element.
     *
     * @param {Array<ol/Feature>} features - The parsed features to group.
     * @param {XMLDocument} xmlDoc - The XML document containing the feature members.
     * @returns {Object} An object with feature type as keys and arrays of features as values.
     */
    groupFeaturesByType(t, e) {
      return t.reduce((n, s, r) => {
        const o = e.getElementsByTagNameNS("*", "featureMember")[r], l = o ? o.firstElementChild : null, h = l ? l.localName : "Unknown Type";
        return n[h] || (n[h] = []), n[h].push(s), n;
      }, {});
    }
    /**
     * Adds a vector layer to the map with controls for visibility and styling.
     *
     * This function creates a vector layer using the provided vector source and style function.
     * It also adds a checkbox to toggle the visibility of the layer, and color pickers
     * for adjusting the layer's fill color, stroke color, and stroke width.
     *
     * @param {string} type - The type or name of the layer.
     * @param {ol/source/Vector} vectorSource - The vector source for the layer.
     * @param {function} [sldStyleFunction] - Optional style function for the layer.
     * @param sldObject the SLD object to apply styles from
     */
    /**
     * Adds a vector layer to the map with controls for visibility and styling.
     * The map symbol in the legend reflects the actual layer styling.
     *
     * @param {string} type - The type or name of the layer.
     * @param {ol/source/Vector} vectorSource - The vector source for the layer.
     * @param {function|Style} styleFunction - Style function or style object for the layer.
     */
    /**
     * Adds a vector layer to the map with controls for visibility and styling.
     * The map symbol in the legend reflects the actual layer styling, including SLD styles.
     *
     * @param {string} type - The type or name of the layer.
     * @param {ol/source/Vector} vectorSource - The vector source for the layer.
     * @param {function|Style} styleFunction - Style function or style object for the layer.
     */
    addLayerWithControls(t, e, n) {
      const s = new Ny({
        source: e,
        style: n || ((c) => this.getStyle(c.getGeometry().getType()))
      });
      this.map.addLayer(s), this.vectorLayers.push(s);
      const r = document.createElement("div");
      r.classList.add("legend-element"), r.style.display = "flex", r.style.alignItems = "center", r.style.marginBottom = "8px";
      const a = document.createElement("input");
      a.type = "checkbox", a.checked = !0, a.style.marginRight = "8px", a.addEventListener("change", () => {
        s.setVisible(a.checked);
      });
      const o = document.createElement("div");
      o.style.width = "20px", o.style.height = "20px", o.style.marginRight = "8px", o.style.position = "relative";
      const l = e.getFeatures()[0];
      if (l) {
        const c = l.getGeometry().getType();
        let u;
        if (typeof n == "function") {
          const d = this.map.getView().getResolution(), g = n(l, d);
          u = Array.isArray(g) ? g[0] : g;
        } else
          u = n || this.getStyle(c);
        switch (c) {
          case "Polygon":
          case "MultiPolygon":
            if (u) {
              const d = u.getFill(), g = u.getStroke();
              d && (o.style.backgroundColor = d.getColor()), g && (o.style.border = `${g.getWidth()}px solid ${g.getColor()}`);
            } else
              o.style.backgroundColor = this.styles.fillColor, o.style.border = `${this.styles.strokeWidth}px solid ${this.styles.strokeColor}`;
            break;
          case "LineString":
          case "MultiLineString":
            if (u) {
              const d = u.getStroke();
              d && (o.style.borderTop = `${d.getWidth()}px solid ${d.getColor()}`);
            } else
              o.style.borderTop = `${this.styles.strokeWidth}px solid ${this.styles.strokeColor}`;
            o.style.height = "0px", o.style.top = "50%";
            break;
          case "Point":
          case "MultiPoint":
            if (u) {
              const d = u.getImage();
              if (d)
                if (d instanceof zn) {
                  const g = d.getFill(), _ = d.getStroke();
                  g && (o.style.backgroundColor = g.getColor()), _ && (o.style.border = `${_.getWidth()}px solid ${_.getColor()}`), o.style.borderRadius = "50%";
                } else {
                  const g = d.getSize();
                  g && (o.style.width = `${g[0]}px`, o.style.height = `${g[1]}px`);
                }
            } else
              o.style.backgroundColor = this.styles.fillColor, o.style.border = `1px solid ${this.styles.strokeColor}`, o.style.borderRadius = "50%";
            break;
        }
      }
      const h = document.createElement("label");
      h.textContent = t, h.style.cursor = "pointer", r.appendChild(a), r.appendChild(o), r.appendChild(h), this.shadowRoot.getElementById("map-legend").appendChild(r);
    }
    // Drag and Drop Functions
    onDragOver(t) {
      t.preventDefault(), this.shadowRoot.getElementById("drop-zone").classList.add("dragover");
    }
    onDragLeave() {
      this.shadowRoot.getElementById("drop-zone").classList.remove("dragover");
    }
    onDrop(t) {
      t.preventDefault(), this.shadowRoot.getElementById("drop-zone").classList.remove("dragover");
      const n = [...t.dataTransfer.files], s = n.find((o) => o.name.endsWith(".gml")), r = n.find((o) => o.name.endsWith(".xml")), a = n.find((o) => o.name.endsWith(".sld"));
      if (s || a || r) {
        const o = document.createElement("input");
        o.type = "file", o.files = new DataTransfer().files, o.dispatchEvent(new Event("change", { bubbles: !0 })), this.uploadFiles({ target: { files: n } });
      }
    }
    render() {
      return Pn`
      <div part="map-container" class="map-container" id="map-container" @dragover="${this.onDragOver}" @dragleave="${this.onDragLeave}" @drop="${this.onDrop}">
        <div id="map" class="map"></div>

        <div id="map-legend"></div>
        
        <div id="metadata"></div>
        

        <div id="controls-container">
          <label class="control-icon" title="Zoom In" @click="${this.zoomIn}">
            <svg class="ds-icon" width="29" height="29" viewBox="0 0 29 29" fill="none" xmlns="http://www.w3.org/2000/svg">
              <g stroke="var(--ds-icon-color, black)" stroke-linejoin="round" stroke-linecap="round" stroke-width="var(--ds-icon-stroke, 1)">
                <path d="M0.5 14.5H28.5M14.5 0.5L14.5 28.5"/>
              </g>
            </svg>
          </label>
          <label class="control-icon" title="Zoom Out" @click="${this.zoomOut}">
            <svg class="ds-icon" width="29" height="29" viewBox="0 0 29 29" fill="none" xmlns="http://www.w3.org/2000/svg">
              <g stroke="var(--ds-icon-color, black)" stroke-linejoin="round" stroke-linecap="round" stroke-width="var(--ds-icon-stroke, 1)">
                <path d="M0.5 14.5H28.5"/>
              </g>
            </svg>
          </label>
          <label class="control-icon" id="drop-zone" title="Upload Files">
            <input type="file" multiple @change="${this.uploadFiles}"/>
            <svg class="ds-icon" width="29" height="29" viewBox="0 0 29 29" fill="none" xmlns="http://www.w3.org/2000/svg">
              <g stroke="var(--ds-icon-color, black)" stroke-linecap="round" fill="none" stroke-width="var(--ds-icon-stroke, 1)">
                <path d="M1.5 26.5H27.5"/>
                <path d="M2 13.0858L13.7929 1.29292C14.1834 0.902398 14.8166 0.902399 15.2071 1.29292L27 13.0858M14.5 1.08582L14.5 20.4999"/>
              </g>
            </svg>
          </label>
        </div>
        <div id="layer-switcher">
          <svg class="ds-icon" width="29" height="29" viewBox="0 0 29 29" fill="none" xmlns="http://www.w3.org/2000/svg">
            <g stroke="var(--ds-icon-color, black)" stroke-linejoin="round" stroke-linecap="round" stroke-width="var(--ds-icon-stroke, 1)">
              <path d="M1.5 14L14.5 20.5L27.5 14M1.5 20L14.5 26.5L27.5 20M14.5 2.5L1.5 8L14.5 14.5L27.5 8L14.5 2.5Z"></path>
            </g>
          </svg>

          <div class="radio-options">
            <label>
              <input type="radio" name="base-layer" value="1" checked> Skrmkort
            </label>
            <label>
              <input type="radio" name="base-layer" value="2"> Ortofoto
            </label>
          </div>
        </div>
        <div id="map"></div>
        <div id="compass-container">
          <svg class="ds-icon" width="40" height="40" viewBox="0 0 31 31" fill="none" xmlns="http://www.w3.org/2000/svg">
            <circle cx="15.5" cy="15.5" r="15" fill="var(--c8, black)" stroke="var(--white, white)" stroke-width="var(--ds-icon-stroke, 1)"/>
            <g stroke="var(--white, white)" stroke-linecap="round" stroke-linejoin="round">
              <path id="west" d="M3.9 16.79L7.12 15.5L3.9 14.21"/>
              <path id="east" d="M23.88 16.79L27.1 14.21M25.81 16.79H25.16C24.45 16.79 23.88 16.21 23.88 15.5C23.88 14.79 24.45 14.21 25.16 14.21H25.81C26.52 14.21 27.1 14.79 27.1 15.5C27.1 16.21 26.52 16.79 25.81 16.79Z"/>
              <path id="south" d="M14.21 26.46C14.21 26.81 14.5 27.1 14.86 27.1H16.06C16.46 27.1 16.79 26.78 16.79 26.38C16.79 26.05 16.56 25.76 16.24 25.68L14.76 25.3C14.44 25.22 14.21 24.93 14.21 24.6C14.21 24.2 14.54 23.88 14.93 23.88H16.14C16.5 23.88 16.79 24.17 16.79 24.52"/>
              <path id="north" d="M14.21 7.12L14.22 3.9L16.79 7.12V3.9"/>
            </g>
            <path id="north-pointer" d="M12.13 15.49C12.12 15.02 12.29 14.72 12.45 14.41L14.96 9.4C15.15 8.99 15.8 9.01 15.99 9.37L18.63 14.65C18.73 14.87 18.85 15.16 18.84 15.49L17.21 15.49C17.21 15.49 17.12 13.78 15.49 13.77C13.86 13.76 13.75 15.49 13.75 15.49L12.13 15.49Z" fill="var(--r5, red)"/>
            <path id="south-pointer" d="M12.12 15.5C12.12 15.96 12.28 16.26 12.44 16.58L14.95 21.58C15.14 21.99 15.79 21.97 15.98 21.61L18.62 16.33C18.73 16.12 18.84 15.82 18.83 15.49L17.2 15.49C17.2 15.49 17.12 17.2 15.48 17.21C13.85 17.22 13.75 15.5 13.75 15.5L12.12 15.5Z" fill="var(--white, white)"/>
            <path d="M5.19 5.19L7.77 7.77M25.81 5.19L23.23 7.77M25.81 25.81L23.23 23.23M5.19 25.81L7.77 23.23" stroke="white" stroke-linecap="round" stroke-linejoin="round" stroke-width="var(--ds-icon-stroke, 1)"/>
          </svg>
        </div>
      </div>
    `;
    }
  }
  En(Xl, "styles", ql`

      :host {
          display: block;
          width: var(--map-viewer-width, 100%);
          height: var(--map-viewer-height, 100%);
          border: var(--map-viewer-border, none);
          box-shadow: var(--map-viewer-box-shadow, none);
      }

      .map-container {
          display: flex;
          justify-content: center;
          align-items: center;
          width: 100%;
          height: 100%;
          position: relative;
      }

      .map {
          width: 100%;
          height: 100%;
      }


      #compass-container {
          position: absolute;
          top: 1rem;
          right: 1rem;
          display: flex;
          flex-direction: column;
          padding: 1rem;
          width: 3rem;
          height: 3rem;
      }

      #controls-container {
          position: absolute;
          bottom: 1rem;
          right: 1rem;
          display: flex;
          flex-direction: column;
          gap: 0.5rem;
          background: rgba(255, 255, 255, 0.8);
          border-radius: 1rem;
          padding: 1rem;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }
      
      #layer-switcher {
          position: absolute;
          bottom: 1rem;
          right: 6rem;
          display: flex;
          flex-direction: row-reverse;
          gap: 0.5rem;
          background: rgba(255, 255, 255, 0.8);
          border-radius: 1rem;
          padding: 1rem;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      .control-icon {
          width: 2.5rem;
          height: 2.5rem;
          display: flex;
          justify-content: center;
          align-items: center;
          background-color: white;
          border: 1px solid #ccc;
          border-radius: 50%;
          cursor: pointer;
          transition: background-color 0.3s, transform 0.2s;
      }

      #map-legend {
          position: absolute;
          bottom: 1rem;
          left: 1rem;
          background: rgba(255, 255, 255, 0.8);
          border-radius: 8px;
          padding: 0.75rem;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
          display: none;
      }
      input {
          accent-color: green;
      }

      button:hover, label:hover {
          transform: scale(1.1);
      }

      label svg {
          width: 1.25rem;
          height: 1.25rem;
          fill: #333;
      }

      input[type="file"] {
          display: none;
      }
      
      .radio-options {
          display: none;
      }
  `), // Define custom properties
  En(Xl, "properties", {
    gmlFile: { type: String, reflect: !0 },
    xmlFile: { type: String, reflect: !0 },
    sldFile: { type: String, reflect: !0 }
  });
  class eg extends qi {
    render() {
      return Pn`
      <map-viewer
          .gmlFile="${"./examples/2019/713/data_demo.gml"}"
          .xmlFile="${"./examples/2019/713/metadata.xml"}"
          .sldFile="${""}">
      </map-viewer>
    `;
    }
  }
  En(eg, "styles", ql``);
  class ig extends qi {
    render() {
      return Pn`
          <map-viewer
              .gmlFile="${"./examples/2019/713/data_demo.gml"}"
              .xmlFile="${"./examples/2019/713/metadata.xml"}"
              .sldFile="${"./examples/2019/713/styles.sld"}">
          </map-viewer>
      `;
    }
  }
  En(ig, "styles", ql``);
  function C2(i) {
    if (i === "#map-viewer")
      return Pn`
    <map-viewer></map-viewer>`;
    if (i === "#map-example")
      return Pn`
    <map-example></map-example>`;
    if (i === "#map-template")
      return Pn`
    <map-template></map-template>`;
  }
  class ng extends qi {
    constructor() {
      super(), this.route = window.location.hash || "#map-viewer", this._setupRouting();
    }
    /**
     * Initializes a hashchange listener to update the route dynamically.
     * The hashchange event is dispatched when the fragment identifier of the URL changes.
     * @private
     */
    _setupRouting() {
      window.addEventListener("hashchange", () => {
        this.route = window.location.hash || "#map-viewer";
      });
    }
    render() {
      return Pn`
      <main>
        ${C2(this.route)} <!-- Pass the current route to the router -->
        <div>
        <div><a href="#map-template" role="button">MapTemplate</a> - Viser et tomt kort, der referer til skabelonen MapTemplate.js, hvor man let kan udfylde med egen data</div>
        <div><a href="#map-example" role="button">MapExample</a> - Viser et kort med udfyldt datast. Samme opstning som ved MapTemplate</div>
        <div><a href="#map-viewer" role="button">Kort</a> - Viser et tomt kort, der betegner selve MapViewer.js</div>
        </div>
      </main>
    `;
    }
    // Optional: Render into the light DOM (if required for styling)
    createRenderRoot() {
      return this;
    }
  }
  En(ng, "properties", {
    route: { type: String }
    // Dynamic route property
  });
  customElements.define("main-component", ng);
  customElements.define("map-viewer", Xl);
  customElements.define("map-template", eg);
  customElements.define("map-example", ig);
});
export default R2();
//# sourceMappingURL=map-viewer-plugin.es.js.map
