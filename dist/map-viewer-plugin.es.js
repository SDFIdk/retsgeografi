var t0 = Object.defineProperty;
var e0 = (i, t, e) => t in i ? t0(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;
var i0 = (i, t) => () => (t || i((t = { exports: {} }).exports, t), t.exports);
var Wi = (i, t, e) => e0(i, typeof t != "symbol" ? t + "" : t, e);
import { LitElement as n0, html as s0 } from "lit";
var K2 = i0((at) => {
  (function() {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload"))
      return;
    for (const s of document.querySelectorAll('link[rel="modulepreload"]'))
      n(s);
    new MutationObserver((s) => {
      for (const r of s)
        if (r.type === "childList")
          for (const a of r.addedNodes)
            a.tagName === "LINK" && a.rel === "modulepreload" && n(a);
    }).observe(document, { childList: !0, subtree: !0 });
    function e(s) {
      const r = {};
      return s.integrity && (r.integrity = s.integrity), s.referrerPolicy && (r.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? r.credentials = "include" : s.crossOrigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r;
    }
    function n(s) {
      if (s.ep)
        return;
      s.ep = !0;
      const r = e(s);
      fetch(s.href, r);
    }
  })();
  /**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  const Aa = globalThis, eh = Aa.ShadowRoot && (Aa.ShadyCSS === void 0 || Aa.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, ih = Symbol(), Sc = /* @__PURE__ */ new WeakMap();
  let ad = class {
    constructor(t, e, n) {
      if (this._$cssResult$ = !0, n !== ih) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
      this.cssText = t, this.t = e;
    }
    get styleSheet() {
      let t = this.o;
      const e = this.t;
      if (eh && t === void 0) {
        const n = e !== void 0 && e.length === 1;
        n && (t = Sc.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), n && Sc.set(e, t));
      }
      return t;
    }
    toString() {
      return this.cssText;
    }
  };
  const r0 = (i) => new ad(typeof i == "string" ? i : i + "", void 0, ih), nh = (i, ...t) => {
    const e = i.length === 1 ? i[0] : t.reduce((n, s, r) => n + ((a) => {
      if (a._$cssResult$ === !0) return a.cssText;
      if (typeof a == "number") return a;
      throw Error("Value passed to 'css' function must be a 'css' function result: " + a + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
    })(s) + i[r + 1], i[0]);
    return new ad(e, i, ih);
  }, a0 = (i, t) => {
    if (eh) i.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet);
    else for (const e of t) {
      const n = document.createElement("style"), s = Aa.litNonce;
      s !== void 0 && n.setAttribute("nonce", s), n.textContent = e.cssText, i.appendChild(n);
    }
  }, Cc = eh ? (i) => i : (i) => i instanceof CSSStyleSheet ? ((t) => {
    let e = "";
    for (const n of t.cssRules) e += n.cssText;
    return r0(e);
  })(i) : i;
  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  const { is: o0, defineProperty: l0, getOwnPropertyDescriptor: h0, getOwnPropertyNames: c0, getOwnPropertySymbols: u0, getPrototypeOf: d0 } = Object, sn = globalThis, Tc = sn.trustedTypes, f0 = Tc ? Tc.emptyScript : "", jo = sn.reactiveElementPolyfillSupport, cr = (i, t) => i, Sl = { toAttribute(i, t) {
    switch (t) {
      case Boolean:
        i = i ? f0 : null;
        break;
      case Object:
      case Array:
        i = i == null ? i : JSON.stringify(i);
    }
    return i;
  }, fromAttribute(i, t) {
    let e = i;
    switch (t) {
      case Boolean:
        e = i !== null;
        break;
      case Number:
        e = i === null ? null : Number(i);
        break;
      case Object:
      case Array:
        try {
          e = JSON.parse(i);
        } catch {
          e = null;
        }
    }
    return e;
  } }, od = (i, t) => !o0(i, t), Ic = { attribute: !0, type: String, converter: Sl, reflect: !1, hasChanged: od };
  Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), sn.litPropertyMetadata ?? (sn.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
  class ss extends HTMLElement {
    static addInitializer(t) {
      this._$Ei(), (this.l ?? (this.l = [])).push(t);
    }
    static get observedAttributes() {
      return this.finalize(), this._$Eh && [...this._$Eh.keys()];
    }
    static createProperty(t, e = Ic) {
      if (e.state && (e.attribute = !1), this._$Ei(), this.elementProperties.set(t, e), !e.noAccessor) {
        const n = Symbol(), s = this.getPropertyDescriptor(t, n, e);
        s !== void 0 && l0(this.prototype, t, s);
      }
    }
    static getPropertyDescriptor(t, e, n) {
      const { get: s, set: r } = h0(this.prototype, t) ?? { get() {
        return this[e];
      }, set(a) {
        this[e] = a;
      } };
      return { get() {
        return s == null ? void 0 : s.call(this);
      }, set(a) {
        const o = s == null ? void 0 : s.call(this);
        r.call(this, a), this.requestUpdate(t, o, n);
      }, configurable: !0, enumerable: !0 };
    }
    static getPropertyOptions(t) {
      return this.elementProperties.get(t) ?? Ic;
    }
    static _$Ei() {
      if (this.hasOwnProperty(cr("elementProperties"))) return;
      const t = d0(this);
      t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
    }
    static finalize() {
      if (this.hasOwnProperty(cr("finalized"))) return;
      if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(cr("properties"))) {
        const e = this.properties, n = [...c0(e), ...u0(e)];
        for (const s of n) this.createProperty(s, e[s]);
      }
      const t = this[Symbol.metadata];
      if (t !== null) {
        const e = litPropertyMetadata.get(t);
        if (e !== void 0) for (const [n, s] of e) this.elementProperties.set(n, s);
      }
      this._$Eh = /* @__PURE__ */ new Map();
      for (const [e, n] of this.elementProperties) {
        const s = this._$Eu(e, n);
        s !== void 0 && this._$Eh.set(s, e);
      }
      this.elementStyles = this.finalizeStyles(this.styles);
    }
    static finalizeStyles(t) {
      const e = [];
      if (Array.isArray(t)) {
        const n = new Set(t.flat(1 / 0).reverse());
        for (const s of n) e.unshift(Cc(s));
      } else t !== void 0 && e.push(Cc(t));
      return e;
    }
    static _$Eu(t, e) {
      const n = e.attribute;
      return n === !1 ? void 0 : typeof n == "string" ? n : typeof t == "string" ? t.toLowerCase() : void 0;
    }
    constructor() {
      super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
    }
    _$Ev() {
      var t;
      this._$ES = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (t = this.constructor.l) == null || t.forEach((e) => e(this));
    }
    addController(t) {
      var e;
      (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t), this.renderRoot !== void 0 && this.isConnected && ((e = t.hostConnected) == null || e.call(t));
    }
    removeController(t) {
      var e;
      (e = this._$EO) == null || e.delete(t);
    }
    _$E_() {
      const t = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
      for (const n of e.keys()) this.hasOwnProperty(n) && (t.set(n, this[n]), delete this[n]);
      t.size > 0 && (this._$Ep = t);
    }
    createRenderRoot() {
      const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
      return a0(t, this.constructor.elementStyles), t;
    }
    connectedCallback() {
      var t;
      this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (t = this._$EO) == null || t.forEach((e) => {
        var n;
        return (n = e.hostConnected) == null ? void 0 : n.call(e);
      });
    }
    enableUpdating(t) {
    }
    disconnectedCallback() {
      var t;
      (t = this._$EO) == null || t.forEach((e) => {
        var n;
        return (n = e.hostDisconnected) == null ? void 0 : n.call(e);
      });
    }
    attributeChangedCallback(t, e, n) {
      this._$AK(t, n);
    }
    _$EC(t, e) {
      var r;
      const n = this.constructor.elementProperties.get(t), s = this.constructor._$Eu(t, n);
      if (s !== void 0 && n.reflect === !0) {
        const a = (((r = n.converter) == null ? void 0 : r.toAttribute) !== void 0 ? n.converter : Sl).toAttribute(e, n.type);
        this._$Em = t, a == null ? this.removeAttribute(s) : this.setAttribute(s, a), this._$Em = null;
      }
    }
    _$AK(t, e) {
      var r;
      const n = this.constructor, s = n._$Eh.get(t);
      if (s !== void 0 && this._$Em !== s) {
        const a = n.getPropertyOptions(s), o = typeof a.converter == "function" ? { fromAttribute: a.converter } : ((r = a.converter) == null ? void 0 : r.fromAttribute) !== void 0 ? a.converter : Sl;
        this._$Em = s, this[s] = o.fromAttribute(e, a.type), this._$Em = null;
      }
    }
    requestUpdate(t, e, n) {
      if (t !== void 0) {
        if (n ?? (n = this.constructor.getPropertyOptions(t)), !(n.hasChanged ?? od)(this[t], e)) return;
        this.P(t, e, n);
      }
      this.isUpdatePending === !1 && (this._$ES = this._$ET());
    }
    P(t, e, n) {
      this._$AL.has(t) || this._$AL.set(t, e), n.reflect === !0 && this._$Em !== t && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(t);
    }
    async _$ET() {
      this.isUpdatePending = !0;
      try {
        await this._$ES;
      } catch (e) {
        Promise.reject(e);
      }
      const t = this.scheduleUpdate();
      return t != null && await t, !this.isUpdatePending;
    }
    scheduleUpdate() {
      return this.performUpdate();
    }
    performUpdate() {
      var n;
      if (!this.isUpdatePending) return;
      if (!this.hasUpdated) {
        if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
          for (const [r, a] of this._$Ep) this[r] = a;
          this._$Ep = void 0;
        }
        const s = this.constructor.elementProperties;
        if (s.size > 0) for (const [r, a] of s) a.wrapped !== !0 || this._$AL.has(r) || this[r] === void 0 || this.P(r, this[r], a);
      }
      let t = !1;
      const e = this._$AL;
      try {
        t = this.shouldUpdate(e), t ? (this.willUpdate(e), (n = this._$EO) == null || n.forEach((s) => {
          var r;
          return (r = s.hostUpdate) == null ? void 0 : r.call(s);
        }), this.update(e)) : this._$EU();
      } catch (s) {
        throw t = !1, this._$EU(), s;
      }
      t && this._$AE(e);
    }
    willUpdate(t) {
    }
    _$AE(t) {
      var e;
      (e = this._$EO) == null || e.forEach((n) => {
        var s;
        return (s = n.hostUpdated) == null ? void 0 : s.call(n);
      }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
    }
    _$EU() {
      this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
    }
    get updateComplete() {
      return this.getUpdateComplete();
    }
    getUpdateComplete() {
      return this._$ES;
    }
    shouldUpdate(t) {
      return !0;
    }
    update(t) {
      this._$Ej && (this._$Ej = this._$Ej.forEach((e) => this._$EC(e, this[e]))), this._$EU();
    }
    updated(t) {
    }
    firstUpdated(t) {
    }
  }
  ss.elementStyles = [], ss.shadowRootOptions = { mode: "open" }, ss[cr("elementProperties")] = /* @__PURE__ */ new Map(), ss[cr("finalized")] = /* @__PURE__ */ new Map(), jo == null || jo({ ReactiveElement: ss }), (sn.reactiveElementVersions ?? (sn.reactiveElementVersions = [])).push("2.0.4");
  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  const ur = globalThis, Da = ur.trustedTypes, Ac = Da ? Da.createPolicy("lit-html", { createHTML: (i) => i }) : void 0, ld = "$lit$", Ji = `lit$${Math.random().toFixed(9).slice(2)}$`, hd = "?" + Ji, g0 = `<${hd}>`, On = document, yr = () => On.createComment(""), vr = (i) => i === null || typeof i != "object" && typeof i != "function", sh = Array.isArray, m0 = (i) => sh(i) || typeof (i == null ? void 0 : i[Symbol.iterator]) == "function", Vo = `[ 	
\f\r]`, Ks = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, Pc = /-->/g, bc = />/g, xn = RegExp(`>|${Vo}(?:([^\\s"'>=/]+)(${Vo}*=${Vo}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), Lc = /'/g, Oc = /"/g, cd = /^(?:script|style|textarea|title)$/i, _0 = (i) => (t, ...e) => ({ _$litType$: i, strings: t, values: e }), _s = _0(1), Ss = Symbol.for("lit-noChange"), Ht = Symbol.for("lit-nothing"), Nc = /* @__PURE__ */ new WeakMap(), Sn = On.createTreeWalker(On, 129);
  function ud(i, t) {
    if (!sh(i) || !i.hasOwnProperty("raw")) throw Error("invalid template strings array");
    return Ac !== void 0 ? Ac.createHTML(t) : t;
  }
  const p0 = (i, t) => {
    const e = i.length - 1, n = [];
    let s, r = t === 2 ? "<svg>" : t === 3 ? "<math>" : "", a = Ks;
    for (let o = 0; o < e; o++) {
      const l = i[o];
      let h, c, u = -1, d = 0;
      for (; d < l.length && (a.lastIndex = d, c = a.exec(l), c !== null); ) d = a.lastIndex, a === Ks ? c[1] === "!--" ? a = Pc : c[1] !== void 0 ? a = bc : c[2] !== void 0 ? (cd.test(c[2]) && (s = RegExp("</" + c[2], "g")), a = xn) : c[3] !== void 0 && (a = xn) : a === xn ? c[0] === ">" ? (a = s ?? Ks, u = -1) : c[1] === void 0 ? u = -2 : (u = a.lastIndex - c[2].length, h = c[1], a = c[3] === void 0 ? xn : c[3] === '"' ? Oc : Lc) : a === Oc || a === Lc ? a = xn : a === Pc || a === bc ? a = Ks : (a = xn, s = void 0);
      const m = a === xn && i[o + 1].startsWith("/>") ? " " : "";
      r += a === Ks ? l + g0 : u >= 0 ? (n.push(h), l.slice(0, u) + ld + l.slice(u) + Ji + m) : l + Ji + (u === -2 ? o : m);
    }
    return [ud(i, r + (i[e] || "<?>") + (t === 2 ? "</svg>" : t === 3 ? "</math>" : "")), n];
  };
  class Er {
    constructor({ strings: t, _$litType$: e }, n) {
      let s;
      this.parts = [];
      let r = 0, a = 0;
      const o = t.length - 1, l = this.parts, [h, c] = p0(t, e);
      if (this.el = Er.createElement(h, n), Sn.currentNode = this.el.content, e === 2 || e === 3) {
        const u = this.el.content.firstChild;
        u.replaceWith(...u.childNodes);
      }
      for (; (s = Sn.nextNode()) !== null && l.length < o; ) {
        if (s.nodeType === 1) {
          if (s.hasAttributes()) for (const u of s.getAttributeNames()) if (u.endsWith(ld)) {
            const d = c[a++], m = s.getAttribute(u).split(Ji), f = /([.?@])?(.*)/.exec(d);
            l.push({ type: 1, index: r, name: f[2], strings: m, ctor: f[1] === "." ? v0 : f[1] === "?" ? E0 : f[1] === "@" ? x0 : lo }), s.removeAttribute(u);
          } else u.startsWith(Ji) && (l.push({ type: 6, index: r }), s.removeAttribute(u));
          if (cd.test(s.tagName)) {
            const u = s.textContent.split(Ji), d = u.length - 1;
            if (d > 0) {
              s.textContent = Da ? Da.emptyScript : "";
              for (let m = 0; m < d; m++) s.append(u[m], yr()), Sn.nextNode(), l.push({ type: 2, index: ++r });
              s.append(u[d], yr());
            }
          }
        } else if (s.nodeType === 8) if (s.data === hd) l.push({ type: 2, index: r });
        else {
          let u = -1;
          for (; (u = s.data.indexOf(Ji, u + 1)) !== -1; ) l.push({ type: 7, index: r }), u += Ji.length - 1;
        }
        r++;
      }
    }
    static createElement(t, e) {
      const n = On.createElement("template");
      return n.innerHTML = t, n;
    }
  }
  function Cs(i, t, e = i, n) {
    var a, o;
    if (t === Ss) return t;
    let s = n !== void 0 ? (a = e._$Co) == null ? void 0 : a[n] : e._$Cl;
    const r = vr(t) ? void 0 : t._$litDirective$;
    return (s == null ? void 0 : s.constructor) !== r && ((o = s == null ? void 0 : s._$AO) == null || o.call(s, !1), r === void 0 ? s = void 0 : (s = new r(i), s._$AT(i, e, n)), n !== void 0 ? (e._$Co ?? (e._$Co = []))[n] = s : e._$Cl = s), s !== void 0 && (t = Cs(i, s._$AS(i, t.values), s, n)), t;
  }
  let y0 = class {
    constructor(t, e) {
      this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
    }
    get parentNode() {
      return this._$AM.parentNode;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    u(t) {
      const { el: { content: e }, parts: n } = this._$AD, s = ((t == null ? void 0 : t.creationScope) ?? On).importNode(e, !0);
      Sn.currentNode = s;
      let r = Sn.nextNode(), a = 0, o = 0, l = n[0];
      for (; l !== void 0; ) {
        if (a === l.index) {
          let h;
          l.type === 2 ? h = new rh(r, r.nextSibling, this, t) : l.type === 1 ? h = new l.ctor(r, l.name, l.strings, this, t) : l.type === 6 && (h = new M0(r, this, t)), this._$AV.push(h), l = n[++o];
        }
        a !== (l == null ? void 0 : l.index) && (r = Sn.nextNode(), a++);
      }
      return Sn.currentNode = On, s;
    }
    p(t) {
      let e = 0;
      for (const n of this._$AV) n !== void 0 && (n.strings !== void 0 ? (n._$AI(t, n, e), e += n.strings.length - 2) : n._$AI(t[e])), e++;
    }
  }, rh = class dd {
    get _$AU() {
      var t;
      return ((t = this._$AM) == null ? void 0 : t._$AU) ?? this._$Cv;
    }
    constructor(t, e, n, s) {
      this.type = 2, this._$AH = Ht, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = n, this.options = s, this._$Cv = (s == null ? void 0 : s.isConnected) ?? !0;
    }
    get parentNode() {
      let t = this._$AA.parentNode;
      const e = this._$AM;
      return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;
    }
    get startNode() {
      return this._$AA;
    }
    get endNode() {
      return this._$AB;
    }
    _$AI(t, e = this) {
      t = Cs(this, t, e), vr(t) ? t === Ht || t == null || t === "" ? (this._$AH !== Ht && this._$AR(), this._$AH = Ht) : t !== this._$AH && t !== Ss && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : m0(t) ? this.k(t) : this._(t);
    }
    O(t) {
      return this._$AA.parentNode.insertBefore(t, this._$AB);
    }
    T(t) {
      this._$AH !== t && (this._$AR(), this._$AH = this.O(t));
    }
    _(t) {
      this._$AH !== Ht && vr(this._$AH) ? this._$AA.nextSibling.data = t : this.T(On.createTextNode(t)), this._$AH = t;
    }
    $(t) {
      var r;
      const { values: e, _$litType$: n } = t, s = typeof n == "number" ? this._$AC(t) : (n.el === void 0 && (n.el = Er.createElement(ud(n.h, n.h[0]), this.options)), n);
      if (((r = this._$AH) == null ? void 0 : r._$AD) === s) this._$AH.p(e);
      else {
        const a = new y0(s, this), o = a.u(this.options);
        a.p(e), this.T(o), this._$AH = a;
      }
    }
    _$AC(t) {
      let e = Nc.get(t.strings);
      return e === void 0 && Nc.set(t.strings, e = new Er(t)), e;
    }
    k(t) {
      sh(this._$AH) || (this._$AH = [], this._$AR());
      const e = this._$AH;
      let n, s = 0;
      for (const r of t) s === e.length ? e.push(n = new dd(this.O(yr()), this.O(yr()), this, this.options)) : n = e[s], n._$AI(r), s++;
      s < e.length && (this._$AR(n && n._$AB.nextSibling, s), e.length = s);
    }
    _$AR(t = this._$AA.nextSibling, e) {
      var n;
      for ((n = this._$AP) == null ? void 0 : n.call(this, !1, !0, e); t && t !== this._$AB; ) {
        const s = t.nextSibling;
        t.remove(), t = s;
      }
    }
    setConnected(t) {
      var e;
      this._$AM === void 0 && (this._$Cv = t, (e = this._$AP) == null || e.call(this, t));
    }
  };
  class lo {
    get tagName() {
      return this.element.tagName;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    constructor(t, e, n, s, r) {
      this.type = 1, this._$AH = Ht, this._$AN = void 0, this.element = t, this.name = e, this._$AM = s, this.options = r, n.length > 2 || n[0] !== "" || n[1] !== "" ? (this._$AH = Array(n.length - 1).fill(new String()), this.strings = n) : this._$AH = Ht;
    }
    _$AI(t, e = this, n, s) {
      const r = this.strings;
      let a = !1;
      if (r === void 0) t = Cs(this, t, e, 0), a = !vr(t) || t !== this._$AH && t !== Ss, a && (this._$AH = t);
      else {
        const o = t;
        let l, h;
        for (t = r[0], l = 0; l < r.length - 1; l++) h = Cs(this, o[n + l], e, l), h === Ss && (h = this._$AH[l]), a || (a = !vr(h) || h !== this._$AH[l]), h === Ht ? t = Ht : t !== Ht && (t += (h ?? "") + r[l + 1]), this._$AH[l] = h;
      }
      a && !s && this.j(t);
    }
    j(t) {
      t === Ht ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
    }
  }
  class v0 extends lo {
    constructor() {
      super(...arguments), this.type = 3;
    }
    j(t) {
      this.element[this.name] = t === Ht ? void 0 : t;
    }
  }
  let E0 = class extends lo {
    constructor() {
      super(...arguments), this.type = 4;
    }
    j(t) {
      this.element.toggleAttribute(this.name, !!t && t !== Ht);
    }
  };
  class x0 extends lo {
    constructor(t, e, n, s, r) {
      super(t, e, n, s, r), this.type = 5;
    }
    _$AI(t, e = this) {
      if ((t = Cs(this, t, e, 0) ?? Ht) === Ss) return;
      const n = this._$AH, s = t === Ht && n !== Ht || t.capture !== n.capture || t.once !== n.once || t.passive !== n.passive, r = t !== Ht && (n === Ht || s);
      s && this.element.removeEventListener(this.name, this, n), r && this.element.addEventListener(this.name, this, t), this._$AH = t;
    }
    handleEvent(t) {
      var e;
      typeof this._$AH == "function" ? this._$AH.call(((e = this.options) == null ? void 0 : e.host) ?? this.element, t) : this._$AH.handleEvent(t);
    }
  }
  class M0 {
    constructor(t, e, n) {
      this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = n;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(t) {
      Cs(this, t);
    }
  }
  const Ho = ur.litHtmlPolyfillSupport;
  Ho == null || Ho(Er, rh), (ur.litHtmlVersions ?? (ur.litHtmlVersions = [])).push("3.2.1");
  const w0 = (i, t, e) => {
    const n = (e == null ? void 0 : e.renderBefore) ?? t;
    let s = n._$litPart$;
    if (s === void 0) {
      const r = (e == null ? void 0 : e.renderBefore) ?? null;
      n._$litPart$ = s = new rh(t.insertBefore(yr(), r), r, void 0, e ?? {});
    }
    return s._$AI(i), s;
  };
  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  class Pn extends ss {
    constructor() {
      super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
    }
    createRenderRoot() {
      var e;
      const t = super.createRenderRoot();
      return (e = this.renderOptions).renderBefore ?? (e.renderBefore = t.firstChild), t;
    }
    update(t) {
      const e = this.render();
      this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = w0(e, this.renderRoot, this.renderOptions);
    }
    connectedCallback() {
      var t;
      super.connectedCallback(), (t = this._$Do) == null || t.setConnected(!0);
    }
    disconnectedCallback() {
      var t;
      super.disconnectedCallback(), (t = this._$Do) == null || t.setConnected(!1);
    }
    render() {
      return Ss;
    }
  }
  var rd;
  Pn._$litElement$ = !0, Pn.finalized = !0, (rd = globalThis.litElementHydrateSupport) == null || rd.call(globalThis, { LitElement: Pn });
  const Jo = globalThis.litElementPolyfillSupport;
  Jo == null || Jo({ LitElement: Pn });
  (globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.1.1");
  class Oi {
    /**
     * @param {string} type Type.
     */
    constructor(t) {
      this.propagationStopped, this.defaultPrevented, this.type = t, this.target = null;
    }
    /**
     * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
     * will be fired.
     * @api
     */
    preventDefault() {
      this.defaultPrevented = !0;
    }
    /**
     * Stop event propagation.
     * @api
     */
    stopPropagation() {
      this.propagationStopped = !0;
    }
  }
  const Ts = {
    /**
     * Triggered when a property is changed.
     * @event module:ol/Object.ObjectEvent#propertychange
     * @api
     */
    PROPERTYCHANGE: "propertychange"
  };
  class ho {
    constructor() {
      this.disposed = !1;
    }
    /**
     * Clean up.
     */
    dispose() {
      this.disposed || (this.disposed = !0, this.disposeInternal());
    }
    /**
     * Extension point for disposable objects.
     * @protected
     */
    disposeInternal() {
    }
  }
  function R0(i, t, e) {
    let n, s;
    e = e || rn;
    let r = 0, a = i.length, o = !1;
    for (; r < a; )
      n = r + (a - r >> 1), s = +e(i[n], t), s < 0 ? r = n + 1 : (a = n, o = !s);
    return o ? r : ~r;
  }
  function rn(i, t) {
    return i > t ? 1 : i < t ? -1 : 0;
  }
  function S0(i, t) {
    return i < t ? 1 : i > t ? -1 : 0;
  }
  function ah(i, t, e) {
    if (i[0] <= t)
      return 0;
    const n = i.length;
    if (t <= i[n - 1])
      return n - 1;
    if (typeof e == "function") {
      for (let s = 1; s < n; ++s) {
        const r = i[s];
        if (r === t)
          return s;
        if (r < t)
          return e(t, i[s - 1], r) > 0 ? s - 1 : s;
      }
      return n - 1;
    }
    if (e > 0) {
      for (let s = 1; s < n; ++s)
        if (i[s] < t)
          return s - 1;
      return n - 1;
    }
    if (e < 0) {
      for (let s = 1; s < n; ++s)
        if (i[s] <= t)
          return s;
      return n - 1;
    }
    for (let s = 1; s < n; ++s) {
      if (i[s] == t)
        return s;
      if (i[s] < t)
        return i[s - 1] - t < t - i[s] ? s - 1 : s;
    }
    return n - 1;
  }
  function C0(i, t, e) {
    for (; t < e; ) {
      const n = i[t];
      i[t] = i[e], i[e] = n, ++t, --e;
    }
  }
  function pe(i, t) {
    const e = Array.isArray(t) ? t : [t], n = e.length;
    for (let s = 0; s < n; s++)
      i[i.length] = e[s];
  }
  function fn(i, t) {
    const e = i.length;
    if (e !== t.length)
      return !1;
    for (let n = 0; n < e; n++)
      if (i[n] !== t[n])
        return !1;
    return !0;
  }
  function T0(i, t, e) {
    const n = t;
    return i.every(function(s, r) {
      if (r === 0)
        return !0;
      const a = n(i[r - 1], s);
      return !(a > 0 || a === 0);
    });
  }
  function xr() {
    return !0;
  }
  function co() {
    return !1;
  }
  function Is() {
  }
  function fd(i) {
    let t, e, n;
    return function() {
      const s = Array.prototype.slice.call(arguments);
      return (!e || this !== n || !fn(s, e)) && (n = this, e = s, t = i.apply(this, arguments)), t;
    };
  }
  function I0(i) {
    function t() {
      let e;
      try {
        e = i();
      } catch (n) {
        return Promise.reject(n);
      }
      return e instanceof Promise ? e : Promise.resolve(e);
    }
    return t();
  }
  function Fr(i) {
    for (const t in i)
      delete i[t];
  }
  function As(i) {
    let t;
    for (t in i)
      return !1;
    return !t;
  }
  class uo extends ho {
    /**
     * @param {*} [target] Default event target for dispatched events.
     */
    constructor(t) {
      super(), this.eventTarget_ = t, this.pendingRemovals_ = null, this.dispatching_ = null, this.listeners_ = null;
    }
    /**
     * @param {string} type Type.
     * @param {import("../events.js").Listener} listener Listener.
     */
    addEventListener(t, e) {
      if (!t || !e)
        return;
      const n = this.listeners_ || (this.listeners_ = {}), s = n[t] || (n[t] = []);
      s.includes(e) || s.push(e);
    }
    /**
     * Dispatches an event and calls all listeners listening for events
     * of this type. The event parameter can either be a string or an
     * Object with a `type` property.
     *
     * @param {import("./Event.js").default|string} event Event object.
     * @return {boolean|undefined} `false` if anyone called preventDefault on the
     *     event object or if any of the listeners returned false.
     * @api
     */
    dispatchEvent(t) {
      const e = typeof t == "string", n = e ? t : t.type, s = this.listeners_ && this.listeners_[n];
      if (!s)
        return;
      const r = e ? new Oi(t) : (
        /** @type {Event} */
        t
      );
      r.target || (r.target = this.eventTarget_ || this);
      const a = this.dispatching_ || (this.dispatching_ = {}), o = this.pendingRemovals_ || (this.pendingRemovals_ = {});
      n in a || (a[n] = 0, o[n] = 0), ++a[n];
      let l;
      for (let h = 0, c = s.length; h < c; ++h)
        if ("handleEvent" in s[h] ? l = /** @type {import("../events.js").ListenerObject} */
        s[h].handleEvent(r) : l = /** @type {import("../events.js").ListenerFunction} */
        s[h].call(this, r), l === !1 || r.propagationStopped) {
          l = !1;
          break;
        }
      if (--a[n] === 0) {
        let h = o[n];
        for (delete o[n]; h--; )
          this.removeEventListener(n, Is);
        delete a[n];
      }
      return l;
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.listeners_ && Fr(this.listeners_);
    }
    /**
     * Get the listeners for a specified event type. Listeners are returned in the
     * order that they will be called in.
     *
     * @param {string} type Type.
     * @return {Array<import("../events.js").Listener>|undefined} Listeners.
     */
    getListeners(t) {
      return this.listeners_ && this.listeners_[t] || void 0;
    }
    /**
     * @param {string} [type] Type. If not provided,
     *     `true` will be returned if this event target has any listeners.
     * @return {boolean} Has listeners.
     */
    hasListener(t) {
      return this.listeners_ ? t ? t in this.listeners_ : Object.keys(this.listeners_).length > 0 : !1;
    }
    /**
     * @param {string} type Type.
     * @param {import("../events.js").Listener} listener Listener.
     */
    removeEventListener(t, e) {
      if (!this.listeners_)
        return;
      const n = this.listeners_[t];
      if (!n)
        return;
      const s = n.indexOf(e);
      s !== -1 && (this.pendingRemovals_ && t in this.pendingRemovals_ ? (n[s] = Is, ++this.pendingRemovals_[t]) : (n.splice(s, 1), n.length === 0 && delete this.listeners_[t]));
    }
  }
  const ht = {
    /**
     * Generic change event. Triggered when the revision counter is increased.
     * @event module:ol/events/Event~BaseEvent#change
     * @api
     */
    CHANGE: "change",
    /**
     * Generic error event. Triggered when an error occurs.
     * @event module:ol/events/Event~BaseEvent#error
     * @api
     */
    ERROR: "error",
    BLUR: "blur",
    CLEAR: "clear",
    CONTEXTMENU: "contextmenu",
    CLICK: "click",
    DBLCLICK: "dblclick",
    DRAGENTER: "dragenter",
    DRAGOVER: "dragover",
    DROP: "drop",
    FOCUS: "focus",
    KEYDOWN: "keydown",
    KEYPRESS: "keypress",
    LOAD: "load",
    RESIZE: "resize",
    TOUCHMOVE: "touchmove",
    WHEEL: "wheel"
  };
  function xt(i, t, e, n, s) {
    if (s) {
      const a = e;
      e = function() {
        i.removeEventListener(t, e), a.apply(n ?? this, arguments);
      };
    } else n && n !== i && (e = e.bind(n));
    const r = {
      target: i,
      type: t,
      listener: e
    };
    return i.addEventListener(t, e), r;
  }
  function ka(i, t, e, n) {
    return xt(i, t, e, n, !0);
  }
  function bt(i) {
    i && i.target && (i.target.removeEventListener(i.type, i.listener), Fr(i));
  }
  class Dr extends uo {
    constructor() {
      super(), this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
      this.onInternal, this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
      this.onceInternal, this.un = /** @type {ObservableOnSignature<void>} */
      this.unInternal, this.revision_ = 0;
    }
    /**
     * Increases the revision counter and dispatches a 'change' event.
     * @api
     */
    changed() {
      ++this.revision_, this.dispatchEvent(ht.CHANGE);
    }
    /**
     * Get the version number for this object.  Each time the object is modified,
     * its version number will be incremented.
     * @return {number} Revision.
     * @api
     */
    getRevision() {
      return this.revision_;
    }
    /**
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
     * @protected
     */
    onInternal(t, e) {
      if (Array.isArray(t)) {
        const n = t.length, s = new Array(n);
        for (let r = 0; r < n; ++r)
          s[r] = xt(this, t[r], e);
        return s;
      }
      return xt(
        this,
        /** @type {string} */
        t,
        e
      );
    }
    /**
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
     * @protected
     */
    onceInternal(t, e) {
      let n;
      if (Array.isArray(t)) {
        const s = t.length;
        n = new Array(s);
        for (let r = 0; r < s; ++r)
          n[r] = ka(this, t[r], e);
      } else
        n = ka(
          this,
          /** @type {string} */
          t,
          e
        );
      return e.ol_key = n, n;
    }
    /**
     * Unlisten for a certain type of event.
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @protected
     */
    unInternal(t, e) {
      const n = (
        /** @type {Object} */
        e.ol_key
      );
      if (n)
        A0(n);
      else if (Array.isArray(t))
        for (let s = 0, r = t.length; s < r; ++s)
          this.removeEventListener(t[s], e);
      else
        this.removeEventListener(t, e);
    }
  }
  Dr.prototype.on;
  Dr.prototype.once;
  Dr.prototype.un;
  function A0(i) {
    if (Array.isArray(i))
      for (let t = 0, e = i.length; t < e; ++t)
        bt(i[t]);
    else
      bt(
        /** @type {import("./events.js").EventsKey} */
        i
      );
  }
  function ft() {
    throw new Error("Unimplemented abstract method.");
  }
  let P0 = 0;
  function St(i) {
    return i.ol_uid || (i.ol_uid = String(++P0));
  }
  class Fc extends Oi {
    /**
     * @param {string} type The event type.
     * @param {string} key The property name.
     * @param {*} oldValue The old value for `key`.
     */
    constructor(t, e, n) {
      super(t), this.key = e, this.oldValue = n;
    }
  }
  class si extends Dr {
    /**
     * @param {Object<string, *>} [values] An object with key-value pairs.
     */
    constructor(t) {
      super(), this.on, this.once, this.un, St(this), this.values_ = null, t !== void 0 && this.setProperties(t);
    }
    /**
     * Gets a value.
     * @param {string} key Key name.
     * @return {*} Value.
     * @api
     */
    get(t) {
      let e;
      return this.values_ && this.values_.hasOwnProperty(t) && (e = this.values_[t]), e;
    }
    /**
     * Get a list of object property names.
     * @return {Array<string>} List of property names.
     * @api
     */
    getKeys() {
      return this.values_ && Object.keys(this.values_) || [];
    }
    /**
     * Get an object of all property names and values.
     * @return {Object<string, *>} Object.
     * @api
     */
    getProperties() {
      return this.values_ && Object.assign({}, this.values_) || {};
    }
    /**
     * Get an object of all property names and values.
     * @return {Object<string, *>?} Object.
     */
    getPropertiesInternal() {
      return this.values_;
    }
    /**
     * @return {boolean} The object has properties.
     */
    hasProperties() {
      return !!this.values_;
    }
    /**
     * @param {string} key Key name.
     * @param {*} oldValue Old value.
     */
    notify(t, e) {
      let n;
      n = `change:${t}`, this.hasListener(n) && this.dispatchEvent(new Fc(n, t, e)), n = Ts.PROPERTYCHANGE, this.hasListener(n) && this.dispatchEvent(new Fc(n, t, e));
    }
    /**
     * @param {string} key Key name.
     * @param {import("./events.js").Listener} listener Listener.
     */
    addChangeListener(t, e) {
      this.addEventListener(`change:${t}`, e);
    }
    /**
     * @param {string} key Key name.
     * @param {import("./events.js").Listener} listener Listener.
     */
    removeChangeListener(t, e) {
      this.removeEventListener(`change:${t}`, e);
    }
    /**
     * Sets a value.
     * @param {string} key Key name.
     * @param {*} value Value.
     * @param {boolean} [silent] Update without triggering an event.
     * @api
     */
    set(t, e, n) {
      const s = this.values_ || (this.values_ = {});
      if (n)
        s[t] = e;
      else {
        const r = s[t];
        s[t] = e, r !== e && this.notify(t, r);
      }
    }
    /**
     * Sets a collection of key-value pairs.  Note that this changes any existing
     * properties and adds new ones (it does not remove any existing properties).
     * @param {Object<string, *>} values Values.
     * @param {boolean} [silent] Update without triggering an event.
     * @api
     */
    setProperties(t, e) {
      for (const n in t)
        this.set(n, t[n], e);
    }
    /**
     * Apply any properties from another object without triggering events.
     * @param {BaseObject} source The source object.
     * @protected
     */
    applyProperties(t) {
      t.values_ && Object.assign(this.values_ || (this.values_ = {}), t.values_);
    }
    /**
     * Unsets a property.
     * @param {string} key Key name.
     * @param {boolean} [silent] Unset without triggering an event.
     * @api
     */
    unset(t, e) {
      if (this.values_ && t in this.values_) {
        const n = this.values_[t];
        delete this.values_[t], As(this.values_) && (this.values_ = null), e || this.notify(t, n);
      }
    }
  }
  const we = {
    /**
     * Triggered when an item is added to the collection.
     * @event module:ol/Collection.CollectionEvent#add
     * @api
     */
    ADD: "add",
    /**
     * Triggered when an item is removed from the collection.
     * @event module:ol/Collection.CollectionEvent#remove
     * @api
     */
    REMOVE: "remove"
  }, Dc = {
    LENGTH: "length"
  };
  class da extends Oi {
    /**
     * @param {import("./CollectionEventType.js").default} type Type.
     * @param {T} element Element.
     * @param {number} index The index of the added or removed element.
     */
    constructor(t, e, n) {
      super(t), this.element = e, this.index = n;
    }
  }
  class hi extends si {
    /**
     * @param {Array<T>} [array] Array.
     * @param {Options} [options] Collection options.
     */
    constructor(t, e) {
      if (super(), this.on, this.once, this.un, e = e || {}, this.unique_ = !!e.unique, this.array_ = t || [], this.unique_)
        for (let n = 0, s = this.array_.length; n < s; ++n)
          this.assertUnique_(this.array_[n], n);
      this.updateLength_();
    }
    /**
     * Remove all elements from the collection.
     * @api
     */
    clear() {
      for (; this.getLength() > 0; )
        this.pop();
    }
    /**
     * Add elements to the collection.  This pushes each item in the provided array
     * to the end of the collection.
     * @param {!Array<T>} arr Array.
     * @return {Collection<T>} This collection.
     * @api
     */
    extend(t) {
      for (let e = 0, n = t.length; e < n; ++e)
        this.push(t[e]);
      return this;
    }
    /**
     * Iterate over each element, calling the provided callback.
     * @param {function(T, number, Array<T>): *} f The function to call
     *     for every element. This function takes 3 arguments (the element, the
     *     index and the array). The return value is ignored.
     * @api
     */
    forEach(t) {
      const e = this.array_;
      for (let n = 0, s = e.length; n < s; ++n)
        t(e[n], n, e);
    }
    /**
     * Get a reference to the underlying Array object. Warning: if the array
     * is mutated, no events will be dispatched by the collection, and the
     * collection's "length" property won't be in sync with the actual length
     * of the array.
     * @return {!Array<T>} Array.
     * @api
     */
    getArray() {
      return this.array_;
    }
    /**
     * Get the element at the provided index.
     * @param {number} index Index.
     * @return {T} Element.
     * @api
     */
    item(t) {
      return this.array_[t];
    }
    /**
     * Get the length of this collection.
     * @return {number} The length of the array.
     * @observable
     * @api
     */
    getLength() {
      return this.get(Dc.LENGTH);
    }
    /**
     * Insert an element at the provided index.
     * @param {number} index Index.
     * @param {T} elem Element.
     * @api
     */
    insertAt(t, e) {
      if (t < 0 || t > this.getLength())
        throw new Error("Index out of bounds: " + t);
      this.unique_ && this.assertUnique_(e), this.array_.splice(t, 0, e), this.updateLength_(), this.dispatchEvent(
        new da(we.ADD, e, t)
      );
    }
    /**
     * Remove the last element of the collection and return it.
     * Return `undefined` if the collection is empty.
     * @return {T|undefined} Element.
     * @api
     */
    pop() {
      return this.removeAt(this.getLength() - 1);
    }
    /**
     * Insert the provided element at the end of the collection.
     * @param {T} elem Element.
     * @return {number} New length of the collection.
     * @api
     */
    push(t) {
      this.unique_ && this.assertUnique_(t);
      const e = this.getLength();
      return this.insertAt(e, t), this.getLength();
    }
    /**
     * Remove the first occurrence of an element from the collection.
     * @param {T} elem Element.
     * @return {T|undefined} The removed element or undefined if none found.
     * @api
     */
    remove(t) {
      const e = this.array_;
      for (let n = 0, s = e.length; n < s; ++n)
        if (e[n] === t)
          return this.removeAt(n);
    }
    /**
     * Remove the element at the provided index and return it.
     * Return `undefined` if the collection does not contain this index.
     * @param {number} index Index.
     * @return {T|undefined} Value.
     * @api
     */
    removeAt(t) {
      if (t < 0 || t >= this.getLength())
        return;
      const e = this.array_[t];
      return this.array_.splice(t, 1), this.updateLength_(), this.dispatchEvent(
        /** @type {CollectionEvent<T>} */
        new da(we.REMOVE, e, t)
      ), e;
    }
    /**
     * Set the element at the provided index.
     * @param {number} index Index.
     * @param {T} elem Element.
     * @api
     */
    setAt(t, e) {
      const n = this.getLength();
      if (t >= n) {
        this.insertAt(t, e);
        return;
      }
      if (t < 0)
        throw new Error("Index out of bounds: " + t);
      this.unique_ && this.assertUnique_(e, t);
      const s = this.array_[t];
      this.array_[t] = e, this.dispatchEvent(
        /** @type {CollectionEvent<T>} */
        new da(we.REMOVE, s, t)
      ), this.dispatchEvent(
        /** @type {CollectionEvent<T>} */
        new da(we.ADD, e, t)
      );
    }
    /**
     * @private
     */
    updateLength_() {
      this.set(Dc.LENGTH, this.array_.length);
    }
    /**
     * @private
     * @param {T} elem Element.
     * @param {number} [except] Optional index to ignore.
     */
    assertUnique_(t, e) {
      for (let n = 0, s = this.array_.length; n < s; ++n)
        if (this.array_[n] === t && n !== e)
          throw new Error("Duplicate item added to a unique collection");
    }
  }
  const At = {
    OPACITY: "opacity",
    VISIBLE: "visible",
    EXTENT: "extent",
    Z_INDEX: "zIndex",
    MAX_RESOLUTION: "maxResolution",
    MIN_RESOLUTION: "minResolution",
    MAX_ZOOM: "maxZoom",
    MIN_ZOOM: "minZoom",
    SOURCE: "source",
    MAP: "map"
  };
  function Mt(i, t) {
    if (!i)
      throw new Error(t);
  }
  function Gt(i, t, e) {
    return Math.min(Math.max(i, t), e);
  }
  function b0(i, t, e, n, s, r) {
    const a = s - e, o = r - n;
    if (a !== 0 || o !== 0) {
      const l = ((i - e) * a + (t - n) * o) / (a * a + o * o);
      l > 1 ? (e = s, n = r) : l > 0 && (e += a * l, n += o * l);
    }
    return bn(i, t, e, n);
  }
  function bn(i, t, e, n) {
    const s = e - i, r = n - t;
    return s * s + r * r;
  }
  function L0(i) {
    const t = i.length;
    for (let n = 0; n < t; n++) {
      let s = n, r = Math.abs(i[n][n]);
      for (let o = n + 1; o < t; o++) {
        const l = Math.abs(i[o][n]);
        l > r && (r = l, s = o);
      }
      if (r === 0)
        return null;
      const a = i[s];
      i[s] = i[n], i[n] = a;
      for (let o = n + 1; o < t; o++) {
        const l = -i[o][n] / i[n][n];
        for (let h = n; h < t + 1; h++)
          n == h ? i[o][h] = 0 : i[o][h] += l * i[n][h];
      }
    }
    const e = new Array(t);
    for (let n = t - 1; n >= 0; n--) {
      e[n] = i[n][t] / i[n][n];
      for (let s = n - 1; s >= 0; s--)
        i[s][t] -= i[s][n] * e[n];
    }
    return e;
  }
  function kc(i) {
    return i * 180 / Math.PI;
  }
  function an(i) {
    return i * Math.PI / 180;
  }
  function ps(i, t) {
    const e = i % t;
    return e * t < 0 ? e + t : e;
  }
  function Fe(i, t, e) {
    return i + e * (t - i);
  }
  function oh(i, t) {
    const e = Math.pow(10, t);
    return Math.round(i * e) / e;
  }
  function fa(i, t) {
    return Math.floor(oh(i, t));
  }
  function ga(i, t) {
    return Math.ceil(oh(i, t));
  }
  function Cl(i, t, e) {
    if (i >= t && i < e)
      return i;
    const n = e - t;
    return ((i - t) % n + n) % n + t;
  }
  class gd extends si {
    /**
     * @param {Options} options Layer options.
     */
    constructor(t) {
      super(), this.on, this.once, this.un, this.background_ = t.background;
      const e = Object.assign({}, t);
      typeof t.properties == "object" && (delete e.properties, Object.assign(e, t.properties)), e[At.OPACITY] = t.opacity !== void 0 ? t.opacity : 1, Mt(
        typeof e[At.OPACITY] == "number",
        "Layer opacity must be a number"
      ), e[At.VISIBLE] = t.visible !== void 0 ? t.visible : !0, e[At.Z_INDEX] = t.zIndex, e[At.MAX_RESOLUTION] = t.maxResolution !== void 0 ? t.maxResolution : 1 / 0, e[At.MIN_RESOLUTION] = t.minResolution !== void 0 ? t.minResolution : 0, e[At.MIN_ZOOM] = t.minZoom !== void 0 ? t.minZoom : -1 / 0, e[At.MAX_ZOOM] = t.maxZoom !== void 0 ? t.maxZoom : 1 / 0, this.className_ = e.className !== void 0 ? e.className : "ol-layer", delete e.className, this.setProperties(e), this.state_ = null;
    }
    /**
     * Get the background for this layer.
     * @return {BackgroundColor|false} Layer background.
     */
    getBackground() {
      return this.background_;
    }
    /**
     * @return {string} CSS class name.
     */
    getClassName() {
      return this.className_;
    }
    /**
     * This method is not meant to be called by layers or layer renderers because the state
     * is incorrect if the layer is included in a layer group.
     *
     * @param {boolean} [managed] Layer is managed.
     * @return {import("./Layer.js").State} Layer state.
     */
    getLayerState(t) {
      const e = this.state_ || /** @type {?} */
      {
        layer: this,
        managed: t === void 0 ? !0 : t
      }, n = this.getZIndex();
      return e.opacity = Gt(Math.round(this.getOpacity() * 100) / 100, 0, 1), e.visible = this.getVisible(), e.extent = this.getExtent(), e.zIndex = n === void 0 && !e.managed ? 1 / 0 : n, e.maxResolution = this.getMaxResolution(), e.minResolution = Math.max(this.getMinResolution(), 0), e.minZoom = this.getMinZoom(), e.maxZoom = this.getMaxZoom(), this.state_ = e, e;
    }
    /**
     * @abstract
     * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
     *     modified in place).
     * @return {Array<import("./Layer.js").default>} Array of layers.
     */
    getLayersArray(t) {
      return ft();
    }
    /**
     * @abstract
     * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
     *     states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     */
    getLayerStatesArray(t) {
      return ft();
    }
    /**
     * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
     * will be visible regardless of extent.
     * @return {import("../extent.js").Extent|undefined} The layer extent.
     * @observable
     * @api
     */
    getExtent() {
      return (
        /** @type {import("../extent.js").Extent|undefined} */
        this.get(At.EXTENT)
      );
    }
    /**
     * Return the maximum resolution of the layer. Returns Infinity if
     * the layer has no maximum resolution set.
     * @return {number} The maximum resolution of the layer.
     * @observable
     * @api
     */
    getMaxResolution() {
      return (
        /** @type {number} */
        this.get(At.MAX_RESOLUTION)
      );
    }
    /**
     * Return the minimum resolution of the layer. Returns 0 if
     * the layer has no minimum resolution set.
     * @return {number} The minimum resolution of the layer.
     * @observable
     * @api
     */
    getMinResolution() {
      return (
        /** @type {number} */
        this.get(At.MIN_RESOLUTION)
      );
    }
    /**
     * Return the minimum zoom level of the layer. Returns -Infinity if
     * the layer has no minimum zoom set.
     * @return {number} The minimum zoom level of the layer.
     * @observable
     * @api
     */
    getMinZoom() {
      return (
        /** @type {number} */
        this.get(At.MIN_ZOOM)
      );
    }
    /**
     * Return the maximum zoom level of the layer. Returns Infinity if
     * the layer has no maximum zoom set.
     * @return {number} The maximum zoom level of the layer.
     * @observable
     * @api
     */
    getMaxZoom() {
      return (
        /** @type {number} */
        this.get(At.MAX_ZOOM)
      );
    }
    /**
     * Return the opacity of the layer (between 0 and 1).
     * @return {number} The opacity of the layer.
     * @observable
     * @api
     */
    getOpacity() {
      return (
        /** @type {number} */
        this.get(At.OPACITY)
      );
    }
    /**
     * @abstract
     * @return {import("../source/Source.js").State} Source state.
     */
    getSourceState() {
      return ft();
    }
    /**
     * Return the value of this layer's `visible` property. To find out whether the layer
     * is visible on a map, use `isVisible()` instead.
     * @return {boolean} The value of the `visible` property of the layer.
     * @observable
     * @api
     */
    getVisible() {
      return (
        /** @type {boolean} */
        this.get(At.VISIBLE)
      );
    }
    /**
     * Return the Z-index of the layer, which is used to order layers before
     * rendering. Returns undefined if the layer is unmanaged.
     * @return {number|undefined} The Z-index of the layer.
     * @observable
     * @api
     */
    getZIndex() {
      return (
        /** @type {number|undefined} */
        this.get(At.Z_INDEX)
      );
    }
    /**
     * Sets the background color.
     * @param {BackgroundColor} [background] Background color.
     */
    setBackground(t) {
      this.background_ = t, this.changed();
    }
    /**
     * Set the extent at which the layer is visible.  If `undefined`, the layer
     * will be visible at all extents.
     * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
     * @observable
     * @api
     */
    setExtent(t) {
      this.set(At.EXTENT, t);
    }
    /**
     * Set the maximum resolution at which the layer is visible.
     * @param {number} maxResolution The maximum resolution of the layer.
     * @observable
     * @api
     */
    setMaxResolution(t) {
      this.set(At.MAX_RESOLUTION, t);
    }
    /**
     * Set the minimum resolution at which the layer is visible.
     * @param {number} minResolution The minimum resolution of the layer.
     * @observable
     * @api
     */
    setMinResolution(t) {
      this.set(At.MIN_RESOLUTION, t);
    }
    /**
     * Set the maximum zoom (exclusive) at which the layer is visible.
     * Note that the zoom levels for layer visibility are based on the
     * view zoom level, which may be different from a tile source zoom level.
     * @param {number} maxZoom The maximum zoom of the layer.
     * @observable
     * @api
     */
    setMaxZoom(t) {
      this.set(At.MAX_ZOOM, t);
    }
    /**
     * Set the minimum zoom (inclusive) at which the layer is visible.
     * Note that the zoom levels for layer visibility are based on the
     * view zoom level, which may be different from a tile source zoom level.
     * @param {number} minZoom The minimum zoom of the layer.
     * @observable
     * @api
     */
    setMinZoom(t) {
      this.set(At.MIN_ZOOM, t);
    }
    /**
     * Set the opacity of the layer, allowed values range from 0 to 1.
     * @param {number} opacity The opacity of the layer.
     * @observable
     * @api
     */
    setOpacity(t) {
      Mt(typeof t == "number", "Layer opacity must be a number"), this.set(At.OPACITY, t);
    }
    /**
     * Set the visibility of the layer (`true` or `false`).
     * @param {boolean} visible The visibility of the layer.
     * @observable
     * @api
     */
    setVisible(t) {
      this.set(At.VISIBLE, t);
    }
    /**
     * Set Z-index of the layer, which is used to order layers before rendering.
     * The default Z-index is 0.
     * @param {number} zindex The z-index of the layer.
     * @observable
     * @api
     */
    setZIndex(t) {
      this.set(At.Z_INDEX, t);
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.state_ && (this.state_.layer = null, this.state_ = null), super.disposeInternal();
    }
  }
  const Be = {
    /**
     * Triggered before a layer is rendered.
     * @event module:ol/render/Event~RenderEvent#prerender
     * @api
     */
    PRERENDER: "prerender",
    /**
     * Triggered after a layer is rendered.
     * @event module:ol/render/Event~RenderEvent#postrender
     * @api
     */
    POSTRENDER: "postrender",
    /**
     * Triggered before layers are composed.  When dispatched by the map, the event object will not have
     * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
     * WebGL layers currently dispatch this event.
     * @event module:ol/render/Event~RenderEvent#precompose
     * @api
     */
    PRECOMPOSE: "precompose",
    /**
     * Triggered after layers are composed.  When dispatched by the map, the event object will not have
     * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
     * WebGL layers currently dispatch this event.
     * @event module:ol/render/Event~RenderEvent#postcompose
     * @api
     */
    POSTCOMPOSE: "postcompose",
    /**
     * Triggered when rendering is complete, i.e. all sources and tiles have
     * finished loading for the current viewport, and all tiles are faded in.
     * The event object will not have a `context` set.
     * @event module:ol/render/Event~RenderEvent#rendercomplete
     * @api
     */
    RENDERCOMPLETE: "rendercomplete"
  }, ae = {
    ANIMATING: 0,
    INTERACTING: 1
  }, Je = {
    CENTER: "center",
    RESOLUTION: "resolution",
    ROTATION: "rotation"
  }, O0 = 42, lh = 256, hh = {
    // use the radius of the Normal sphere
    radians: 6370997 / (2 * Math.PI),
    degrees: 2 * Math.PI * 6370997 / 360,
    ft: 0.3048,
    m: 1,
    "us-ft": 1200 / 3937
  };
  let fo = class {
    /**
     * @param {Options} options Projection options.
     */
    constructor(t) {
      this.code_ = t.code, this.units_ = /** @type {import("./Units.js").Units} */
      t.units, this.extent_ = t.extent !== void 0 ? t.extent : null, this.worldExtent_ = t.worldExtent !== void 0 ? t.worldExtent : null, this.axisOrientation_ = t.axisOrientation !== void 0 ? t.axisOrientation : "enu", this.global_ = t.global !== void 0 ? t.global : !1, this.canWrapX_ = !!(this.global_ && this.extent_), this.getPointResolutionFunc_ = t.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = t.metersPerUnit;
    }
    /**
     * @return {boolean} The projection is suitable for wrapping the x-axis
     */
    canWrapX() {
      return this.canWrapX_;
    }
    /**
     * Get the code for this projection, e.g. 'EPSG:4326'.
     * @return {string} Code.
     * @api
     */
    getCode() {
      return this.code_;
    }
    /**
     * Get the validity extent for this projection.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getExtent() {
      return this.extent_;
    }
    /**
     * Get the units of this projection.
     * @return {import("./Units.js").Units} Units.
     * @api
     */
    getUnits() {
      return this.units_;
    }
    /**
     * Get the amount of meters per unit of this projection.  If the projection is
     * not configured with `metersPerUnit` or a units identifier, the return is
     * `undefined`.
     * @return {number|undefined} Meters.
     * @api
     */
    getMetersPerUnit() {
      return this.metersPerUnit_ || hh[this.units_];
    }
    /**
     * Get the world extent for this projection.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getWorldExtent() {
      return this.worldExtent_;
    }
    /**
     * Get the axis orientation of this projection.
     * Example values are:
     * enu - the default easting, northing, elevation.
     * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
     *     or south orientated transverse mercator.
     * wnu - westing, northing, up - some planetary coordinate systems have
     *     "west positive" coordinate systems
     * @return {string} Axis orientation.
     * @api
     */
    getAxisOrientation() {
      return this.axisOrientation_;
    }
    /**
     * Is this projection a global projection which spans the whole world?
     * @return {boolean} Whether the projection is global.
     * @api
     */
    isGlobal() {
      return this.global_;
    }
    /**
     * Set if the projection is a global projection which spans the whole world
     * @param {boolean} global Whether the projection is global.
     * @api
     */
    setGlobal(t) {
      this.global_ = t, this.canWrapX_ = !!(t && this.extent_);
    }
    /**
     * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
     */
    getDefaultTileGrid() {
      return this.defaultTileGrid_;
    }
    /**
     * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
     */
    setDefaultTileGrid(t) {
      this.defaultTileGrid_ = t;
    }
    /**
     * Set the validity extent for this projection.
     * @param {import("../extent.js").Extent} extent Extent.
     * @api
     */
    setExtent(t) {
      this.extent_ = t, this.canWrapX_ = !!(this.global_ && t);
    }
    /**
     * Set the world extent for this projection.
     * @param {import("../extent.js").Extent} worldExtent World extent
     *     [minlon, minlat, maxlon, maxlat].
     * @api
     */
    setWorldExtent(t) {
      this.worldExtent_ = t;
    }
    /**
     * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
     * for this projection.
     * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
     * @api
     */
    setGetPointResolution(t) {
      this.getPointResolutionFunc_ = t;
    }
    /**
     * Get the custom point resolution function for this projection (if set).
     * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
     * resolution function (if set).
     */
    getPointResolutionFunc() {
      return this.getPointResolutionFunc_;
    }
  };
  const kr = 6378137, cs = Math.PI * kr, N0 = [-cs, -cs, cs, cs], F0 = [-180, -85, 180, 85], ma = kr * Math.log(Math.tan(Math.PI / 2));
  class Vn extends fo {
    /**
     * @param {string} code Code.
     */
    constructor(t) {
      super({
        code: t,
        units: "m",
        extent: N0,
        global: !0,
        worldExtent: F0,
        getPointResolution: function(e, n) {
          return e / Math.cosh(n[1] / kr);
        }
      });
    }
  }
  const Gc = [
    new Vn("EPSG:3857"),
    new Vn("EPSG:102100"),
    new Vn("EPSG:102113"),
    new Vn("EPSG:900913"),
    new Vn("http://www.opengis.net/def/crs/EPSG/0/3857"),
    new Vn("http://www.opengis.net/gml/srs/epsg.xml#3857")
  ];
  function D0(i, t, e, n) {
    const s = i.length;
    e = e > 1 ? e : 2, n = n ?? e, t === void 0 && (e > 2 ? t = i.slice() : t = new Array(s));
    for (let r = 0; r < s; r += n) {
      t[r] = cs * i[r] / 180;
      let a = kr * Math.log(Math.tan(Math.PI * (+i[r + 1] + 90) / 360));
      a > ma ? a = ma : a < -ma && (a = -ma), t[r + 1] = a;
    }
    return t;
  }
  function k0(i, t, e, n) {
    const s = i.length;
    e = e > 1 ? e : 2, n = n ?? e, t === void 0 && (e > 2 ? t = i.slice() : t = new Array(s));
    for (let r = 0; r < s; r += n)
      t[r] = 180 * i[r] / cs, t[r + 1] = 360 * Math.atan(Math.exp(i[r + 1] / kr)) / Math.PI - 90;
    return t;
  }
  const G0 = 6378137, Uc = [-180, -90, 180, 90], U0 = Math.PI * G0 / 180;
  class Mn extends fo {
    /**
     * @param {string} code Code.
     * @param {string} [axisOrientation] Axis orientation.
     */
    constructor(t, e) {
      super({
        code: t,
        units: "degrees",
        extent: Uc,
        axisOrientation: e,
        global: !0,
        metersPerUnit: U0,
        worldExtent: Uc
      });
    }
  }
  const zc = [
    new Mn("CRS:84"),
    new Mn("EPSG:4326", "neu"),
    new Mn("urn:ogc:def:crs:OGC:1.3:CRS84"),
    new Mn("urn:ogc:def:crs:OGC:2:84"),
    new Mn("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
    new Mn("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
    new Mn("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
  ];
  let Tl = {};
  function Pa(i) {
    return Tl[i] || Tl[i.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
  }
  function z0(i, t) {
    Tl[i] = t;
  }
  let ys = {};
  function Nn(i, t, e) {
    const n = i.getCode(), s = t.getCode();
    n in ys || (ys[n] = {}), ys[n][s] = e;
  }
  function ba(i, t) {
    return i in ys && t in ys[i] ? ys[i][t] : null;
  }
  const Vt = {
    UNKNOWN: 0,
    INTERSECTING: 1,
    ABOVE: 2,
    RIGHT: 4,
    BELOW: 8,
    LEFT: 16
  };
  function Il(i) {
    const t = Ae();
    for (let e = 0, n = i.length; e < n; ++e)
      Ln(t, i[e]);
    return t;
  }
  function B0(i, t, e) {
    const n = Math.min.apply(null, i), s = Math.min.apply(null, t), r = Math.max.apply(null, i), a = Math.max.apply(null, t);
    return ke(n, s, r, a, e);
  }
  function go(i, t, e) {
    return e ? (e[0] = i[0] - t, e[1] = i[1] - t, e[2] = i[2] + t, e[3] = i[3] + t, e) : [
      i[0] - t,
      i[1] - t,
      i[2] + t,
      i[3] + t
    ];
  }
  function ch(i, t) {
    return t ? (t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t) : i.slice();
  }
  function gn(i, t, e) {
    let n, s;
    return t < i[0] ? n = i[0] - t : i[2] < t ? n = t - i[2] : n = 0, e < i[1] ? s = i[1] - e : i[3] < e ? s = e - i[3] : s = 0, n * n + s * s;
  }
  function Fn(i, t) {
    return mo(i, t[0], t[1]);
  }
  function Qi(i, t) {
    return i[0] <= t[0] && t[2] <= i[2] && i[1] <= t[1] && t[3] <= i[3];
  }
  function mo(i, t, e) {
    return i[0] <= t && t <= i[2] && i[1] <= e && e <= i[3];
  }
  function Ga(i, t) {
    const e = i[0], n = i[1], s = i[2], r = i[3], a = t[0], o = t[1];
    let l = Vt.UNKNOWN;
    return a < e ? l = l | Vt.LEFT : a > s && (l = l | Vt.RIGHT), o < n ? l = l | Vt.BELOW : o > r && (l = l | Vt.ABOVE), l === Vt.UNKNOWN && (l = Vt.INTERSECTING), l;
  }
  function Ae() {
    return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  }
  function ke(i, t, e, n, s) {
    return s ? (s[0] = i, s[1] = t, s[2] = e, s[3] = n, s) : [i, t, e, n];
  }
  function Ni(i) {
    return ke(1 / 0, 1 / 0, -1 / 0, -1 / 0, i);
  }
  function uh(i, t) {
    const e = i[0], n = i[1];
    return ke(e, n, e, n, t);
  }
  function $0(i, t) {
    const e = Ni(t);
    return dh(e, i);
  }
  function _o(i, t, e, n, s) {
    const r = Ni(s);
    return fh(r, i, t, e, n);
  }
  function X0(i, t) {
    const e = Ni(t);
    return md(e, i);
  }
  function Ps(i, t) {
    return i[0] == t[0] && i[2] == t[2] && i[1] == t[1] && i[3] == t[3];
  }
  function W0(i, t, e) {
    return Math.abs(i[0] - t[0]) < e && Math.abs(i[2] - t[2]) < e && Math.abs(i[1] - t[1]) < e && Math.abs(i[3] - t[3]) < e;
  }
  function Gr(i, t) {
    return t[0] < i[0] && (i[0] = t[0]), t[2] > i[2] && (i[2] = t[2]), t[1] < i[1] && (i[1] = t[1]), t[3] > i[3] && (i[3] = t[3]), i;
  }
  function Ln(i, t) {
    t[0] < i[0] && (i[0] = t[0]), t[0] > i[2] && (i[2] = t[0]), t[1] < i[1] && (i[1] = t[1]), t[1] > i[3] && (i[3] = t[1]);
  }
  function dh(i, t) {
    for (let e = 0, n = t.length; e < n; ++e)
      Ln(i, t[e]);
    return i;
  }
  function fh(i, t, e, n, s) {
    for (; e < n; e += s)
      _d(i, t[e], t[e + 1]);
    return i;
  }
  function md(i, t) {
    for (let e = 0, n = t.length; e < n; ++e)
      dh(i, t[e]);
    return i;
  }
  function _d(i, t, e) {
    i[0] = Math.min(i[0], t), i[1] = Math.min(i[1], e), i[2] = Math.max(i[2], t), i[3] = Math.max(i[3], e);
  }
  function po(i, t) {
    let e;
    return e = t(Ur(i)), e || (e = t(zr(i)), e) || (e = t(Br(i)), e) || (e = t(fi(i)), e) ? e : !1;
  }
  function Dn(i) {
    let t = 0;
    return zs(i) || (t = _t(i) * $t(i)), t;
  }
  function Ur(i) {
    return [i[0], i[1]];
  }
  function zr(i) {
    return [i[2], i[1]];
  }
  function bi(i) {
    return [(i[0] + i[2]) / 2, (i[1] + i[3]) / 2];
  }
  function pd(i, t) {
    let e;
    if (t === "bottom-left")
      e = Ur(i);
    else if (t === "bottom-right")
      e = zr(i);
    else if (t === "top-left")
      e = fi(i);
    else if (t === "top-right")
      e = Br(i);
    else
      throw new Error("Invalid corner");
    return e;
  }
  function Y0(i, t) {
    const e = Math.min(i[0], t[0]), n = Math.min(i[1], t[1]), s = Math.max(i[2], t[2]), r = Math.max(i[3], t[3]);
    return (s - e) * (r - n);
  }
  function Ua(i, t, e, n, s) {
    const [r, a, o, l, h, c, u, d] = yd(
      i,
      t,
      e,
      n
    );
    return ke(
      Math.min(r, o, h, u),
      Math.min(a, l, c, d),
      Math.max(r, o, h, u),
      Math.max(a, l, c, d),
      s
    );
  }
  function yd(i, t, e, n) {
    const s = t * n[0] / 2, r = t * n[1] / 2, a = Math.cos(e), o = Math.sin(e), l = s * a, h = s * o, c = r * a, u = r * o, d = i[0], m = i[1];
    return [
      d - l + u,
      m - h - c,
      d - l - u,
      m - h + c,
      d + l - u,
      m + h + c,
      d + l + u,
      m + h - c,
      d - l + u,
      m - h - c
    ];
  }
  function $t(i) {
    return i[3] - i[1];
  }
  function Z0(i, t) {
    const e = De(i, t);
    return Dn(e);
  }
  function De(i, t, e) {
    const n = e || Ae();
    return he(i, t) ? (i[0] > t[0] ? n[0] = i[0] : n[0] = t[0], i[1] > t[1] ? n[1] = i[1] : n[1] = t[1], i[2] < t[2] ? n[2] = i[2] : n[2] = t[2], i[3] < t[3] ? n[3] = i[3] : n[3] = t[3]) : Ni(n), n;
  }
  function q0(i) {
    return _t(i) + $t(i);
  }
  function K0(i) {
    return [i[2] - i[0], i[3] - i[1]];
  }
  function fi(i) {
    return [i[0], i[3]];
  }
  function Br(i) {
    return [i[2], i[3]];
  }
  function _t(i) {
    return i[2] - i[0];
  }
  function he(i, t) {
    return i[0] <= t[2] && i[2] >= t[0] && i[1] <= t[3] && i[3] >= t[1];
  }
  function zs(i) {
    return i[2] < i[0] || i[3] < i[1];
  }
  function vd(i, t) {
    return t ? (t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t) : i;
  }
  function j0(i, t) {
    const e = (i[2] - i[0]) / 2 * (t - 1), n = (i[3] - i[1]) / 2 * (t - 1);
    i[0] -= e, i[2] += e, i[1] -= n, i[3] += n;
  }
  function Ed(i, t, e) {
    let n = !1;
    const s = Ga(i, t), r = Ga(i, e);
    if (s === Vt.INTERSECTING || r === Vt.INTERSECTING)
      n = !0;
    else {
      const a = i[0], o = i[1], l = i[2], h = i[3], c = t[0], u = t[1], d = e[0], m = e[1], f = (m - u) / (d - c);
      let y, E;
      r & Vt.ABOVE && !(s & Vt.ABOVE) && (y = d - (m - h) / f, n = y >= a && y <= l), !n && r & Vt.RIGHT && !(s & Vt.RIGHT) && (E = m - (d - l) * f, n = E >= o && E <= h), !n && r & Vt.BELOW && !(s & Vt.BELOW) && (y = d - (m - o) / f, n = y >= a && y <= l), !n && r & Vt.LEFT && !(s & Vt.LEFT) && (E = m - (d - a) * f, n = E >= o && E <= h);
    }
    return n;
  }
  function xd(i, t, e, n) {
    if (zs(i))
      return Ni(e);
    let s = [];
    if (n > 1) {
      const o = i[2] - i[0], l = i[3] - i[1];
      for (let h = 0; h < n; ++h)
        s.push(
          i[0] + o * h / n,
          i[1],
          i[2],
          i[1] + l * h / n,
          i[2] - o * h / n,
          i[3],
          i[0],
          i[3] - l * h / n
        );
    } else
      s = [
        i[0],
        i[1],
        i[2],
        i[1],
        i[2],
        i[3],
        i[0],
        i[3]
      ];
    t(s, s, 2);
    const r = [], a = [];
    for (let o = 0, l = s.length; o < l; o += 2)
      r.push(s[o]), a.push(s[o + 1]);
    return B0(r, a, e);
  }
  function gh(i, t) {
    const e = t.getExtent(), n = bi(i);
    if (t.canWrapX() && (n[0] < e[0] || n[0] >= e[2])) {
      const s = _t(e), a = Math.floor(
        (n[0] - e[0]) / s
      ) * s;
      i[0] -= a, i[2] -= a;
    }
    return i;
  }
  function yo(i, t, e) {
    if (t.canWrapX()) {
      const n = t.getExtent();
      if (!isFinite(i[0]) || !isFinite(i[2]))
        return [[n[0], i[1], n[2], i[3]]];
      gh(i, t);
      const s = _t(n);
      if (_t(i) > s && !e)
        return [[n[0], i[1], n[2], i[3]]];
      if (i[0] < n[0])
        return [
          [i[0] + s, i[1], n[2], i[3]],
          [n[0], i[1], i[2], i[3]]
        ];
      if (i[2] > n[2])
        return [
          [i[0], i[1], n[2], i[3]],
          [n[0], i[1], i[2] - s, i[3]]
        ];
    }
    return [i];
  }
  const V0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    applyTransform: xd,
    approximatelyEquals: W0,
    boundingExtent: Il,
    buffer: go,
    clone: ch,
    closestSquaredDistanceXY: gn,
    containsCoordinate: Fn,
    containsExtent: Qi,
    containsXY: mo,
    coordinateRelationship: Ga,
    createEmpty: Ae,
    createOrUpdate: ke,
    createOrUpdateEmpty: Ni,
    createOrUpdateFromCoordinate: uh,
    createOrUpdateFromCoordinates: $0,
    createOrUpdateFromFlatCoordinates: _o,
    createOrUpdateFromRings: X0,
    equals: Ps,
    extend: Gr,
    extendCoordinate: Ln,
    extendCoordinates: dh,
    extendFlatCoordinates: fh,
    extendRings: md,
    extendXY: _d,
    forEachCorner: po,
    getArea: Dn,
    getBottomLeft: Ur,
    getBottomRight: zr,
    getCenter: bi,
    getCorner: pd,
    getEnlargedArea: Y0,
    getForViewAndSize: Ua,
    getHeight: $t,
    getIntersection: De,
    getIntersectionArea: Z0,
    getMargin: q0,
    getRotatedViewport: yd,
    getSize: K0,
    getTopLeft: fi,
    getTopRight: Br,
    getWidth: _t,
    intersects: he,
    intersectsSegment: Ed,
    isEmpty: zs,
    returnOrUpdate: vd,
    scaleFromCenter: j0,
    wrapAndSliceX: yo,
    wrapX: gh
  }, Symbol.toStringTag, { value: "Module" }));
  function H0(i, t) {
    return i[0] += +t[0], i[1] += +t[1], i;
  }
  function za(i, t) {
    let e = !0;
    for (let n = i.length - 1; n >= 0; --n)
      if (i[n] != t[n]) {
        e = !1;
        break;
      }
    return e;
  }
  function mh(i, t) {
    const e = Math.cos(t), n = Math.sin(t), s = i[0] * e - i[1] * n, r = i[1] * e + i[0] * n;
    return i[0] = s, i[1] = r, i;
  }
  function J0(i, t) {
    return i[0] *= t, i[1] *= t, i;
  }
  function Md(i, t) {
    if (t.canWrapX()) {
      const e = _t(t.getExtent()), n = wd(i, t, e);
      n && (i[0] -= n * e);
    }
    return i;
  }
  function wd(i, t, e) {
    const n = t.getExtent();
    let s = 0;
    return t.canWrapX() && (i[0] < n[0] || i[0] > n[2]) && (e = e || _t(n), s = Math.floor(
      (i[0] - n[0]) / e
    )), s;
  }
  const Q0 = 63710088e-1;
  function Bc(i, t, e) {
    e = e || Q0;
    const n = an(i[1]), s = an(t[1]), r = (s - n) / 2, a = an(t[0] - i[0]) / 2, o = Math.sin(r) * Math.sin(r) + Math.sin(a) * Math.sin(a) * Math.cos(n) * Math.cos(s);
    return 2 * e * Math.atan2(Math.sqrt(o), Math.sqrt(1 - o));
  }
  const Ba = 0.9996, Xe = 669438e-8, vo = Xe * Xe, Eo = vo * Xe, Cn = Xe / (1 - Xe), $c = Math.sqrt(1 - Xe), bs = (1 - $c) / (1 + $c), Rd = bs * bs, _h = Rd * bs, ph = _h * bs, Sd = ph * bs, Cd = 1 - Xe / 4 - 3 * vo / 64 - 5 * Eo / 256, tm = 3 * Xe / 8 + 3 * vo / 32 + 45 * Eo / 1024, em = 15 * vo / 256 + 45 * Eo / 1024, im = 35 * Eo / 3072, nm = 3 / 2 * bs - 27 / 32 * _h + 269 / 512 * Sd, sm = 21 / 16 * Rd - 55 / 32 * ph, rm = 151 / 96 * _h - 417 / 128 * Sd, am = 1097 / 512 * ph, $a = 6378137;
  function om(i, t, e) {
    const n = i - 5e5, a = (e.north ? t : t - 1e7) / Ba / ($a * Cd), o = a + nm * Math.sin(2 * a) + sm * Math.sin(4 * a) + rm * Math.sin(6 * a) + am * Math.sin(8 * a), l = Math.sin(o), h = l * l, c = Math.cos(o), u = l / c, d = u * u, m = d * d, f = 1 - Xe * h, y = Math.sqrt(1 - Xe * h), E = $a / y, x = (1 - Xe) / f, M = Cn * c ** 2, C = M * M, R = n / (E * Ba), S = R * R, A = S * R, O = A * R, P = O * R, L = P * R, F = o - u / x * (S / 2 - O / 24 * (5 + 3 * d + 10 * M - 4 * C - 9 * Cn)) + L / 720 * (61 + 90 * d + 298 * M + 45 * m - 252 * Cn - 3 * C);
    let z = (R - A / 6 * (1 + 2 * d + M) + P / 120 * (5 - 2 * M + 28 * d - 3 * C + 8 * Cn + 24 * m)) / c;
    return z = Cl(
      z + an(Td(e.number)),
      -Math.PI,
      Math.PI
    ), [kc(z), kc(F)];
  }
  const Xc = -80, Wc = 84, lm = -180, hm = 180;
  function cm(i, t, e) {
    i = Cl(i, lm, hm), t < Xc ? t = Xc : t > Wc && (t = Wc);
    const n = an(t), s = Math.sin(n), r = Math.cos(n), a = s / r, o = a * a, l = o * o, h = an(i), c = Td(e.number), u = an(c), d = $a / Math.sqrt(1 - Xe * s ** 2), m = Cn * r ** 2, f = r * Cl(h - u, -Math.PI, Math.PI), y = f * f, E = y * f, x = E * f, M = x * f, C = M * f, R = $a * (Cd * n - tm * Math.sin(2 * n) + em * Math.sin(4 * n) - im * Math.sin(6 * n)), S = Ba * d * (f + E / 6 * (1 - o + m) + M / 120 * (5 - 18 * o + l + 72 * m - 58 * Cn)) + 5e5;
    let A = Ba * (R + d * a * (y / 2 + x / 24 * (5 - o + 9 * m + 4 * m ** 2) + C / 720 * (61 - 58 * o + l + 600 * m - 330 * Cn)));
    return e.north || (A += 1e7), [S, A];
  }
  function Td(i) {
    return (i - 1) * 6 - 180 + 3;
  }
  const um = [
    /^EPSG:(\d+)$/,
    /^urn:ogc:def:crs:EPSG::(\d+)$/,
    /^http:\/\/www\.opengis\.net\/def\/crs\/EPSG\/0\/(\d+)$/
  ];
  function Id(i) {
    let t = 0;
    for (const s of um) {
      const r = i.match(s);
      if (r) {
        t = parseInt(r[1]);
        break;
      }
    }
    if (!t)
      return null;
    let e = 0, n = !1;
    return t > 32700 && t < 32761 ? e = t - 32700 : t > 32600 && t < 32661 && (n = !0, e = t - 32600), e ? { number: e, north: n } : null;
  }
  function Yc(i, t) {
    return function(e, n, s, r) {
      const a = e.length;
      s = s > 1 ? s : 2, r = r ?? s, n || (s > 2 ? n = e.slice() : n = new Array(a));
      for (let o = 0; o < a; o += r) {
        const l = e[o], h = e[o + 1], c = i(l, h, t);
        n[o] = c[0], n[o + 1] = c[1];
      }
      return n;
    };
  }
  function dm(i) {
    return Id(i) ? new fo({ code: i, units: "m" }) : null;
  }
  function fm(i) {
    const t = Id(i.getCode());
    return t ? {
      forward: Yc(cm, t),
      inverse: Yc(om, t)
    } : null;
  }
  function Ad(...i) {
    console.warn(...i);
  }
  const gm = [fm], mm = [dm];
  let Al = !0;
  function _m(i) {
    Al = !1;
  }
  function yh(i, t) {
    if (t !== void 0) {
      for (let e = 0, n = i.length; e < n; ++e)
        t[e] = i[e];
      t = t;
    } else
      t = i.slice();
    return t;
  }
  function Xa(i) {
    z0(i.getCode(), i), Nn(i, i, yh);
  }
  function pm(i) {
    i.forEach(Xa);
  }
  function Pt(i) {
    if (typeof i != "string")
      return i;
    const t = Pa(i);
    if (t)
      return t;
    for (const e of mm) {
      const n = e(i);
      if (n)
        return n;
    }
    return null;
  }
  function Pl(i, t, e, n) {
    i = Pt(i);
    let s;
    const r = i.getPointResolutionFunc();
    if (r)
      s = r(t, e);
    else {
      const a = i.getUnits();
      if (a == "degrees" || n == "degrees")
        s = t;
      else {
        const o = Eh(
          i,
          Pt("EPSG:4326")
        );
        if (!o && a !== "degrees")
          s = t * i.getMetersPerUnit();
        else {
          let h = [
            e[0] - t / 2,
            e[1],
            e[0] + t / 2,
            e[1],
            e[0],
            e[1] - t / 2,
            e[0],
            e[1] + t / 2
          ];
          h = o(h, h, 2);
          const c = Bc(h.slice(0, 2), h.slice(2, 4)), u = Bc(h.slice(4, 6), h.slice(6, 8));
          s = (c + u) / 2;
        }
        const l = i.getMetersPerUnit();
        l !== void 0 && (s /= l);
      }
    }
    return s;
  }
  function bl(i) {
    pm(i), i.forEach(function(t) {
      i.forEach(function(e) {
        t !== e && Nn(t, e, yh);
      });
    });
  }
  function ym(i, t, e, n) {
    i.forEach(function(s) {
      t.forEach(function(r) {
        Nn(s, r, e), Nn(r, s, n);
      });
    });
  }
  function vh(i, t) {
    return i ? typeof i == "string" ? Pt(i) : (
      /** @type {Projection} */
      i
    ) : Pt(t);
  }
  function Ll(i) {
    return (
      /**
       * @param {Array<number>} input Input.
       * @param {Array<number>} [output] Output.
       * @param {number} [dimension] Dimensions that should be transformed.
       * @param {number} [stride] Stride.
       * @return {Array<number>} Output.
       */
      function(t, e, n, s) {
        const r = t.length;
        n = n !== void 0 ? n : 2, s = s ?? n, e = e !== void 0 ? e : new Array(r);
        for (let a = 0; a < r; a += s) {
          const o = i(t.slice(a, a + n)), l = o.length;
          for (let h = 0, c = s; h < c; ++h)
            e[a + h] = h >= l ? t[a + h] : o[h];
        }
        return e;
      }
    );
  }
  function vm(i, t, e, n) {
    const s = Pt(i), r = Pt(t);
    Nn(
      s,
      r,
      Ll(e)
    ), Nn(
      r,
      s,
      Ll(n)
    );
  }
  function dr(i, t) {
    if (i === t)
      return !0;
    const e = i.getUnits() === t.getUnits();
    return (i.getCode() === t.getCode() || Eh(i, t) === yh) && e;
  }
  function Eh(i, t) {
    const e = i.getCode(), n = t.getCode();
    let s = ba(e, n);
    if (s)
      return s;
    let r = null, a = null;
    for (const l of gm)
      r || (r = l(i)), a || (a = l(t));
    if (!r && !a)
      return null;
    const o = "EPSG:4326";
    if (a)
      if (r)
        s = Qo(
          r.inverse,
          a.forward
        );
      else {
        const l = ba(e, o);
        l && (s = Qo(
          l,
          a.forward
        ));
      }
    else {
      const l = ba(o, n);
      l && (s = Qo(
        r.inverse,
        l
      ));
    }
    return s && (Xa(i), Xa(t), Nn(i, t, s)), s;
  }
  function Qo(i, t) {
    return function(e, n, s, r) {
      return n = i(e, n, s, r), t(n, n, s, r);
    };
  }
  function Ls(i, t) {
    const e = Pt(i), n = Pt(t);
    return Eh(e, n);
  }
  function Pd(i, t, e) {
    const n = Ls(t, e);
    if (!n) {
      const s = Pt(t).getCode(), r = Pt(e).getCode();
      throw new Error(
        `No transform available between ${s} and ${r}`
      );
    }
    return n(i, void 0, i.length);
  }
  function Em(i, t, e, n) {
    const s = Ls(t, e);
    return xd(i, s, void 0, n);
  }
  function Ol(i, t) {
    return i;
  }
  function Si(i, t) {
    return Al && !za(i, [0, 0]) && i[0] >= -180 && i[0] <= 180 && i[1] >= -90 && i[1] <= 90 && (Al = !1, Ad(
      "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
    )), i;
  }
  function bd(i, t) {
    return i;
  }
  function tn(i, t) {
    return i;
  }
  function Zc(i, t, e) {
    return function(n) {
      let s, r;
      if (i.canWrapX()) {
        const a = i.getExtent(), o = _t(a);
        n = n.slice(0), r = wd(n, i, o), r && (n[0] = n[0] - r * o), n[0] = Gt(n[0], a[0], a[2]), n[1] = Gt(n[1], a[1], a[3]), s = e(n);
      } else
        s = e(n);
      return r && t.canWrapX() && (s[0] += r * _t(t.getExtent())), s;
    };
  }
  function xm() {
    bl(Gc), bl(zc), ym(
      zc,
      Gc,
      D0,
      k0
    );
  }
  xm();
  function qc(i, t, e) {
    return (
      /**
       * @param {import("./coordinate.js").Coordinate|undefined} center Center.
       * @param {number|undefined} resolution Resolution.
       * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
       * @param {boolean} [isMoving] True if an interaction or animation is in progress.
       * @param {Array<number>} [centerShift] Shift between map center and viewport center.
       * @return {import("./coordinate.js").Coordinate|undefined} Center.
       */
      function(n, s, r, a, o) {
        if (!n)
          return;
        if (!s && !t)
          return n;
        const l = t ? 0 : r[0] * s, h = t ? 0 : r[1] * s, c = o ? o[0] : 0, u = o ? o[1] : 0;
        let d = i[0] + l / 2 + c, m = i[2] - l / 2 + c, f = i[1] + h / 2 + u, y = i[3] - h / 2 + u;
        d > m && (d = (m + d) / 2, m = d), f > y && (f = (y + f) / 2, y = f);
        let E = Gt(n[0], d, m), x = Gt(n[1], f, y);
        if (a && e && s) {
          const M = 30 * s;
          E += -M * Math.log(1 + Math.max(0, d - n[0]) / M) + M * Math.log(1 + Math.max(0, n[0] - m) / M), x += -M * Math.log(1 + Math.max(0, f - n[1]) / M) + M * Math.log(1 + Math.max(0, n[1] - y) / M);
        }
        return [E, x];
      }
    );
  }
  function Mm(i) {
    return i;
  }
  function xh(i, t, e, n) {
    const s = _t(t) / e[0], r = $t(t) / e[1];
    return n ? Math.min(i, Math.max(s, r)) : Math.min(i, Math.min(s, r));
  }
  function Mh(i, t, e) {
    let n = Math.min(i, t);
    const s = 50;
    return n *= Math.log(1 + s * Math.max(0, i / t - 1)) / s + 1, e && (n = Math.max(n, e), n /= Math.log(1 + s * Math.max(0, e / i - 1)) / s + 1), Gt(n, e / 2, t * 2);
  }
  function wm(i, t, e, n) {
    return t = t !== void 0 ? t : !0, /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(s, r, a, o) {
      if (s !== void 0) {
        const l = i[0], h = i[i.length - 1], c = e ? xh(
          l,
          e,
          a,
          n
        ) : l;
        if (o)
          return t ? Mh(
            s,
            c,
            h
          ) : Gt(s, h, c);
        const u = Math.min(c, s), d = Math.floor(ah(i, u, r));
        return i[d] > c && d < i.length - 1 ? i[d + 1] : i[d];
      }
    };
  }
  function Rm(i, t, e, n, s, r) {
    return n = n !== void 0 ? n : !0, e = e !== void 0 ? e : 0, /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(a, o, l, h) {
      if (a !== void 0) {
        const c = s ? xh(
          t,
          s,
          l,
          r
        ) : t;
        if (h)
          return n ? Mh(
            a,
            c,
            e
          ) : Gt(a, e, c);
        const u = 1e-9, d = Math.ceil(
          Math.log(t / c) / Math.log(i) - u
        ), m = -o * (0.5 - u) + 0.5, f = Math.min(c, a), y = Math.floor(
          Math.log(t / f) / Math.log(i) + m
        ), E = Math.max(d, y), x = t / Math.pow(i, E);
        return Gt(x, e, c);
      }
    };
  }
  function Kc(i, t, e, n, s) {
    return e = e !== void 0 ? e : !0, /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(r, a, o, l) {
      if (r !== void 0) {
        const h = n ? xh(
          i,
          n,
          o,
          s
        ) : i;
        return !e || !l ? Gt(r, t, h) : Mh(
          r,
          h,
          t
        );
      }
    };
  }
  function wh(i) {
    if (i !== void 0)
      return 0;
  }
  function jc(i) {
    if (i !== void 0)
      return i;
  }
  function Sm(i) {
    const t = 2 * Math.PI / i;
    return (
      /**
       * @param {number|undefined} rotation Rotation.
       * @param {boolean} [isMoving] True if an interaction or animation is in progress.
       * @return {number|undefined} Rotation.
       */
      function(e, n) {
        if (n)
          return e;
        if (e !== void 0)
          return e = Math.floor(e / t + 0.5) * t, e;
      }
    );
  }
  function Cm(i) {
    const t = an(5);
    return (
      /**
       * @param {number|undefined} rotation Rotation.
       * @param {boolean} [isMoving] True if an interaction or animation is in progress.
       * @return {number|undefined} Rotation.
       */
      function(e, n) {
        return n || e === void 0 ? e : Math.abs(e) <= t ? 0 : e;
      }
    );
  }
  function Ld(i) {
    return Math.pow(i, 3);
  }
  function Bs(i) {
    return 1 - Ld(1 - i);
  }
  function Tm(i) {
    return 3 * i * i - 2 * i * i * i;
  }
  function Im(i) {
    return i;
  }
  const Am = new Array(6);
  function We() {
    return [1, 0, 0, 1, 0, 0];
  }
  function Od(i, t) {
    const e = i[0], n = i[1], s = i[2], r = i[3], a = i[4], o = i[5], l = t[0], h = t[1], c = t[2], u = t[3], d = t[4], m = t[5];
    return i[0] = e * l + s * h, i[1] = n * l + r * h, i[2] = e * c + s * u, i[3] = n * c + r * u, i[4] = e * d + s * m + a, i[5] = n * d + r * m + o, i;
  }
  function Pm(i, t, e, n, s, r, a) {
    return i[0] = t, i[1] = e, i[2] = n, i[3] = s, i[4] = r, i[5] = a, i;
  }
  function bm(i, t) {
    return i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[4] = t[4], i[5] = t[5], i;
  }
  function Yt(i, t) {
    const e = t[0], n = t[1];
    return t[0] = i[0] * e + i[2] * n + i[4], t[1] = i[1] * e + i[3] * n + i[5], t;
  }
  function Lm(i, t, e) {
    return Od(i, Pm(Am, t, 0, 0, e, 0, 0));
  }
  function Li(i, t, e, n, s, r, a, o) {
    const l = Math.sin(r), h = Math.cos(r);
    return i[0] = n * h, i[1] = s * l, i[2] = -n * l, i[3] = s * h, i[4] = a * n * h - o * n * l + t, i[5] = a * s * l + o * s * h + e, i;
  }
  function Nd(i, t) {
    const e = Om(t);
    Mt(e !== 0, "Transformation matrix cannot be inverted");
    const n = t[0], s = t[1], r = t[2], a = t[3], o = t[4], l = t[5];
    return i[0] = a / e, i[1] = -s / e, i[2] = -r / e, i[3] = n / e, i[4] = (r * l - a * o) / e, i[5] = -(n * l - s * o) / e, i;
  }
  function Om(i) {
    return i[0] * i[3] - i[1] * i[2];
  }
  const Vc = [1e6, 1e6, 1e6, 1e6, 2, 2];
  function Nm(i) {
    return "matrix(" + i.map(
      (e, n) => Math.round(e * Vc[n]) / Vc[n]
    ).join(", ") + ")";
  }
  function on(i, t, e, n, s, r, a) {
    r = r || [], a = a || 2;
    let o = 0;
    for (let l = t; l < e; l += n) {
      const h = i[l], c = i[l + 1];
      r[o++] = s[0] * h + s[2] * c + s[4], r[o++] = s[1] * h + s[3] * c + s[5];
      for (let u = 2; u < a; u++)
        r[o++] = i[l + u];
    }
    return r && r.length != o && (r.length = o), r;
  }
  function Rh(i, t, e, n, s, r, a) {
    a = a || [];
    const o = Math.cos(s), l = Math.sin(s), h = r[0], c = r[1];
    let u = 0;
    for (let d = t; d < e; d += n) {
      const m = i[d] - h, f = i[d + 1] - c;
      a[u++] = h + m * o - f * l, a[u++] = c + m * l + f * o;
      for (let y = d + 2; y < d + n; ++y)
        a[u++] = i[y];
    }
    return a && a.length != u && (a.length = u), a;
  }
  function Fm(i, t, e, n, s, r, a, o) {
    o = o || [];
    const l = a[0], h = a[1];
    let c = 0;
    for (let u = t; u < e; u += n) {
      const d = i[u] - l, m = i[u + 1] - h;
      o[c++] = l + s * d, o[c++] = h + r * m;
      for (let f = u + 2; f < u + n; ++f)
        o[c++] = i[f];
    }
    return o && o.length != c && (o.length = c), o;
  }
  function Dm(i, t, e, n, s, r, a) {
    a = a || [];
    let o = 0;
    for (let l = t; l < e; l += n) {
      a[o++] = i[l] + s, a[o++] = i[l + 1] + r;
      for (let h = l + 2; h < l + n; ++h)
        a[o++] = i[h];
    }
    return a && a.length != o && (a.length = o), a;
  }
  const Hc = We();
  class xo extends si {
    constructor() {
      super(), this.extent_ = Ae(), this.extentRevision_ = -1, this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = 0, this.simplifyTransformedInternal = fd(
        (t, e, n) => {
          if (!n)
            return this.getSimplifiedGeometry(e);
          const s = this.clone();
          return s.applyTransform(n), s.getSimplifiedGeometry(e);
        }
      );
    }
    /**
     * Get a transformed and simplified version of the geometry.
     * @abstract
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
     * @return {Geometry} Simplified geometry.
     */
    simplifyTransformed(t, e) {
      return this.simplifyTransformedInternal(
        this.getRevision(),
        t,
        e
      );
    }
    /**
     * Make a complete copy of the geometry.
     * @abstract
     * @return {!Geometry} Clone.
     */
    clone() {
      return ft();
    }
    /**
     * @abstract
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
    closestPointXY(t, e, n, s) {
      return ft();
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
    containsXY(t, e) {
      const n = this.getClosestPoint([t, e]);
      return n[0] === t && n[1] === e;
    }
    /**
     * Return the closest point of the geometry to the passed point as
     * {@link module:ol/coordinate~Coordinate coordinate}.
     * @param {import("../coordinate.js").Coordinate} point Point.
     * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
     * @return {import("../coordinate.js").Coordinate} Closest point.
     * @api
     */
    getClosestPoint(t, e) {
      return e = e || [NaN, NaN], this.closestPointXY(t[0], t[1], e, 1 / 0), e;
    }
    /**
     * Returns true if this geometry includes the specified coordinate. If the
     * coordinate is on the boundary of the geometry, returns false.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains coordinate.
     * @api
     */
    intersectsCoordinate(t) {
      return this.containsXY(t[0], t[1]);
    }
    /**
     * @abstract
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     */
    computeExtent(t) {
      return ft();
    }
    /**
     * Get the extent of the geometry.
     * @param {import("../extent.js").Extent} [extent] Extent.
     * @return {import("../extent.js").Extent} extent Extent.
     * @api
     */
    getExtent(t) {
      if (this.extentRevision_ != this.getRevision()) {
        const e = this.computeExtent(this.extent_);
        (isNaN(e[0]) || isNaN(e[1])) && Ni(e), this.extentRevision_ = this.getRevision();
      }
      return vd(this.extent_, t);
    }
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @abstract
     * @param {number} angle Rotation angle in radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     */
    rotate(t, e) {
      ft();
    }
    /**
     * Scale the geometry (with an optional origin).  This modifies the geometry
     * coordinates in place.
     * @abstract
     * @param {number} sx The scaling factor in the x-direction.
     * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
     * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
     *     of the geometry extent).
     * @api
     */
    scale(t, e, n) {
      ft();
    }
    /**
     * Create a simplified version of this geometry.  For linestrings, this uses
     * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
     * algorithm.  For polygons, a quantization-based
     * simplification is used to preserve topology.
     * @param {number} tolerance The tolerance distance for simplification.
     * @return {Geometry} A new, simplified version of the original geometry.
     * @api
     */
    simplify(t) {
      return this.getSimplifiedGeometry(t * t);
    }
    /**
     * Create a simplified version of this geometry using the Douglas Peucker
     * algorithm.
     * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
     * @abstract
     * @param {number} squaredTolerance Squared tolerance.
     * @return {Geometry} Simplified geometry.
     */
    getSimplifiedGeometry(t) {
      return ft();
    }
    /**
     * Get the type of this geometry.
     * @abstract
     * @return {Type} Geometry type.
     */
    getType() {
      return ft();
    }
    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @abstract
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     * Called with a flat array of geometry coordinates.
     */
    applyTransform(t) {
      ft();
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @abstract
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     */
    intersectsExtent(t) {
      return ft();
    }
    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @abstract
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     */
    translate(t, e) {
      ft();
    }
    /**
     * Transform each coordinate of the geometry from one coordinate reference
     * system to another. The geometry is modified in place.
     * For example, a line will be transformed to a line and a circle to a circle.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     *
     * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
     * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
     * @return {this} This geometry.  Note that original geometry is
     *     modified in place.
     * @api
     */
    transform(t, e) {
      const n = Pt(t), s = n.getUnits() == "tile-pixels" ? function(r, a, o) {
        const l = n.getExtent(), h = n.getWorldExtent(), c = $t(h) / $t(l);
        Li(
          Hc,
          h[0],
          h[3],
          c,
          -c,
          0,
          0,
          0
        );
        const u = on(
          r,
          0,
          r.length,
          o,
          Hc,
          a
        ), d = Ls(n, e);
        return d ? d(u, u, o) : u;
      } : Ls(n, e);
      return this.applyTransform(s), this;
    }
  }
  class Fi extends xo {
    constructor() {
      super(), this.layout = "XY", this.stride = 2, this.flatCoordinates;
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     * @override
     */
    computeExtent(t) {
      return _o(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        t
      );
    }
    /**
     * @abstract
     * @return {Array<*> | null} Coordinates.
     */
    getCoordinates() {
      return ft();
    }
    /**
     * Return the first coordinate of the geometry.
     * @return {import("../coordinate.js").Coordinate} First coordinate.
     * @api
     */
    getFirstCoordinate() {
      return this.flatCoordinates.slice(0, this.stride);
    }
    /**
     * @return {Array<number>} Flat coordinates.
     */
    getFlatCoordinates() {
      return this.flatCoordinates;
    }
    /**
     * Return the last coordinate of the geometry.
     * @return {import("../coordinate.js").Coordinate} Last point.
     * @api
     */
    getLastCoordinate() {
      return this.flatCoordinates.slice(
        this.flatCoordinates.length - this.stride
      );
    }
    /**
     * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
     * @return {import("./Geometry.js").GeometryLayout} Layout.
     * @api
     */
    getLayout() {
      return this.layout;
    }
    /**
     * Create a simplified version of this geometry using the Douglas Peucker algorithm.
     * @param {number} squaredTolerance Squared tolerance.
     * @return {SimpleGeometry} Simplified geometry.
     * @override
     */
    getSimplifiedGeometry(t) {
      if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && t <= this.simplifiedGeometryMaxMinSquaredTolerance)
        return this;
      const e = this.getSimplifiedGeometryInternal(t);
      return e.getFlatCoordinates().length < this.flatCoordinates.length ? e : (this.simplifiedGeometryMaxMinSquaredTolerance = t, this);
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {SimpleGeometry} Simplified geometry.
     * @protected
     */
    getSimplifiedGeometryInternal(t) {
      return this;
    }
    /**
     * @return {number} Stride.
     */
    getStride() {
      return this.stride;
    }
    /**
     * @param {import("./Geometry.js").GeometryLayout} layout Layout.
     * @param {Array<number>} flatCoordinates Flat coordinates.
     */
    setFlatCoordinates(t, e) {
      this.stride = Jc(t), this.layout = t, this.flatCoordinates = e;
    }
    /**
     * @abstract
     * @param {!Array<*>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    setCoordinates(t, e) {
      ft();
    }
    /**
     * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
     * @param {Array<*>} coordinates Coordinates.
     * @param {number} nesting Nesting.
     * @protected
     */
    setLayout(t, e, n) {
      let s;
      if (t)
        s = Jc(t);
      else {
        for (let r = 0; r < n; ++r) {
          if (e.length === 0) {
            this.layout = "XY", this.stride = 2;
            return;
          }
          e = /** @type {Array<unknown>} */
          e[0];
        }
        s = e.length, t = km(s);
      }
      this.layout = t, this.stride = s;
    }
    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     * Called with a flat array of geometry coordinates.
     * @api
     * @override
     */
    applyTransform(t) {
      this.flatCoordinates && (t(
        this.flatCoordinates,
        this.flatCoordinates,
        this.layout.startsWith("XYZ") ? 3 : 2,
        this.stride
      ), this.changed());
    }
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @param {number} angle Rotation angle in counter-clockwise radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     * @override
     */
    rotate(t, e) {
      const n = this.getFlatCoordinates();
      if (n) {
        const s = this.getStride();
        Rh(
          n,
          0,
          n.length,
          s,
          t,
          e,
          n
        ), this.changed();
      }
    }
    /**
     * Scale the geometry (with an optional origin).  This modifies the geometry
     * coordinates in place.
     * @param {number} sx The scaling factor in the x-direction.
     * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
     * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
     *     of the geometry extent).
     * @api
     * @override
     */
    scale(t, e, n) {
      e === void 0 && (e = t), n || (n = bi(this.getExtent()));
      const s = this.getFlatCoordinates();
      if (s) {
        const r = this.getStride();
        Fm(
          s,
          0,
          s.length,
          r,
          t,
          e,
          n,
          s
        ), this.changed();
      }
    }
    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     * @override
     */
    translate(t, e) {
      const n = this.getFlatCoordinates();
      if (n) {
        const s = this.getStride();
        Dm(
          n,
          0,
          n.length,
          s,
          t,
          e,
          n
        ), this.changed();
      }
    }
  }
  function km(i) {
    let t;
    return i == 2 ? t = "XY" : i == 3 ? t = "XYZ" : i == 4 && (t = "XYZM"), /** @type {import("./Geometry.js").GeometryLayout} */
    t;
  }
  function Jc(i) {
    let t;
    return i == "XY" ? t = 2 : i == "XYZ" || i == "XYM" ? t = 3 : i == "XYZM" && (t = 4), /** @type {number} */
    t;
  }
  function Gm(i, t, e) {
    const n = i.getFlatCoordinates();
    if (!n)
      return null;
    const s = i.getStride();
    return on(
      n,
      0,
      n.length,
      s,
      t,
      e
    );
  }
  function Qc(i, t, e, n, s, r, a) {
    const o = i[t], l = i[t + 1], h = i[e] - o, c = i[e + 1] - l;
    let u;
    if (h === 0 && c === 0)
      u = t;
    else {
      const d = ((s - o) * h + (r - l) * c) / (h * h + c * c);
      if (d > 1)
        u = e;
      else if (d > 0) {
        for (let m = 0; m < n; ++m)
          a[m] = Fe(
            i[t + m],
            i[e + m],
            d
          );
        a.length = n;
        return;
      } else
        u = t;
    }
    for (let d = 0; d < n; ++d)
      a[d] = i[u + d];
    a.length = n;
  }
  function Sh(i, t, e, n, s) {
    let r = i[t], a = i[t + 1];
    for (t += n; t < e; t += n) {
      const o = i[t], l = i[t + 1], h = bn(r, a, o, l);
      h > s && (s = h), r = o, a = l;
    }
    return s;
  }
  function Ch(i, t, e, n, s) {
    for (let r = 0, a = e.length; r < a; ++r) {
      const o = e[r];
      s = Sh(i, t, o, n, s), t = o;
    }
    return s;
  }
  function Um(i, t, e, n, s) {
    for (let r = 0, a = e.length; r < a; ++r) {
      const o = e[r];
      s = Ch(i, t, o, n, s), t = o[o.length - 1];
    }
    return s;
  }
  function Th(i, t, e, n, s, r, a, o, l, h, c) {
    if (t == e)
      return h;
    let u, d;
    if (s === 0) {
      if (d = bn(
        a,
        o,
        i[t],
        i[t + 1]
      ), d < h) {
        for (u = 0; u < n; ++u)
          l[u] = i[t + u];
        return l.length = n, d;
      }
      return h;
    }
    c = c || [NaN, NaN];
    let m = t + n;
    for (; m < e; )
      if (Qc(
        i,
        m - n,
        m,
        n,
        a,
        o,
        c
      ), d = bn(a, o, c[0], c[1]), d < h) {
        for (h = d, u = 0; u < n; ++u)
          l[u] = c[u];
        l.length = n, m += n;
      } else
        m += n * Math.max(
          (Math.sqrt(d) - Math.sqrt(h)) / s | 0,
          1
        );
    if (r && (Qc(
      i,
      e - n,
      t,
      n,
      a,
      o,
      c
    ), d = bn(a, o, c[0], c[1]), d < h)) {
      for (h = d, u = 0; u < n; ++u)
        l[u] = c[u];
      l.length = n;
    }
    return h;
  }
  function Ih(i, t, e, n, s, r, a, o, l, h, c) {
    c = c || [NaN, NaN];
    for (let u = 0, d = e.length; u < d; ++u) {
      const m = e[u];
      h = Th(
        i,
        t,
        m,
        n,
        s,
        r,
        a,
        o,
        l,
        h,
        c
      ), t = m;
    }
    return h;
  }
  function zm(i, t, e, n, s, r, a, o, l, h, c) {
    c = c || [NaN, NaN];
    for (let u = 0, d = e.length; u < d; ++u) {
      const m = e[u];
      h = Ih(
        i,
        t,
        m,
        n,
        s,
        r,
        a,
        o,
        l,
        h,
        c
      ), t = m[m.length - 1];
    }
    return h;
  }
  function Fd(i, t, e, n) {
    for (let s = 0, r = e.length; s < r; ++s)
      i[t++] = e[s];
    return t;
  }
  function Mo(i, t, e, n) {
    for (let s = 0, r = e.length; s < r; ++s) {
      const a = e[s];
      for (let o = 0; o < n; ++o)
        i[t++] = a[o];
    }
    return t;
  }
  function Ah(i, t, e, n, s) {
    s = s || [];
    let r = 0;
    for (let a = 0, o = e.length; a < o; ++a) {
      const l = Mo(
        i,
        t,
        e[a],
        n
      );
      s[r++] = l, t = l;
    }
    return s.length = r, s;
  }
  function Bm(i, t, e, n, s) {
    s = s || [];
    let r = 0;
    for (let a = 0, o = e.length; a < o; ++a) {
      const l = Ah(
        i,
        t,
        e[a],
        n,
        s[r]
      );
      l.length === 0 && (l[0] = t), s[r++] = l, t = l[l.length - 1];
    }
    return s.length = r, s;
  }
  function wo(i, t, e, n, s, r, a) {
    const o = (e - t) / n;
    if (o < 3) {
      for (; t < e; t += n)
        r[a++] = i[t], r[a++] = i[t + 1];
      return a;
    }
    const l = new Array(o);
    l[0] = 1, l[o - 1] = 1;
    const h = [t, e - n];
    let c = 0;
    for (; h.length > 0; ) {
      const u = h.pop(), d = h.pop();
      let m = 0;
      const f = i[d], y = i[d + 1], E = i[u], x = i[u + 1];
      for (let M = d + n; M < u; M += n) {
        const C = i[M], R = i[M + 1], S = b0(C, R, f, y, E, x);
        S > m && (c = M, m = S);
      }
      m > s && (l[(c - t) / n] = 1, d + n < c && h.push(d, c), c + n < u && h.push(c, u));
    }
    for (let u = 0; u < o; ++u)
      l[u] && (r[a++] = i[t + u * n], r[a++] = i[t + u * n + 1]);
    return a;
  }
  function Dd(i, t, e, n, s, r, a, o) {
    for (let l = 0, h = e.length; l < h; ++l) {
      const c = e[l];
      a = wo(
        i,
        t,
        c,
        n,
        s,
        r,
        a
      ), o.push(a), t = c;
    }
    return a;
  }
  function Rn(i, t) {
    return t * Math.round(i / t);
  }
  function $m(i, t, e, n, s, r, a) {
    if (t == e)
      return a;
    let o = Rn(i[t], s), l = Rn(i[t + 1], s);
    t += n, r[a++] = o, r[a++] = l;
    let h, c;
    do
      if (h = Rn(i[t], s), c = Rn(i[t + 1], s), t += n, t == e)
        return r[a++] = h, r[a++] = c, a;
    while (h == o && c == l);
    for (; t < e; ) {
      const u = Rn(i[t], s), d = Rn(i[t + 1], s);
      if (t += n, u == h && d == c)
        continue;
      const m = h - o, f = c - l, y = u - o, E = d - l;
      if (m * E == f * y && (m < 0 && y < m || m == y || m > 0 && y > m) && (f < 0 && E < f || f == E || f > 0 && E > f)) {
        h = u, c = d;
        continue;
      }
      r[a++] = h, r[a++] = c, o = h, l = c, h = u, c = d;
    }
    return r[a++] = h, r[a++] = c, a;
  }
  function Ph(i, t, e, n, s, r, a, o) {
    for (let l = 0, h = e.length; l < h; ++l) {
      const c = e[l];
      a = $m(
        i,
        t,
        c,
        n,
        s,
        r,
        a
      ), o.push(a), t = c;
    }
    return a;
  }
  function Xm(i, t, e, n, s, r, a, o) {
    for (let l = 0, h = e.length; l < h; ++l) {
      const c = e[l], u = [];
      a = Ph(
        i,
        t,
        c,
        n,
        s,
        r,
        a,
        u
      ), o.push(u), t = c[c.length - 1];
    }
    return a;
  }
  function en(i, t, e, n, s) {
    s = s !== void 0 ? s : [];
    let r = 0;
    for (let a = t; a < e; a += n)
      s[r++] = i.slice(a, a + n);
    return s.length = r, s;
  }
  function Mr(i, t, e, n, s) {
    s = s !== void 0 ? s : [];
    let r = 0;
    for (let a = 0, o = e.length; a < o; ++a) {
      const l = e[a];
      s[r++] = en(
        i,
        t,
        l,
        n,
        s[r]
      ), t = l;
    }
    return s.length = r, s;
  }
  function Nl(i, t, e, n, s) {
    s = s !== void 0 ? s : [];
    let r = 0;
    for (let a = 0, o = e.length; a < o; ++a) {
      const l = e[a];
      s[r++] = l.length === 1 && l[0] === t ? [] : Mr(
        i,
        t,
        l,
        n,
        s[r]
      ), t = l[l.length - 1];
    }
    return s.length = r, s;
  }
  function kd(i, t, e, n) {
    let s = 0;
    const r = i[e - n], a = i[e - n + 1];
    let o = 0, l = 0;
    for (; t < e; t += n) {
      const h = i[t] - r, c = i[t + 1] - a;
      s += l * h - o * c, o = h, l = c;
    }
    return s / 2;
  }
  function Gd(i, t, e, n) {
    let s = 0;
    for (let r = 0, a = e.length; r < a; ++r) {
      const o = e[r];
      s += kd(i, t, o, n), t = o;
    }
    return s;
  }
  function Wm(i, t, e, n) {
    let s = 0;
    for (let r = 0, a = e.length; r < a; ++r) {
      const o = e[r];
      s += Gd(i, t, o, n), t = o[o.length - 1];
    }
    return s;
  }
  class kn extends Fi {
    /**
     * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `layout` are also accepted.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    constructor(t, e) {
      super(), this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, e !== void 0 && !Array.isArray(t[0]) ? this.setFlatCoordinates(
        e,
        /** @type {Array<number>} */
        t
      ) : this.setCoordinates(
        /** @type {Array<import("../coordinate.js").Coordinate>} */
        t,
        e
      );
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!LinearRing} Clone.
     * @api
     * @override
     */
    clone() {
      return new kn(this.flatCoordinates.slice(), this.layout);
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(t, e, n, s) {
      return s < gn(this.getExtent(), t, e) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
        Sh(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          0
        )
      ), this.maxDeltaRevision_ = this.getRevision()), Th(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        this.maxDelta_,
        !0,
        t,
        e,
        n,
        s
      ));
    }
    /**
     * Return the area of the linear ring on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */
    getArea() {
      return kd(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    /**
     * Return the coordinates of the linear ring.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     * @override
     */
    getCoordinates() {
      return en(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {LinearRing} Simplified LinearRing.
     * @protected
     * @override
     */
    getSimplifiedGeometryInternal(t) {
      const e = [];
      return e.length = wo(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        t,
        e,
        0
      ), new kn(e, "XY");
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "LinearRing";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(t) {
      return !1;
    }
    /**
     * Set the coordinates of the linear ring.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    setCoordinates(t, e) {
      this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Mo(
        this.flatCoordinates,
        0,
        t,
        this.stride
      ), this.changed();
    }
  }
  let wr = class Ud extends Fi {
    /**
     * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    constructor(t, e) {
      super(), this.setCoordinates(t, e);
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!Point} Clone.
     * @api
     * @override
     */
    clone() {
      const t = new Ud(this.flatCoordinates.slice(), this.layout);
      return t.applyProperties(this), t;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(t, e, n, s) {
      const r = this.flatCoordinates, a = bn(
        t,
        e,
        r[0],
        r[1]
      );
      if (a < s) {
        const o = this.stride;
        for (let l = 0; l < o; ++l)
          n[l] = r[l];
        return n.length = o, a;
      }
      return s;
    }
    /**
     * Return the coordinate of the point.
     * @return {import("../coordinate.js").Coordinate} Coordinates.
     * @api
     * @override
     */
    getCoordinates() {
      return this.flatCoordinates.slice();
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     * @override
     */
    computeExtent(t) {
      return uh(this.flatCoordinates, t);
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "Point";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(t) {
      return mo(t, this.flatCoordinates[0], this.flatCoordinates[1]);
    }
    /**
     * @param {!Array<*>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    setCoordinates(t, e) {
      this.setLayout(e, t, 0), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Fd(
        this.flatCoordinates,
        0,
        t,
        this.stride
      ), this.changed();
    }
  };
  function Ym(i, t, e, n, s) {
    return !po(
      s,
      /**
       * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
       * @return {boolean} Contains (x, y).
       */
      function(a) {
        return !Tn(
          i,
          t,
          e,
          n,
          a[0],
          a[1]
        );
      }
    );
  }
  function Tn(i, t, e, n, s, r) {
    let a = 0, o = i[e - n], l = i[e - n + 1];
    for (; t < e; t += n) {
      const h = i[t], c = i[t + 1];
      l <= r ? c > r && (h - o) * (r - l) - (s - o) * (c - l) > 0 && a++ : c <= r && (h - o) * (r - l) - (s - o) * (c - l) < 0 && a--, o = h, l = c;
    }
    return a !== 0;
  }
  function bh(i, t, e, n, s, r) {
    if (e.length === 0 || !Tn(i, t, e[0], n, s, r))
      return !1;
    for (let a = 1, o = e.length; a < o; ++a)
      if (Tn(i, e[a - 1], e[a], n, s, r))
        return !1;
    return !0;
  }
  function Zm(i, t, e, n, s, r) {
    if (e.length === 0)
      return !1;
    for (let a = 0, o = e.length; a < o; ++a) {
      const l = e[a];
      if (bh(i, t, l, n, s, r))
        return !0;
      t = l[l.length - 1];
    }
    return !1;
  }
  function Lh(i, t, e, n, s, r, a) {
    let o, l, h, c, u, d, m;
    const f = s[r + 1], y = [];
    for (let M = 0, C = e.length; M < C; ++M) {
      const R = e[M];
      for (c = i[R - n], d = i[R - n + 1], o = t; o < R; o += n)
        u = i[o], m = i[o + 1], (f <= d && m <= f || d <= f && f <= m) && (h = (f - d) / (m - d) * (u - c) + c, y.push(h)), c = u, d = m;
    }
    let E = NaN, x = -1 / 0;
    for (y.sort(rn), c = y[0], o = 1, l = y.length; o < l; ++o) {
      u = y[o];
      const M = Math.abs(u - c);
      M > x && (h = (c + u) / 2, bh(i, t, e, n, h, f) && (E = h, x = M)), c = u;
    }
    return isNaN(E) && (E = s[r]), a ? (a.push(E, f, x), a) : [E, f, x];
  }
  function zd(i, t, e, n, s) {
    let r = [];
    for (let a = 0, o = e.length; a < o; ++a) {
      const l = e[a];
      r = Lh(
        i,
        t,
        l,
        n,
        s,
        2 * a,
        r
      ), t = l[l.length - 1];
    }
    return r;
  }
  function Bd(i, t, e, n, s) {
    let r;
    for (t += n; t < e; t += n)
      if (r = s(
        i.slice(t - n, t),
        i.slice(t, t + n)
      ), r)
        return r;
    return !1;
  }
  function Ro(i, t, e, n, s) {
    const r = fh(
      Ae(),
      i,
      t,
      e,
      n
    );
    return he(s, r) ? Qi(s, r) || r[0] >= s[0] && r[2] <= s[2] || r[1] >= s[1] && r[3] <= s[3] ? !0 : Bd(
      i,
      t,
      e,
      n,
      /**
       * @param {import("../../coordinate.js").Coordinate} point1 Start point.
       * @param {import("../../coordinate.js").Coordinate} point2 End point.
       * @return {boolean} `true` if the segment and the extent intersect,
       *     `false` otherwise.
       */
      function(a, o) {
        return Ed(s, a, o);
      }
    ) : !1;
  }
  function qm(i, t, e, n, s) {
    for (let r = 0, a = e.length; r < a; ++r) {
      if (Ro(i, t, e[r], n, s))
        return !0;
      t = e[r];
    }
    return !1;
  }
  function $d(i, t, e, n, s) {
    return !!(Ro(i, t, e, n, s) || Tn(
      i,
      t,
      e,
      n,
      s[0],
      s[1]
    ) || Tn(
      i,
      t,
      e,
      n,
      s[0],
      s[3]
    ) || Tn(
      i,
      t,
      e,
      n,
      s[2],
      s[1]
    ) || Tn(
      i,
      t,
      e,
      n,
      s[2],
      s[3]
    ));
  }
  function Xd(i, t, e, n, s) {
    if (!$d(i, t, e[0], n, s))
      return !1;
    if (e.length === 1)
      return !0;
    for (let r = 1, a = e.length; r < a; ++r)
      if (Ym(
        i,
        e[r - 1],
        e[r],
        n,
        s
      ) && !Ro(
        i,
        e[r - 1],
        e[r],
        n,
        s
      ))
        return !1;
    return !0;
  }
  function Km(i, t, e, n, s) {
    for (let r = 0, a = e.length; r < a; ++r) {
      const o = e[r];
      if (Xd(i, t, o, n, s))
        return !0;
      t = o[o.length - 1];
    }
    return !1;
  }
  function jm(i, t, e, n) {
    for (; t < e - n; ) {
      for (let s = 0; s < n; ++s) {
        const r = i[t + s];
        i[t + s] = i[e - n + s], i[e - n + s] = r;
      }
      t += n, e -= n;
    }
  }
  function Oh(i, t, e, n) {
    let s = 0, r = i[e - n], a = i[e - n + 1];
    for (; t < e; t += n) {
      const o = i[t], l = i[t + 1];
      s += (o - r) * (l + a), r = o, a = l;
    }
    return s === 0 ? void 0 : s > 0;
  }
  function Wd(i, t, e, n, s) {
    s = s !== void 0 ? s : !1;
    for (let r = 0, a = e.length; r < a; ++r) {
      const o = e[r], l = Oh(
        i,
        t,
        o,
        n
      );
      if (r === 0) {
        if (s && l || !s && !l)
          return !1;
      } else if (s && !l || !s && l)
        return !1;
      t = o;
    }
    return !0;
  }
  function Vm(i, t, e, n, s) {
    for (let r = 0, a = e.length; r < a; ++r) {
      const o = e[r];
      if (!Wd(i, t, o, n, s))
        return !1;
      o.length && (t = o[o.length - 1]);
    }
    return !0;
  }
  function Fl(i, t, e, n, s) {
    s = s !== void 0 ? s : !1;
    for (let r = 0, a = e.length; r < a; ++r) {
      const o = e[r], l = Oh(
        i,
        t,
        o,
        n
      );
      (r === 0 ? s && l || !s && !l : s && !l || !s && l) && jm(i, t, o, n), t = o;
    }
    return t;
  }
  function tu(i, t, e, n, s) {
    for (let r = 0, a = e.length; r < a; ++r)
      t = Fl(
        i,
        t,
        e[r],
        n,
        s
      );
    return t;
  }
  function Hm(i, t) {
    const e = [];
    let n = 0, s = 0, r;
    for (let a = 0, o = t.length; a < o; ++a) {
      const l = t[a], h = Oh(i, n, l, 2);
      if (r === void 0 && (r = h), h === r)
        e.push(t.slice(s, a + 1));
      else {
        if (e.length === 0)
          continue;
        e[e.length - 1].push(t[s]);
      }
      s = a + 1, n = l;
    }
    return e;
  }
  class gi extends Fi {
    /**
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
     *     Array of linear rings that define the polygon. The first linear ring of the
     *     array defines the outer-boundary or surface of the polygon. Each subsequent
     *     linear ring defines a hole in the surface of the polygon. A linear ring is
     *     an array of vertices' coordinates where the first coordinate and the last are
     *     equivalent. (For internal use, flat coordinates in combination with
     *     `layout` and `ends` are also accepted.)
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
     */
    constructor(t, e, n) {
      super(), this.ends_ = [], this.flatInteriorPointRevision_ = -1, this.flatInteriorPoint_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, e !== void 0 && n ? (this.setFlatCoordinates(
        e,
        /** @type {Array<number>} */
        t
      ), this.ends_ = n) : this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
        t,
        e
      );
    }
    /**
     * Append the passed linear ring to this polygon.
     * @param {LinearRing} linearRing Linear ring.
     * @api
     */
    appendLinearRing(t) {
      this.flatCoordinates ? pe(this.flatCoordinates, t.getFlatCoordinates()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!Polygon} Clone.
     * @api
     * @override
     */
    clone() {
      const t = new gi(
        this.flatCoordinates.slice(),
        this.layout,
        this.ends_.slice()
      );
      return t.applyProperties(this), t;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(t, e, n, s) {
      return s < gn(this.getExtent(), t, e) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
        Ch(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          0
        )
      ), this.maxDeltaRevision_ = this.getRevision()), Ih(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        this.maxDelta_,
        !0,
        t,
        e,
        n,
        s
      ));
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     * @override
     */
    containsXY(t, e) {
      return bh(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        t,
        e
      );
    }
    /**
     * Return the area of the polygon on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */
    getArea() {
      return Gd(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride
      );
    }
    /**
     * Get the coordinate array for this geometry.  This array has the structure
     * of a GeoJSON coordinate array for polygons.
     *
     * @param {boolean} [right] Orient coordinates according to the right-hand
     *     rule (counter-clockwise for exterior and clockwise for interior rings).
     *     If `false`, coordinates will be oriented according to the left-hand rule
     *     (clockwise for exterior and counter-clockwise for interior rings).
     *     By default, coordinate orientation will depend on how the geometry was
     *     constructed.
     * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
     * @api
     * @override
     */
    getCoordinates(t) {
      let e;
      return t !== void 0 ? (e = this.getOrientedFlatCoordinates().slice(), Fl(e, 0, this.ends_, this.stride, t)) : e = this.flatCoordinates, Mr(e, 0, this.ends_, this.stride);
    }
    /**
     * @return {Array<number>} Ends.
     */
    getEnds() {
      return this.ends_;
    }
    /**
     * @return {Array<number>} Interior point.
     */
    getFlatInteriorPoint() {
      if (this.flatInteriorPointRevision_ != this.getRevision()) {
        const t = bi(this.getExtent());
        this.flatInteriorPoint_ = Lh(
          this.getOrientedFlatCoordinates(),
          0,
          this.ends_,
          this.stride,
          t,
          0
        ), this.flatInteriorPointRevision_ = this.getRevision();
      }
      return (
        /** @type {import("../coordinate.js").Coordinate} */
        this.flatInteriorPoint_
      );
    }
    /**
     * Return an interior point of the polygon.
     * @return {Point} Interior point as XYM coordinate, where M is the
     * length of the horizontal intersection that the point belongs to.
     * @api
     */
    getInteriorPoint() {
      return new wr(this.getFlatInteriorPoint(), "XYM");
    }
    /**
     * Return the number of rings of the polygon,  this includes the exterior
     * ring and any interior rings.
     *
     * @return {number} Number of rings.
     * @api
     */
    getLinearRingCount() {
      return this.ends_.length;
    }
    /**
     * Return the Nth linear ring of the polygon geometry. Return `null` if the
     * given index is out of range.
     * The exterior linear ring is available at index `0` and the interior rings
     * at index `1` and beyond.
     *
     * @param {number} index Index.
     * @return {LinearRing|null} Linear ring.
     * @api
     */
    getLinearRing(t) {
      return t < 0 || this.ends_.length <= t ? null : new kn(
        this.flatCoordinates.slice(
          t === 0 ? 0 : this.ends_[t - 1],
          this.ends_[t]
        ),
        this.layout
      );
    }
    /**
     * Return the linear rings of the polygon.
     * @return {Array<LinearRing>} Linear rings.
     * @api
     */
    getLinearRings() {
      const t = this.layout, e = this.flatCoordinates, n = this.ends_, s = [];
      let r = 0;
      for (let a = 0, o = n.length; a < o; ++a) {
        const l = n[a], h = new kn(
          e.slice(r, l),
          t
        );
        s.push(h), r = l;
      }
      return s;
    }
    /**
     * @return {Array<number>} Oriented flat coordinates.
     */
    getOrientedFlatCoordinates() {
      if (this.orientedRevision_ != this.getRevision()) {
        const t = this.flatCoordinates;
        Wd(t, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = Fl(
          this.orientedFlatCoordinates_,
          0,
          this.ends_,
          this.stride
        )), this.orientedRevision_ = this.getRevision();
      }
      return (
        /** @type {Array<number>} */
        this.orientedFlatCoordinates_
      );
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {Polygon} Simplified Polygon.
     * @protected
     * @override
     */
    getSimplifiedGeometryInternal(t) {
      const e = [], n = [];
      return e.length = Ph(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        Math.sqrt(t),
        e,
        0,
        n
      ), new gi(e, "XY", n);
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "Polygon";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(t) {
      return Xd(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        t
      );
    }
    /**
     * Set the coordinates of the polygon.
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    setCoordinates(t, e) {
      this.setLayout(e, t, 2), this.flatCoordinates || (this.flatCoordinates = []);
      const n = Ah(
        this.flatCoordinates,
        0,
        t,
        this.stride,
        this.ends_
      );
      this.flatCoordinates.length = n.length === 0 ? 0 : n[n.length - 1], this.changed();
    }
  }
  function eu(i) {
    if (zs(i))
      throw new Error("Cannot create polygon from empty extent");
    const t = i[0], e = i[1], n = i[2], s = i[3], r = [
      t,
      e,
      t,
      s,
      n,
      s,
      n,
      e,
      t,
      e
    ];
    return new gi(r, "XY", [r.length]);
  }
  const tl = 0;
  class oi extends si {
    /**
     * @param {ViewOptions} [options] View options.
     */
    constructor(t) {
      super(), this.on, this.once, this.un, t = Object.assign({}, t), this.hints_ = [0, 0], this.animations_ = [], this.updateAnimationKey_, this.projection_ = vh(t.projection, "EPSG:3857"), this.viewportSize_ = [100, 100], this.targetCenter_ = null, this.targetResolution_, this.targetRotation_, this.nextCenter_ = null, this.nextResolution_, this.nextRotation_, this.cancelAnchor_ = void 0, t.projection && _m(), t.center && (t.center = Si(t.center, this.projection_)), t.extent && (t.extent = tn(t.extent, this.projection_)), this.applyOptions_(t);
    }
    /**
     * Set up the view with the given options.
     * @param {ViewOptions} options View options.
     */
    applyOptions_(t) {
      const e = Object.assign({}, t);
      for (const o in Je)
        delete e[o];
      this.setProperties(e, !0);
      const n = Qm(t);
      this.maxResolution_ = n.maxResolution, this.minResolution_ = n.minResolution, this.zoomFactor_ = n.zoomFactor, this.resolutions_ = t.resolutions, this.padding_ = t.padding, this.minZoom_ = n.minZoom;
      const s = Jm(t), r = n.constraint, a = t_(t);
      this.constraints_ = {
        center: s,
        resolution: r,
        rotation: a
      }, this.setRotation(t.rotation !== void 0 ? t.rotation : 0), this.setCenterInternal(
        t.center !== void 0 ? t.center : null
      ), t.resolution !== void 0 ? this.setResolution(t.resolution) : t.zoom !== void 0 && this.setZoom(t.zoom);
    }
    /**
     * Padding (in css pixels).
     * If the map viewport is partially covered with other content (overlays) along
     * its edges, this setting allows to shift the center of the viewport away from that
     * content. The order of the values in the array is top, right, bottom, left.
     * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
     * @type {Array<number>|undefined}
     * @api
     */
    get padding() {
      return this.padding_;
    }
    set padding(t) {
      let e = this.padding_;
      this.padding_ = t;
      const n = this.getCenterInternal();
      if (n) {
        const s = t || [0, 0, 0, 0];
        e = e || [0, 0, 0, 0];
        const r = this.getResolution(), a = r / 2 * (s[3] - e[3] + e[1] - s[1]), o = r / 2 * (s[0] - e[0] + e[2] - s[2]);
        this.setCenterInternal([n[0] + a, n[1] - o]);
      }
    }
    /**
     * Get an updated version of the view options used to construct the view.  The
     * current resolution (or zoom), center, and rotation are applied to any stored
     * options.  The provided options can be used to apply new min/max zoom or
     * resolution limits.
     * @param {ViewOptions} newOptions New options to be applied.
     * @return {ViewOptions} New options updated with the current view state.
     */
    getUpdatedOptions_(t) {
      const e = this.getProperties();
      return e.resolution !== void 0 ? e.resolution = this.getResolution() : e.zoom = this.getZoom(), e.center = this.getCenterInternal(), e.rotation = this.getRotation(), Object.assign({}, e, t);
    }
    /**
     * Animate the view.  The view's center, zoom (or resolution), and rotation
     * can be animated for smooth transitions between view states.  For example,
     * to animate the view to a new zoom level:
     *
     *     view.animate({zoom: view.getZoom() + 1});
     *
     * By default, the animation lasts one second and uses in-and-out easing.  You
     * can customize this behavior by including `duration` (in milliseconds) and
     * `easing` options (see {@link module:ol/easing}).
     *
     * To chain together multiple animations, call the method with multiple
     * animation objects.  For example, to first zoom and then pan:
     *
     *     view.animate({zoom: 10}, {center: [0, 0]});
     *
     * If you provide a function as the last argument to the animate method, it
     * will get called at the end of an animation series.  The callback will be
     * called with `true` if the animation series completed on its own or `false`
     * if it was cancelled.
     *
     * Animations are cancelled by user interactions (e.g. dragging the map) or by
     * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
     * (or another method that calls one of these).
     *
     * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
     *     options.  Multiple animations can be run in series by passing multiple
     *     options objects.  To run multiple animations in parallel, call the method
     *     multiple times.  An optional callback can be provided as a final
     *     argument.  The callback will be called with a boolean indicating whether
     *     the animation completed without being cancelled.
     * @api
     */
    animate(t) {
      this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
      const e = new Array(arguments.length);
      for (let n = 0; n < e.length; ++n) {
        let s = arguments[n];
        s.center && (s = Object.assign({}, s), s.center = Si(
          s.center,
          this.getProjection()
        )), s.anchor && (s = Object.assign({}, s), s.anchor = Si(
          s.anchor,
          this.getProjection()
        )), e[n] = s;
      }
      this.animateInternal.apply(this, e);
    }
    /**
     * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
     */
    animateInternal(t) {
      let e = arguments.length, n;
      e > 1 && typeof arguments[e - 1] == "function" && (n = arguments[e - 1], --e);
      let s = 0;
      for (; s < e && !this.isDef(); ++s) {
        const c = arguments[s];
        c.center && this.setCenterInternal(c.center), c.zoom !== void 0 ? this.setZoom(c.zoom) : c.resolution && this.setResolution(c.resolution), c.rotation !== void 0 && this.setRotation(c.rotation);
      }
      if (s === e) {
        n && _a(n, !0);
        return;
      }
      let r = Date.now(), a = this.targetCenter_.slice(), o = this.targetResolution_, l = this.targetRotation_;
      const h = [];
      for (; s < e; ++s) {
        const c = (
          /** @type {AnimationOptions} */
          arguments[s]
        ), u = {
          start: r,
          complete: !1,
          anchor: c.anchor,
          duration: c.duration !== void 0 ? c.duration : 1e3,
          easing: c.easing || Tm,
          callback: n
        };
        if (c.center && (u.sourceCenter = a, u.targetCenter = c.center.slice(), a = u.targetCenter), c.zoom !== void 0 ? (u.sourceResolution = o, u.targetResolution = this.getResolutionForZoom(c.zoom), o = u.targetResolution) : c.resolution && (u.sourceResolution = o, u.targetResolution = c.resolution, o = u.targetResolution), c.rotation !== void 0) {
          u.sourceRotation = l;
          const d = ps(c.rotation - l + Math.PI, 2 * Math.PI) - Math.PI;
          u.targetRotation = l + d, l = u.targetRotation;
        }
        e_(u) ? u.complete = !0 : r += u.duration, h.push(u);
      }
      this.animations_.push(h), this.setHint(ae.ANIMATING, 1), this.updateAnimations_();
    }
    /**
     * Determine if the view is being animated.
     * @return {boolean} The view is being animated.
     * @api
     */
    getAnimating() {
      return this.hints_[ae.ANIMATING] > 0;
    }
    /**
     * Determine if the user is interacting with the view, such as panning or zooming.
     * @return {boolean} The view is being interacted with.
     * @api
     */
    getInteracting() {
      return this.hints_[ae.INTERACTING] > 0;
    }
    /**
     * Cancel any ongoing animations.
     * @api
     */
    cancelAnimations() {
      this.setHint(ae.ANIMATING, -this.hints_[ae.ANIMATING]);
      let t;
      for (let e = 0, n = this.animations_.length; e < n; ++e) {
        const s = this.animations_[e];
        if (s[0].callback && _a(s[0].callback, !1), !t)
          for (let r = 0, a = s.length; r < a; ++r) {
            const o = s[r];
            if (!o.complete) {
              t = o.anchor;
              break;
            }
          }
      }
      this.animations_.length = 0, this.cancelAnchor_ = t, this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
    }
    /**
     * Update all animations.
     */
    updateAnimations_() {
      if (this.updateAnimationKey_ !== void 0 && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0), !this.getAnimating())
        return;
      const t = Date.now();
      let e = !1;
      for (let n = this.animations_.length - 1; n >= 0; --n) {
        const s = this.animations_[n];
        let r = !0;
        for (let a = 0, o = s.length; a < o; ++a) {
          const l = s[a];
          if (l.complete)
            continue;
          const h = t - l.start;
          let c = l.duration > 0 ? h / l.duration : 1;
          c >= 1 ? (l.complete = !0, c = 1) : r = !1;
          const u = l.easing(c);
          if (l.sourceCenter) {
            const d = l.sourceCenter[0], m = l.sourceCenter[1], f = l.targetCenter[0], y = l.targetCenter[1];
            this.nextCenter_ = l.targetCenter;
            const E = d + u * (f - d), x = m + u * (y - m);
            this.targetCenter_ = [E, x];
          }
          if (l.sourceResolution && l.targetResolution) {
            const d = u === 1 ? l.targetResolution : l.sourceResolution + u * (l.targetResolution - l.sourceResolution);
            if (l.anchor) {
              const m = this.getViewportSize_(this.getRotation()), f = this.constraints_.resolution(
                d,
                0,
                m,
                !0
              );
              this.targetCenter_ = this.calculateCenterZoom(
                f,
                l.anchor
              );
            }
            this.nextResolution_ = l.targetResolution, this.targetResolution_ = d, this.applyTargetState_(!0);
          }
          if (l.sourceRotation !== void 0 && l.targetRotation !== void 0) {
            const d = u === 1 ? ps(l.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : l.sourceRotation + u * (l.targetRotation - l.sourceRotation);
            if (l.anchor) {
              const m = this.constraints_.rotation(
                d,
                !0
              );
              this.targetCenter_ = this.calculateCenterRotate(
                m,
                l.anchor
              );
            }
            this.nextRotation_ = l.targetRotation, this.targetRotation_ = d;
          }
          if (this.applyTargetState_(!0), e = !0, !l.complete)
            break;
        }
        if (r) {
          this.animations_[n] = null, this.setHint(ae.ANIMATING, -1), this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
          const a = s[0].callback;
          a && _a(a, !0);
        }
      }
      this.animations_ = this.animations_.filter(Boolean), e && this.updateAnimationKey_ === void 0 && (this.updateAnimationKey_ = requestAnimationFrame(
        this.updateAnimations_.bind(this)
      ));
    }
    /**
     * @param {number} rotation Target rotation.
     * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
     * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
     */
    calculateCenterRotate(t, e) {
      let n;
      const s = this.getCenterInternal();
      return s !== void 0 && (n = [s[0] - e[0], s[1] - e[1]], mh(n, t - this.getRotation()), H0(n, e)), n;
    }
    /**
     * @param {number} resolution Target resolution.
     * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
     * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
     */
    calculateCenterZoom(t, e) {
      let n;
      const s = this.getCenterInternal(), r = this.getResolution();
      if (s !== void 0 && r !== void 0) {
        const a = e[0] - t * (e[0] - s[0]) / r, o = e[1] - t * (e[1] - s[1]) / r;
        n = [a, o];
      }
      return n;
    }
    /**
     * Returns the current viewport size.
     * @private
     * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
     * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
     */
    getViewportSize_(t) {
      const e = this.viewportSize_;
      if (t) {
        const n = e[0], s = e[1];
        return [
          Math.abs(n * Math.cos(t)) + Math.abs(s * Math.sin(t)),
          Math.abs(n * Math.sin(t)) + Math.abs(s * Math.cos(t))
        ];
      }
      return e;
    }
    /**
     * Stores the viewport size on the view. The viewport size is not read every time from the DOM
     * to avoid performance hit and layout reflow.
     * This should be done on map size change.
     * Note: the constraints are not resolved during an animation to avoid stopping it
     * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
     */
    setViewportSize(t) {
      this.viewportSize_ = Array.isArray(t) ? t.slice() : [100, 100], this.getAnimating() || this.resolveConstraints(0);
    }
    /**
     * Get the view center.
     * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
     * @observable
     * @api
     */
    getCenter() {
      const t = this.getCenterInternal();
      return t && Ol(t, this.getProjection());
    }
    /**
     * Get the view center without transforming to user projection.
     * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
     */
    getCenterInternal() {
      return (
        /** @type {import("./coordinate.js").Coordinate|undefined} */
        this.get(Je.CENTER)
      );
    }
    /**
     * @return {Constraints} Constraints.
     */
    getConstraints() {
      return this.constraints_;
    }
    /**
     * @return {boolean} Resolution constraint is set
     */
    getConstrainResolution() {
      return this.get("constrainResolution");
    }
    /**
     * @param {Array<number>} [hints] Destination array.
     * @return {Array<number>} Hint.
     */
    getHints(t) {
      return t !== void 0 ? (t[0] = this.hints_[0], t[1] = this.hints_[1], t) : this.hints_.slice();
    }
    /**
     * Calculate the extent for the current view state and the passed box size.
     * @param {import("./size.js").Size} [size] The pixel dimensions of the box
     * into which the calculated extent should fit. Defaults to the size of the
     * map the view is associated with.
     * If no map or multiple maps are connected to the view, provide the desired
     * box size (e.g. `map.getSize()`).
     * @return {import("./extent.js").Extent} Extent.
     * @api
     */
    calculateExtent(t) {
      const e = this.calculateExtentInternal(t);
      return bd(e, this.getProjection());
    }
    /**
     * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
     * the map's last known viewport size will be used.
     * @return {import("./extent.js").Extent} Extent.
     */
    calculateExtentInternal(t) {
      t = t || this.getViewportSizeMinusPadding_();
      const e = (
        /** @type {!import("./coordinate.js").Coordinate} */
        this.getCenterInternal()
      );
      Mt(e, "The view center is not defined");
      const n = (
        /** @type {!number} */
        this.getResolution()
      );
      Mt(n !== void 0, "The view resolution is not defined");
      const s = (
        /** @type {!number} */
        this.getRotation()
      );
      return Mt(s !== void 0, "The view rotation is not defined"), Ua(e, n, s, t);
    }
    /**
     * Get the maximum resolution of the view.
     * @return {number} The maximum resolution of the view.
     * @api
     */
    getMaxResolution() {
      return this.maxResolution_;
    }
    /**
     * Get the minimum resolution of the view.
     * @return {number} The minimum resolution of the view.
     * @api
     */
    getMinResolution() {
      return this.minResolution_;
    }
    /**
     * Get the maximum zoom level for the view.
     * @return {number} The maximum zoom level.
     * @api
     */
    getMaxZoom() {
      return (
        /** @type {number} */
        this.getZoomForResolution(this.minResolution_)
      );
    }
    /**
     * Set a new maximum zoom level for the view.
     * @param {number} zoom The maximum zoom level.
     * @api
     */
    setMaxZoom(t) {
      this.applyOptions_(this.getUpdatedOptions_({ maxZoom: t }));
    }
    /**
     * Get the minimum zoom level for the view.
     * @return {number} The minimum zoom level.
     * @api
     */
    getMinZoom() {
      return (
        /** @type {number} */
        this.getZoomForResolution(this.maxResolution_)
      );
    }
    /**
     * Set a new minimum zoom level for the view.
     * @param {number} zoom The minimum zoom level.
     * @api
     */
    setMinZoom(t) {
      this.applyOptions_(this.getUpdatedOptions_({ minZoom: t }));
    }
    /**
     * Set whether the view should allow intermediary zoom levels.
     * @param {boolean} enabled Whether the resolution is constrained.
     * @api
     */
    setConstrainResolution(t) {
      this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: t }));
    }
    /**
     * Get the view projection.
     * @return {import("./proj/Projection.js").default} The projection of the view.
     * @api
     */
    getProjection() {
      return this.projection_;
    }
    /**
     * Get the view resolution.
     * @return {number|undefined} The resolution of the view.
     * @observable
     * @api
     */
    getResolution() {
      return (
        /** @type {number|undefined} */
        this.get(Je.RESOLUTION)
      );
    }
    /**
     * Get the resolutions for the view. This returns the array of resolutions
     * passed to the constructor of the View, or undefined if none were given.
     * @return {Array<number>|undefined} The resolutions of the view.
     * @api
     */
    getResolutions() {
      return this.resolutions_;
    }
    /**
     * Get the resolution for a provided extent (in map units) and size (in pixels).
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {import("./size.js").Size} [size] Box pixel size.
     * @return {number} The resolution at which the provided extent will render at
     *     the given size.
     * @api
     */
    getResolutionForExtent(t, e) {
      return this.getResolutionForExtentInternal(
        tn(t, this.getProjection()),
        e
      );
    }
    /**
     * Get the resolution for a provided extent (in map units) and size (in pixels).
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {import("./size.js").Size} [size] Box pixel size.
     * @return {number} The resolution at which the provided extent will render at
     *     the given size.
     */
    getResolutionForExtentInternal(t, e) {
      e = e || this.getViewportSizeMinusPadding_();
      const n = _t(t) / e[0], s = $t(t) / e[1];
      return Math.max(n, s);
    }
    /**
     * Return a function that returns a value between 0 and 1 for a
     * resolution. Exponential scaling is assumed.
     * @param {number} [power] Power.
     * @return {function(number): number} Resolution for value function.
     */
    getResolutionForValueFunction(t) {
      t = t || 2;
      const e = this.getConstrainedResolution(this.maxResolution_), n = this.minResolution_, s = Math.log(e / n) / Math.log(t);
      return (
        /**
         * @param {number} value Value.
         * @return {number} Resolution.
         */
        function(r) {
          return e / Math.pow(t, r * s);
        }
      );
    }
    /**
     * Get the view rotation.
     * @return {number} The rotation of the view in radians.
     * @observable
     * @api
     */
    getRotation() {
      return (
        /** @type {number} */
        this.get(Je.ROTATION)
      );
    }
    /**
     * Return a function that returns a resolution for a value between
     * 0 and 1. Exponential scaling is assumed.
     * @param {number} [power] Power.
     * @return {function(number): number} Value for resolution function.
     */
    getValueForResolutionFunction(t) {
      const e = Math.log(t || 2), n = this.getConstrainedResolution(this.maxResolution_), s = this.minResolution_, r = Math.log(n / s) / e;
      return (
        /**
         * @param {number} resolution Resolution.
         * @return {number} Value.
         */
        function(a) {
          return Math.log(n / a) / e / r;
        }
      );
    }
    /**
     * Returns the size of the viewport minus padding.
     * @private
     * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
     * @return {import("./size.js").Size} Viewport size reduced by the padding.
     */
    getViewportSizeMinusPadding_(t) {
      let e = this.getViewportSize_(t);
      const n = this.padding_;
      return n && (e = [
        e[0] - n[1] - n[3],
        e[1] - n[0] - n[2]
      ]), e;
    }
    /**
     * @return {State} View state.
     */
    getState() {
      const t = this.getProjection(), e = this.getResolution(), n = this.getRotation();
      let s = (
        /** @type {import("./coordinate.js").Coordinate} */
        this.getCenterInternal()
      );
      const r = this.padding_;
      if (r) {
        const a = this.getViewportSizeMinusPadding_();
        s = el(
          s,
          this.getViewportSize_(),
          [a[0] / 2 + r[3], a[1] / 2 + r[0]],
          e,
          n
        );
      }
      return {
        center: s.slice(0),
        projection: t !== void 0 ? t : null,
        resolution: e,
        nextCenter: this.nextCenter_,
        nextResolution: this.nextResolution_,
        nextRotation: this.nextRotation_,
        rotation: n,
        zoom: this.getZoom()
      };
    }
    /**
     * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
     */
    getViewStateAndExtent() {
      return {
        viewState: this.getState(),
        extent: this.calculateExtent()
      };
    }
    /**
     * Get the current zoom level. This method may return non-integer zoom levels
     * if the view does not constrain the resolution, or if an interaction or
     * animation is underway.
     * @return {number|undefined} Zoom.
     * @api
     */
    getZoom() {
      let t;
      const e = this.getResolution();
      return e !== void 0 && (t = this.getZoomForResolution(e)), t;
    }
    /**
     * Get the zoom level for a resolution.
     * @param {number} resolution The resolution.
     * @return {number|undefined} The zoom level for the provided resolution.
     * @api
     */
    getZoomForResolution(t) {
      let e = this.minZoom_ || 0, n, s;
      if (this.resolutions_) {
        const r = ah(this.resolutions_, t, 1);
        e = r, n = this.resolutions_[r], r == this.resolutions_.length - 1 ? s = 2 : s = n / this.resolutions_[r + 1];
      } else
        n = this.maxResolution_, s = this.zoomFactor_;
      return e + Math.log(n / t) / Math.log(s);
    }
    /**
     * Get the resolution for a zoom level.
     * @param {number} zoom Zoom level.
     * @return {number} The view resolution for the provided zoom level.
     * @api
     */
    getResolutionForZoom(t) {
      var e;
      if ((e = this.resolutions_) != null && e.length) {
        if (this.resolutions_.length === 1)
          return this.resolutions_[0];
        const n = Gt(
          Math.floor(t),
          0,
          this.resolutions_.length - 2
        ), s = this.resolutions_[n] / this.resolutions_[n + 1];
        return this.resolutions_[n] / Math.pow(s, Gt(t - n, 0, 1));
      }
      return this.maxResolution_ / Math.pow(this.zoomFactor_, t - this.minZoom_);
    }
    /**
     * Fit the given geometry or extent based on the given map size and border.
     * The size is pixel dimensions of the box to fit the extent into.
     * In most cases you will want to use the map size, that is `map.getSize()`.
     * Takes care of the map angle.
     * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
     *     extent to fit the view to.
     * @param {FitOptions} [options] Options.
     * @api
     */
    fit(t, e) {
      let n;
      if (Mt(
        Array.isArray(t) || typeof /** @type {?} */
        t.getSimplifiedGeometry == "function",
        "Invalid extent or geometry provided as `geometry`"
      ), Array.isArray(t)) {
        Mt(
          !zs(t),
          "Cannot fit empty extent provided as `geometry`"
        );
        const s = tn(t, this.getProjection());
        n = eu(s);
      } else if (t.getType() === "Circle") {
        const s = tn(
          t.getExtent(),
          this.getProjection()
        );
        n = eu(s), n.rotate(this.getRotation(), bi(s));
      } else
        n = t;
      this.fitInternal(n, e);
    }
    /**
     * Calculate rotated extent
     * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
     * @return {import("./extent").Extent} The rotated extent for the geometry.
     */
    rotatedExtentForGeometry(t) {
      const e = this.getRotation(), n = Math.cos(e), s = Math.sin(-e), r = t.getFlatCoordinates(), a = t.getStride();
      let o = 1 / 0, l = 1 / 0, h = -1 / 0, c = -1 / 0;
      for (let u = 0, d = r.length; u < d; u += a) {
        const m = r[u] * n - r[u + 1] * s, f = r[u] * s + r[u + 1] * n;
        o = Math.min(o, m), l = Math.min(l, f), h = Math.max(h, m), c = Math.max(c, f);
      }
      return [o, l, h, c];
    }
    /**
     * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
     * @param {FitOptions} [options] Options.
     */
    fitInternal(t, e) {
      e = e || {};
      let n = e.size;
      n || (n = this.getViewportSizeMinusPadding_());
      const s = e.padding !== void 0 ? e.padding : [0, 0, 0, 0], r = e.nearest !== void 0 ? e.nearest : !1;
      let a;
      e.minResolution !== void 0 ? a = e.minResolution : e.maxZoom !== void 0 ? a = this.getResolutionForZoom(e.maxZoom) : a = 0;
      const o = this.rotatedExtentForGeometry(t);
      let l = this.getResolutionForExtentInternal(o, [
        n[0] - s[1] - s[3],
        n[1] - s[0] - s[2]
      ]);
      l = isNaN(l) ? a : Math.max(l, a), l = this.getConstrainedResolution(l, r ? 0 : 1);
      const h = this.getRotation(), c = Math.sin(h), u = Math.cos(h), d = bi(o);
      d[0] += (s[1] - s[3]) / 2 * l, d[1] += (s[0] - s[2]) / 2 * l;
      const m = d[0] * u - d[1] * c, f = d[1] * u + d[0] * c, y = this.getConstrainedCenter([m, f], l), E = e.callback ? e.callback : Is;
      e.duration !== void 0 ? this.animateInternal(
        {
          resolution: l,
          center: y,
          duration: e.duration,
          easing: e.easing
        },
        E
      ) : (this.targetResolution_ = l, this.targetCenter_ = y, this.applyTargetState_(!1, !0), _a(E, !0));
    }
    /**
     * Center on coordinate and view position.
     * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("./size.js").Size} size Box pixel size.
     * @param {import("./pixel.js").Pixel} position Position on the view to center on.
     * @api
     */
    centerOn(t, e, n) {
      this.centerOnInternal(
        Si(t, this.getProjection()),
        e,
        n
      );
    }
    /**
     * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("./size.js").Size} size Box pixel size.
     * @param {import("./pixel.js").Pixel} position Position on the view to center on.
     */
    centerOnInternal(t, e, n) {
      this.setCenterInternal(
        el(
          t,
          e,
          n,
          this.getResolution(),
          this.getRotation()
        )
      );
    }
    /**
     * Calculates the shift between map and viewport center.
     * @param {import("./coordinate.js").Coordinate} center Center.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {import("./size.js").Size} size Size.
     * @return {Array<number>|undefined} Center shift.
     */
    calculateCenterShift(t, e, n, s) {
      let r;
      const a = this.padding_;
      if (a && t) {
        const o = this.getViewportSizeMinusPadding_(-n), l = el(
          t,
          s,
          [o[0] / 2 + a[3], o[1] / 2 + a[0]],
          e,
          n
        );
        r = [
          t[0] - l[0],
          t[1] - l[1]
        ];
      }
      return r;
    }
    /**
     * @return {boolean} Is defined.
     */
    isDef() {
      return !!this.getCenterInternal() && this.getResolution() !== void 0;
    }
    /**
     * Adds relative coordinates to the center of the view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
     * @api
     */
    adjustCenter(t) {
      const e = Ol(this.targetCenter_, this.getProjection());
      this.setCenter([
        e[0] + t[0],
        e[1] + t[1]
      ]);
    }
    /**
     * Adds relative coordinates to the center of the view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
     */
    adjustCenterInternal(t) {
      const e = this.targetCenter_;
      this.setCenterInternal([
        e[0] + t[0],
        e[1] + t[1]
      ]);
    }
    /**
     * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} ratio The ratio to apply on the view resolution.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     * @api
     */
    adjustResolution(t, e) {
      e = e && Si(e, this.getProjection()), this.adjustResolutionInternal(t, e);
    }
    /**
     * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} ratio The ratio to apply on the view resolution.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     */
    adjustResolutionInternal(t, e) {
      const n = this.getAnimating() || this.getInteracting(), s = this.getViewportSize_(this.getRotation()), r = this.constraints_.resolution(
        this.targetResolution_ * t,
        0,
        s,
        n
      );
      e && (this.targetCenter_ = this.calculateCenterZoom(r, e)), this.targetResolution_ *= t, this.applyTargetState_();
    }
    /**
     * Adds a value to the view zoom level, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} delta Relative value to add to the zoom level.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     * @api
     */
    adjustZoom(t, e) {
      this.adjustResolution(Math.pow(this.zoomFactor_, -t), e);
    }
    /**
     * Adds a value to the view rotation, optionally using an anchor. Any rotation
     * constraint will apply.
     * @param {number} delta Relative value to add to the zoom rotation, in radians.
     * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
     * @api
     */
    adjustRotation(t, e) {
      e && (e = Si(e, this.getProjection())), this.adjustRotationInternal(t, e);
    }
    /**
     * @param {number} delta Relative value to add to the zoom rotation, in radians.
     * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
     */
    adjustRotationInternal(t, e) {
      const n = this.getAnimating() || this.getInteracting(), s = this.constraints_.rotation(
        this.targetRotation_ + t,
        n
      );
      e && (this.targetCenter_ = this.calculateCenterRotate(s, e)), this.targetRotation_ += t, this.applyTargetState_();
    }
    /**
     * Set the center of the current view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
     * @observable
     * @api
     */
    setCenter(t) {
      this.setCenterInternal(
        t && Si(t, this.getProjection())
      );
    }
    /**
     * Set the center using the view projection (not the user projection).
     * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
     */
    setCenterInternal(t) {
      this.targetCenter_ = t, this.applyTargetState_();
    }
    /**
     * @param {import("./ViewHint.js").default} hint Hint.
     * @param {number} delta Delta.
     * @return {number} New value.
     */
    setHint(t, e) {
      return this.hints_[t] += e, this.changed(), this.hints_[t];
    }
    /**
     * Set the resolution for this view. Any resolution constraint will apply.
     * @param {number|undefined} resolution The resolution of the view.
     * @observable
     * @api
     */
    setResolution(t) {
      this.targetResolution_ = t, this.applyTargetState_();
    }
    /**
     * Set the rotation for this view. Any rotation constraint will apply.
     * @param {number} rotation The rotation of the view in radians.
     * @observable
     * @api
     */
    setRotation(t) {
      this.targetRotation_ = t, this.applyTargetState_();
    }
    /**
     * Zoom to a specific zoom level. Any resolution constrain will apply.
     * @param {number} zoom Zoom level.
     * @api
     */
    setZoom(t) {
      this.setResolution(this.getResolutionForZoom(t));
    }
    /**
     * Recompute rotation/resolution/center based on target values.
     * Note: we have to compute rotation first, then resolution and center considering that
     * parameters can influence one another in case a view extent constraint is present.
     * @param {boolean} [doNotCancelAnims] Do not cancel animations.
     * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
     * @private
     */
    applyTargetState_(t, e) {
      const n = this.getAnimating() || this.getInteracting() || e, s = this.constraints_.rotation(
        this.targetRotation_,
        n
      ), r = this.getViewportSize_(s), a = this.constraints_.resolution(
        this.targetResolution_,
        0,
        r,
        n
      ), o = this.constraints_.center(
        this.targetCenter_,
        a,
        r,
        n,
        this.calculateCenterShift(
          this.targetCenter_,
          a,
          s,
          r
        )
      );
      this.get(Je.ROTATION) !== s && this.set(Je.ROTATION, s), this.get(Je.RESOLUTION) !== a && (this.set(Je.RESOLUTION, a), this.set("zoom", this.getZoom(), !0)), (!o || !this.get(Je.CENTER) || !za(this.get(Je.CENTER), o)) && this.set(Je.CENTER, o), this.getAnimating() && !t && this.cancelAnimations(), this.cancelAnchor_ = void 0;
    }
    /**
     * If any constraints need to be applied, an animation will be triggered.
     * This is typically done on interaction end.
     * Note: calling this with a duration of 0 will apply the constrained values straight away,
     * without animation.
     * @param {number} [duration] The animation duration in ms.
     * @param {number} [resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     */
    resolveConstraints(t, e, n) {
      t = t !== void 0 ? t : 200;
      const s = e || 0, r = this.constraints_.rotation(this.targetRotation_), a = this.getViewportSize_(r), o = this.constraints_.resolution(
        this.targetResolution_,
        s,
        a
      ), l = this.constraints_.center(
        this.targetCenter_,
        o,
        a,
        !1,
        this.calculateCenterShift(
          this.targetCenter_,
          o,
          r,
          a
        )
      );
      if (t === 0 && !this.cancelAnchor_) {
        this.targetResolution_ = o, this.targetRotation_ = r, this.targetCenter_ = l, this.applyTargetState_();
        return;
      }
      n = n || (t === 0 ? this.cancelAnchor_ : void 0), this.cancelAnchor_ = void 0, (this.getResolution() !== o || this.getRotation() !== r || !this.getCenterInternal() || !za(this.getCenterInternal(), l)) && (this.getAnimating() && this.cancelAnimations(), this.animateInternal({
        rotation: r,
        center: l,
        resolution: o,
        duration: t,
        easing: Bs,
        anchor: n
      }));
    }
    /**
     * Notify the View that an interaction has started.
     * The view state will be resolved to a stable one if needed
     * (depending on its constraints).
     * @api
     */
    beginInteraction() {
      this.resolveConstraints(0), this.setHint(ae.INTERACTING, 1);
    }
    /**
     * Notify the View that an interaction has ended. The view state will be resolved
     * to a stable one if needed (depending on its constraints).
     * @param {number} [duration] Animation duration in ms.
     * @param {number} [resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     * @api
     */
    endInteraction(t, e, n) {
      n = n && Si(n, this.getProjection()), this.endInteractionInternal(t, e, n);
    }
    /**
     * Notify the View that an interaction has ended. The view state will be resolved
     * to a stable one if needed (depending on its constraints).
     * @param {number} [duration] Animation duration in ms.
     * @param {number} [resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     */
    endInteractionInternal(t, e, n) {
      this.getInteracting() && (this.setHint(ae.INTERACTING, -1), this.resolveConstraints(t, e, n));
    }
    /**
     * Get a valid position for the view center according to the current constraints.
     * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
     * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
     * This is useful to guess a valid center position at a different zoom level.
     * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
     */
    getConstrainedCenter(t, e) {
      const n = this.getViewportSize_(this.getRotation());
      return this.constraints_.center(
        t,
        e || this.getResolution(),
        n
      );
    }
    /**
     * Get a valid zoom level according to the current view constraints.
     * @param {number|undefined} targetZoom Target zoom.
     * @param {number} [direction=0] Indicate which resolution should be used
     * by a renderer if the view resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @return {number|undefined} Valid zoom level.
     */
    getConstrainedZoom(t, e) {
      const n = this.getResolutionForZoom(t);
      return this.getZoomForResolution(
        this.getConstrainedResolution(n, e)
      );
    }
    /**
     * Get a valid resolution according to the current view constraints.
     * @param {number|undefined} targetResolution Target resolution.
     * @param {number} [direction=0] Indicate which resolution should be used
     * by a renderer if the view resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @return {number|undefined} Valid resolution.
     */
    getConstrainedResolution(t, e) {
      e = e || 0;
      const n = this.getViewportSize_(this.getRotation());
      return this.constraints_.resolution(t, e, n);
    }
  }
  function _a(i, t) {
    setTimeout(function() {
      i(t);
    }, 0);
  }
  function Jm(i) {
    if (i.extent !== void 0) {
      const e = i.smoothExtentConstraint !== void 0 ? i.smoothExtentConstraint : !0;
      return qc(i.extent, i.constrainOnlyCenter, e);
    }
    const t = vh(i.projection, "EPSG:3857");
    if (i.multiWorld !== !0 && t.isGlobal()) {
      const e = t.getExtent().slice();
      return e[0] = -1 / 0, e[2] = 1 / 0, qc(e, !1, !1);
    }
    return Mm;
  }
  function Qm(i) {
    let t, e, n, a = i.minZoom !== void 0 ? i.minZoom : tl, o = i.maxZoom !== void 0 ? i.maxZoom : 28;
    const l = i.zoomFactor !== void 0 ? i.zoomFactor : 2, h = i.multiWorld !== void 0 ? i.multiWorld : !1, c = i.smoothResolutionConstraint !== void 0 ? i.smoothResolutionConstraint : !0, u = i.showFullExtent !== void 0 ? i.showFullExtent : !1, d = vh(i.projection, "EPSG:3857"), m = d.getExtent();
    let f = i.constrainOnlyCenter, y = i.extent;
    if (!h && !y && d.isGlobal() && (f = !1, y = m), i.resolutions !== void 0) {
      const E = i.resolutions;
      e = E[a], n = E[o] !== void 0 ? E[o] : E[E.length - 1], i.constrainResolution ? t = wm(
        E,
        c,
        !f && y,
        u
      ) : t = Kc(
        e,
        n,
        c,
        !f && y,
        u
      );
    } else {
      const x = (m ? Math.max(_t(m), $t(m)) : (
        // use an extent that can fit the whole world if need be
        360 * hh.degrees / d.getMetersPerUnit()
      )) / lh / Math.pow(2, tl), M = x / Math.pow(2, 28 - tl);
      e = i.maxResolution, e !== void 0 ? a = 0 : e = x / Math.pow(l, a), n = i.minResolution, n === void 0 && (i.maxZoom !== void 0 ? i.maxResolution !== void 0 ? n = e / Math.pow(l, o) : n = x / Math.pow(l, o) : n = M), o = a + Math.floor(
        Math.log(e / n) / Math.log(l)
      ), n = e / Math.pow(l, o - a), i.constrainResolution ? t = Rm(
        l,
        e,
        n,
        c,
        !f && y,
        u
      ) : t = Kc(
        e,
        n,
        c,
        !f && y,
        u
      );
    }
    return {
      constraint: t,
      maxResolution: e,
      minResolution: n,
      minZoom: a,
      zoomFactor: l
    };
  }
  function t_(i) {
    if (i.enableRotation !== void 0 ? i.enableRotation : !0) {
      const e = i.constrainRotation;
      return e === void 0 || e === !0 ? Cm() : e === !1 ? jc : typeof e == "number" ? Sm(e) : jc;
    }
    return wh;
  }
  function e_(i) {
    return !(i.sourceCenter && i.targetCenter && !za(i.sourceCenter, i.targetCenter) || i.sourceResolution !== i.targetResolution || i.sourceRotation !== i.targetRotation);
  }
  function el(i, t, e, n, s) {
    const r = Math.cos(-s);
    let a = Math.sin(-s), o = i[0] * r - i[1] * a, l = i[1] * r + i[0] * a;
    o += (t[0] / 2 - e[0]) * n, l += (e[1] - t[1] / 2) * n, a = -a;
    const h = o * r - l * a, c = l * r + o * a;
    return [h, c];
  }
  class So extends gd {
    /**
     * @param {Options<SourceType>} options Layer options.
     */
    constructor(t) {
      const e = Object.assign({}, t);
      delete e.source, super(e), this.on, this.once, this.un, this.mapPrecomposeKey_ = null, this.mapRenderKey_ = null, this.sourceChangeKey_ = null, this.renderer_ = null, this.sourceReady_ = !1, this.rendered = !1, t.render && (this.render = t.render), t.map && this.setMap(t.map), this.addChangeListener(
        At.SOURCE,
        this.handleSourcePropertyChange_
      );
      const n = t.source ? (
        /** @type {SourceType} */
        t.source
      ) : null;
      this.setSource(n);
    }
    /**
     * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
     * @return {Array<import("./Layer.js").default>} Array of layers.
     * @override
     */
    getLayersArray(t) {
      return t = t || [], t.push(this), t;
    }
    /**
     * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     * @override
     */
    getLayerStatesArray(t) {
      return t = t || [], t.push(this.getLayerState()), t;
    }
    /**
     * Get the layer source.
     * @return {SourceType|null} The layer source (or `null` if not yet set).
     * @observable
     * @api
     */
    getSource() {
      return (
        /** @type {SourceType} */
        this.get(At.SOURCE) || null
      );
    }
    /**
     * @return {SourceType|null} The source being rendered.
     */
    getRenderSource() {
      return this.getSource();
    }
    /**
     * @return {import("../source/Source.js").State} Source state.
     * @override
     */
    getSourceState() {
      const t = this.getSource();
      return t ? t.getState() : "undefined";
    }
    /**
     * @private
     */
    handleSourceChange_() {
      this.changed(), !(this.sourceReady_ || this.getSource().getState() !== "ready") && (this.sourceReady_ = !0, this.dispatchEvent("sourceready"));
    }
    /**
     * @private
     */
    handleSourcePropertyChange_() {
      this.sourceChangeKey_ && (bt(this.sourceChangeKey_), this.sourceChangeKey_ = null), this.sourceReady_ = !1;
      const t = this.getSource();
      t && (this.sourceChangeKey_ = xt(
        t,
        ht.CHANGE,
        this.handleSourceChange_,
        this
      ), t.getState() === "ready" && (this.sourceReady_ = !0, setTimeout(() => {
        this.dispatchEvent("sourceready");
      }, 0))), this.changed();
    }
    /**
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
     * an array of features.
     */
    getFeatures(t) {
      return this.renderer_ ? this.renderer_.getFeatures(t) : Promise.resolve([]);
    }
    /**
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     */
    getData(t) {
      return !this.renderer_ || !this.rendered ? null : this.renderer_.getData(t);
    }
    /**
     * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
     * extent, not set to `visible: false`, and not inside a layer group that is set
     * to `visible: false`.
     * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
     * Only required when the layer is not added to a map.
     * @return {boolean} The layer is visible in the map view.
     * @api
     */
    isVisible(t) {
      let e;
      const n = this.getMapInternal();
      !t && n && (t = n.getView()), t instanceof oi ? e = {
        viewState: t.getState(),
        extent: t.calculateExtent()
      } : e = t, !e.layerStatesArray && n && (e.layerStatesArray = n.getLayerGroup().getLayerStatesArray());
      let s;
      if (e.layerStatesArray) {
        if (s = e.layerStatesArray.find(
          (a) => a.layer === this
        ), !s)
          return !1;
      } else
        s = this.getLayerState();
      const r = this.getExtent();
      return Nh(s, e.viewState) && (!r || he(r, e.extent));
    }
    /**
     * Get the attributions of the source of this layer for the given view.
     * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
     * Only required when the layer is not added to a map.
     * @return {Array<string>} Attributions for this layer at the given view.
     * @api
     */
    getAttributions(t) {
      var r;
      if (!this.isVisible(t))
        return [];
      const e = (r = this.getSource()) == null ? void 0 : r.getAttributions();
      if (!e)
        return [];
      const n = t instanceof oi ? t.getViewStateAndExtent() : t;
      let s = e(n);
      return Array.isArray(s) || (s = [s]), s;
    }
    /**
     * In charge to manage the rendering of the layer. One layer type is
     * bounded with one layer renderer.
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target which the renderer may (but need not) use
     * for rendering its content.
     * @return {HTMLElement|null} The rendered element.
     */
    render(t, e) {
      const n = this.getRenderer();
      return n.prepareFrame(t) ? (this.rendered = !0, n.renderFrame(t, e)) : null;
    }
    /**
     * Called when a layer is not visible during a map render.
     */
    unrender() {
      this.rendered = !1;
    }
    /** @return {string} Declutter */
    getDeclutter() {
    }
    /**
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {import("../layer/Layer.js").State} layerState Layer state.
     */
    renderDeclutter(t, e) {
    }
    /**
     * When the renderer follows a layout -> render approach, do the final rendering here.
     * @param {import('../Map.js').FrameState} frameState Frame state
     */
    renderDeferred(t) {
      const e = this.getRenderer();
      e && e.renderDeferred(t);
    }
    /**
     * For use inside the library only.
     * @param {import("../Map.js").default|null} map Map.
     */
    setMapInternal(t) {
      t || this.unrender(), this.set(At.MAP, t);
    }
    /**
     * For use inside the library only.
     * @return {import("../Map.js").default|null} Map.
     */
    getMapInternal() {
      return this.get(At.MAP);
    }
    /**
     * Sets the layer to be rendered on top of other layers on a map. The map will
     * not manage this layer in its layers collection. This
     * is useful for temporary layers. To remove an unmanaged layer from the map,
     * use `#setMap(null)`.
     *
     * To add the layer to a map and have it managed by the map, use
     * {@link module:ol/Map~Map#addLayer} instead.
     * @param {import("../Map.js").default|null} map Map.
     * @api
     */
    setMap(t) {
      this.mapPrecomposeKey_ && (bt(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null), t || this.changed(), this.mapRenderKey_ && (bt(this.mapRenderKey_), this.mapRenderKey_ = null), t && (this.mapPrecomposeKey_ = xt(
        t,
        Be.PRECOMPOSE,
        this.handlePrecompose_,
        this
      ), this.mapRenderKey_ = xt(this, ht.CHANGE, t.render, t), this.changed());
    }
    /**
     * @param {import("../events/Event.js").default} renderEvent Render event
     * @private
     */
    handlePrecompose_(t) {
      const e = (
        /** @type {import("../render/Event.js").default} */
        t.frameState.layerStatesArray
      ), n = this.getLayerState(!1);
      Mt(
        !e.some(
          (s) => s.layer === n.layer
        ),
        "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
      ), e.push(n);
    }
    /**
     * Set the layer source.
     * @param {SourceType|null} source The layer source.
     * @observable
     * @api
     */
    setSource(t) {
      this.set(At.SOURCE, t);
    }
    /**
     * Get the renderer for this layer.
     * @return {RendererType|null} The layer renderer.
     */
    getRenderer() {
      return this.renderer_ || (this.renderer_ = this.createRenderer()), this.renderer_;
    }
    /**
     * @return {boolean} The layer has a renderer.
     */
    hasRenderer() {
      return !!this.renderer_;
    }
    /**
     * Create a renderer for this layer.
     * @return {RendererType} A layer renderer.
     * @protected
     */
    createRenderer() {
      return null;
    }
    /**
     * This will clear the renderer so that a new one can be created next time it is needed
     */
    clearRenderer() {
      this.renderer_ && (this.renderer_.dispose(), delete this.renderer_);
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.clearRenderer(), this.setSource(null), super.disposeInternal();
    }
  }
  function Nh(i, t) {
    if (!i.visible)
      return !1;
    const e = t.resolution;
    if (e < i.minResolution || e >= i.maxResolution)
      return !1;
    const n = t.zoom;
    return n > i.minZoom && n <= i.maxZoom;
  }
  function Yd(i, t, e = 0, n = i.length - 1, s = i_) {
    for (; n > e; ) {
      if (n - e > 600) {
        const l = n - e + 1, h = t - e + 1, c = Math.log(l), u = 0.5 * Math.exp(2 * c / 3), d = 0.5 * Math.sqrt(c * u * (l - u) / l) * (h - l / 2 < 0 ? -1 : 1), m = Math.max(e, Math.floor(t - h * u / l + d)), f = Math.min(n, Math.floor(t + (l - h) * u / l + d));
        Yd(i, t, m, f, s);
      }
      const r = i[t];
      let a = e, o = n;
      for (js(i, e, t), s(i[n], r) > 0 && js(i, e, n); a < o; ) {
        for (js(i, a, o), a++, o--; s(i[a], r) < 0; ) a++;
        for (; s(i[o], r) > 0; ) o--;
      }
      s(i[e], r) === 0 ? js(i, e, o) : (o++, js(i, o, n)), o <= t && (e = o + 1), t <= o && (n = o - 1);
    }
  }
  function js(i, t, e) {
    const n = i[t];
    i[t] = i[e], i[e] = n;
  }
  function i_(i, t) {
    return i < t ? -1 : i > t ? 1 : 0;
  }
  let Zd = class {
    constructor(t = 9) {
      this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
    }
    all() {
      return this._all(this.data, []);
    }
    search(t) {
      let e = this.data;
      const n = [];
      if (!ya(t, e)) return n;
      const s = this.toBBox, r = [];
      for (; e; ) {
        for (let a = 0; a < e.children.length; a++) {
          const o = e.children[a], l = e.leaf ? s(o) : o;
          ya(t, l) && (e.leaf ? n.push(o) : nl(t, l) ? this._all(o, n) : r.push(o));
        }
        e = r.pop();
      }
      return n;
    }
    collides(t) {
      let e = this.data;
      if (!ya(t, e)) return !1;
      const n = [];
      for (; e; ) {
        for (let s = 0; s < e.children.length; s++) {
          const r = e.children[s], a = e.leaf ? this.toBBox(r) : r;
          if (ya(t, a)) {
            if (e.leaf || nl(t, a)) return !0;
            n.push(r);
          }
        }
        e = n.pop();
      }
      return !1;
    }
    load(t) {
      if (!(t && t.length)) return this;
      if (t.length < this._minEntries) {
        for (let n = 0; n < t.length; n++)
          this.insert(t[n]);
        return this;
      }
      let e = this._build(t.slice(), 0, t.length - 1, 0);
      if (!this.data.children.length)
        this.data = e;
      else if (this.data.height === e.height)
        this._splitRoot(this.data, e);
      else {
        if (this.data.height < e.height) {
          const n = this.data;
          this.data = e, e = n;
        }
        this._insert(e, this.data.height - e.height - 1, !0);
      }
      return this;
    }
    insert(t) {
      return t && this._insert(t, this.data.height - 1), this;
    }
    clear() {
      return this.data = rs([]), this;
    }
    remove(t, e) {
      if (!t) return this;
      let n = this.data;
      const s = this.toBBox(t), r = [], a = [];
      let o, l, h;
      for (; n || r.length; ) {
        if (n || (n = r.pop(), l = r[r.length - 1], o = a.pop(), h = !0), n.leaf) {
          const c = n_(t, n.children, e);
          if (c !== -1)
            return n.children.splice(c, 1), r.push(n), this._condense(r), this;
        }
        !h && !n.leaf && nl(n, s) ? (r.push(n), a.push(o), o = 0, l = n, n = n.children[0]) : l ? (o++, n = l.children[o], h = !1) : n = null;
      }
      return this;
    }
    toBBox(t) {
      return t;
    }
    compareMinX(t, e) {
      return t.minX - e.minX;
    }
    compareMinY(t, e) {
      return t.minY - e.minY;
    }
    toJSON() {
      return this.data;
    }
    fromJSON(t) {
      return this.data = t, this;
    }
    _all(t, e) {
      const n = [];
      for (; t; )
        t.leaf ? e.push(...t.children) : n.push(...t.children), t = n.pop();
      return e;
    }
    _build(t, e, n, s) {
      const r = n - e + 1;
      let a = this._maxEntries, o;
      if (r <= a)
        return o = rs(t.slice(e, n + 1)), Hn(o, this.toBBox), o;
      s || (s = Math.ceil(Math.log(r) / Math.log(a)), a = Math.ceil(r / Math.pow(a, s - 1))), o = rs([]), o.leaf = !1, o.height = s;
      const l = Math.ceil(r / a), h = l * Math.ceil(Math.sqrt(a));
      iu(t, e, n, h, this.compareMinX);
      for (let c = e; c <= n; c += h) {
        const u = Math.min(c + h - 1, n);
        iu(t, c, u, l, this.compareMinY);
        for (let d = c; d <= u; d += l) {
          const m = Math.min(d + l - 1, u);
          o.children.push(this._build(t, d, m, s - 1));
        }
      }
      return Hn(o, this.toBBox), o;
    }
    _chooseSubtree(t, e, n, s) {
      for (; s.push(e), !(e.leaf || s.length - 1 === n); ) {
        let r = 1 / 0, a = 1 / 0, o;
        for (let l = 0; l < e.children.length; l++) {
          const h = e.children[l], c = il(h), u = a_(t, h) - c;
          u < a ? (a = u, r = c < r ? c : r, o = h) : u === a && c < r && (r = c, o = h);
        }
        e = o || e.children[0];
      }
      return e;
    }
    _insert(t, e, n) {
      const s = n ? t : this.toBBox(t), r = [], a = this._chooseSubtree(s, this.data, e, r);
      for (a.children.push(t), er(a, s); e >= 0 && r[e].children.length > this._maxEntries; )
        this._split(r, e), e--;
      this._adjustParentBBoxes(s, r, e);
    }
    // split overflowed node into two
    _split(t, e) {
      const n = t[e], s = n.children.length, r = this._minEntries;
      this._chooseSplitAxis(n, r, s);
      const a = this._chooseSplitIndex(n, r, s), o = rs(n.children.splice(a, n.children.length - a));
      o.height = n.height, o.leaf = n.leaf, Hn(n, this.toBBox), Hn(o, this.toBBox), e ? t[e - 1].children.push(o) : this._splitRoot(n, o);
    }
    _splitRoot(t, e) {
      this.data = rs([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, Hn(this.data, this.toBBox);
    }
    _chooseSplitIndex(t, e, n) {
      let s, r = 1 / 0, a = 1 / 0;
      for (let o = e; o <= n - e; o++) {
        const l = tr(t, 0, o, this.toBBox), h = tr(t, o, n, this.toBBox), c = o_(l, h), u = il(l) + il(h);
        c < r ? (r = c, s = o, a = u < a ? u : a) : c === r && u < a && (a = u, s = o);
      }
      return s || n - e;
    }
    // sorts node children by the best axis for split
    _chooseSplitAxis(t, e, n) {
      const s = t.leaf ? this.compareMinX : s_, r = t.leaf ? this.compareMinY : r_, a = this._allDistMargin(t, e, n, s), o = this._allDistMargin(t, e, n, r);
      a < o && t.children.sort(s);
    }
    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin(t, e, n, s) {
      t.children.sort(s);
      const r = this.toBBox, a = tr(t, 0, e, r), o = tr(t, n - e, n, r);
      let l = pa(a) + pa(o);
      for (let h = e; h < n - e; h++) {
        const c = t.children[h];
        er(a, t.leaf ? r(c) : c), l += pa(a);
      }
      for (let h = n - e - 1; h >= e; h--) {
        const c = t.children[h];
        er(o, t.leaf ? r(c) : c), l += pa(o);
      }
      return l;
    }
    _adjustParentBBoxes(t, e, n) {
      for (let s = n; s >= 0; s--)
        er(e[s], t);
    }
    _condense(t) {
      for (let e = t.length - 1, n; e >= 0; e--)
        t[e].children.length === 0 ? e > 0 ? (n = t[e - 1].children, n.splice(n.indexOf(t[e]), 1)) : this.clear() : Hn(t[e], this.toBBox);
    }
  };
  function n_(i, t, e) {
    if (!e) return t.indexOf(i);
    for (let n = 0; n < t.length; n++)
      if (e(i, t[n])) return n;
    return -1;
  }
  function Hn(i, t) {
    tr(i, 0, i.children.length, t, i);
  }
  function tr(i, t, e, n, s) {
    s || (s = rs(null)), s.minX = 1 / 0, s.minY = 1 / 0, s.maxX = -1 / 0, s.maxY = -1 / 0;
    for (let r = t; r < e; r++) {
      const a = i.children[r];
      er(s, i.leaf ? n(a) : a);
    }
    return s;
  }
  function er(i, t) {
    return i.minX = Math.min(i.minX, t.minX), i.minY = Math.min(i.minY, t.minY), i.maxX = Math.max(i.maxX, t.maxX), i.maxY = Math.max(i.maxY, t.maxY), i;
  }
  function s_(i, t) {
    return i.minX - t.minX;
  }
  function r_(i, t) {
    return i.minY - t.minY;
  }
  function il(i) {
    return (i.maxX - i.minX) * (i.maxY - i.minY);
  }
  function pa(i) {
    return i.maxX - i.minX + (i.maxY - i.minY);
  }
  function a_(i, t) {
    return (Math.max(t.maxX, i.maxX) - Math.min(t.minX, i.minX)) * (Math.max(t.maxY, i.maxY) - Math.min(t.minY, i.minY));
  }
  function o_(i, t) {
    const e = Math.max(i.minX, t.minX), n = Math.max(i.minY, t.minY), s = Math.min(i.maxX, t.maxX), r = Math.min(i.maxY, t.maxY);
    return Math.max(0, s - e) * Math.max(0, r - n);
  }
  function nl(i, t) {
    return i.minX <= t.minX && i.minY <= t.minY && t.maxX <= i.maxX && t.maxY <= i.maxY;
  }
  function ya(i, t) {
    return t.minX <= i.maxX && t.minY <= i.maxY && t.maxX >= i.minX && t.maxY >= i.minY;
  }
  function rs(i) {
    return {
      children: i,
      height: 1,
      leaf: !0,
      minX: 1 / 0,
      minY: 1 / 0,
      maxX: -1 / 0,
      maxY: -1 / 0
    };
  }
  function iu(i, t, e, n, s) {
    const r = [t, e];
    for (; r.length; ) {
      if (e = r.pop(), t = r.pop(), e - t <= n) continue;
      const a = t + Math.ceil((e - t) / n / 2) * n;
      Yd(i, a, t, e, s), r.push(t, a, a, e);
    }
  }
  const mt = {
    IDLE: 0,
    LOADING: 1,
    LOADED: 2,
    ERROR: 3,
    EMPTY: 4
  };
  var Rr = {
    name: "rgb",
    min: [0, 0, 0],
    max: [255, 255, 255],
    channel: ["red", "green", "blue"],
    alias: ["RGB"]
  }, ce = {
    name: "xyz",
    min: [0, 0, 0],
    channel: ["X", "Y", "Z"],
    alias: ["XYZ", "ciexyz", "cie1931"],
    /**
     * Whitepoint reference values with observer/illuminant
     *
     * http://en.wikipedia.org/wiki/Standard_illuminant
     */
    whitepoint: {
      //1931 2
      2: {
        //incadescent
        A: [109.85, 100, 35.585],
        // B:[],
        C: [98.074, 100, 118.232],
        D50: [96.422, 100, 82.521],
        D55: [95.682, 100, 92.149],
        //daylight
        D65: [95.045592705167, 100, 108.9057750759878],
        D75: [94.972, 100, 122.638],
        //flourescent
        // F1: [],
        F2: [99.187, 100, 67.395],
        // F3: [],
        // F4: [],
        // F5: [],
        // F6:[],
        F7: [95.044, 100, 108.755],
        // F8: [],
        // F9: [],
        // F10: [],
        F11: [100.966, 100, 64.37],
        // F12: [],
        E: [100, 100, 100]
      },
      //1964  10
      10: {
        //incadescent
        A: [111.144, 100, 35.2],
        C: [97.285, 100, 116.145],
        D50: [96.72, 100, 81.427],
        D55: [95.799, 100, 90.926],
        //daylight
        D65: [94.811, 100, 107.304],
        D75: [94.416, 100, 120.641],
        //flourescent
        F2: [103.28, 100, 69.026],
        F7: [95.792, 100, 107.687],
        F11: [103.866, 100, 65.627],
        E: [100, 100, 100]
      }
    }
  };
  ce.max = ce.whitepoint[2].D65;
  ce.rgb = function(i, t) {
    t = t || ce.whitepoint[2].E;
    var e = i[0] / t[0], n = i[1] / t[1], s = i[2] / t[2], r, a, o;
    return r = e * 3.240969941904521 + n * -1.537383177570093 + s * -0.498610760293, a = e * -0.96924363628087 + n * 1.87596750150772 + s * 0.041555057407175, o = e * 0.055630079696993 + n * -0.20397695888897 + s * 1.056971514242878, r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r = r * 12.92, a = a > 31308e-7 ? 1.055 * Math.pow(a, 1 / 2.4) - 0.055 : a = a * 12.92, o = o > 31308e-7 ? 1.055 * Math.pow(o, 1 / 2.4) - 0.055 : o = o * 12.92, r = Math.min(Math.max(0, r), 1), a = Math.min(Math.max(0, a), 1), o = Math.min(Math.max(0, o), 1), [r * 255, a * 255, o * 255];
  };
  Rr.xyz = function(i, t) {
    var e = i[0] / 255, n = i[1] / 255, s = i[2] / 255;
    e = e > 0.04045 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92, n = n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92, s = s > 0.04045 ? Math.pow((s + 0.055) / 1.055, 2.4) : s / 12.92;
    var r = e * 0.41239079926595 + n * 0.35758433938387 + s * 0.18048078840183, a = e * 0.21263900587151 + n * 0.71516867876775 + s * 0.072192315360733, o = e * 0.019330818715591 + n * 0.11919477979462 + s * 0.95053215224966;
    return t = t || ce.whitepoint[2].E, [r * t[0], a * t[1], o * t[2]];
  };
  var Fh = {
    name: "luv",
    //NOTE: luv has no rigidly defined limits
    //easyrgb fails to get proper coords
    //boronine states no rigid limits
    //colorMine refers this ones:
    min: [0, -134, -140],
    max: [100, 224, 122],
    channel: ["lightness", "u", "v"],
    alias: ["LUV", "cieluv", "cie1976"],
    xyz: function(i, t, e) {
      var n, s, r, a, o, l, h, c, u, d, m, f, y;
      if (r = i[0], a = i[1], o = i[2], r === 0) return [0, 0, 0];
      var E = 0.0011070564598794539;
      return t = t || "D65", e = e || 2, u = ce.whitepoint[e][t][0], d = ce.whitepoint[e][t][1], m = ce.whitepoint[e][t][2], f = 4 * u / (u + 15 * d + 3 * m), y = 9 * d / (u + 15 * d + 3 * m), n = a / (13 * r) + f || 0, s = o / (13 * r) + y || 0, h = r > 8 ? d * Math.pow((r + 16) / 116, 3) : d * r * E, l = h * 9 * n / (4 * s) || 0, c = h * (12 - 3 * n - 20 * s) / (4 * s) || 0, [l, h, c];
    }
  };
  ce.luv = function(i, t, e) {
    var n, s, r, a, o, l, h, c, u, d, m, f, y, E = 0.008856451679035631, x = 903.2962962962961;
    t = t || "D65", e = e || 2, u = ce.whitepoint[e][t][0], d = ce.whitepoint[e][t][1], m = ce.whitepoint[e][t][2], f = 4 * u / (u + 15 * d + 3 * m), y = 9 * d / (u + 15 * d + 3 * m), l = i[0], h = i[1], c = i[2], n = 4 * l / (l + 15 * h + 3 * c) || 0, s = 9 * h / (l + 15 * h + 3 * c) || 0;
    var M = h / d;
    return r = M <= E ? x * M : 116 * Math.pow(M, 1 / 3) - 16, a = 13 * r * (n - f), o = 13 * r * (s - y), [r, a, o];
  };
  var qd = {
    name: "lchuv",
    channel: ["lightness", "chroma", "hue"],
    alias: ["LCHuv", "cielchuv"],
    min: [0, 0, 0],
    max: [100, 100, 360],
    luv: function(i) {
      var t = i[0], e = i[1], n = i[2], s, r, a;
      return a = n / 360 * 2 * Math.PI, s = e * Math.cos(a), r = e * Math.sin(a), [t, s, r];
    },
    xyz: function(i) {
      return Fh.xyz(qd.luv(i));
    }
  };
  Fh.lchuv = function(i) {
    var t = i[0], e = i[1], n = i[2], s = Math.sqrt(e * e + n * n), r = Math.atan2(n, e), a = r * 360 / 2 / Math.PI;
    return a < 0 && (a += 360), [t, s, a];
  };
  ce.lchuv = function(i) {
    return Fh.lchuv(ce.luv(i));
  };
  const nu = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
  var su = {
    red: 0,
    orange: 60,
    yellow: 120,
    green: 180,
    blue: 240,
    purple: 300
  };
  function l_(i) {
    var c, u;
    var t, e = [], n = 1, s;
    if (typeof i == "number")
      return { space: "rgb", values: [i >>> 16, (i & 65280) >>> 8, i & 255], alpha: 1 };
    if (typeof i == "number") return { space: "rgb", values: [i >>> 16, (i & 65280) >>> 8, i & 255], alpha: 1 };
    if (i = String(i).toLowerCase(), nu[i])
      e = nu[i].slice(), s = "rgb";
    else if (i === "transparent")
      n = 0, s = "rgb", e = [0, 0, 0];
    else if (i[0] === "#") {
      var r = i.slice(1), a = r.length, o = a <= 4;
      n = 1, o ? (e = [
        parseInt(r[0] + r[0], 16),
        parseInt(r[1] + r[1], 16),
        parseInt(r[2] + r[2], 16)
      ], a === 4 && (n = parseInt(r[3] + r[3], 16) / 255)) : (e = [
        parseInt(r[0] + r[1], 16),
        parseInt(r[2] + r[3], 16),
        parseInt(r[4] + r[5], 16)
      ], a === 8 && (n = parseInt(r[6] + r[7], 16) / 255)), e[0] || (e[0] = 0), e[1] || (e[1] = 0), e[2] || (e[2] = 0), s = "rgb";
    } else if (t = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(i)) {
      var l = t[1];
      s = l.replace(/a$/, "");
      var h = s === "cmyk" ? 4 : s === "gray" ? 1 : 3;
      e = t[2].trim().split(/\s*[,\/]\s*|\s+/), s === "color" && (s = e.shift()), e = e.map(function(d, m) {
        if (d[d.length - 1] === "%")
          return d = parseFloat(d) / 100, m === 3 ? d : s === "rgb" ? d * 255 : s[0] === "h" || s[0] === "l" && !m ? d * 100 : s === "lab" ? d * 125 : s === "lch" ? m < 2 ? d * 150 : d * 360 : s[0] === "o" && !m ? d : s === "oklab" ? d * 0.4 : s === "oklch" ? m < 2 ? d * 0.4 : d * 360 : d;
        if (s[m] === "h" || m === 2 && s[s.length - 1] === "h") {
          if (su[d] !== void 0) return su[d];
          if (d.endsWith("deg")) return parseFloat(d);
          if (d.endsWith("turn")) return parseFloat(d) * 360;
          if (d.endsWith("grad")) return parseFloat(d) * 360 / 400;
          if (d.endsWith("rad")) return parseFloat(d) * 180 / Math.PI;
        }
        return d === "none" ? 0 : parseFloat(d);
      }), n = e.length > h ? e.pop() : 1;
    } else /[0-9](?:\s|\/|,)/.test(i) && (e = i.match(/([0-9]+)/g).map(function(d) {
      return parseFloat(d);
    }), s = ((u = (c = i.match(/([a-z])/ig)) == null ? void 0 : c.join("")) == null ? void 0 : u.toLowerCase()) || "rgb");
    return {
      space: s,
      values: e,
      alpha: n
    };
  }
  var sl = {
    name: "hsl",
    min: [0, 0, 0],
    max: [360, 100, 100],
    channel: ["hue", "saturation", "lightness"],
    alias: ["HSL"],
    rgb: function(i) {
      var t = i[0] / 360, e = i[1] / 100, n = i[2] / 100, s, r, a, o, l, h = 0;
      if (e === 0) return l = n * 255, [l, l, l];
      for (r = n < 0.5 ? n * (1 + e) : n + e - n * e, s = 2 * n - r, o = [0, 0, 0]; h < 3; )
        a = t + 1 / 3 * -(h - 1), a < 0 ? a++ : a > 1 && a--, l = 6 * a < 1 ? s + (r - s) * 6 * a : 2 * a < 1 ? r : 3 * a < 2 ? s + (r - s) * (2 / 3 - a) * 6 : s, o[h++] = l * 255;
      return o;
    }
  };
  Rr.hsl = function(i) {
    var t = i[0] / 255, e = i[1] / 255, n = i[2] / 255, s = Math.min(t, e, n), r = Math.max(t, e, n), a = r - s, o, l, h;
    return r === s ? o = 0 : t === r ? o = (e - n) / a : e === r ? o = 2 + (n - t) / a : n === r && (o = 4 + (t - e) / a), o = Math.min(o * 60, 360), o < 0 && (o += 360), h = (s + r) / 2, r === s ? l = 0 : h <= 0.5 ? l = a / (r + s) : l = a / (2 - r - s), [o, l * 100, h * 100];
  };
  function h_(i) {
    Array.isArray(i) && i.raw && (i = String.raw(...arguments)), i instanceof Number && (i = +i);
    var t, e = l_(i);
    if (!e.space) return [];
    const n = e.space[0] === "h" ? sl.min : Rr.min, s = e.space[0] === "h" ? sl.max : Rr.max;
    return t = Array(3), t[0] = Math.min(Math.max(e.values[0], n[0]), s[0]), t[1] = Math.min(Math.max(e.values[1], n[1]), s[1]), t[2] = Math.min(Math.max(e.values[2], n[2]), s[2]), e.space[0] === "h" && (t = sl.rgb(t)), t.push(Math.min(Math.max(e.alpha, 0), 1)), t;
  }
  const Dh = [NaN, NaN, NaN, 0];
  function c_(i) {
    return typeof i == "string" ? i : Gh(i);
  }
  const u_ = 1024, Vs = {};
  let rl = 0;
  function d_(i) {
    if (i.length === 4)
      return i;
    const t = i.slice();
    return t[3] = 1, t;
  }
  function ru(i) {
    const t = ce.lchuv(Rr.xyz(i));
    return t[3] = i[3], t;
  }
  function f_(i) {
    const t = ce.rgb(qd.xyz(i));
    return t[3] = i[3], t;
  }
  function kh(i) {
    if (i === "none")
      return Dh;
    if (Vs.hasOwnProperty(i))
      return Vs[i];
    if (rl >= u_) {
      let e = 0;
      for (const n in Vs)
        e++ & 3 || (delete Vs[n], --rl);
    }
    const t = h_(i);
    if (t.length !== 4)
      throw new Error('failed to parse "' + i + '" as color');
    for (const e of t)
      if (isNaN(e))
        throw new Error('failed to parse "' + i + '" as color');
    return Kd(t), Vs[i] = t, ++rl, t;
  }
  function Os(i) {
    return Array.isArray(i) ? i : kh(i);
  }
  function Kd(i) {
    return i[0] = Gt(i[0] + 0.5 | 0, 0, 255), i[1] = Gt(i[1] + 0.5 | 0, 0, 255), i[2] = Gt(i[2] + 0.5 | 0, 0, 255), i[3] = Gt(i[3], 0, 1), i;
  }
  function Gh(i) {
    let t = i[0];
    t != (t | 0) && (t = t + 0.5 | 0);
    let e = i[1];
    e != (e | 0) && (e = e + 0.5 | 0);
    let n = i[2];
    n != (n | 0) && (n = n + 0.5 | 0);
    const s = i[3] === void 0 ? 1 : Math.round(i[3] * 1e3) / 1e3;
    return "rgba(" + t + "," + e + "," + n + "," + s + ")";
  }
  const hn = typeof navigator < "u" && typeof navigator.userAgent < "u" ? navigator.userAgent.toLowerCase() : "", jd = hn.includes("firefox"), Vd = hn.includes("safari") && !hn.includes("chrom"), g_ = Vd && (hn.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(hn)), Hd = hn.includes("webkit") && !hn.includes("edge"), Uh = hn.includes("macintosh"), Co = typeof devicePixelRatio < "u" ? devicePixelRatio : 1, To = typeof WorkerGlobalScope < "u" && typeof OffscreenCanvas < "u" && self instanceof WorkerGlobalScope, zh = typeof Image < "u" && Image.prototype.decode, m_ = typeof createImageBitmap == "function", Bh = function() {
    let i = !1;
    try {
      const t = Object.defineProperty({}, "passive", {
        get: function() {
          i = !0;
        }
      });
      window.addEventListener("_", null, t), window.removeEventListener("_", null, t);
    } catch {
    }
    return i;
  }(), __ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    CREATE_IMAGE_BITMAP: m_,
    DEVICE_PIXEL_RATIO: Co,
    FIREFOX: jd,
    IMAGE_DECODE: zh,
    MAC: Uh,
    PASSIVE_EVENT_LISTENERS: Bh,
    SAFARI: Vd,
    SAFARI_BUG_237906: g_,
    WEBKIT: Hd,
    WORKER_OFFSCREEN_CANVAS: To
  }, Symbol.toStringTag, { value: "Module" }));
  function Xt(i, t, e, n) {
    let s;
    return e && e.length ? s = /** @type {HTMLCanvasElement} */
    e.shift() : To ? s = new OffscreenCanvas(i || 300, t || 300) : s = document.createElement("canvas"), i && (s.width = i), t && (s.height = t), /** @type {CanvasRenderingContext2D} */
    s.getContext("2d", n);
  }
  let al;
  function Wa() {
    return al || (al = Xt(1, 1)), al;
  }
  function Io(i) {
    const t = i.canvas;
    t.width = 1, t.height = 1, i.clearRect(0, 0, 1, 1);
  }
  function p_(i) {
    let t = i.offsetWidth;
    const e = getComputedStyle(i);
    return t += parseInt(e.marginLeft, 10) + parseInt(e.marginRight, 10), t;
  }
  function y_(i) {
    let t = i.offsetHeight;
    const e = getComputedStyle(i);
    return t += parseInt(e.marginTop, 10) + parseInt(e.marginBottom, 10), t;
  }
  function au(i, t) {
    const e = t.parentNode;
    e && e.replaceChild(i, t);
  }
  function Jd(i) {
    for (; i.lastChild; )
      i.lastChild.remove();
  }
  function v_(i, t) {
    const e = i.childNodes;
    for (let n = 0; ; ++n) {
      const s = e[n], r = t[n];
      if (!s && !r)
        break;
      if (s !== r) {
        if (!s) {
          i.appendChild(r);
          continue;
        }
        if (!r) {
          i.removeChild(s), --n;
          continue;
        }
        i.insertBefore(r, s);
      }
    }
  }
  function E_(i, t, e) {
    const n = (
      /** @type {HTMLImageElement} */
      i
    );
    let s = !0, r = !1, a = !1;
    const o = [
      ka(n, ht.LOAD, function() {
        a = !0, r || t();
      })
    ];
    return n.src && zh ? (r = !0, n.decode().then(function() {
      s && t();
    }).catch(function(l) {
      s && (a ? t() : e());
    })) : o.push(ka(n, ht.ERROR, e)), function() {
      s = !1, o.forEach(bt);
    };
  }
  function x_(i, t) {
    return new Promise((e, n) => {
      function s() {
        a(), e(i);
      }
      function r() {
        a(), n(new Error("Image load error"));
      }
      function a() {
        i.removeEventListener("load", s), i.removeEventListener("error", r);
      }
      i.addEventListener("load", s), i.addEventListener("error", r);
    });
  }
  function M_(i, t) {
    return t && (i.src = t), i.src && zh ? new Promise(
      (e, n) => i.decode().then(() => e(i)).catch(
        (s) => i.complete && i.width ? e(i) : n(s)
      )
    ) : x_(i);
  }
  class w_ {
    constructor() {
      this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0, this.maxCacheSize_ = 1024;
    }
    /**
     * FIXME empty description for jsdoc
     */
    clear() {
      this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0;
    }
    /**
     * @return {boolean} Can expire cache.
     */
    canExpireCache() {
      return this.cacheSize_ > this.maxCacheSize_;
    }
    /**
     * FIXME empty description for jsdoc
     */
    expire() {
      if (this.canExpireCache()) {
        let t = 0;
        for (const e in this.cache_) {
          const n = this.cache_[e];
          !(t++ & 3) && !n.hasListener() && (delete this.cache_[e], delete this.patternCache_[e], --this.cacheSize_);
        }
      }
    }
    /**
     * @param {string} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../color.js").Color|string|null} color Color.
     * @return {import("./IconImage.js").default} Icon image.
     */
    get(t, e, n) {
      const s = ol(t, e, n);
      return s in this.cache_ ? this.cache_[s] : null;
    }
    /**
     * @param {string} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../color.js").Color|string|null} color Color.
     * @return {CanvasPattern} Icon image.
     */
    getPattern(t, e, n) {
      const s = ol(t, e, n);
      return s in this.patternCache_ ? this.patternCache_[s] : null;
    }
    /**
     * @param {string} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../color.js").Color|string|null} color Color.
     * @param {import("./IconImage.js").default|null} iconImage Icon image.
     * @param {boolean} [pattern] Also cache a `'repeat'` pattern with this `iconImage`.
     */
    set(t, e, n, s, r) {
      const a = ol(t, e, n), o = a in this.cache_;
      this.cache_[a] = s, r && (s.getImageState() === mt.IDLE && s.load(), s.getImageState() === mt.LOADING ? s.ready().then(() => {
        this.patternCache_[a] = Wa().createPattern(
          s.getImage(1),
          "repeat"
        );
      }) : this.patternCache_[a] = Wa().createPattern(
        s.getImage(1),
        "repeat"
      )), o || ++this.cacheSize_;
    }
    /**
     * Set the cache size of the icon cache. Default is `1024`. Change this value when
     * your map uses more than 1024 different icon images and you are not caching icon
     * styles on the application level.
     * @param {number} maxCacheSize Cache max size.
     * @api
     */
    setSize(t) {
      this.maxCacheSize_ = t, this.expire();
    }
  }
  function ol(i, t, e) {
    const n = e ? Os(e) : "null";
    return t + ":" + i + ":" + n;
  }
  const $e = new w_();
  let Hs = null;
  class $h extends uo {
    /**
     * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap|null} image Image.
     * @param {string|undefined} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../ImageState.js").default|undefined} imageState Image state.
     * @param {import("../color.js").Color|string|null} color Color.
     */
    constructor(t, e, n, s, r) {
      super(), this.hitDetectionImage_ = null, this.image_ = t, this.crossOrigin_ = n, this.canvas_ = {}, this.color_ = r, this.imageState_ = s === void 0 ? mt.IDLE : s, this.size_ = t && t.width && t.height ? [t.width, t.height] : null, this.src_ = e, this.tainted_, this.ready_ = null;
    }
    /**
     * @private
     */
    initializeImage_() {
      this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_);
    }
    /**
     * @private
     * @return {boolean} The image canvas is tainted.
     */
    isTainted_() {
      if (this.tainted_ === void 0 && this.imageState_ === mt.LOADED) {
        Hs || (Hs = Xt(1, 1, void 0, {
          willReadFrequently: !0
        })), Hs.drawImage(this.image_, 0, 0);
        try {
          Hs.getImageData(0, 0, 1, 1), this.tainted_ = !1;
        } catch {
          Hs = null, this.tainted_ = !0;
        }
      }
      return this.tainted_ === !0;
    }
    /**
     * @private
     */
    dispatchChangeEvent_() {
      this.dispatchEvent(ht.CHANGE);
    }
    /**
     * @private
     */
    handleImageError_() {
      this.imageState_ = mt.ERROR, this.dispatchChangeEvent_();
    }
    /**
     * @private
     */
    handleImageLoad_() {
      this.imageState_ = mt.LOADED, this.size_ = [this.image_.width, this.image_.height], this.dispatchChangeEvent_();
    }
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
     */
    getImage(t) {
      return this.image_ || this.initializeImage_(), this.replaceColor_(t), this.canvas_[t] ? this.canvas_[t] : this.image_;
    }
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Image or Canvas element.
     */
    getPixelRatio(t) {
      return this.replaceColor_(t), this.canvas_[t] ? t : 1;
    }
    /**
     * @return {import("../ImageState.js").default} Image state.
     */
    getImageState() {
      return this.imageState_;
    }
    /**
     * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
     */
    getHitDetectionImage() {
      if (this.image_ || this.initializeImage_(), !this.hitDetectionImage_)
        if (this.isTainted_()) {
          const t = this.size_[0], e = this.size_[1], n = Xt(t, e);
          n.fillRect(0, 0, t, e), this.hitDetectionImage_ = n.canvas;
        } else
          this.hitDetectionImage_ = this.image_;
      return this.hitDetectionImage_;
    }
    /**
     * Get the size of the icon (in pixels).
     * @return {import("../size.js").Size} Image size.
     */
    getSize() {
      return this.size_;
    }
    /**
     * @return {string|undefined} Image src.
     */
    getSrc() {
      return this.src_;
    }
    /**
     * Load not yet loaded URI.
     */
    load() {
      if (this.imageState_ === mt.IDLE) {
        this.image_ || this.initializeImage_(), this.imageState_ = mt.LOADING;
        try {
          this.src_ !== void 0 && (this.image_.src = this.src_);
        } catch {
          this.handleImageError_();
        }
        this.image_ instanceof HTMLImageElement && M_(this.image_, this.src_).then((t) => {
          this.image_ = t, this.handleImageLoad_();
        }).catch(this.handleImageError_.bind(this));
      }
    }
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @private
     */
    replaceColor_(t) {
      if (!this.color_ || this.canvas_[t] || this.imageState_ !== mt.LOADED)
        return;
      const e = this.image_, n = Xt(
        Math.ceil(e.width * t),
        Math.ceil(e.height * t)
      ), s = n.canvas;
      n.scale(t, t), n.drawImage(e, 0, 0), n.globalCompositeOperation = "multiply", n.fillStyle = c_(this.color_), n.fillRect(0, 0, s.width / t, s.height / t), n.globalCompositeOperation = "destination-in", n.drawImage(e, 0, 0), this.canvas_[t] = s;
    }
    /**
     * @return {Promise<void>} Promise that resolves when the image is loaded.
     */
    ready() {
      return this.ready_ || (this.ready_ = new Promise((t) => {
        if (this.imageState_ === mt.LOADED || this.imageState_ === mt.ERROR)
          t();
        else {
          const e = () => {
            (this.imageState_ === mt.LOADED || this.imageState_ === mt.ERROR) && (this.removeEventListener(ht.CHANGE, e), t());
          };
          this.addEventListener(ht.CHANGE, e);
        }
      })), this.ready_;
    }
  }
  function Xh(i, t, e, n, s, r) {
    let a = t === void 0 ? void 0 : $e.get(t, e, s);
    return a || (a = new $h(
      i,
      i && "src" in i ? i.src || void 0 : t,
      e,
      n,
      s
    ), $e.set(t, e, s, a, r)), r && a && !$e.getPattern(t, e, s) && $e.set(t, e, s, a, r), a;
  }
  function ou(i) {
    return i[0] > 0 && i[1] > 0;
  }
  function R_(i, t, e) {
    return e === void 0 && (e = [0, 0]), e[0] = i[0] * t + 0.5 | 0, e[1] = i[1] * t + 0.5 | 0, e;
  }
  function Ie(i, t) {
    return Array.isArray(i) ? i : (t === void 0 ? t = [i, i] : (t[0] = i, t[1] = i), t);
  }
  class $r {
    /**
     * @param {Options} options Options.
     */
    constructor(t) {
      this.opacity_ = t.opacity, this.rotateWithView_ = t.rotateWithView, this.rotation_ = t.rotation, this.scale_ = t.scale, this.scaleArray_ = Ie(t.scale), this.displacement_ = t.displacement, this.declutterMode_ = t.declutterMode;
    }
    /**
     * Clones the style.
     * @return {ImageStyle} The cloned style.
     * @api
     */
    clone() {
      const t = this.getScale();
      return new $r({
        opacity: this.getOpacity(),
        scale: Array.isArray(t) ? t.slice() : t,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
    }
    /**
     * Get the symbolizer opacity.
     * @return {number} Opacity.
     * @api
     */
    getOpacity() {
      return this.opacity_;
    }
    /**
     * Determine whether the symbolizer rotates with the map.
     * @return {boolean} Rotate with map.
     * @api
     */
    getRotateWithView() {
      return this.rotateWithView_;
    }
    /**
     * Get the symoblizer rotation.
     * @return {number} Rotation.
     * @api
     */
    getRotation() {
      return this.rotation_;
    }
    /**
     * Get the symbolizer scale.
     * @return {number|import("../size.js").Size} Scale.
     * @api
     */
    getScale() {
      return this.scale_;
    }
    /**
     * Get the symbolizer scale array.
     * @return {import("../size.js").Size} Scale array.
     */
    getScaleArray() {
      return this.scaleArray_;
    }
    /**
     * Get the displacement of the shape
     * @return {Array<number>} Shape's center displacement
     * @api
     */
    getDisplacement() {
      return this.displacement_;
    }
    /**
     * Get the declutter mode of the shape
     * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
     * @api
     */
    getDeclutterMode() {
      return this.declutterMode_;
    }
    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @abstract
     * @return {Array<number>} Anchor.
     */
    getAnchor() {
      return ft();
    }
    /**
     * Get the image element for the symbolizer.
     * @abstract
     * @param {number} pixelRatio Pixel ratio.
     * @return {import('../DataTile.js').ImageLike} Image element.
     */
    getImage(t) {
      return ft();
    }
    /**
     * @abstract
     * @return {import('../DataTile.js').ImageLike} Image element.
     */
    getHitDetectionImage() {
      return ft();
    }
    /**
     * Get the image pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Pixel ratio.
     */
    getPixelRatio(t) {
      return 1;
    }
    /**
     * @abstract
     * @return {import("../ImageState.js").default} Image state.
     */
    getImageState() {
      return ft();
    }
    /**
     * @abstract
     * @return {import("../size.js").Size} Image size.
     */
    getImageSize() {
      return ft();
    }
    /**
     * Get the origin of the symbolizer.
     * @abstract
     * @return {Array<number>} Origin.
     */
    getOrigin() {
      return ft();
    }
    /**
     * Get the size of the symbolizer (in pixels).
     * @abstract
     * @return {import("../size.js").Size} Size.
     */
    getSize() {
      return ft();
    }
    /**
     * Set the displacement.
     *
     * @param {Array<number>} displacement Displacement.
     * @api
     */
    setDisplacement(t) {
      this.displacement_ = t;
    }
    /**
     * Set the opacity.
     *
     * @param {number} opacity Opacity.
     * @api
     */
    setOpacity(t) {
      this.opacity_ = t;
    }
    /**
     * Set whether to rotate the style with the view.
     *
     * @param {boolean} rotateWithView Rotate with map.
     * @api
     */
    setRotateWithView(t) {
      this.rotateWithView_ = t;
    }
    /**
     * Set the rotation.
     *
     * @param {number} rotation Rotation.
     * @api
     */
    setRotation(t) {
      this.rotation_ = t;
    }
    /**
     * Set the scale.
     *
     * @param {number|import("../size.js").Size} scale Scale.
     * @api
     */
    setScale(t) {
      this.scale_ = t, this.scaleArray_ = Ie(t);
    }
    /**
     * @abstract
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
    listenImageChange(t) {
      ft();
    }
    /**
     * Load not yet loaded URI.
     * @abstract
     */
    load() {
      ft();
    }
    /**
     * @abstract
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
    unlistenImageChange(t) {
      ft();
    }
    /**
     * @return {Promise<void>} `false` or Promise that resolves when the style is ready to use.
     */
    ready() {
      return Promise.resolve();
    }
  }
  function ci(i) {
    return i ? Array.isArray(i) ? Gh(i) : typeof i == "object" && "src" in i ? S_(i) : i : null;
  }
  function S_(i) {
    if (!i.offset || !i.size)
      return $e.getPattern(i.src, "anonymous", i.color);
    const t = i.src + ":" + i.offset, e = $e.getPattern(
      t,
      void 0,
      i.color
    );
    if (e)
      return e;
    const n = $e.get(i.src, "anonymous", null);
    if (n.getImageState() !== mt.LOADED)
      return null;
    const s = Xt(
      i.size[0],
      i.size[1]
    );
    return s.drawImage(
      n.getImage(1),
      i.offset[0],
      i.offset[1],
      i.size[0],
      i.size[1],
      0,
      0,
      i.size[0],
      i.size[1]
    ), Xh(
      s.canvas,
      t,
      void 0,
      mt.LOADED,
      i.color,
      !0
    ), $e.getPattern(t, void 0, i.color);
  }
  const va = "ol-hidden", C_ = "ol-selectable", Ao = "ol-unselectable", Wh = "ol-control", lu = "ol-collapsed", T_ = new RegExp(
    [
      "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
      "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
      "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
      "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
      "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
      "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
      `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
    ].join(""),
    "i"
  ), hu = [
    "style",
    "variant",
    "weight",
    "size",
    "lineHeight",
    "family"
  ], Qd = function(i) {
    const t = i.match(T_);
    if (!t)
      return null;
    const e = (
      /** @type {FontParameters} */
      {
        lineHeight: "normal",
        size: "1.2em",
        style: "normal",
        weight: "normal",
        variant: "normal"
      }
    );
    for (let n = 0, s = hu.length; n < s; ++n) {
      const r = t[n + 1];
      r !== void 0 && (e[hu[n]] = r);
    }
    return e.families = e.family.split(/,\s?/), e;
  }, tf = "10px sans-serif", Re = "#000", Ns = "round", Ai = [], Pi = 0, Fs = "round", Sr = 10, Cr = "#000", Tr = "center", Ya = "middle", In = [0, 0, 0, 0], Ir = 1, Ci = new si();
  let as = null, Dl;
  const kl = {}, I_ = function() {
    const t = "32px ", e = ["monospace", "serif"], n = e.length, s = "wmytzilWMYTZIL@#/&?$%10";
    let r, a;
    function o(h, c, u) {
      let d = !0;
      for (let m = 0; m < n; ++m) {
        const f = e[m];
        if (a = Za(
          h + " " + c + " " + t + f,
          s
        ), u != f) {
          const y = Za(
            h + " " + c + " " + t + u + "," + f,
            s
          );
          d = d && y != a;
        }
      }
      return !!d;
    }
    function l() {
      let h = !0;
      const c = Ci.getKeys();
      for (let u = 0, d = c.length; u < d; ++u) {
        const m = c[u];
        if (Ci.get(m) < 100) {
          const [f, y, E] = m.split(`
`);
          o(f, y, E) ? (Fr(kl), as = null, Dl = void 0, Ci.set(m, 100)) : (Ci.set(m, Ci.get(m) + 1, !0), h = !1);
        }
      }
      h && (clearInterval(r), r = void 0);
    }
    return function(h) {
      const c = Qd(h);
      if (!c)
        return;
      const u = c.families;
      for (let d = 0, m = u.length; d < m; ++d) {
        const f = u[d], y = c.style + `
` + c.weight + `
` + f;
        Ci.get(y) === void 0 && (Ci.set(y, 100, !0), o(c.style, c.weight, f) || (Ci.set(y, 0, !0), r === void 0 && (r = setInterval(l, 32))));
      }
    };
  }(), A_ = /* @__PURE__ */ function() {
    let i;
    return function(t) {
      let e = kl[t];
      if (e == null) {
        if (To) {
          const n = Qd(t), s = ef(t, "g");
          e = (isNaN(Number(n.lineHeight)) ? 1.2 : Number(n.lineHeight)) * (s.actualBoundingBoxAscent + s.actualBoundingBoxDescent);
        } else
          i || (i = document.createElement("div"), i.innerHTML = "M", i.style.minHeight = "0", i.style.maxHeight = "none", i.style.height = "auto", i.style.padding = "0", i.style.border = "none", i.style.position = "absolute", i.style.display = "block", i.style.left = "-99999px"), i.style.font = t, document.body.appendChild(i), e = i.offsetHeight, document.body.removeChild(i);
        kl[t] = e;
      }
      return e;
    };
  }();
  function ef(i, t) {
    return as || (as = Xt(1, 1)), i != Dl && (as.font = i, Dl = as.font), as.measureText(t);
  }
  function Za(i, t) {
    return ef(i, t).width;
  }
  function cu(i, t, e) {
    if (t in e)
      return e[t];
    const n = t.split(`
`).reduce((s, r) => Math.max(s, Za(i, r)), 0);
    return e[t] = n, n;
  }
  function P_(i, t) {
    const e = [], n = [], s = [];
    let r = 0, a = 0, o = 0, l = 0;
    for (let h = 0, c = t.length; h <= c; h += 2) {
      const u = t[h];
      if (u === `
` || h === c) {
        r = Math.max(r, a), s.push(a), a = 0, o += l, l = 0;
        continue;
      }
      const d = t[h + 1] || i.font, m = Za(d, u);
      e.push(m), a += m;
      const f = A_(d);
      n.push(f), l = Math.max(l, f);
    }
    return { width: r, height: o, widths: e, heights: n, lineWidths: s };
  }
  function b_(i, t, e, n, s, r, a, o, l, h, c) {
    i.save(), e !== 1 && (i.globalAlpha === void 0 ? i.globalAlpha = (u) => u.globalAlpha *= e : i.globalAlpha *= e), t && i.transform.apply(i, t), /** @type {*} */
    n.contextInstructions ? (i.translate(l, h), i.scale(c[0], c[1]), L_(
      /** @type {Label} */
      n,
      i
    )) : c[0] < 0 || c[1] < 0 ? (i.translate(l, h), i.scale(c[0], c[1]), i.drawImage(
      /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
      n,
      s,
      r,
      a,
      o,
      0,
      0,
      a,
      o
    )) : i.drawImage(
      /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
      n,
      s,
      r,
      a,
      o,
      l,
      h,
      a * c[0],
      o * c[1]
    ), i.restore();
  }
  function L_(i, t) {
    const e = i.contextInstructions;
    for (let n = 0, s = e.length; n < s; n += 2)
      Array.isArray(e[n + 1]) ? t[e[n]].apply(
        t,
        e[n + 1]
      ) : t[e[n]] = e[n + 1];
  }
  class Xr extends $r {
    /**
     * @param {Options} options Options.
     */
    constructor(t) {
      super({
        opacity: 1,
        rotateWithView: t.rotateWithView !== void 0 ? t.rotateWithView : !1,
        rotation: t.rotation !== void 0 ? t.rotation : 0,
        scale: t.scale !== void 0 ? t.scale : 1,
        displacement: t.displacement !== void 0 ? t.displacement : [0, 0],
        declutterMode: t.declutterMode
      }), this.hitDetectionCanvas_ = null, this.fill_ = t.fill !== void 0 ? t.fill : null, this.origin_ = [0, 0], this.points_ = t.points, this.radius = t.radius, this.radius2_ = t.radius2, this.angle_ = t.angle !== void 0 ? t.angle : 0, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.size_, this.renderOptions_, this.imageState_ = this.fill_ && this.fill_.loading() ? mt.LOADING : mt.LOADED, this.imageState_ === mt.LOADING && this.ready().then(() => this.imageState_ = mt.LOADED), this.render();
    }
    /**
     * Clones the style.
     * @return {RegularShape} The cloned style.
     * @api
     * @override
     */
    clone() {
      const t = this.getScale(), e = new Xr({
        fill: this.getFill() ? this.getFill().clone() : void 0,
        points: this.getPoints(),
        radius: this.getRadius(),
        radius2: this.getRadius2(),
        angle: this.getAngle(),
        stroke: this.getStroke() ? this.getStroke().clone() : void 0,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        scale: Array.isArray(t) ? t.slice() : t,
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
      return e.setOpacity(this.getOpacity()), e;
    }
    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @return {Array<number>} Anchor.
     * @api
     * @override
     */
    getAnchor() {
      const t = this.size_, e = this.getDisplacement(), n = this.getScaleArray();
      return [
        t[0] / 2 - e[0] / n[0],
        t[1] / 2 + e[1] / n[1]
      ];
    }
    /**
     * Get the angle used in generating the shape.
     * @return {number} Shape's rotation in radians.
     * @api
     */
    getAngle() {
      return this.angle_;
    }
    /**
     * Get the fill style for the shape.
     * @return {import("./Fill.js").default|null} Fill style.
     * @api
     */
    getFill() {
      return this.fill_;
    }
    /**
     * Set the fill style.
     * @param {import("./Fill.js").default|null} fill Fill style.
     * @api
     */
    setFill(t) {
      this.fill_ = t, this.render();
    }
    /**
     * @return {HTMLCanvasElement} Image element.
     * @override
     */
    getHitDetectionImage() {
      return this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(
        this.renderOptions_
      )), this.hitDetectionCanvas_;
    }
    /**
     * Get the image icon.
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLCanvasElement} Image or Canvas element.
     * @api
     * @override
     */
    getImage(t) {
      var r, a;
      const e = (r = this.fill_) == null ? void 0 : r.getKey(), n = `${t},${this.angle_},${this.radius},${this.radius2_},${this.points_},${e}` + Object.values(this.renderOptions_).join(",");
      let s = (
        /** @type {HTMLCanvasElement} */
        (a = $e.get(n, null, null)) == null ? void 0 : a.getImage(1)
      );
      if (!s) {
        const o = this.renderOptions_, l = Math.ceil(o.size * t), h = Xt(l, l);
        this.draw_(o, h, t), s = h.canvas, $e.set(
          n,
          null,
          null,
          new $h(s, void 0, null, mt.LOADED, null)
        );
      }
      return s;
    }
    /**
     * Get the image pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Pixel ratio.
     * @override
     */
    getPixelRatio(t) {
      return t;
    }
    /**
     * @return {import("../size.js").Size} Image size.
     * @override
     */
    getImageSize() {
      return this.size_;
    }
    /**
     * @return {import("../ImageState.js").default} Image state.
     * @override
     */
    getImageState() {
      return this.imageState_;
    }
    /**
     * Get the origin of the symbolizer.
     * @return {Array<number>} Origin.
     * @api
     * @override
     */
    getOrigin() {
      return this.origin_;
    }
    /**
     * Get the number of points for generating the shape.
     * @return {number} Number of points for stars and regular polygons.
     * @api
     */
    getPoints() {
      return this.points_;
    }
    /**
     * Get the (primary) radius for the shape.
     * @return {number} Radius.
     * @api
     */
    getRadius() {
      return this.radius;
    }
    /**
     * Get the secondary radius for the shape.
     * @return {number|undefined} Radius2.
     * @api
     */
    getRadius2() {
      return this.radius2_;
    }
    /**
     * Get the size of the symbolizer (in pixels).
     * @return {import("../size.js").Size} Size.
     * @api
     * @override
     */
    getSize() {
      return this.size_;
    }
    /**
     * Get the stroke style for the shape.
     * @return {import("./Stroke.js").default|null} Stroke style.
     * @api
     */
    getStroke() {
      return this.stroke_;
    }
    /**
     * Set the stroke style.
     * @param {import("./Stroke.js").default|null} stroke Stroke style.
     * @api
     */
    setStroke(t) {
      this.stroke_ = t, this.render();
    }
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     * @override
     */
    listenImageChange(t) {
    }
    /**
     * Load not yet loaded URI.
     * @override
     */
    load() {
    }
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     * @override
     */
    unlistenImageChange(t) {
    }
    /**
     * Calculate additional canvas size needed for the miter.
     * @param {string} lineJoin Line join
     * @param {number} strokeWidth Stroke width
     * @param {number} miterLimit Miter limit
     * @return {number} Additional canvas size needed
     * @private
     */
    calculateLineJoinSize_(t, e, n) {
      if (e === 0 || this.points_ === 1 / 0 || t !== "bevel" && t !== "miter")
        return e;
      let s = this.radius, r = this.radius2_ === void 0 ? s : this.radius2_;
      if (s < r) {
        const A = s;
        s = r, r = A;
      }
      const a = this.radius2_ === void 0 ? this.points_ : this.points_ * 2, o = 2 * Math.PI / a, l = r * Math.sin(o), h = Math.sqrt(r * r - l * l), c = s - h, u = Math.sqrt(l * l + c * c), d = u / l;
      if (t === "miter" && d <= n)
        return d * e;
      const m = e / 2 / d, f = e / 2 * (c / u), E = Math.sqrt((s + m) * (s + m) + f * f) - s;
      if (this.radius2_ === void 0 || t === "bevel")
        return E * 2;
      const x = s * Math.sin(o), M = Math.sqrt(s * s - x * x), C = r - M, S = Math.sqrt(x * x + C * C) / x;
      if (S <= n) {
        const A = S * e / 2 - r - s;
        return 2 * Math.max(E, A);
      }
      return E * 2;
    }
    /**
     * @return {RenderOptions}  The render options
     * @protected
     */
    createRenderOptions() {
      let t = Ns, e = Fs, n = 0, s = null, r = 0, a, o = 0;
      this.stroke_ && (a = ci(this.stroke_.getColor() ?? Cr), o = this.stroke_.getWidth() ?? Ir, s = this.stroke_.getLineDash(), r = this.stroke_.getLineDashOffset() ?? 0, e = this.stroke_.getLineJoin() ?? Fs, t = this.stroke_.getLineCap() ?? Ns, n = this.stroke_.getMiterLimit() ?? Sr);
      const l = this.calculateLineJoinSize_(e, o, n), h = Math.max(this.radius, this.radius2_ || 0), c = Math.ceil(2 * h + l);
      return {
        strokeStyle: a,
        strokeWidth: o,
        size: c,
        lineCap: t,
        lineDash: s,
        lineDashOffset: r,
        lineJoin: e,
        miterLimit: n
      };
    }
    /**
     * @protected
     */
    render() {
      this.renderOptions_ = this.createRenderOptions();
      const t = this.renderOptions_.size;
      this.hitDetectionCanvas_ = null, this.size_ = [t, t];
    }
    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     * @param {CanvasRenderingContext2D} context The rendering context.
     * @param {number} pixelRatio The pixel ratio.
     */
    draw_(t, e, n) {
      if (e.scale(n, n), e.translate(t.size / 2, t.size / 2), this.createPath_(e), this.fill_) {
        let s = this.fill_.getColor();
        s === null && (s = Re), e.fillStyle = ci(s), e.fill();
      }
      t.strokeStyle && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineCap = t.lineCap, e.lineJoin = t.lineJoin, e.miterLimit = t.miterLimit, e.stroke());
    }
    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     * @return {HTMLCanvasElement} Canvas containing the icon
     */
    createHitDetectionCanvas_(t) {
      let e;
      if (this.fill_) {
        let n = this.fill_.getColor(), s = 0;
        typeof n == "string" && (n = Os(n)), n === null ? s = 1 : Array.isArray(n) && (s = n.length === 4 ? n[3] : 1), s === 0 && (e = Xt(t.size, t.size), this.drawHitDetectionCanvas_(t, e));
      }
      return e ? e.canvas : this.getImage(1);
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context The context to draw in.
     */
    createPath_(t) {
      let e = this.points_;
      const n = this.radius;
      if (e === 1 / 0)
        t.arc(0, 0, n, 0, 2 * Math.PI);
      else {
        const s = this.radius2_ === void 0 ? n : this.radius2_;
        this.radius2_ !== void 0 && (e *= 2);
        const r = this.angle_ - Math.PI / 2, a = 2 * Math.PI / e;
        for (let o = 0; o < e; o++) {
          const l = r + o * a, h = o % 2 === 0 ? n : s;
          t.lineTo(h * Math.cos(l), h * Math.sin(l));
        }
        t.closePath();
      }
    }
    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     * @param {CanvasRenderingContext2D} context The context.
     */
    drawHitDetectionCanvas_(t, e) {
      e.translate(t.size / 2, t.size / 2), this.createPath_(e), e.fillStyle = Re, e.fill(), t.strokeStyle && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineJoin = t.lineJoin, e.miterLimit = t.miterLimit, e.stroke());
    }
    /**
     * @override
     */
    ready() {
      return this.fill_ ? this.fill_.ready() : Promise.resolve();
    }
  }
  class Gn extends Xr {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      t = t || { radius: 5 }, super({
        points: 1 / 0,
        fill: t.fill,
        radius: t.radius,
        stroke: t.stroke,
        scale: t.scale !== void 0 ? t.scale : 1,
        rotation: t.rotation !== void 0 ? t.rotation : 0,
        rotateWithView: t.rotateWithView !== void 0 ? t.rotateWithView : !1,
        displacement: t.displacement !== void 0 ? t.displacement : [0, 0],
        declutterMode: t.declutterMode
      });
    }
    /**
     * Clones the style.
     * @return {CircleStyle} The cloned style.
     * @api
     * @override
     */
    clone() {
      const t = this.getScale(), e = new Gn({
        fill: this.getFill() ? this.getFill().clone() : void 0,
        stroke: this.getStroke() ? this.getStroke().clone() : void 0,
        radius: this.getRadius(),
        scale: Array.isArray(t) ? t.slice() : t,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
      return e.setOpacity(this.getOpacity()), e;
    }
    /**
     * Set the circle radius.
     *
     * @param {number} radius Circle radius.
     * @api
     */
    setRadius(t) {
      this.radius = t, this.render();
    }
  }
  class ti {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      t = t || {}, this.patternImage_ = null, this.color_ = null, t.color !== void 0 && this.setColor(t.color);
    }
    /**
     * Clones the style. The color is not cloned if it is a {@link module:ol/colorlike~ColorLike}.
     * @return {Fill} The cloned style.
     * @api
     */
    clone() {
      const t = this.getColor();
      return new ti({
        color: Array.isArray(t) ? t.slice() : t || void 0
      });
    }
    /**
     * Get the fill color.
     * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} Color.
     * @api
     */
    getColor() {
      return this.color_;
    }
    /**
     * Set the color.
     *
     * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} color Color.
     * @api
     */
    setColor(t) {
      if (t !== null && typeof t == "object" && "src" in t) {
        const e = Xh(
          null,
          t.src,
          "anonymous",
          void 0,
          t.offset ? null : t.color ? t.color : null,
          !(t.offset && t.size)
        );
        e.ready().then(() => {
          this.patternImage_ = null;
        }), e.getImageState() === mt.IDLE && e.load(), e.getImageState() === mt.LOADING && (this.patternImage_ = e);
      }
      this.color_ = t;
    }
    /**
     * @return {string} Key of the fill for cache lookup.
     */
    getKey() {
      const t = this.getColor();
      return t ? t instanceof CanvasPattern || t instanceof CanvasGradient ? St(t) : typeof t == "object" && "src" in t ? t.src + ":" + t.offset : Os(t).toString() : "";
    }
    /**
     * @return {boolean} The fill style is loading an image pattern.
     */
    loading() {
      return !!this.patternImage_;
    }
    /**
     * @return {Promise<void>} `false` or a promise that resolves when the style is ready to use.
     */
    ready() {
      return this.patternImage_ ? this.patternImage_.ready() : Promise.resolve();
    }
  }
  class Ne {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      t = t || {}, this.color_ = t.color !== void 0 ? t.color : null, this.lineCap_ = t.lineCap, this.lineDash_ = t.lineDash !== void 0 ? t.lineDash : null, this.lineDashOffset_ = t.lineDashOffset, this.lineJoin_ = t.lineJoin, this.miterLimit_ = t.miterLimit, this.width_ = t.width;
    }
    /**
     * Clones the style.
     * @return {Stroke} The cloned style.
     * @api
     */
    clone() {
      const t = this.getColor();
      return new Ne({
        color: Array.isArray(t) ? t.slice() : t || void 0,
        lineCap: this.getLineCap(),
        lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
        lineDashOffset: this.getLineDashOffset(),
        lineJoin: this.getLineJoin(),
        miterLimit: this.getMiterLimit(),
        width: this.getWidth()
      });
    }
    /**
     * Get the stroke color.
     * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
     * @api
     */
    getColor() {
      return this.color_;
    }
    /**
     * Get the line cap type for the stroke.
     * @return {CanvasLineCap|undefined} Line cap.
     * @api
     */
    getLineCap() {
      return this.lineCap_;
    }
    /**
     * Get the line dash style for the stroke.
     * @return {Array<number>|null} Line dash.
     * @api
     */
    getLineDash() {
      return this.lineDash_;
    }
    /**
     * Get the line dash offset for the stroke.
     * @return {number|undefined} Line dash offset.
     * @api
     */
    getLineDashOffset() {
      return this.lineDashOffset_;
    }
    /**
     * Get the line join type for the stroke.
     * @return {CanvasLineJoin|undefined} Line join.
     * @api
     */
    getLineJoin() {
      return this.lineJoin_;
    }
    /**
     * Get the miter limit for the stroke.
     * @return {number|undefined} Miter limit.
     * @api
     */
    getMiterLimit() {
      return this.miterLimit_;
    }
    /**
     * Get the stroke width.
     * @return {number|undefined} Width.
     * @api
     */
    getWidth() {
      return this.width_;
    }
    /**
     * Set the color.
     *
     * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
     * @api
     */
    setColor(t) {
      this.color_ = t;
    }
    /**
     * Set the line cap.
     *
     * @param {CanvasLineCap|undefined} lineCap Line cap.
     * @api
     */
    setLineCap(t) {
      this.lineCap_ = t;
    }
    /**
     * Set the line dash.
     *
     * @param {Array<number>|null} lineDash Line dash.
     * @api
     */
    setLineDash(t) {
      this.lineDash_ = t;
    }
    /**
     * Set the line dash offset.
     *
     * @param {number|undefined} lineDashOffset Line dash offset.
     * @api
     */
    setLineDashOffset(t) {
      this.lineDashOffset_ = t;
    }
    /**
     * Set the line join.
     *
     * @param {CanvasLineJoin|undefined} lineJoin Line join.
     * @api
     */
    setLineJoin(t) {
      this.lineJoin_ = t;
    }
    /**
     * Set the miter limit.
     *
     * @param {number|undefined} miterLimit Miter limit.
     * @api
     */
    setMiterLimit(t) {
      this.miterLimit_ = t;
    }
    /**
     * Set the width.
     *
     * @param {number|undefined} width Width.
     * @api
     */
    setWidth(t) {
      this.width_ = t;
    }
  }
  class oe {
    /**
     * @param {Options} [options] Style options.
     */
    constructor(t) {
      t = t || {}, this.geometry_ = null, this.geometryFunction_ = uu, t.geometry !== void 0 && this.setGeometry(t.geometry), this.fill_ = t.fill !== void 0 ? t.fill : null, this.image_ = t.image !== void 0 ? t.image : null, this.renderer_ = t.renderer !== void 0 ? t.renderer : null, this.hitDetectionRenderer_ = t.hitDetectionRenderer !== void 0 ? t.hitDetectionRenderer : null, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.text_ = t.text !== void 0 ? t.text : null, this.zIndex_ = t.zIndex;
    }
    /**
     * Clones the style.
     * @return {Style} The cloned style.
     * @api
     */
    clone() {
      let t = this.getGeometry();
      return t && typeof t == "object" && (t = /** @type {import("../geom/Geometry.js").default} */
      t.clone()), new oe({
        geometry: t ?? void 0,
        fill: this.getFill() ? this.getFill().clone() : void 0,
        image: this.getImage() ? this.getImage().clone() : void 0,
        renderer: this.getRenderer() ?? void 0,
        stroke: this.getStroke() ? this.getStroke().clone() : void 0,
        text: this.getText() ? this.getText().clone() : void 0,
        zIndex: this.getZIndex()
      });
    }
    /**
     * Get the custom renderer function that was configured with
     * {@link #setRenderer} or the `renderer` constructor option.
     * @return {RenderFunction|null} Custom renderer function.
     * @api
     */
    getRenderer() {
      return this.renderer_;
    }
    /**
     * Sets a custom renderer function for this style. When set, `fill`, `stroke`
     * and `image` options of the style will be ignored.
     * @param {RenderFunction|null} renderer Custom renderer function.
     * @api
     */
    setRenderer(t) {
      this.renderer_ = t;
    }
    /**
     * Sets a custom renderer function for this style used
     * in hit detection.
     * @param {RenderFunction|null} renderer Custom renderer function.
     * @api
     */
    setHitDetectionRenderer(t) {
      this.hitDetectionRenderer_ = t;
    }
    /**
     * Get the custom renderer function that was configured with
     * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
     * @return {RenderFunction|null} Custom renderer function.
     * @api
     */
    getHitDetectionRenderer() {
      return this.hitDetectionRenderer_;
    }
    /**
     * Get the geometry to be rendered.
     * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
     * Feature property or geometry or function that returns the geometry that will
     * be rendered with this style.
     * @api
     */
    getGeometry() {
      return this.geometry_;
    }
    /**
     * Get the function used to generate a geometry for rendering.
     * @return {!GeometryFunction} Function that is called with a feature
     * and returns the geometry to render instead of the feature's geometry.
     * @api
     */
    getGeometryFunction() {
      return this.geometryFunction_;
    }
    /**
     * Get the fill style.
     * @return {import("./Fill.js").default|null} Fill style.
     * @api
     */
    getFill() {
      return this.fill_;
    }
    /**
     * Set the fill style.
     * @param {import("./Fill.js").default|null} fill Fill style.
     * @api
     */
    setFill(t) {
      this.fill_ = t;
    }
    /**
     * Get the image style.
     * @return {import("./Image.js").default|null} Image style.
     * @api
     */
    getImage() {
      return this.image_;
    }
    /**
     * Set the image style.
     * @param {import("./Image.js").default} image Image style.
     * @api
     */
    setImage(t) {
      this.image_ = t;
    }
    /**
     * Get the stroke style.
     * @return {import("./Stroke.js").default|null} Stroke style.
     * @api
     */
    getStroke() {
      return this.stroke_;
    }
    /**
     * Set the stroke style.
     * @param {import("./Stroke.js").default|null} stroke Stroke style.
     * @api
     */
    setStroke(t) {
      this.stroke_ = t;
    }
    /**
     * Get the text style.
     * @return {import("./Text.js").default|null} Text style.
     * @api
     */
    getText() {
      return this.text_;
    }
    /**
     * Set the text style.
     * @param {import("./Text.js").default} text Text style.
     * @api
     */
    setText(t) {
      this.text_ = t;
    }
    /**
     * Get the z-index for the style.
     * @return {number|undefined} ZIndex.
     * @api
     */
    getZIndex() {
      return this.zIndex_;
    }
    /**
     * Set a geometry that is rendered instead of the feature's geometry.
     *
     * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
     *     Feature property or geometry or function returning a geometry to render
     *     for this style.
     * @api
     */
    setGeometry(t) {
      typeof t == "function" ? this.geometryFunction_ = t : typeof t == "string" ? this.geometryFunction_ = function(e) {
        return (
          /** @type {import("../geom/Geometry.js").default} */
          e.get(t)
        );
      } : t ? t !== void 0 && (this.geometryFunction_ = function() {
        return (
          /** @type {import("../geom/Geometry.js").default} */
          t
        );
      }) : this.geometryFunction_ = uu, this.geometry_ = t;
    }
    /**
     * Set the z-index.
     *
     * @param {number|undefined} zIndex ZIndex.
     * @api
     */
    setZIndex(t) {
      this.zIndex_ = t;
    }
  }
  function O_(i) {
    let t;
    if (typeof i == "function")
      t = i;
    else {
      let e;
      Array.isArray(i) ? e = i : (Mt(
        typeof /** @type {?} */
        i.getZIndex == "function",
        "Expected an `Style` or an array of `Style`"
      ), e = [
        /** @type {Style} */
        i
      ]), t = function() {
        return e;
      };
    }
    return t;
  }
  let ll = null;
  function nf(i, t) {
    if (!ll) {
      const e = new ti({
        color: "rgba(255,255,255,0.4)"
      }), n = new Ne({
        color: "#3399CC",
        width: 1.25
      });
      ll = [
        new oe({
          image: new Gn({
            fill: e,
            stroke: n,
            radius: 5
          }),
          fill: e,
          stroke: n
        })
      ];
    }
    return ll;
  }
  function uu(i) {
    return i.getGeometry();
  }
  function du(i, t, e, n) {
    return e !== void 0 && n !== void 0 ? [e / i, n / t] : e !== void 0 ? e / i : n !== void 0 ? n / t : 1;
  }
  class Wr extends $r {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      t = t || {};
      const e = t.opacity !== void 0 ? t.opacity : 1, n = t.rotation !== void 0 ? t.rotation : 0, s = t.scale !== void 0 ? t.scale : 1, r = t.rotateWithView !== void 0 ? t.rotateWithView : !1;
      super({
        opacity: e,
        rotation: n,
        scale: s,
        displacement: t.displacement !== void 0 ? t.displacement : [0, 0],
        rotateWithView: r,
        declutterMode: t.declutterMode
      }), this.anchor_ = t.anchor !== void 0 ? t.anchor : [0.5, 0.5], this.normalizedAnchor_ = null, this.anchorOrigin_ = t.anchorOrigin !== void 0 ? t.anchorOrigin : "top-left", this.anchorXUnits_ = t.anchorXUnits !== void 0 ? t.anchorXUnits : "fraction", this.anchorYUnits_ = t.anchorYUnits !== void 0 ? t.anchorYUnits : "fraction", this.crossOrigin_ = t.crossOrigin !== void 0 ? t.crossOrigin : null;
      const a = t.img !== void 0 ? t.img : null;
      let o = t.src;
      Mt(
        !(o !== void 0 && a),
        "`image` and `src` cannot be provided at the same time"
      ), (o === void 0 || o.length === 0) && a && (o = /** @type {HTMLImageElement} */
      a.src || St(a)), Mt(
        o !== void 0 && o.length > 0,
        "A defined and non-empty `src` or `image` must be provided"
      ), Mt(
        !((t.width !== void 0 || t.height !== void 0) && t.scale !== void 0),
        "`width` or `height` cannot be provided together with `scale`"
      );
      let l;
      if (t.src !== void 0 ? l = mt.IDLE : a !== void 0 && ("complete" in a ? a.complete ? l = a.src ? mt.LOADED : mt.IDLE : l = mt.LOADING : l = mt.LOADED), this.color_ = t.color !== void 0 ? Os(t.color) : null, this.iconImage_ = Xh(
        a,
        /** @type {string} */
        o,
        this.crossOrigin_,
        l,
        this.color_
      ), this.offset_ = t.offset !== void 0 ? t.offset : [0, 0], this.offsetOrigin_ = t.offsetOrigin !== void 0 ? t.offsetOrigin : "top-left", this.origin_ = null, this.size_ = t.size !== void 0 ? t.size : null, this.initialOptions_, t.width !== void 0 || t.height !== void 0) {
        let h, c;
        if (t.size)
          [h, c] = t.size;
        else {
          const u = this.getImage(1);
          if (u.width && u.height)
            h = u.width, c = u.height;
          else if (u instanceof HTMLImageElement) {
            this.initialOptions_ = t;
            const d = () => {
              if (this.unlistenImageChange(d), !this.initialOptions_)
                return;
              const m = this.iconImage_.getSize();
              this.setScale(
                du(
                  m[0],
                  m[1],
                  t.width,
                  t.height
                )
              );
            };
            this.listenImageChange(d);
            return;
          }
        }
        h !== void 0 && this.setScale(
          du(h, c, t.width, t.height)
        );
      }
    }
    /**
     * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
     * @return {Icon} The cloned style.
     * @api
     * @override
     */
    clone() {
      let t, e, n;
      return this.initialOptions_ ? (e = this.initialOptions_.width, n = this.initialOptions_.height) : (t = this.getScale(), t = Array.isArray(t) ? t.slice() : t), new Wr({
        anchor: this.anchor_.slice(),
        anchorOrigin: this.anchorOrigin_,
        anchorXUnits: this.anchorXUnits_,
        anchorYUnits: this.anchorYUnits_,
        color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
        crossOrigin: this.crossOrigin_,
        offset: this.offset_.slice(),
        offsetOrigin: this.offsetOrigin_,
        opacity: this.getOpacity(),
        rotateWithView: this.getRotateWithView(),
        rotation: this.getRotation(),
        scale: t,
        width: e,
        height: n,
        size: this.size_ !== null ? this.size_.slice() : void 0,
        src: this.getSrc(),
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
    }
    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @return {Array<number>} Anchor.
     * @api
     * @override
     */
    getAnchor() {
      let t = this.normalizedAnchor_;
      if (!t) {
        t = this.anchor_;
        const s = this.getSize();
        if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
          if (!s)
            return null;
          t = this.anchor_.slice(), this.anchorXUnits_ == "fraction" && (t[0] *= s[0]), this.anchorYUnits_ == "fraction" && (t[1] *= s[1]);
        }
        if (this.anchorOrigin_ != "top-left") {
          if (!s)
            return null;
          t === this.anchor_ && (t = this.anchor_.slice()), (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") && (t[0] = -t[0] + s[0]), (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") && (t[1] = -t[1] + s[1]);
        }
        this.normalizedAnchor_ = t;
      }
      const e = this.getDisplacement(), n = this.getScaleArray();
      return [
        t[0] - e[0] / n[0],
        t[1] + e[1] / n[1]
      ];
    }
    /**
     * Set the anchor point. The anchor determines the center point for the
     * symbolizer.
     *
     * @param {Array<number>} anchor Anchor.
     * @api
     */
    setAnchor(t) {
      this.anchor_ = t, this.normalizedAnchor_ = null;
    }
    /**
     * Get the icon color.
     * @return {import("../color.js").Color} Color.
     * @api
     */
    getColor() {
      return this.color_;
    }
    /**
     * Get the image icon.
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element. If the Icon
     * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
     * @api
     * @override
     */
    getImage(t) {
      return this.iconImage_.getImage(t);
    }
    /**
     * Get the pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} The pixel ratio of the image.
     * @api
     * @override
     */
    getPixelRatio(t) {
      return this.iconImage_.getPixelRatio(t);
    }
    /**
     * @return {import("../size.js").Size} Image size.
     * @override
     */
    getImageSize() {
      return this.iconImage_.getSize();
    }
    /**
     * @return {import("../ImageState.js").default} Image state.
     * @override
     */
    getImageState() {
      return this.iconImage_.getImageState();
    }
    /**
     * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
     * @override
     */
    getHitDetectionImage() {
      return this.iconImage_.getHitDetectionImage();
    }
    /**
     * Get the origin of the symbolizer.
     * @return {Array<number>} Origin.
     * @api
     * @override
     */
    getOrigin() {
      if (this.origin_)
        return this.origin_;
      let t = this.offset_;
      if (this.offsetOrigin_ != "top-left") {
        const e = this.getSize(), n = this.iconImage_.getSize();
        if (!e || !n)
          return null;
        t = t.slice(), (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") && (t[0] = n[0] - e[0] - t[0]), (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") && (t[1] = n[1] - e[1] - t[1]);
      }
      return this.origin_ = t, this.origin_;
    }
    /**
     * Get the image URL.
     * @return {string|undefined} Image src.
     * @api
     */
    getSrc() {
      return this.iconImage_.getSrc();
    }
    /**
     * Get the size of the icon (in pixels).
     * @return {import("../size.js").Size} Image size.
     * @api
     * @override
     */
    getSize() {
      return this.size_ ? this.size_ : this.iconImage_.getSize();
    }
    /**
     * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
     * @return {number} Icon width (in pixels).
     * @api
     */
    getWidth() {
      const t = this.getScaleArray();
      if (this.size_)
        return this.size_[0] * t[0];
      if (this.iconImage_.getImageState() == mt.LOADED)
        return this.iconImage_.getSize()[0] * t[0];
    }
    /**
     * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
     * @return {number} Icon height (in pixels).
     * @api
     */
    getHeight() {
      const t = this.getScaleArray();
      if (this.size_)
        return this.size_[1] * t[1];
      if (this.iconImage_.getImageState() == mt.LOADED)
        return this.iconImage_.getSize()[1] * t[1];
    }
    /**
     * Set the scale.
     *
     * @param {number|import("../size.js").Size} scale Scale.
     * @api
     * @override
     */
    setScale(t) {
      delete this.initialOptions_, super.setScale(t);
    }
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     * @override
     */
    listenImageChange(t) {
      this.iconImage_.addEventListener(ht.CHANGE, t);
    }
    /**
     * Load not yet loaded URI.
     * When rendering a feature with an icon style, the vector renderer will
     * automatically call this method. However, you might want to call this
     * method yourself for preloading or other purposes.
     * @api
     * @override
     */
    load() {
      this.iconImage_.load();
    }
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     * @override
     */
    unlistenImageChange(t) {
      this.iconImage_.removeEventListener(ht.CHANGE, t);
    }
    /**
     * @override
     */
    ready() {
      return this.iconImage_.ready();
    }
  }
  const N_ = "#333";
  class Po {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      t = t || {}, this.font_ = t.font, this.rotation_ = t.rotation, this.rotateWithView_ = t.rotateWithView, this.keepUpright_ = t.keepUpright, this.scale_ = t.scale, this.scaleArray_ = Ie(t.scale !== void 0 ? t.scale : 1), this.text_ = t.text, this.textAlign_ = t.textAlign, this.justify_ = t.justify, this.repeat_ = t.repeat, this.textBaseline_ = t.textBaseline, this.fill_ = t.fill !== void 0 ? t.fill : new ti({ color: N_ }), this.maxAngle_ = t.maxAngle !== void 0 ? t.maxAngle : Math.PI / 4, this.placement_ = t.placement !== void 0 ? t.placement : "point", this.overflow_ = !!t.overflow, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.offsetX_ = t.offsetX !== void 0 ? t.offsetX : 0, this.offsetY_ = t.offsetY !== void 0 ? t.offsetY : 0, this.backgroundFill_ = t.backgroundFill ? t.backgroundFill : null, this.backgroundStroke_ = t.backgroundStroke ? t.backgroundStroke : null, this.padding_ = t.padding === void 0 ? null : t.padding, this.declutterMode_ = t.declutterMode;
    }
    /**
     * Clones the style.
     * @return {Text} The cloned style.
     * @api
     */
    clone() {
      const t = this.getScale();
      return new Po({
        font: this.getFont(),
        placement: this.getPlacement(),
        repeat: this.getRepeat(),
        maxAngle: this.getMaxAngle(),
        overflow: this.getOverflow(),
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        keepUpright: this.getKeepUpright(),
        scale: Array.isArray(t) ? t.slice() : t,
        text: this.getText(),
        textAlign: this.getTextAlign(),
        justify: this.getJustify(),
        textBaseline: this.getTextBaseline(),
        fill: this.getFill() ? this.getFill().clone() : void 0,
        stroke: this.getStroke() ? this.getStroke().clone() : void 0,
        offsetX: this.getOffsetX(),
        offsetY: this.getOffsetY(),
        backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
        backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
        padding: this.getPadding() || void 0,
        declutterMode: this.getDeclutterMode()
      });
    }
    /**
     * Get the `overflow` configuration.
     * @return {boolean} Let text overflow the length of the path they follow.
     * @api
     */
    getOverflow() {
      return this.overflow_;
    }
    /**
     * Get the font name.
     * @return {string|undefined} Font.
     * @api
     */
    getFont() {
      return this.font_;
    }
    /**
     * Get the maximum angle between adjacent characters.
     * @return {number} Angle in radians.
     * @api
     */
    getMaxAngle() {
      return this.maxAngle_;
    }
    /**
     * Get the label placement.
     * @return {TextPlacement} Text placement.
     * @api
     */
    getPlacement() {
      return this.placement_;
    }
    /**
     * Get the repeat interval of the text.
     * @return {number|undefined} Repeat interval in pixels.
     * @api
     */
    getRepeat() {
      return this.repeat_;
    }
    /**
     * Get the x-offset for the text.
     * @return {number} Horizontal text offset.
     * @api
     */
    getOffsetX() {
      return this.offsetX_;
    }
    /**
     * Get the y-offset for the text.
     * @return {number} Vertical text offset.
     * @api
     */
    getOffsetY() {
      return this.offsetY_;
    }
    /**
     * Get the fill style for the text.
     * @return {import("./Fill.js").default|null} Fill style.
     * @api
     */
    getFill() {
      return this.fill_;
    }
    /**
     * Determine whether the text rotates with the map.
     * @return {boolean|undefined} Rotate with map.
     * @api
     */
    getRotateWithView() {
      return this.rotateWithView_;
    }
    /**
     * Determine whether the text can be rendered upside down.
     * @return {boolean|undefined} Keep text upright.
     * @api
     */
    getKeepUpright() {
      return this.keepUpright_;
    }
    /**
     * Get the text rotation.
     * @return {number|undefined} Rotation.
     * @api
     */
    getRotation() {
      return this.rotation_;
    }
    /**
     * Get the text scale.
     * @return {number|import("../size.js").Size|undefined} Scale.
     * @api
     */
    getScale() {
      return this.scale_;
    }
    /**
     * Get the symbolizer scale array.
     * @return {import("../size.js").Size} Scale array.
     */
    getScaleArray() {
      return this.scaleArray_;
    }
    /**
     * Get the stroke style for the text.
     * @return {import("./Stroke.js").default|null} Stroke style.
     * @api
     */
    getStroke() {
      return this.stroke_;
    }
    /**
     * Get the text to be rendered.
     * @return {string|Array<string>|undefined} Text.
     * @api
     */
    getText() {
      return this.text_;
    }
    /**
     * Get the text alignment.
     * @return {CanvasTextAlign|undefined} Text align.
     * @api
     */
    getTextAlign() {
      return this.textAlign_;
    }
    /**
     * Get the justification.
     * @return {TextJustify|undefined} Justification.
     * @api
     */
    getJustify() {
      return this.justify_;
    }
    /**
     * Get the text baseline.
     * @return {CanvasTextBaseline|undefined} Text baseline.
     * @api
     */
    getTextBaseline() {
      return this.textBaseline_;
    }
    /**
     * Get the background fill style for the text.
     * @return {import("./Fill.js").default|null} Fill style.
     * @api
     */
    getBackgroundFill() {
      return this.backgroundFill_;
    }
    /**
     * Get the background stroke style for the text.
     * @return {import("./Stroke.js").default|null} Stroke style.
     * @api
     */
    getBackgroundStroke() {
      return this.backgroundStroke_;
    }
    /**
     * Get the padding for the text.
     * @return {Array<number>|null} Padding.
     * @api
     */
    getPadding() {
      return this.padding_;
    }
    /**
     * Get the declutter mode of the shape
     * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
     * @api
     */
    getDeclutterMode() {
      return this.declutterMode_;
    }
    /**
     * Set the `overflow` property.
     *
     * @param {boolean} overflow Let text overflow the path that it follows.
     * @api
     */
    setOverflow(t) {
      this.overflow_ = t;
    }
    /**
     * Set the font.
     *
     * @param {string|undefined} font Font.
     * @api
     */
    setFont(t) {
      this.font_ = t;
    }
    /**
     * Set the maximum angle between adjacent characters.
     *
     * @param {number} maxAngle Angle in radians.
     * @api
     */
    setMaxAngle(t) {
      this.maxAngle_ = t;
    }
    /**
     * Set the x offset.
     *
     * @param {number} offsetX Horizontal text offset.
     * @api
     */
    setOffsetX(t) {
      this.offsetX_ = t;
    }
    /**
     * Set the y offset.
     *
     * @param {number} offsetY Vertical text offset.
     * @api
     */
    setOffsetY(t) {
      this.offsetY_ = t;
    }
    /**
     * Set the text placement.
     *
     * @param {TextPlacement} placement Placement.
     * @api
     */
    setPlacement(t) {
      this.placement_ = t;
    }
    /**
     * Set the repeat interval of the text.
     * @param {number|undefined} [repeat] Repeat interval in pixels.
     * @api
     */
    setRepeat(t) {
      this.repeat_ = t;
    }
    /**
     * Set whether to rotate the text with the view.
     *
     * @param {boolean} rotateWithView Rotate with map.
     * @api
     */
    setRotateWithView(t) {
      this.rotateWithView_ = t;
    }
    /**
     * Set whether the text can be rendered upside down.
     *
     * @param {boolean} keepUpright Keep text upright.
     * @api
     */
    setKeepUpright(t) {
      this.keepUpright_ = t;
    }
    /**
     * Set the fill.
     *
     * @param {import("./Fill.js").default|null} fill Fill style.
     * @api
     */
    setFill(t) {
      this.fill_ = t;
    }
    /**
     * Set the rotation.
     *
     * @param {number|undefined} rotation Rotation.
     * @api
     */
    setRotation(t) {
      this.rotation_ = t;
    }
    /**
     * Set the scale.
     *
     * @param {number|import("../size.js").Size|undefined} scale Scale.
     * @api
     */
    setScale(t) {
      this.scale_ = t, this.scaleArray_ = Ie(t !== void 0 ? t : 1);
    }
    /**
     * Set the stroke.
     *
     * @param {import("./Stroke.js").default|null} stroke Stroke style.
     * @api
     */
    setStroke(t) {
      this.stroke_ = t;
    }
    /**
     * Set the text.
     *
     * @param {string|Array<string>|undefined} text Text.
     * @api
     */
    setText(t) {
      this.text_ = t;
    }
    /**
     * Set the text alignment.
     *
     * @param {CanvasTextAlign|undefined} textAlign Text align.
     * @api
     */
    setTextAlign(t) {
      this.textAlign_ = t;
    }
    /**
     * Set the justification.
     *
     * @param {TextJustify|undefined} justify Justification.
     * @api
     */
    setJustify(t) {
      this.justify_ = t;
    }
    /**
     * Set the text baseline.
     *
     * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
     * @api
     */
    setTextBaseline(t) {
      this.textBaseline_ = t;
    }
    /**
     * Set the background fill.
     *
     * @param {import("./Fill.js").default|null} fill Fill style.
     * @api
     */
    setBackgroundFill(t) {
      this.backgroundFill_ = t;
    }
    /**
     * Set the background stroke.
     *
     * @param {import("./Stroke.js").default|null} stroke Stroke style.
     * @api
     */
    setBackgroundStroke(t) {
      this.backgroundStroke_ = t;
    }
    /**
     * Set the padding (`[top, right, bottom, left]`).
     *
     * @param {Array<number>|null} padding Padding.
     * @api
     */
    setPadding(t) {
      this.padding_ = t;
    }
  }
  let $n = 0;
  const me = 1 << $n++, Et = 1 << $n++, Se = 1 << $n++, ei = 1 << $n++, Un = 1 << $n++, ir = 1 << $n++, Ea = Math.pow(2, $n) - 1, Yh = {
    [me]: "boolean",
    [Et]: "number",
    [Se]: "string",
    [ei]: "color",
    [Un]: "number[]",
    [ir]: "size"
  }, F_ = Object.keys(Yh).map(Number).sort(rn);
  function D_(i) {
    return i in Yh;
  }
  function nr(i) {
    const t = [];
    for (const e of F_)
      sr(i, e) && t.push(Yh[e]);
    return t.length === 0 ? "untyped" : t.length < 3 ? t.join(" or ") : t.slice(0, -1).join(", ") + ", or " + t[t.length - 1];
  }
  function sr(i, t) {
    return (i & t) === t;
  }
  function Yi(i, t) {
    return i === t;
  }
  class Wt {
    /**
     * @param {number} type The value type.
     * @param {LiteralValue} value The literal value.
     */
    constructor(t, e) {
      if (!D_(t))
        throw new Error(
          `literal expressions must have a specific type, got ${nr(t)}`
        );
      this.type = t, this.value = e;
    }
  }
  class k_ {
    /**
     * @param {number} type The return type.
     * @param {string} operator The operator.
     * @param {...Expression} args The arguments.
     */
    constructor(t, e, ...n) {
      this.type = t, this.operator = e, this.args = n;
    }
  }
  function sf() {
    return {
      variables: /* @__PURE__ */ new Set(),
      properties: /* @__PURE__ */ new Set(),
      featureId: !1,
      geometryType: !1
    };
  }
  function ie(i, t, e) {
    switch (typeof i) {
      case "boolean": {
        if (Yi(t, Se))
          return new Wt(Se, i ? "true" : "false");
        if (!sr(t, me))
          throw new Error(
            `got a boolean, but expected ${nr(t)}`
          );
        return new Wt(me, i);
      }
      case "number": {
        if (Yi(t, ir))
          return new Wt(ir, Ie(i));
        if (Yi(t, me))
          return new Wt(me, !!i);
        if (Yi(t, Se))
          return new Wt(Se, i.toString());
        if (!sr(t, Et))
          throw new Error(`got a number, but expected ${nr(t)}`);
        return new Wt(Et, i);
      }
      case "string": {
        if (Yi(t, ei))
          return new Wt(ei, kh(i));
        if (Yi(t, me))
          return new Wt(me, !!i);
        if (!sr(t, Se))
          throw new Error(`got a string, but expected ${nr(t)}`);
        return new Wt(Se, i);
      }
    }
    if (!Array.isArray(i))
      throw new Error("expression must be an array or a primitive value");
    if (i.length === 0)
      throw new Error("empty expression");
    if (typeof i[0] == "string")
      return K_(i, t, e);
    for (const n of i)
      if (typeof n != "number")
        throw new Error("expected an array of numbers");
    if (Yi(t, ir)) {
      if (i.length !== 2)
        throw new Error(
          `expected an array of two values for a size, got ${i.length}`
        );
      return new Wt(ir, i);
    }
    if (Yi(t, ei)) {
      if (i.length === 3)
        return new Wt(ei, [...i, 1]);
      if (i.length === 4)
        return new Wt(ei, i);
      throw new Error(
        `expected an array of 3 or 4 values for a color, got ${i.length}`
      );
    }
    if (!sr(t, Un))
      throw new Error(
        `got an array of numbers, but expected ${nr(t)}`
      );
    return new Wt(Un, i);
  }
  const b = {
    Get: "get",
    Var: "var",
    Concat: "concat",
    GeometryType: "geometry-type",
    LineMetric: "line-metric",
    Any: "any",
    All: "all",
    Not: "!",
    Resolution: "resolution",
    Zoom: "zoom",
    Time: "time",
    Equal: "==",
    NotEqual: "!=",
    GreaterThan: ">",
    GreaterThanOrEqualTo: ">=",
    LessThan: "<",
    LessThanOrEqualTo: "<=",
    Multiply: "*",
    Divide: "/",
    Add: "+",
    Subtract: "-",
    Clamp: "clamp",
    Mod: "%",
    Pow: "^",
    Abs: "abs",
    Floor: "floor",
    Ceil: "ceil",
    Round: "round",
    Sin: "sin",
    Cos: "cos",
    Atan: "atan",
    Sqrt: "sqrt",
    Match: "match",
    Between: "between",
    Interpolate: "interpolate",
    Coalesce: "coalesce",
    Case: "case",
    In: "in",
    Number: "number",
    String: "string",
    Array: "array",
    Color: "color",
    Id: "id",
    Band: "band",
    Palette: "palette",
    ToString: "to-string",
    Has: "has"
  }, G_ = {
    [b.Get]: rt(dt(1, 1 / 0), fu),
    [b.Var]: rt(dt(1, 1), U_),
    [b.Has]: rt(dt(1, 1 / 0), fu),
    [b.Id]: rt(z_, Jn),
    [b.Concat]: rt(
      dt(2, 1 / 0),
      Rt(Se)
    ),
    [b.GeometryType]: rt(B_, Jn),
    [b.LineMetric]: rt(Jn),
    [b.Resolution]: rt(Jn),
    [b.Zoom]: rt(Jn),
    [b.Time]: rt(Jn),
    [b.Any]: rt(
      dt(2, 1 / 0),
      Rt(me)
    ),
    [b.All]: rt(
      dt(2, 1 / 0),
      Rt(me)
    ),
    [b.Not]: rt(
      dt(1, 1),
      Rt(me)
    ),
    [b.Equal]: rt(
      dt(2, 2),
      Rt(Ea)
    ),
    [b.NotEqual]: rt(
      dt(2, 2),
      Rt(Ea)
    ),
    [b.GreaterThan]: rt(
      dt(2, 2),
      Rt(Et)
    ),
    [b.GreaterThanOrEqualTo]: rt(
      dt(2, 2),
      Rt(Et)
    ),
    [b.LessThan]: rt(
      dt(2, 2),
      Rt(Et)
    ),
    [b.LessThanOrEqualTo]: rt(
      dt(2, 2),
      Rt(Et)
    ),
    [b.Multiply]: rt(
      dt(2, 1 / 0),
      gu
    ),
    [b.Coalesce]: rt(
      dt(2, 1 / 0),
      gu
    ),
    [b.Divide]: rt(
      dt(2, 2),
      Rt(Et)
    ),
    [b.Add]: rt(
      dt(2, 1 / 0),
      Rt(Et)
    ),
    [b.Subtract]: rt(
      dt(2, 2),
      Rt(Et)
    ),
    [b.Clamp]: rt(
      dt(3, 3),
      Rt(Et)
    ),
    [b.Mod]: rt(
      dt(2, 2),
      Rt(Et)
    ),
    [b.Pow]: rt(
      dt(2, 2),
      Rt(Et)
    ),
    [b.Abs]: rt(
      dt(1, 1),
      Rt(Et)
    ),
    [b.Floor]: rt(
      dt(1, 1),
      Rt(Et)
    ),
    [b.Ceil]: rt(
      dt(1, 1),
      Rt(Et)
    ),
    [b.Round]: rt(
      dt(1, 1),
      Rt(Et)
    ),
    [b.Sin]: rt(
      dt(1, 1),
      Rt(Et)
    ),
    [b.Cos]: rt(
      dt(1, 1),
      Rt(Et)
    ),
    [b.Atan]: rt(
      dt(1, 2),
      Rt(Et)
    ),
    [b.Sqrt]: rt(
      dt(1, 1),
      Rt(Et)
    ),
    [b.Match]: rt(
      dt(4, 1 / 0),
      mu,
      X_
    ),
    [b.Between]: rt(
      dt(3, 3),
      Rt(Et)
    ),
    [b.Interpolate]: rt(
      dt(6, 1 / 0),
      mu,
      W_
    ),
    [b.Case]: rt(
      dt(3, 1 / 0),
      $_,
      Y_
    ),
    [b.In]: rt(dt(2, 2), Z_),
    [b.Number]: rt(
      dt(1, 1 / 0),
      Rt(Ea)
    ),
    [b.String]: rt(
      dt(1, 1 / 0),
      Rt(Ea)
    ),
    [b.Array]: rt(
      dt(1, 1 / 0),
      Rt(Et)
    ),
    [b.Color]: rt(
      dt(1, 4),
      Rt(Et)
    ),
    [b.Band]: rt(
      dt(1, 3),
      Rt(Et)
    ),
    [b.Palette]: rt(
      dt(2, 2),
      q_
    ),
    [b.ToString]: rt(
      dt(1, 1),
      Rt(me | Et | Se | ei)
    )
  };
  function fu(i, t, e) {
    const n = i.length - 1, s = new Array(n);
    for (let r = 0; r < n; ++r) {
      const a = i[r + 1];
      switch (typeof a) {
        case "number": {
          s[r] = new Wt(Et, a);
          break;
        }
        case "string": {
          s[r] = new Wt(Se, a);
          break;
        }
        default:
          throw new Error(
            `expected a string key or numeric array index for a get operation, got ${a}`
          );
      }
      r === 0 && e.properties.add(String(a));
    }
    return s;
  }
  function U_(i, t, e) {
    const n = i[1];
    if (typeof n != "string")
      throw new Error("expected a string argument for var operation");
    return e.variables.add(n), [new Wt(Se, n)];
  }
  function z_(i, t, e) {
    e.featureId = !0;
  }
  function B_(i, t, e) {
    e.geometryType = !0;
  }
  function Jn(i, t, e) {
    const n = i[0];
    if (i.length !== 1)
      throw new Error(`expected no arguments for ${n} operation`);
    return [];
  }
  function dt(i, t) {
    return function(e, n, s) {
      const r = e[0], a = e.length - 1;
      if (i === t) {
        if (a !== i) {
          const o = i === 1 ? "" : "s";
          throw new Error(
            `expected ${i} argument${o} for ${r}, got ${a}`
          );
        }
      } else if (a < i || a > t) {
        const o = t === 1 / 0 ? `${i} or more` : `${i} to ${t}`;
        throw new Error(
          `expected ${o} arguments for ${r}, got ${a}`
        );
      }
    };
  }
  function gu(i, t, e) {
    const n = i.length - 1, s = new Array(n);
    for (let r = 0; r < n; ++r) {
      const a = ie(i[r + 1], t, e);
      s[r] = a;
    }
    return s;
  }
  function Rt(i) {
    return function(t, e, n) {
      const s = t.length - 1, r = new Array(s);
      for (let a = 0; a < s; ++a) {
        const o = ie(t[a + 1], i, n);
        r[a] = o;
      }
      return r;
    };
  }
  function $_(i, t, e) {
    const n = i[0], s = i.length - 1;
    if (s % 2 === 0)
      throw new Error(
        `expected an odd number of arguments for ${n}, got ${s} instead`
      );
  }
  function mu(i, t, e) {
    const n = i[0], s = i.length - 1;
    if (s % 2 === 1)
      throw new Error(
        `expected an even number of arguments for operation ${n}, got ${s} instead`
      );
  }
  function X_(i, t, e) {
    const n = i.length - 1, s = Se | Et | me, r = ie(i[1], s, e), a = ie(i[i.length - 1], t, e), o = new Array(n - 2);
    for (let l = 0; l < n - 2; l += 2) {
      try {
        const h = ie(i[l + 2], r.type, e);
        o[l] = h;
      } catch (h) {
        throw new Error(
          `failed to parse argument ${l + 1} of match expression: ${h.message}`
        );
      }
      try {
        const h = ie(i[l + 3], a.type, e);
        o[l + 1] = h;
      } catch (h) {
        throw new Error(
          `failed to parse argument ${l + 2} of match expression: ${h.message}`
        );
      }
    }
    return [r, ...o, a];
  }
  function W_(i, t, e) {
    const n = i[1];
    let s;
    switch (n[0]) {
      case "linear":
        s = 1;
        break;
      case "exponential":
        const l = n[1];
        if (typeof l != "number" || l <= 0)
          throw new Error(
            `expected a number base for exponential interpolation, got ${JSON.stringify(l)} instead`
          );
        s = l;
        break;
      default:
        throw new Error(
          `invalid interpolation type: ${JSON.stringify(n)}`
        );
    }
    const r = new Wt(Et, s);
    let a;
    try {
      a = ie(i[2], Et, e);
    } catch (l) {
      throw new Error(
        `failed to parse argument 1 in interpolate expression: ${l.message}`
      );
    }
    const o = new Array(i.length - 3);
    for (let l = 0; l < o.length; l += 2) {
      try {
        const h = ie(i[l + 3], Et, e);
        o[l] = h;
      } catch (h) {
        throw new Error(
          `failed to parse argument ${l + 2} for interpolate expression: ${h.message}`
        );
      }
      try {
        const h = ie(i[l + 4], t, e);
        o[l + 1] = h;
      } catch (h) {
        throw new Error(
          `failed to parse argument ${l + 3} for interpolate expression: ${h.message}`
        );
      }
    }
    return [r, a, ...o];
  }
  function Y_(i, t, e) {
    const n = ie(i[i.length - 1], t, e), s = new Array(i.length - 1);
    for (let r = 0; r < s.length - 1; r += 2) {
      try {
        const a = ie(i[r + 1], me, e);
        s[r] = a;
      } catch (a) {
        throw new Error(
          `failed to parse argument ${r} of case expression: ${a.message}`
        );
      }
      try {
        const a = ie(i[r + 2], n.type, e);
        s[r + 1] = a;
      } catch (a) {
        throw new Error(
          `failed to parse argument ${r + 1} of case expression: ${a.message}`
        );
      }
    }
    return s[s.length - 1] = n, s;
  }
  function Z_(i, t, e) {
    let n = i[2];
    if (!Array.isArray(n))
      throw new Error(
        'the second argument for the "in" operator must be an array'
      );
    let s;
    if (typeof n[0] == "string") {
      if (n[0] !== "literal")
        throw new Error(
          'for the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions'
        );
      if (!Array.isArray(n[1]))
        throw new Error(
          'failed to parse "in" expression: the literal operator must be followed by an array'
        );
      n = n[1], s = Se;
    } else
      s = Et;
    const r = new Array(n.length);
    for (let o = 0; o < r.length; o++)
      try {
        const l = ie(n[o], s, e);
        r[o] = l;
      } catch (l) {
        throw new Error(
          `failed to parse haystack item ${o} for "in" expression: ${l.message}`
        );
      }
    return [ie(i[1], s, e), ...r];
  }
  function q_(i, t, e) {
    let n;
    try {
      n = ie(i[1], Et, e);
    } catch (a) {
      throw new Error(
        `failed to parse first argument in palette expression: ${a.message}`
      );
    }
    const s = i[2];
    if (!Array.isArray(s))
      throw new Error("the second argument of palette must be an array");
    const r = new Array(s.length);
    for (let a = 0; a < r.length; a++) {
      let o;
      try {
        o = ie(s[a], ei, e);
      } catch (l) {
        throw new Error(
          `failed to parse color at index ${a} in palette expression: ${l.message}`
        );
      }
      if (!(o instanceof Wt))
        throw new Error(
          `the palette color at index ${a} must be a literal value`
        );
      r[a] = o;
    }
    return [n, ...r];
  }
  function rt(...i) {
    return function(t, e, n) {
      const s = t[0];
      let r;
      for (let a = 0; a < i.length; a++) {
        const o = i[a](t, e, n);
        if (a == i.length - 1) {
          if (!o)
            throw new Error(
              "expected last argument validator to return the parsed args"
            );
          r = o;
        }
      }
      return new k_(e, s, ...r);
    };
  }
  function K_(i, t, e) {
    const n = i[0], s = G_[n];
    if (!s)
      throw new Error(`unknown operator: ${n}`);
    return s(i, t, e);
  }
  function rf(i) {
    if (!i)
      return "";
    const t = i.getType();
    switch (t) {
      case "Point":
      case "LineString":
      case "Polygon":
        return t;
      case "MultiPoint":
      case "MultiLineString":
      case "MultiPolygon":
        return (
          /** @type {'Point'|'LineString'|'Polygon'} */
          t.substring(5)
        );
      case "Circle":
        return "Polygon";
      case "GeometryCollection":
        return rf(
          /** @type {import("../geom/GeometryCollection.js").default} */
          i.getGeometries()[0]
        );
      default:
        return "";
    }
  }
  function af() {
    return {
      variables: {},
      properties: {},
      resolution: NaN,
      featureId: null,
      geometryType: ""
    };
  }
  function Di(i, t, e) {
    const n = ie(i, t, e);
    return ni(n);
  }
  function ni(i, t) {
    if (i instanceof Wt) {
      if (i.type === ei && typeof i.value == "string") {
        const n = kh(i.value);
        return function() {
          return n;
        };
      }
      return function() {
        return i.value;
      };
    }
    const e = i.operator;
    switch (e) {
      case b.Number:
      case b.String:
      case b.Coalesce:
        return j_(i);
      case b.Get:
      case b.Var:
      case b.Has:
        return V_(i);
      case b.Id:
        return (n) => n.featureId;
      case b.GeometryType:
        return (n) => n.geometryType;
      case b.Concat: {
        const n = i.args.map((s) => ni(s));
        return (s) => "".concat(...n.map((r) => r(s).toString()));
      }
      case b.Resolution:
        return (n) => n.resolution;
      case b.Any:
      case b.All:
      case b.Between:
      case b.In:
      case b.Not:
        return J_(i);
      case b.Equal:
      case b.NotEqual:
      case b.LessThan:
      case b.LessThanOrEqualTo:
      case b.GreaterThan:
      case b.GreaterThanOrEqualTo:
        return H_(i);
      case b.Multiply:
      case b.Divide:
      case b.Add:
      case b.Subtract:
      case b.Clamp:
      case b.Mod:
      case b.Pow:
      case b.Abs:
      case b.Floor:
      case b.Ceil:
      case b.Round:
      case b.Sin:
      case b.Cos:
      case b.Atan:
      case b.Sqrt:
        return Q_(i);
      case b.Case:
        return tp(i);
      case b.Match:
        return ep(i);
      case b.Interpolate:
        return ip(i);
      case b.ToString:
        return np(i);
      default:
        throw new Error(`Unsupported operator ${e}`);
    }
  }
  function j_(i, t) {
    const e = i.operator, n = i.args.length, s = new Array(n);
    for (let r = 0; r < n; ++r)
      s[r] = ni(i.args[r]);
    switch (e) {
      case b.Coalesce:
        return (r) => {
          for (let a = 0; a < n; ++a) {
            const o = s[a](r);
            if (typeof o < "u" && o !== null)
              return o;
          }
          throw new Error("Expected one of the values to be non-null");
        };
      case b.Number:
      case b.String:
        return (r) => {
          for (let a = 0; a < n; ++a) {
            const o = s[a](r);
            if (typeof o === e)
              return o;
          }
          throw new Error(`Expected one of the values to be a ${e}`);
        };
      default:
        throw new Error(`Unsupported assertion operator ${e}`);
    }
  }
  function V_(i, t) {
    const n = (
      /** @type {string} */
      /** @type {LiteralExpression} */
      i.args[0].value
    );
    switch (i.operator) {
      case b.Get:
        return (s) => {
          const r = i.args;
          let a = s.properties[n];
          for (let o = 1, l = r.length; o < l; ++o) {
            const c = (
              /** @type {string|number} */
              /** @type {LiteralExpression} */
              r[o].value
            );
            a = a[c];
          }
          return a;
        };
      case b.Var:
        return (s) => s.variables[n];
      case b.Has:
        return (s) => {
          const r = i.args;
          if (!(n in s.properties))
            return !1;
          let a = s.properties[n];
          for (let o = 1, l = r.length; o < l; ++o) {
            const c = (
              /** @type {string|number} */
              /** @type {LiteralExpression} */
              r[o].value
            );
            if (!a || !Object.hasOwn(a, c))
              return !1;
            a = a[c];
          }
          return !0;
        };
      default:
        throw new Error(`Unsupported accessor operator ${i.operator}`);
    }
  }
  function H_(i, t) {
    const e = i.operator, n = ni(i.args[0]), s = ni(i.args[1]);
    switch (e) {
      case b.Equal:
        return (r) => n(r) === s(r);
      case b.NotEqual:
        return (r) => n(r) !== s(r);
      case b.LessThan:
        return (r) => n(r) < s(r);
      case b.LessThanOrEqualTo:
        return (r) => n(r) <= s(r);
      case b.GreaterThan:
        return (r) => n(r) > s(r);
      case b.GreaterThanOrEqualTo:
        return (r) => n(r) >= s(r);
      default:
        throw new Error(`Unsupported comparison operator ${e}`);
    }
  }
  function J_(i, t) {
    const e = i.operator, n = i.args.length, s = new Array(n);
    for (let r = 0; r < n; ++r)
      s[r] = ni(i.args[r]);
    switch (e) {
      case b.Any:
        return (r) => {
          for (let a = 0; a < n; ++a)
            if (s[a](r))
              return !0;
          return !1;
        };
      case b.All:
        return (r) => {
          for (let a = 0; a < n; ++a)
            if (!s[a](r))
              return !1;
          return !0;
        };
      case b.Between:
        return (r) => {
          const a = s[0](r), o = s[1](r), l = s[2](r);
          return a >= o && a <= l;
        };
      case b.In:
        return (r) => {
          const a = s[0](r);
          for (let o = 1; o < n; ++o)
            if (a === s[o](r))
              return !0;
          return !1;
        };
      case b.Not:
        return (r) => !s[0](r);
      default:
        throw new Error(`Unsupported logical operator ${e}`);
    }
  }
  function Q_(i, t) {
    const e = i.operator, n = i.args.length, s = new Array(n);
    for (let r = 0; r < n; ++r)
      s[r] = ni(i.args[r]);
    switch (e) {
      case b.Multiply:
        return (r) => {
          let a = 1;
          for (let o = 0; o < n; ++o)
            a *= s[o](r);
          return a;
        };
      case b.Divide:
        return (r) => s[0](r) / s[1](r);
      case b.Add:
        return (r) => {
          let a = 0;
          for (let o = 0; o < n; ++o)
            a += s[o](r);
          return a;
        };
      case b.Subtract:
        return (r) => s[0](r) - s[1](r);
      case b.Clamp:
        return (r) => {
          const a = s[0](r), o = s[1](r);
          if (a < o)
            return o;
          const l = s[2](r);
          return a > l ? l : a;
        };
      case b.Mod:
        return (r) => s[0](r) % s[1](r);
      case b.Pow:
        return (r) => Math.pow(s[0](r), s[1](r));
      case b.Abs:
        return (r) => Math.abs(s[0](r));
      case b.Floor:
        return (r) => Math.floor(s[0](r));
      case b.Ceil:
        return (r) => Math.ceil(s[0](r));
      case b.Round:
        return (r) => Math.round(s[0](r));
      case b.Sin:
        return (r) => Math.sin(s[0](r));
      case b.Cos:
        return (r) => Math.cos(s[0](r));
      case b.Atan:
        return n === 2 ? (r) => Math.atan2(s[0](r), s[1](r)) : (r) => Math.atan(s[0](r));
      case b.Sqrt:
        return (r) => Math.sqrt(s[0](r));
      default:
        throw new Error(`Unsupported numeric operator ${e}`);
    }
  }
  function tp(i, t) {
    const e = i.args.length, n = new Array(e);
    for (let s = 0; s < e; ++s)
      n[s] = ni(i.args[s]);
    return (s) => {
      for (let r = 0; r < e - 1; r += 2)
        if (n[r](s))
          return n[r + 1](s);
      return n[e - 1](s);
    };
  }
  function ep(i, t) {
    const e = i.args.length, n = new Array(e);
    for (let s = 0; s < e; ++s)
      n[s] = ni(i.args[s]);
    return (s) => {
      const r = n[0](s);
      for (let a = 1; a < e; a += 2)
        if (r === n[a](s))
          return n[a + 1](s);
      return n[e - 1](s);
    };
  }
  function ip(i, t) {
    const e = i.args.length, n = new Array(e);
    for (let s = 0; s < e; ++s)
      n[s] = ni(i.args[s]);
    return (s) => {
      const r = n[0](s), a = n[1](s);
      let o, l;
      for (let h = 2; h < e; h += 2) {
        const c = n[h](s);
        let u = n[h + 1](s);
        const d = Array.isArray(u);
        if (d && (u = d_(u)), c >= a)
          return h === 2 ? u : d ? sp(
            r,
            a,
            o,
            l,
            c,
            u
          ) : rr(
            r,
            a,
            o,
            l,
            c,
            u
          );
        o = c, l = u;
      }
      return l;
    };
  }
  function np(i, t) {
    const e = i.operator, n = i.args.length, s = new Array(n);
    for (let r = 0; r < n; ++r)
      s[r] = ni(i.args[r]);
    switch (e) {
      case b.ToString:
        return (r) => {
          const a = s[0](r);
          return i.args[0].type === ei ? Gh(a) : a.toString();
        };
      default:
        throw new Error(`Unsupported convert operator ${e}`);
    }
  }
  function rr(i, t, e, n, s, r) {
    const a = s - e;
    if (a === 0)
      return n;
    const o = t - e, l = i === 1 ? o / a : (Math.pow(i, o) - 1) / (Math.pow(i, a) - 1);
    return n + l * (r - n);
  }
  function sp(i, t, e, n, s, r) {
    if (s - e === 0)
      return n;
    const o = ru(n), l = ru(r);
    let h = l[2] - o[2];
    h > 180 ? h -= 360 : h < -180 && (h += 360);
    const c = [
      rr(i, t, e, o[0], s, l[0]),
      rr(i, t, e, o[1], s, l[1]),
      o[2] + rr(i, t, e, 0, s, h),
      rr(i, t, e, n[3], s, r[3])
    ];
    return Kd(f_(c));
  }
  function rp(i) {
    return !0;
  }
  function ap(i) {
    const t = sf(), e = op(i, t), n = af();
    return function(s, r) {
      if (n.properties = s.getPropertiesInternal(), n.resolution = r, t.featureId) {
        const a = s.getId();
        a !== void 0 ? n.featureId = a : n.featureId = null;
      }
      return t.geometryType && (n.geometryType = rf(
        s.getGeometry()
      )), e(n);
    };
  }
  function _u(i) {
    const t = sf(), e = i.length, n = new Array(e);
    for (let a = 0; a < e; ++a)
      n[a] = Gl(i[a], t);
    const s = af(), r = new Array(e);
    return function(a, o) {
      if (s.properties = a.getPropertiesInternal(), s.resolution = o, t.featureId) {
        const h = a.getId();
        h !== void 0 ? s.featureId = h : s.featureId = null;
      }
      let l = 0;
      for (let h = 0; h < e; ++h) {
        const c = n[h](s);
        c && (r[l] = c, l += 1);
      }
      return r.length = l, r;
    };
  }
  function op(i, t) {
    const e = i.length, n = new Array(e);
    for (let s = 0; s < e; ++s) {
      const r = i[s], a = "filter" in r ? Di(r.filter, me, t) : rp;
      let o;
      if (Array.isArray(r.style)) {
        const l = r.style.length;
        o = new Array(l);
        for (let h = 0; h < l; ++h)
          o[h] = Gl(r.style[h], t);
      } else
        o = [Gl(r.style, t)];
      n[s] = { filter: a, styles: o };
    }
    return function(s) {
      const r = [];
      let a = !1;
      for (let o = 0; o < e; ++o) {
        const l = n[o].filter;
        if (l(s) && !(i[o].else && a)) {
          a = !0;
          for (const h of n[o].styles) {
            const c = h(s);
            c && r.push(c);
          }
        }
      }
      return r;
    };
  }
  function Gl(i, t) {
    const e = Ar(i, "", t), n = Pr(i, "", t), s = lp(i, t), r = hp(i, t), a = Ce(i, "z-index", t);
    if (!e && !n && !s && !r && !As(i))
      throw new Error(
        "No fill, stroke, point, or text symbolizer properties in style: " + JSON.stringify(i)
      );
    const o = new oe();
    return function(l) {
      let h = !0;
      if (e) {
        const c = e(l);
        c && (h = !1), o.setFill(c);
      }
      if (n) {
        const c = n(l);
        c && (h = !1), o.setStroke(c);
      }
      if (s) {
        const c = s(l);
        c && (h = !1), o.setText(c);
      }
      if (r) {
        const c = r(l);
        c && (h = !1), o.setImage(c);
      }
      return a && o.setZIndex(a(l)), h ? null : o;
    };
  }
  function Ar(i, t, e) {
    let n;
    if (t + "fill-pattern-src" in i)
      n = fp(i, t + "fill-", e);
    else {
      if (i[t + "fill-color"] === "none")
        return (r) => null;
      n = Zh(
        i,
        t + "fill-color",
        e
      );
    }
    if (!n)
      return null;
    const s = new ti();
    return function(r) {
      const a = n(r);
      return a === Dh ? null : (s.setColor(a), s);
    };
  }
  function Pr(i, t, e) {
    const n = Ce(
      i,
      t + "stroke-width",
      e
    ), s = Zh(
      i,
      t + "stroke-color",
      e
    );
    if (!n && !s)
      return null;
    const r = Ii(
      i,
      t + "stroke-line-cap",
      e
    ), a = Ii(
      i,
      t + "stroke-line-join",
      e
    ), o = of(
      i,
      t + "stroke-line-dash",
      e
    ), l = Ce(
      i,
      t + "stroke-line-dash-offset",
      e
    ), h = Ce(
      i,
      t + "stroke-miter-limit",
      e
    ), c = new Ne();
    return function(u) {
      if (s) {
        const d = s(u);
        if (d === Dh)
          return null;
        c.setColor(d);
      }
      if (n && c.setWidth(n(u)), r) {
        const d = r(u);
        if (d !== "butt" && d !== "round" && d !== "square")
          throw new Error("Expected butt, round, or square line cap");
        c.setLineCap(d);
      }
      if (a) {
        const d = a(u);
        if (d !== "bevel" && d !== "round" && d !== "miter")
          throw new Error("Expected bevel, round, or miter line join");
        c.setLineJoin(d);
      }
      return o && c.setLineDash(o(u)), l && c.setLineDashOffset(l(u)), h && c.setMiterLimit(h(u)), c;
    };
  }
  function lp(i, t) {
    const e = "text-", n = Ii(i, e + "value", t);
    if (!n)
      return null;
    const s = Ar(i, e, t), r = Ar(
      i,
      e + "background-",
      t
    ), a = Pr(i, e, t), o = Pr(
      i,
      e + "background-",
      t
    ), l = Ii(i, e + "font", t), h = Ce(
      i,
      e + "max-angle",
      t
    ), c = Ce(
      i,
      e + "offset-x",
      t
    ), u = Ce(
      i,
      e + "offset-y",
      t
    ), d = vs(
      i,
      e + "overflow",
      t
    ), m = Ii(
      i,
      e + "placement",
      t
    ), f = Ce(i, e + "repeat", t), y = bo(i, e + "scale", t), E = vs(
      i,
      e + "rotate-with-view",
      t
    ), x = Ce(
      i,
      e + "rotation",
      t
    ), M = Ii(i, e + "align", t), C = Ii(
      i,
      e + "justify",
      t
    ), R = Ii(
      i,
      e + "baseline",
      t
    ), S = vs(
      i,
      e + "keep-upright",
      t
    ), A = of(
      i,
      e + "padding",
      t
    ), O = Lo(
      i,
      e + "declutter-mode"
    ), P = new Po({ declutterMode: O });
    return function(L) {
      if (P.setText(n(L)), s && P.setFill(s(L)), r && P.setBackgroundFill(r(L)), a && P.setStroke(a(L)), o && P.setBackgroundStroke(o(L)), l && P.setFont(l(L)), h && P.setMaxAngle(h(L)), c && P.setOffsetX(c(L)), u && P.setOffsetY(u(L)), d && P.setOverflow(d(L)), m) {
        const F = m(L);
        if (F !== "point" && F !== "line")
          throw new Error("Expected point or line for text-placement");
        P.setPlacement(F);
      }
      if (f && P.setRepeat(f(L)), y && P.setScale(y(L)), E && P.setRotateWithView(E(L)), x && P.setRotation(x(L)), M) {
        const F = M(L);
        if (F !== "left" && F !== "center" && F !== "right" && F !== "end" && F !== "start")
          throw new Error(
            "Expected left, right, center, start, or end for text-align"
          );
        P.setTextAlign(F);
      }
      if (C) {
        const F = C(L);
        if (F !== "left" && F !== "right" && F !== "center")
          throw new Error("Expected left, right, or center for text-justify");
        P.setJustify(F);
      }
      if (R) {
        const F = R(L);
        if (F !== "bottom" && F !== "top" && F !== "middle" && F !== "alphabetic" && F !== "hanging")
          throw new Error(
            "Expected bottom, top, middle, alphabetic, or hanging for text-baseline"
          );
        P.setTextBaseline(F);
      }
      return A && P.setPadding(A(L)), S && P.setKeepUpright(S(L)), P;
    };
  }
  function hp(i, t) {
    return "icon-src" in i ? cp(i, t) : "shape-points" in i ? up(i, t) : "circle-radius" in i ? dp(i, t) : null;
  }
  function cp(i, t) {
    const e = "icon-", n = e + "src", s = lf(i[n], n), r = qa(
      i,
      e + "anchor",
      t
    ), a = bo(i, e + "scale", t), o = Ce(
      i,
      e + "opacity",
      t
    ), l = qa(
      i,
      e + "displacement",
      t
    ), h = Ce(
      i,
      e + "rotation",
      t
    ), c = vs(
      i,
      e + "rotate-with-view",
      t
    ), u = yu(i, e + "anchor-origin"), d = vu(
      i,
      e + "anchor-x-units"
    ), m = vu(
      i,
      e + "anchor-y-units"
    ), f = pp(i, e + "color"), y = mp(i, e + "cross-origin"), E = _p(i, e + "offset"), x = yu(i, e + "offset-origin"), M = Ka(i, e + "width"), C = Ka(i, e + "height"), R = gp(i, e + "size"), S = Lo(
      i,
      e + "declutter-mode"
    ), A = new Wr({
      src: s,
      anchorOrigin: u,
      anchorXUnits: d,
      anchorYUnits: m,
      color: f,
      crossOrigin: y,
      offset: E,
      offsetOrigin: x,
      height: C,
      width: M,
      size: R,
      declutterMode: S
    });
    return function(O) {
      return o && A.setOpacity(o(O)), l && A.setDisplacement(l(O)), h && A.setRotation(h(O)), c && A.setRotateWithView(c(O)), a && A.setScale(a(O)), r && A.setAnchor(r(O)), A;
    };
  }
  function up(i, t) {
    const e = "shape-", n = e + "points", s = e + "radius", r = Ul(i[n], n), a = Ul(i[s], s), o = Ar(i, e, t), l = Pr(i, e, t), h = bo(i, e + "scale", t), c = qa(
      i,
      e + "displacement",
      t
    ), u = Ce(
      i,
      e + "rotation",
      t
    ), d = vs(
      i,
      e + "rotate-with-view",
      t
    ), m = Ka(i, e + "radius2"), f = Ka(i, e + "angle"), y = Lo(
      i,
      e + "declutter-mode"
    ), E = new Xr({
      points: r,
      radius: a,
      radius2: m,
      angle: f,
      declutterMode: y
    });
    return function(x) {
      return o && E.setFill(o(x)), l && E.setStroke(l(x)), c && E.setDisplacement(c(x)), u && E.setRotation(u(x)), d && E.setRotateWithView(d(x)), h && E.setScale(h(x)), E;
    };
  }
  function dp(i, t) {
    const e = "circle-", n = Ar(i, e, t), s = Pr(i, e, t), r = Ce(i, e + "radius", t), a = bo(i, e + "scale", t), o = qa(
      i,
      e + "displacement",
      t
    ), l = Ce(
      i,
      e + "rotation",
      t
    ), h = vs(
      i,
      e + "rotate-with-view",
      t
    ), c = Lo(
      i,
      e + "declutter-mode"
    ), u = new Gn({
      radius: 5,
      // this is arbitrary, but required - the evaluated radius is used below
      declutterMode: c
    });
    return function(d) {
      return r && u.setRadius(r(d)), n && u.setFill(n(d)), s && u.setStroke(s(d)), o && u.setDisplacement(o(d)), l && u.setRotation(l(d)), h && u.setRotateWithView(h(d)), a && u.setScale(a(d)), u;
    };
  }
  function Ce(i, t, e) {
    if (!(t in i))
      return;
    const n = Di(i[t], Et, e);
    return function(s) {
      return Ul(n(s), t);
    };
  }
  function Ii(i, t, e) {
    if (!(t in i))
      return null;
    const n = Di(i[t], Se, e);
    return function(s) {
      return lf(n(s), t);
    };
  }
  function fp(i, t, e) {
    const n = Ii(
      i,
      t + "pattern-src",
      e
    ), s = pu(
      i,
      t + "pattern-offset",
      e
    ), r = pu(
      i,
      t + "pattern-size",
      e
    ), a = Zh(
      i,
      t + "color",
      e
    );
    return function(o) {
      return {
        src: n(o),
        offset: s && s(o),
        size: r && r(o),
        color: a && a(o)
      };
    };
  }
  function vs(i, t, e) {
    if (!(t in i))
      return null;
    const n = Di(i[t], me, e);
    return function(s) {
      const r = n(s);
      if (typeof r != "boolean")
        throw new Error(`Expected a boolean for ${t}`);
      return r;
    };
  }
  function Zh(i, t, e) {
    if (!(t in i))
      return null;
    const n = Di(i[t], ei, e);
    return function(s) {
      return hf(n(s), t);
    };
  }
  function of(i, t, e) {
    if (!(t in i))
      return null;
    const n = Di(i[t], Un, e);
    return function(s) {
      return Yr(n(s), t);
    };
  }
  function qa(i, t, e) {
    if (!(t in i))
      return null;
    const n = Di(i[t], Un, e);
    return function(s) {
      const r = Yr(n(s), t);
      if (r.length !== 2)
        throw new Error(`Expected two numbers for ${t}`);
      return r;
    };
  }
  function pu(i, t, e) {
    if (!(t in i))
      return null;
    const n = Di(i[t], Un, e);
    return function(s) {
      return cf(n(s), t);
    };
  }
  function bo(i, t, e) {
    if (!(t in i))
      return null;
    const n = Di(
      i[t],
      Un | Et,
      e
    );
    return function(s) {
      return yp(n(s), t);
    };
  }
  function Ka(i, t) {
    const e = i[t];
    if (e !== void 0) {
      if (typeof e != "number")
        throw new Error(`Expected a number for ${t}`);
      return e;
    }
  }
  function gp(i, t) {
    const e = i[t];
    if (e !== void 0) {
      if (typeof e == "number")
        return Ie(e);
      if (!Array.isArray(e))
        throw new Error(`Expected a number or size array for ${t}`);
      if (e.length !== 2 || typeof e[0] != "number" || typeof e[1] != "number")
        throw new Error(`Expected a number or size array for ${t}`);
      return e;
    }
  }
  function mp(i, t) {
    const e = i[t];
    if (e !== void 0) {
      if (typeof e != "string")
        throw new Error(`Expected a string for ${t}`);
      return e;
    }
  }
  function yu(i, t) {
    const e = i[t];
    if (e !== void 0) {
      if (e !== "bottom-left" && e !== "bottom-right" && e !== "top-left" && e !== "top-right")
        throw new Error(
          `Expected bottom-left, bottom-right, top-left, or top-right for ${t}`
        );
      return e;
    }
  }
  function vu(i, t) {
    const e = i[t];
    if (e !== void 0) {
      if (e !== "pixels" && e !== "fraction")
        throw new Error(`Expected pixels or fraction for ${t}`);
      return e;
    }
  }
  function _p(i, t) {
    const e = i[t];
    if (e !== void 0)
      return Yr(e, t);
  }
  function Lo(i, t) {
    const e = i[t];
    if (e !== void 0) {
      if (typeof e != "string")
        throw new Error(`Expected a string for ${t}`);
      if (e !== "declutter" && e !== "obstacle" && e !== "none")
        throw new Error(`Expected declutter, obstacle, or none for ${t}`);
      return e;
    }
  }
  function pp(i, t) {
    const e = i[t];
    if (e !== void 0)
      return hf(e, t);
  }
  function Yr(i, t) {
    if (!Array.isArray(i))
      throw new Error(`Expected an array for ${t}`);
    const e = i.length;
    for (let n = 0; n < e; ++n)
      if (typeof i[n] != "number")
        throw new Error(`Expected an array of numbers for ${t}`);
    return i;
  }
  function lf(i, t) {
    if (typeof i != "string")
      throw new Error(`Expected a string for ${t}`);
    return i;
  }
  function Ul(i, t) {
    if (typeof i != "number")
      throw new Error(`Expected a number for ${t}`);
    return i;
  }
  function hf(i, t) {
    if (typeof i == "string")
      return i;
    const e = Yr(i, t), n = e.length;
    if (n < 3 || n > 4)
      throw new Error(`Expected a color with 3 or 4 values for ${t}`);
    return e;
  }
  function cf(i, t) {
    const e = Yr(i, t);
    if (e.length !== 2)
      throw new Error(`Expected an array of two numbers for ${t}`);
    return e;
  }
  function yp(i, t) {
    return typeof i == "number" ? i : cf(i, t);
  }
  const Eu = {
    RENDER_ORDER: "renderOrder"
  };
  class uf extends So {
    /**
     * @param {Options<FeatureType, VectorSourceType>} [options] Options.
     */
    constructor(t) {
      t = t || {};
      const e = Object.assign({}, t);
      delete e.style, delete e.renderBuffer, delete e.updateWhileAnimating, delete e.updateWhileInteracting, super(e), this.declutter_ = t.declutter ? String(t.declutter) : void 0, this.renderBuffer_ = t.renderBuffer !== void 0 ? t.renderBuffer : 100, this.style_ = null, this.styleFunction_ = void 0, this.setStyle(t.style), this.updateWhileAnimating_ = t.updateWhileAnimating !== void 0 ? t.updateWhileAnimating : !1, this.updateWhileInteracting_ = t.updateWhileInteracting !== void 0 ? t.updateWhileInteracting : !1;
    }
    /**
     * @return {string} Declutter group.
     * @override
     */
    getDeclutter() {
      return this.declutter_;
    }
    /**
     * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
     * that resolves with an array of features. The array will either contain the topmost feature
     * when a hit was detected, or it will be empty.
     *
     * The hit detection algorithm used for this method is optimized for performance, but is less
     * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
     * Text is not considered, and icons are only represented by their bounding box instead of the exact
     * image.
     *
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
     * @api
     * @override
     */
    getFeatures(t) {
      return super.getFeatures(t);
    }
    /**
     * @return {number|undefined} Render buffer.
     */
    getRenderBuffer() {
      return this.renderBuffer_;
    }
    /**
     * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
     *     order.
     */
    getRenderOrder() {
      return (
        /** @type {import("../render.js").OrderFunction|null|undefined} */
        this.get(Eu.RENDER_ORDER)
      );
    }
    /**
     * Get the style for features.  This returns whatever was passed to the `style`
     * option at construction or to the `setStyle` method.
     * @return {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null|undefined} Layer style.
     * @api
     */
    getStyle() {
      return this.style_;
    }
    /**
     * Get the style function.
     * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
     * @api
     */
    getStyleFunction() {
      return this.styleFunction_;
    }
    /**
     * @return {boolean} Whether the rendered layer should be updated while
     *     animating.
     */
    getUpdateWhileAnimating() {
      return this.updateWhileAnimating_;
    }
    /**
     * @return {boolean} Whether the rendered layer should be updated while
     *     interacting.
     */
    getUpdateWhileInteracting() {
      return this.updateWhileInteracting_;
    }
    /**
     * Render declutter items for this layer
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {import("../layer/Layer.js").State} layerState Layer state.
     * @override
     */
    renderDeclutter(t, e) {
      const n = this.getDeclutter();
      n in t.declutter || (t.declutter[n] = new Zd(9)), this.getRenderer().renderDeclutter(t, e);
    }
    /**
     * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
     *     Render order.
     */
    setRenderOrder(t) {
      this.set(Eu.RENDER_ORDER, t);
    }
    /**
     * Set the style for features.  This can be a single style object, an array
     * of styles, or a function that takes a feature and resolution and returns
     * an array of styles. If set to `null`, the layer has no style (a `null` style),
     * so only features that have their own styles will be rendered in the layer. Call
     * `setStyle()` without arguments to reset to the default style. See
     * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
     *
     * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
     * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
     * ```js
     * vectorLayer.setStyle({
     *   "fill-color": "yellow",
     *   "stroke-color": "black",
     *   "stroke-width": 4
     * })
     * ```
     *
     * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
     * @api
     */
    setStyle(t) {
      this.style_ = t === void 0 ? nf : t;
      const e = vp(t);
      this.styleFunction_ = t === null ? void 0 : O_(e), this.changed();
    }
    /**
     * @param {boolean|string|number} declutter Declutter images and text.
     * @api
     */
    setDeclutter(t) {
      this.declutter_ = t ? String(t) : void 0, this.changed();
    }
  }
  function vp(i) {
    if (i === void 0)
      return nf;
    if (!i)
      return null;
    if (typeof i == "function" || i instanceof oe)
      return i;
    if (!Array.isArray(i))
      return _u([i]);
    if (i.length === 0)
      return [];
    const t = i.length, e = i[0];
    if (e instanceof oe) {
      const s = new Array(t);
      for (let r = 0; r < t; ++r) {
        const a = i[r];
        if (!(a instanceof oe))
          throw new Error("Expected a list of style instances");
        s[r] = a;
      }
      return s;
    }
    if ("style" in e) {
      const s = new Array(t);
      for (let r = 0; r < t; ++r) {
        const a = i[r];
        if (!("style" in a))
          throw new Error("Expected a list of rules with a style property");
        s[r] = a;
      }
      return ap(s);
    }
    return _u(
      /** @type {Array<import("../style/flat.js").FlatStyle>} */
      i
    );
  }
  class Ep extends ho {
    /**
     * @param {import("../Map.js").default} map Map.
     */
    constructor(t) {
      super(), this.map_ = t;
    }
    /**
     * @abstract
     * @param {import("../render/EventType.js").default} type Event type.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */
    dispatchRenderEvent(t, e) {
      ft();
    }
    /**
     * @param {import("../Map.js").FrameState} frameState FrameState.
     * @protected
     */
    calculateMatrices2D(t) {
      const e = t.viewState, n = t.coordinateToPixelTransform, s = t.pixelToCoordinateTransform;
      Li(
        n,
        t.size[0] / 2,
        t.size[1] / 2,
        1 / e.resolution,
        -1 / e.resolution,
        -e.rotation,
        -e.center[0],
        -e.center[1]
      ), Nd(s, n);
    }
    /**
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../Map.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {boolean} checkWrapped Check for wrapped geometries.
     * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {S} thisArg Value to use as `this` when executing `callback`.
     * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
     *     function, only layers which are visible and for which this function
     *     returns `true` will be tested for features.  By default, all visible
     *     layers will be tested.
     * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
     * @return {T|undefined} Callback result.
     * @template S,T,U
     */
    forEachFeatureAtCoordinate(t, e, n, s, r, a, o, l) {
      let h;
      const c = e.viewState;
      function u(R, S, A, O) {
        return r.call(a, S, R ? A : null, O);
      }
      const d = c.projection, m = Md(t.slice(), d), f = [[0, 0]];
      if (d.canWrapX() && s) {
        const R = d.getExtent(), S = _t(R);
        f.push([-S, 0], [S, 0]);
      }
      const y = e.layerStatesArray, E = y.length, x = (
        /** @type {Array<HitMatch<T>>} */
        []
      ), M = [];
      for (let R = 0; R < f.length; R++)
        for (let S = E - 1; S >= 0; --S) {
          const A = y[S], O = A.layer;
          if (O.hasRenderer() && Nh(A, c) && o.call(l, O)) {
            const P = O.getRenderer(), L = O.getSource();
            if (P && L) {
              const F = L.getWrapX() ? m : t, z = u.bind(
                null,
                A.managed
              );
              M[0] = F[0] + f[R][0], M[1] = F[1] + f[R][1], h = P.forEachFeatureAtCoordinate(
                M,
                e,
                n,
                z,
                x
              );
            }
            if (h)
              return h;
          }
        }
      if (x.length === 0)
        return;
      const C = 1 / x.length;
      return x.forEach((R, S) => R.distanceSq += S * C), x.sort((R, S) => R.distanceSq - S.distanceSq), x.some((R) => h = R.callback(R.feature, R.layer, R.geometry)), h;
    }
    /**
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../Map.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {boolean} checkWrapped Check for wrapped geometries.
     * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
     *     function, only layers which are visible and for which this function
     *     returns `true` will be tested for features.  By default, all visible
     *     layers will be tested.
     * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
     * @return {boolean} Is there a feature at the given coordinate?
     * @template U
     */
    hasFeatureAtCoordinate(t, e, n, s, r, a) {
      return this.forEachFeatureAtCoordinate(
        t,
        e,
        n,
        s,
        xr,
        this,
        r,
        a
      ) !== void 0;
    }
    /**
     * @return {import("../Map.js").default} Map.
     */
    getMap() {
      return this.map_;
    }
    /**
     * Render.
     * @abstract
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     */
    renderFrame(t) {
      ft();
    }
    /**
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    scheduleExpireIconCache(t) {
      $e.canExpireCache() && t.postRenderFunctions.push(xp);
    }
  }
  function xp(i, t) {
    $e.expire();
  }
  class df extends Oi {
    /**
     * @param {import("./EventType.js").default} type Type.
     * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
     *     CSS pixels to rendered pixels.
     * @param {import("../Map.js").FrameState} [frameState] Frame state.
     * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
     */
    constructor(t, e, n, s) {
      super(t), this.inversePixelTransform = e, this.frameState = n, this.context = s;
    }
  }
  class Mp extends Ep {
    /**
     * @param {import("../Map.js").default} map Map.
     */
    constructor(t) {
      super(t), this.fontChangeListenerKey_ = xt(
        Ci,
        Ts.PROPERTYCHANGE,
        t.redrawText,
        t
      ), this.element_ = document.createElement("div");
      const e = this.element_.style;
      e.position = "absolute", e.width = "100%", e.height = "100%", e.zIndex = "0", this.element_.className = Ao + " ol-layers";
      const n = t.getViewport();
      n.insertBefore(this.element_, n.firstChild || null), this.children_ = [], this.renderedVisible_ = !0;
    }
    /**
     * @param {import("../render/EventType.js").default} type Event type.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @override
     */
    dispatchRenderEvent(t, e) {
      const n = this.getMap();
      if (n.hasListener(t)) {
        const s = new df(t, void 0, e);
        n.dispatchEvent(s);
      }
    }
    /**
     * @override
     */
    disposeInternal() {
      bt(this.fontChangeListenerKey_), this.element_.remove(), super.disposeInternal();
    }
    /**
     * Render.
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     * @override
     */
    renderFrame(t) {
      if (!t) {
        this.renderedVisible_ && (this.element_.style.display = "none", this.renderedVisible_ = !1);
        return;
      }
      this.calculateMatrices2D(t), this.dispatchRenderEvent(Be.PRECOMPOSE, t);
      const e = t.layerStatesArray.sort(
        (o, l) => o.zIndex - l.zIndex
      );
      e.some(
        (o) => o.layer instanceof uf && o.layer.getDeclutter()
      ) && (t.declutter = {});
      const s = t.viewState;
      this.children_.length = 0;
      const r = [];
      let a = null;
      for (let o = 0, l = e.length; o < l; ++o) {
        const h = e[o];
        t.layerIndex = o;
        const c = h.layer, u = c.getSourceState();
        if (!Nh(h, s) || u != "ready" && u != "undefined") {
          c.unrender();
          continue;
        }
        const d = c.render(t, a);
        d && (d !== a && (this.children_.push(d), a = d), r.push(h));
      }
      this.declutter(t, r), v_(this.element_, this.children_), this.dispatchRenderEvent(Be.POSTCOMPOSE, t), this.renderedVisible_ || (this.element_.style.display = "", this.renderedVisible_ = !0), this.scheduleExpireIconCache(t);
    }
    /**
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {Array<import('../layer/Layer.js').State>} layerStates Layers.
     */
    declutter(t, e) {
      if (t.declutter) {
        for (let n = e.length - 1; n >= 0; --n) {
          const s = e[n], r = s.layer;
          r.getDeclutter() && r.renderDeclutter(t, s);
        }
        e.forEach(
          (n) => n.layer.renderDeferred(t)
        );
      }
    }
  }
  class Hi extends Oi {
    /**
     * @param {GroupEventType} type The event type.
     * @param {BaseLayer} layer The layer.
     */
    constructor(t, e) {
      super(t), this.layer = e;
    }
  }
  const hl = {
    LAYERS: "layers"
  };
  class $s extends gd {
    /**
     * @param {Options} [options] Layer options.
     */
    constructor(t) {
      t = t || {};
      const e = (
        /** @type {Options} */
        Object.assign({}, t)
      );
      delete e.layers;
      let n = t.layers;
      super(e), this.on, this.once, this.un, this.layersListenerKeys_ = [], this.listenerKeys_ = {}, this.addChangeListener(hl.LAYERS, this.handleLayersChanged_), n ? Array.isArray(n) ? n = new hi(n.slice(), { unique: !0 }) : Mt(
        typeof /** @type {?} */
        n.getArray == "function",
        "Expected `layers` to be an array or a `Collection`"
      ) : n = new hi(void 0, { unique: !0 }), this.setLayers(n);
    }
    /**
     * @private
     */
    handleLayerChange_() {
      this.changed();
    }
    /**
     * @private
     */
    handleLayersChanged_() {
      this.layersListenerKeys_.forEach(bt), this.layersListenerKeys_.length = 0;
      const t = this.getLayers();
      this.layersListenerKeys_.push(
        xt(t, we.ADD, this.handleLayersAdd_, this),
        xt(
          t,
          we.REMOVE,
          this.handleLayersRemove_,
          this
        )
      );
      for (const n in this.listenerKeys_)
        this.listenerKeys_[n].forEach(bt);
      Fr(this.listenerKeys_);
      const e = t.getArray();
      for (let n = 0, s = e.length; n < s; n++) {
        const r = e[n];
        this.registerLayerListeners_(r), this.dispatchEvent(new Hi("addlayer", r));
      }
      this.changed();
    }
    /**
     * @param {BaseLayer} layer The layer.
     */
    registerLayerListeners_(t) {
      const e = [
        xt(
          t,
          Ts.PROPERTYCHANGE,
          this.handleLayerChange_,
          this
        ),
        xt(t, ht.CHANGE, this.handleLayerChange_, this)
      ];
      t instanceof $s && e.push(
        xt(t, "addlayer", this.handleLayerGroupAdd_, this),
        xt(t, "removelayer", this.handleLayerGroupRemove_, this)
      ), this.listenerKeys_[St(t)] = e;
    }
    /**
     * @param {GroupEvent} event The layer group event.
     */
    handleLayerGroupAdd_(t) {
      this.dispatchEvent(new Hi("addlayer", t.layer));
    }
    /**
     * @param {GroupEvent} event The layer group event.
     */
    handleLayerGroupRemove_(t) {
      this.dispatchEvent(new Hi("removelayer", t.layer));
    }
    /**
     * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
     * @private
     */
    handleLayersAdd_(t) {
      const e = t.element;
      this.registerLayerListeners_(e), this.dispatchEvent(new Hi("addlayer", e)), this.changed();
    }
    /**
     * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
     * @private
     */
    handleLayersRemove_(t) {
      const e = t.element, n = St(e);
      this.listenerKeys_[n].forEach(bt), delete this.listenerKeys_[n], this.dispatchEvent(new Hi("removelayer", e)), this.changed();
    }
    /**
     * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
     * in this group.
     * @return {!Collection<import("./Base.js").default>} Collection of
     *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
     * @observable
     * @api
     */
    getLayers() {
      return (
        /** @type {!Collection<import("./Base.js").default>} */
        this.get(hl.LAYERS)
      );
    }
    /**
     * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
     * in this group.
     * @param {!Collection<import("./Base.js").default>} layers Collection of
     *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
     * @observable
     * @api
     */
    setLayers(t) {
      const e = this.getLayers();
      if (e) {
        const n = e.getArray();
        for (let s = 0, r = n.length; s < r; ++s)
          this.dispatchEvent(new Hi("removelayer", n[s]));
      }
      this.set(hl.LAYERS, t);
    }
    /**
     * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
     * @return {Array<import("./Layer.js").default>} Array of layers.
     * @override
     */
    getLayersArray(t) {
      return t = t !== void 0 ? t : [], this.getLayers().forEach(function(e) {
        e.getLayersArray(t);
      }), t;
    }
    /**
     * Get the layer states list and use this groups z-index as the default
     * for all layers in this and nested groups, if it is unset at this point.
     * If dest is not provided and this group's z-index is undefined
     * 0 is used a the default z-index.
     * @param {Array<import("./Layer.js").State>} [dest] Optional list
     * of layer states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     * @override
     */
    getLayerStatesArray(t) {
      const e = t !== void 0 ? t : [], n = e.length;
      this.getLayers().forEach(function(a) {
        a.getLayerStatesArray(e);
      });
      const s = this.getLayerState();
      let r = s.zIndex;
      !t && s.zIndex === void 0 && (r = 0);
      for (let a = n, o = e.length; a < o; a++) {
        const l = e[a];
        l.opacity *= s.opacity, l.visible = l.visible && s.visible, l.maxResolution = Math.min(
          l.maxResolution,
          s.maxResolution
        ), l.minResolution = Math.max(
          l.minResolution,
          s.minResolution
        ), l.minZoom = Math.max(l.minZoom, s.minZoom), l.maxZoom = Math.min(l.maxZoom, s.maxZoom), s.extent !== void 0 && (l.extent !== void 0 ? l.extent = De(
          l.extent,
          s.extent
        ) : l.extent = s.extent), l.zIndex === void 0 && (l.zIndex = r);
      }
      return e;
    }
    /**
     * @return {import("../source/Source.js").State} Source state.
     * @override
     */
    getSourceState() {
      return "ready";
    }
  }
  class os extends Oi {
    /**
     * @param {string} type Event type.
     * @param {import("./Map.js").default} map Map.
     * @param {?import("./Map.js").FrameState} [frameState] Frame state.
     */
    constructor(t, e, n) {
      super(t), this.map = e, this.frameState = n !== void 0 ? n : null;
    }
  }
  class Vi extends os {
    /**
     * @param {string} type Event type.
     * @param {import("./Map.js").default} map Map.
     * @param {EVENT} originalEvent Original event.
     * @param {boolean} [dragging] Is the map currently being dragged?
     * @param {import("./Map.js").FrameState} [frameState] Frame state.
     * @param {Array<PointerEvent>} [activePointers] Active pointers.
     */
    constructor(t, e, n, s, r, a) {
      super(t, e, r), this.originalEvent = n, this.pixel_ = null, this.coordinate_ = null, this.dragging = s !== void 0 ? s : !1, this.activePointers = a;
    }
    /**
     * The map pixel relative to the viewport corresponding to the original event.
     * @type {import("./pixel.js").Pixel}
     * @api
     */
    get pixel() {
      return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)), this.pixel_;
    }
    set pixel(t) {
      this.pixel_ = t;
    }
    /**
     * The coordinate corresponding to the original browser event.  This will be in the user
     * projection if one is set.  Otherwise it will be in the view projection.
     * @type {import("./coordinate.js").Coordinate}
     * @api
     */
    get coordinate() {
      return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)), this.coordinate_;
    }
    set coordinate(t) {
      this.coordinate_ = t;
    }
    /**
     * Prevents the default browser action.
     * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
     * @api
     * @override
     */
    preventDefault() {
      super.preventDefault(), "preventDefault" in this.originalEvent && this.originalEvent.preventDefault();
    }
    /**
     * Prevents further propagation of the current event.
     * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
     * @api
     * @override
     */
    stopPropagation() {
      super.stopPropagation(), "stopPropagation" in this.originalEvent && this.originalEvent.stopPropagation();
    }
  }
  const zt = {
    /**
     * A true single click with no dragging and no double click. Note that this
     * event is delayed by 250 ms to ensure that it is not a double click.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
     * @api
     */
    SINGLECLICK: "singleclick",
    /**
     * A click with no dragging. A double click will fire two of this.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
     * @api
     */
    CLICK: ht.CLICK,
    /**
     * A true double click, with no dragging.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
     * @api
     */
    DBLCLICK: ht.DBLCLICK,
    /**
     * Triggered when a pointer is dragged.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
     * @api
     */
    POINTERDRAG: "pointerdrag",
    /**
     * Triggered when a pointer is moved. Note that on touch devices this is
     * triggered when the map is panned, so is not the same as mousemove.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
     * @api
     */
    POINTERMOVE: "pointermove",
    POINTERDOWN: "pointerdown",
    POINTERUP: "pointerup",
    POINTEROVER: "pointerover",
    POINTEROUT: "pointerout",
    POINTERENTER: "pointerenter",
    POINTERLEAVE: "pointerleave",
    POINTERCANCEL: "pointercancel"
  }, zl = {
    POINTERMOVE: "pointermove",
    POINTERDOWN: "pointerdown",
    POINTERUP: "pointerup",
    POINTEROVER: "pointerover",
    POINTEROUT: "pointerout",
    POINTERENTER: "pointerenter",
    POINTERLEAVE: "pointerleave",
    POINTERCANCEL: "pointercancel"
  };
  class wp extends uo {
    /**
     * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
     * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
     */
    constructor(t, e) {
      super(t), this.map_ = t, this.clickTimeoutId_, this.emulateClicks_ = !1, this.dragging_ = !1, this.dragListenerKeys_ = [], this.moveTolerance_ = e === void 0 ? 1 : e, this.down_ = null;
      const n = this.map_.getViewport();
      this.activePointers_ = [], this.trackedTouches_ = {}, this.element_ = n, this.pointerdownListenerKey_ = xt(
        n,
        zl.POINTERDOWN,
        this.handlePointerDown_,
        this
      ), this.originalPointerMoveEvent_, this.relayedListenerKey_ = xt(
        n,
        zl.POINTERMOVE,
        this.relayMoveEvent_,
        this
      ), this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this), this.element_.addEventListener(
        ht.TOUCHMOVE,
        this.boundHandleTouchMove_,
        Bh ? { passive: !1 } : !1
      );
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    emulateClick_(t) {
      let e = new Vi(
        zt.CLICK,
        this.map_,
        t
      );
      this.dispatchEvent(e), this.clickTimeoutId_ !== void 0 ? (clearTimeout(this.clickTimeoutId_), this.clickTimeoutId_ = void 0, e = new Vi(
        zt.DBLCLICK,
        this.map_,
        t
      ), this.dispatchEvent(e)) : this.clickTimeoutId_ = setTimeout(() => {
        this.clickTimeoutId_ = void 0;
        const n = new Vi(
          zt.SINGLECLICK,
          this.map_,
          t
        );
        this.dispatchEvent(n);
      }, 250);
    }
    /**
     * Keeps track on how many pointers are currently active.
     *
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    updateActivePointers_(t) {
      const e = t, n = e.pointerId;
      if (e.type == zt.POINTERUP || e.type == zt.POINTERCANCEL) {
        delete this.trackedTouches_[n];
        for (const s in this.trackedTouches_)
          if (this.trackedTouches_[s].target !== e.target) {
            delete this.trackedTouches_[s];
            break;
          }
      } else (e.type == zt.POINTERDOWN || e.type == zt.POINTERMOVE) && (this.trackedTouches_[n] = e);
      this.activePointers_ = Object.values(this.trackedTouches_);
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    handlePointerUp_(t) {
      this.updateActivePointers_(t);
      const e = new Vi(
        zt.POINTERUP,
        this.map_,
        t,
        void 0,
        void 0,
        this.activePointers_
      );
      this.dispatchEvent(e), this.emulateClicks_ && !e.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(t) && this.emulateClick_(this.down_), this.activePointers_.length === 0 && (this.dragListenerKeys_.forEach(bt), this.dragListenerKeys_.length = 0, this.dragging_ = !1, this.down_ = null);
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @return {boolean} If the left mouse button was pressed.
     * @private
     */
    isMouseActionButton_(t) {
      return t.button === 0;
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    handlePointerDown_(t) {
      this.emulateClicks_ = this.activePointers_.length === 0, this.updateActivePointers_(t);
      const e = new Vi(
        zt.POINTERDOWN,
        this.map_,
        t,
        void 0,
        void 0,
        this.activePointers_
      );
      if (this.dispatchEvent(e), this.down_ = new PointerEvent(t.type, t), Object.defineProperty(this.down_, "target", {
        writable: !1,
        value: t.target
      }), this.dragListenerKeys_.length === 0) {
        const n = this.map_.getOwnerDocument();
        this.dragListenerKeys_.push(
          xt(
            n,
            zt.POINTERMOVE,
            this.handlePointerMove_,
            this
          ),
          xt(n, zt.POINTERUP, this.handlePointerUp_, this),
          /* Note that the listener for `pointercancel is set up on
           * `pointerEventHandler_` and not `documentPointerEventHandler_` like
           * the `pointerup` and `pointermove` listeners.
           *
           * The reason for this is the following: `TouchSource.vacuumTouches_()`
           * issues `pointercancel` events, when there was no `touchend` for a
           * `touchstart`. Now, let's say a first `touchstart` is registered on
           * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
           * But `documentPointerEventHandler_` doesn't know about the first
           * `touchstart`. If there is no `touchend` for the `touchstart`, we can
           * only receive a `touchcancel` from `pointerEventHandler_`, because it is
           * only registered there.
           */
          xt(
            this.element_,
            zt.POINTERCANCEL,
            this.handlePointerUp_,
            this
          )
        ), this.element_.getRootNode && this.element_.getRootNode() !== n && this.dragListenerKeys_.push(
          xt(
            this.element_.getRootNode(),
            zt.POINTERUP,
            this.handlePointerUp_,
            this
          )
        );
      }
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    handlePointerMove_(t) {
      if (this.isMoving_(t)) {
        this.updateActivePointers_(t), this.dragging_ = !0;
        const e = new Vi(
          zt.POINTERDRAG,
          this.map_,
          t,
          this.dragging_,
          void 0,
          this.activePointers_
        );
        this.dispatchEvent(e);
      }
    }
    /**
     * Wrap and relay a pointermove event.
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    relayMoveEvent_(t) {
      this.originalPointerMoveEvent_ = t;
      const e = !!(this.down_ && this.isMoving_(t));
      this.dispatchEvent(
        new Vi(
          zt.POINTERMOVE,
          this.map_,
          t,
          e
        )
      );
    }
    /**
     * Flexible handling of a `touch-action: none` css equivalent: because calling
     * `preventDefault()` on a `pointermove` event does not stop native page scrolling
     * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
     * when an interaction (currently `DragPan` handles the event.
     * @param {TouchEvent} event Event.
     * @private
     */
    handleTouchMove_(t) {
      const e = this.originalPointerMoveEvent_;
      (!e || e.defaultPrevented) && (typeof t.cancelable != "boolean" || t.cancelable === !0) && t.preventDefault();
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @return {boolean} Is moving.
     * @private
     */
    isMoving_(t) {
      return this.dragging_ || Math.abs(t.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(t.clientY - this.down_.clientY) > this.moveTolerance_;
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.relayedListenerKey_ && (bt(this.relayedListenerKey_), this.relayedListenerKey_ = null), this.element_.removeEventListener(
        ht.TOUCHMOVE,
        this.boundHandleTouchMove_
      ), this.pointerdownListenerKey_ && (bt(this.pointerdownListenerKey_), this.pointerdownListenerKey_ = null), this.dragListenerKeys_.forEach(bt), this.dragListenerKeys_.length = 0, this.element_ = null, super.disposeInternal();
    }
  }
  const Ti = {
    /**
     * Triggered after a map frame is rendered.
     * @event module:ol/MapEvent~MapEvent#postrender
     * @api
     */
    POSTRENDER: "postrender",
    /**
     * Triggered when the map starts moving.
     * @event module:ol/MapEvent~MapEvent#movestart
     * @api
     */
    MOVESTART: "movestart",
    /**
     * Triggered after the map is moved.
     * @event module:ol/MapEvent~MapEvent#moveend
     * @api
     */
    MOVEEND: "moveend",
    /**
     * Triggered when loading of additional map data (tiles, images, features) starts.
     * @event module:ol/MapEvent~MapEvent#loadstart
     * @api
     */
    LOADSTART: "loadstart",
    /**
     * Triggered when loading of additional map data has completed.
     * @event module:ol/MapEvent~MapEvent#loadend
     * @api
     */
    LOADEND: "loadend"
  }, re = {
    LAYERGROUP: "layergroup",
    SIZE: "size",
    TARGET: "target",
    VIEW: "view"
  }, ja = 1 / 0;
  class Rp {
    /**
     * @param {function(T): number} priorityFunction Priority function.
     * @param {function(T): string} keyFunction Key function.
     */
    constructor(t, e) {
      this.priorityFunction_ = t, this.keyFunction_ = e, this.elements_ = [], this.priorities_ = [], this.queuedElements_ = {};
    }
    /**
     * FIXME empty description for jsdoc
     */
    clear() {
      this.elements_.length = 0, this.priorities_.length = 0, Fr(this.queuedElements_);
    }
    /**
     * Remove and return the highest-priority element. O(log N).
     * @return {T} Element.
     */
    dequeue() {
      const t = this.elements_, e = this.priorities_, n = t[0];
      t.length == 1 ? (t.length = 0, e.length = 0) : (t[0] = /** @type {T} */
      t.pop(), e[0] = /** @type {number} */
      e.pop(), this.siftUp_(0));
      const s = this.keyFunction_(n);
      return delete this.queuedElements_[s], n;
    }
    /**
     * Enqueue an element. O(log N).
     * @param {T} element Element.
     * @return {boolean} The element was added to the queue.
     */
    enqueue(t) {
      Mt(
        !(this.keyFunction_(t) in this.queuedElements_),
        "Tried to enqueue an `element` that was already added to the queue"
      );
      const e = this.priorityFunction_(t);
      return e != ja ? (this.elements_.push(t), this.priorities_.push(e), this.queuedElements_[this.keyFunction_(t)] = !0, this.siftDown_(0, this.elements_.length - 1), !0) : !1;
    }
    /**
     * @return {number} Count.
     */
    getCount() {
      return this.elements_.length;
    }
    /**
     * Gets the index of the left child of the node at the given index.
     * @param {number} index The index of the node to get the left child for.
     * @return {number} The index of the left child.
     * @private
     */
    getLeftChildIndex_(t) {
      return t * 2 + 1;
    }
    /**
     * Gets the index of the right child of the node at the given index.
     * @param {number} index The index of the node to get the right child for.
     * @return {number} The index of the right child.
     * @private
     */
    getRightChildIndex_(t) {
      return t * 2 + 2;
    }
    /**
     * Gets the index of the parent of the node at the given index.
     * @param {number} index The index of the node to get the parent for.
     * @return {number} The index of the parent.
     * @private
     */
    getParentIndex_(t) {
      return t - 1 >> 1;
    }
    /**
     * Make this a heap. O(N).
     * @private
     */
    heapify_() {
      let t;
      for (t = (this.elements_.length >> 1) - 1; t >= 0; t--)
        this.siftUp_(t);
    }
    /**
     * @return {boolean} Is empty.
     */
    isEmpty() {
      return this.elements_.length === 0;
    }
    /**
     * @param {string} key Key.
     * @return {boolean} Is key queued.
     */
    isKeyQueued(t) {
      return t in this.queuedElements_;
    }
    /**
     * @param {T} element Element.
     * @return {boolean} Is queued.
     */
    isQueued(t) {
      return this.isKeyQueued(this.keyFunction_(t));
    }
    /**
     * @param {number} index The index of the node to move down.
     * @private
     */
    siftUp_(t) {
      const e = this.elements_, n = this.priorities_, s = e.length, r = e[t], a = n[t], o = t;
      for (; t < s >> 1; ) {
        const l = this.getLeftChildIndex_(t), h = this.getRightChildIndex_(t), c = h < s && n[h] < n[l] ? h : l;
        e[t] = e[c], n[t] = n[c], t = c;
      }
      e[t] = r, n[t] = a, this.siftDown_(o, t);
    }
    /**
     * @param {number} startIndex The index of the root.
     * @param {number} index The index of the node to move up.
     * @private
     */
    siftDown_(t, e) {
      const n = this.elements_, s = this.priorities_, r = n[e], a = s[e];
      for (; e > t; ) {
        const o = this.getParentIndex_(e);
        if (s[o] > a)
          n[e] = n[o], s[e] = s[o], e = o;
        else
          break;
      }
      n[e] = r, s[e] = a;
    }
    /**
     * FIXME empty description for jsdoc
     */
    reprioritize() {
      const t = this.priorityFunction_, e = this.elements_, n = this.priorities_;
      let s = 0;
      const r = e.length;
      let a, o, l;
      for (o = 0; o < r; ++o)
        a = e[o], l = t(a), l == ja ? delete this.queuedElements_[this.keyFunction_(a)] : (n[s] = l, e[s++] = a);
      e.length = s, n.length = s, this.heapify_();
    }
  }
  const V = {
    IDLE: 0,
    LOADING: 1,
    LOADED: 2,
    /**
     * Indicates that tile loading failed
     * @type {number}
     */
    ERROR: 3,
    EMPTY: 4
  };
  class Sp extends Rp {
    /**
     * @param {PriorityFunction} tilePriorityFunction Tile priority function.
     * @param {function(): ?} tileChangeCallback Function called on each tile change event.
     */
    constructor(t, e) {
      super(
        /**
         * @param {Array} element Element.
         * @return {number} Priority.
         */
        function(n) {
          return t.apply(null, n);
        },
        /**
         * @param {Array} element Element.
         * @return {string} Key.
         */
        function(n) {
          return (
            /** @type {import("./Tile.js").default} */
            n[0].getKey()
          );
        }
      ), this.boundHandleTileChange_ = this.handleTileChange.bind(this), this.tileChangeCallback_ = e, this.tilesLoading_ = 0, this.tilesLoadingKeys_ = {};
    }
    /**
     * @param {Array} element Element.
     * @return {boolean} The element was added to the queue.
     * @override
     */
    enqueue(t) {
      const e = super.enqueue(t);
      return e && t[0].addEventListener(ht.CHANGE, this.boundHandleTileChange_), e;
    }
    /**
     * @return {number} Number of tiles loading.
     */
    getTilesLoading() {
      return this.tilesLoading_;
    }
    /**
     * @param {import("./events/Event.js").default} event Event.
     * @protected
     */
    handleTileChange(t) {
      const e = (
        /** @type {import("./Tile.js").default} */
        t.target
      ), n = e.getState();
      if (n === V.LOADED || n === V.ERROR || n === V.EMPTY) {
        n !== V.ERROR && e.removeEventListener(ht.CHANGE, this.boundHandleTileChange_);
        const s = e.getKey();
        s in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[s], --this.tilesLoading_), this.tileChangeCallback_();
      }
    }
    /**
     * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
     * @param {number} maxNewLoads Maximum number of new tiles to load.
     */
    loadMoreTiles(t, e) {
      let n = 0;
      for (; this.tilesLoading_ < t && n < e && this.getCount() > 0; ) {
        const s = this.dequeue()[0], r = s.getKey();
        s.getState() === V.IDLE && !(r in this.tilesLoadingKeys_) && (this.tilesLoadingKeys_[r] = !0, ++this.tilesLoading_, ++n, s.load());
      }
    }
  }
  function Cp(i, t, e, n, s) {
    if (!i || !(e in i.wantedTiles) || !i.wantedTiles[e][t.getKey()])
      return ja;
    const r = i.viewState.center, a = n[0] - r[0], o = n[1] - r[1];
    return 65536 * Math.log(s) + Math.sqrt(a * a + o * o) / s;
  }
  class qh extends si {
    /**
     * @param {Options} options Control options.
     */
    constructor(t) {
      super();
      const e = t.element;
      e && !t.target && !e.style.pointerEvents && (e.style.pointerEvents = "auto"), this.element = e || null, this.target_ = null, this.map_ = null, this.listenerKeys = [], t.render && (this.render = t.render), t.target && this.setTarget(t.target);
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      var t;
      (t = this.element) == null || t.remove(), super.disposeInternal();
    }
    /**
     * Get the map associated with this control.
     * @return {import("../Map.js").default|null} Map.
     * @api
     */
    getMap() {
      return this.map_;
    }
    /**
     * Remove the control from its current map and attach it to the new map.
     * Pass `null` to just remove the control from the current map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../Map.js").default|null} map Map.
     * @api
     */
    setMap(t) {
      var e;
      this.map_ && ((e = this.element) == null || e.remove());
      for (let n = 0, s = this.listenerKeys.length; n < s; ++n)
        bt(this.listenerKeys[n]);
      if (this.listenerKeys.length = 0, this.map_ = t, t) {
        const n = this.target_ ?? t.getOverlayContainerStopEvent();
        this.element && n.appendChild(this.element), this.render !== Is && this.listenerKeys.push(
          xt(t, Ti.POSTRENDER, this.render, this)
        ), t.render();
      }
    }
    /**
     * Renders the control.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @api
     */
    render(t) {
    }
    /**
     * This function is used to set a target element for the control. It has no
     * effect if it is called after the control has been added to the map (i.e.
     * after `setMap` is called on the control). If no `target` is set in the
     * options passed to the control constructor and if `setTarget` is not called
     * then the control is added to the map's overlay container.
     * @param {HTMLElement|string} target Target.
     * @api
     */
    setTarget(t) {
      this.target_ = typeof t == "string" ? document.getElementById(t) : t;
    }
  }
  class Tp extends qh {
    /**
     * @param {Options} [options] Attribution options.
     */
    constructor(t) {
      t = t || {}, super({
        element: document.createElement("div"),
        render: t.render,
        target: t.target
      }), this.ulElement_ = document.createElement("ul"), this.collapsed_ = t.collapsed !== void 0 ? t.collapsed : !0, this.userCollapsed_ = this.collapsed_, this.overrideCollapsible_ = t.collapsible !== void 0, this.collapsible_ = t.collapsible !== void 0 ? t.collapsible : !0, this.collapsible_ || (this.collapsed_ = !1), this.attributions_ = t.attributions;
      const e = t.className !== void 0 ? t.className : "ol-attribution", n = t.tipLabel !== void 0 ? t.tipLabel : "Attributions", s = t.expandClassName !== void 0 ? t.expandClassName : e + "-expand", r = t.collapseLabel !== void 0 ? t.collapseLabel : "", a = t.collapseClassName !== void 0 ? t.collapseClassName : e + "-collapse";
      typeof r == "string" ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = r, this.collapseLabel_.className = a) : this.collapseLabel_ = r;
      const o = t.label !== void 0 ? t.label : "i";
      typeof o == "string" ? (this.label_ = document.createElement("span"), this.label_.textContent = o, this.label_.className = s) : this.label_ = o;
      const l = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
      this.toggleButton_ = document.createElement("button"), this.toggleButton_.setAttribute("type", "button"), this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_)), this.toggleButton_.title = n, this.toggleButton_.appendChild(l), this.toggleButton_.addEventListener(
        ht.CLICK,
        this.handleClick_.bind(this),
        !1
      );
      const h = e + " " + Ao + " " + Wh + (this.collapsed_ && this.collapsible_ ? " " + lu : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), c = this.element;
      c.className = h, c.appendChild(this.toggleButton_), c.appendChild(this.ulElement_), this.renderedAttributions_ = [], this.renderedVisible_ = !0;
    }
    /**
     * Collect a list of visible attributions and set the collapsible state.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @return {Array<string>} Attributions.
     * @private
     */
    collectSourceAttributions_(t) {
      const e = this.getMap().getAllLayers(), n = new Set(
        e.flatMap((s) => s.getAttributions(t))
      );
      if (this.attributions_ !== void 0 && (Array.isArray(this.attributions_) ? this.attributions_.forEach((s) => n.add(s)) : n.add(this.attributions_)), !this.overrideCollapsible_) {
        const s = !e.some(
          (r) => {
            var a;
            return ((a = r.getSource()) == null ? void 0 : a.getAttributionsCollapsible()) === !1;
          }
        );
        this.setCollapsible(s);
      }
      return Array.from(n);
    }
    /**
     * @private
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     */
    async updateElement_(t) {
      if (!t) {
        this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1);
        return;
      }
      const e = await Promise.all(
        this.collectSourceAttributions_(t).map(
          (s) => I0(() => s)
        )
      ), n = e.length > 0;
      if (this.renderedVisible_ != n && (this.element.style.display = n ? "" : "none", this.renderedVisible_ = n), !fn(e, this.renderedAttributions_)) {
        Jd(this.ulElement_);
        for (let s = 0, r = e.length; s < r; ++s) {
          const a = document.createElement("li");
          a.innerHTML = e[s], this.ulElement_.appendChild(a);
        }
        this.renderedAttributions_ = e;
      }
    }
    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */
    handleClick_(t) {
      t.preventDefault(), this.handleToggle_(), this.userCollapsed_ = this.collapsed_;
    }
    /**
     * @private
     */
    handleToggle_() {
      this.element.classList.toggle(lu), this.collapsed_ ? au(this.collapseLabel_, this.label_) : au(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_, this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
    }
    /**
     * Return `true` if the attribution is collapsible, `false` otherwise.
     * @return {boolean} True if the widget is collapsible.
     * @api
     */
    getCollapsible() {
      return this.collapsible_;
    }
    /**
     * Set whether the attribution should be collapsible.
     * @param {boolean} collapsible True if the widget is collapsible.
     * @api
     */
    setCollapsible(t) {
      this.collapsible_ !== t && (this.collapsible_ = t, this.element.classList.toggle("ol-uncollapsible"), this.userCollapsed_ && this.handleToggle_());
    }
    /**
     * Collapse or expand the attribution according to the passed parameter. Will
     * not do anything if the attribution isn't collapsible or if the current
     * collapsed state is already the one requested.
     * @param {boolean} collapsed True if the widget is collapsed.
     * @api
     */
    setCollapsed(t) {
      this.userCollapsed_ = t, !(!this.collapsible_ || this.collapsed_ === t) && this.handleToggle_();
    }
    /**
     * Return `true` when the attribution is currently collapsed or `false`
     * otherwise.
     * @return {boolean} True if the widget is collapsed.
     * @api
     */
    getCollapsed() {
      return this.collapsed_;
    }
    /**
     * Update the attribution element.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @override
     */
    render(t) {
      this.updateElement_(t.frameState);
    }
  }
  class Ip extends qh {
    /**
     * @param {Options} [options] Rotate options.
     */
    constructor(t) {
      t = t || {}, super({
        element: document.createElement("div"),
        render: t.render,
        target: t.target
      });
      const e = t.className !== void 0 ? t.className : "ol-rotate", n = t.label !== void 0 ? t.label : "", s = t.compassClassName !== void 0 ? t.compassClassName : "ol-compass";
      this.label_ = null, typeof n == "string" ? (this.label_ = document.createElement("span"), this.label_.className = s, this.label_.textContent = n) : (this.label_ = n, this.label_.classList.add(s));
      const r = t.tipLabel ? t.tipLabel : "Reset rotation", a = document.createElement("button");
      a.className = e + "-reset", a.setAttribute("type", "button"), a.title = r, a.appendChild(this.label_), a.addEventListener(
        ht.CLICK,
        this.handleClick_.bind(this),
        !1
      );
      const o = e + " " + Ao + " " + Wh, l = this.element;
      l.className = o, l.appendChild(a), this.callResetNorth_ = t.resetNorth ? t.resetNorth : void 0, this.duration_ = t.duration !== void 0 ? t.duration : 250, this.autoHide_ = t.autoHide !== void 0 ? t.autoHide : !0, this.rotation_ = void 0, this.autoHide_ && this.element.classList.add(va);
    }
    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */
    handleClick_(t) {
      t.preventDefault(), this.callResetNorth_ !== void 0 ? this.callResetNorth_() : this.resetNorth_();
    }
    /**
     * @private
     */
    resetNorth_() {
      const e = this.getMap().getView();
      if (!e)
        return;
      const n = e.getRotation();
      n !== void 0 && (this.duration_ > 0 && n % (2 * Math.PI) !== 0 ? e.animate({
        rotation: 0,
        duration: this.duration_,
        easing: Bs
      }) : e.setRotation(0));
    }
    /**
     * Update the rotate control element.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @override
     */
    render(t) {
      const e = t.frameState;
      if (!e)
        return;
      const n = e.viewState.rotation;
      if (n != this.rotation_) {
        const s = "rotate(" + n + "rad)";
        if (this.autoHide_) {
          const r = this.element.classList.contains(va);
          !r && n === 0 ? this.element.classList.add(va) : r && n !== 0 && this.element.classList.remove(va);
        }
        this.label_.style.transform = s;
      }
      this.rotation_ = n;
    }
  }
  class Ap extends qh {
    /**
     * @param {Options} [options] Zoom options.
     */
    constructor(t) {
      t = t || {}, super({
        element: document.createElement("div"),
        target: t.target
      });
      const e = t.className !== void 0 ? t.className : "ol-zoom", n = t.delta !== void 0 ? t.delta : 1, s = t.zoomInClassName !== void 0 ? t.zoomInClassName : e + "-in", r = t.zoomOutClassName !== void 0 ? t.zoomOutClassName : e + "-out", a = t.zoomInLabel !== void 0 ? t.zoomInLabel : "+", o = t.zoomOutLabel !== void 0 ? t.zoomOutLabel : "", l = t.zoomInTipLabel !== void 0 ? t.zoomInTipLabel : "Zoom in", h = t.zoomOutTipLabel !== void 0 ? t.zoomOutTipLabel : "Zoom out", c = document.createElement("button");
      c.className = s, c.setAttribute("type", "button"), c.title = l, c.appendChild(
        typeof a == "string" ? document.createTextNode(a) : a
      ), c.addEventListener(
        ht.CLICK,
        this.handleClick_.bind(this, n),
        !1
      );
      const u = document.createElement("button");
      u.className = r, u.setAttribute("type", "button"), u.title = h, u.appendChild(
        typeof o == "string" ? document.createTextNode(o) : o
      ), u.addEventListener(
        ht.CLICK,
        this.handleClick_.bind(this, -n),
        !1
      );
      const d = e + " " + Ao + " " + Wh, m = this.element;
      m.className = d, m.appendChild(c), m.appendChild(u), this.duration_ = t.duration !== void 0 ? t.duration : 250;
    }
    /**
     * @param {number} delta Zoom delta.
     * @param {MouseEvent} event The event to handle
     * @private
     */
    handleClick_(t, e) {
      e.preventDefault(), this.zoomByDelta_(t);
    }
    /**
     * @param {number} delta Zoom delta.
     * @private
     */
    zoomByDelta_(t) {
      const n = this.getMap().getView();
      if (!n)
        return;
      const s = n.getZoom();
      if (s !== void 0) {
        const r = n.getConstrainedZoom(s + t);
        this.duration_ > 0 ? (n.getAnimating() && n.cancelAnimations(), n.animate({
          zoom: r,
          duration: this.duration_,
          easing: Bs
        })) : n.setZoom(r);
      }
    }
  }
  function Pp(i) {
    i = i || {};
    const t = new hi();
    return (i.zoom !== void 0 ? i.zoom : !0) && t.push(new Ap(i.zoomOptions)), (i.rotate !== void 0 ? i.rotate : !0) && t.push(new Ip(i.rotateOptions)), (i.attribution !== void 0 ? i.attribution : !0) && t.push(new Tp(i.attributionOptions)), t;
  }
  const xu = {
    ACTIVE: "active"
  };
  class Zr extends si {
    /**
     * @param {InteractionOptions} [options] Options.
     */
    constructor(t) {
      super(), this.on, this.once, this.un, t && t.handleEvent && (this.handleEvent = t.handleEvent), this.map_ = null, this.setActive(!0);
    }
    /**
     * Return whether the interaction is currently active.
     * @return {boolean} `true` if the interaction is active, `false` otherwise.
     * @observable
     * @api
     */
    getActive() {
      return (
        /** @type {boolean} */
        this.get(xu.ACTIVE)
      );
    }
    /**
     * Get the map associated with this interaction.
     * @return {import("../Map.js").default|null} Map.
     * @api
     */
    getMap() {
      return this.map_;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @api
     */
    handleEvent(t) {
      return !0;
    }
    /**
     * Activate or deactivate the interaction.
     * @param {boolean} active Active.
     * @observable
     * @api
     */
    setActive(t) {
      this.set(xu.ACTIVE, t);
    }
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../Map.js").default|null} map Map.
     */
    setMap(t) {
      this.map_ = t;
    }
  }
  function bp(i, t, e) {
    const n = i.getCenterInternal();
    if (n) {
      const s = [n[0] + t[0], n[1] + t[1]];
      i.animateInternal({
        duration: e !== void 0 ? e : 250,
        easing: Im,
        center: i.getConstrainedCenter(s)
      });
    }
  }
  function Kh(i, t, e, n) {
    const s = i.getZoom();
    if (s === void 0)
      return;
    const r = i.getConstrainedZoom(s + t), a = i.getResolutionForZoom(r);
    i.getAnimating() && i.cancelAnimations(), i.animate({
      resolution: a,
      anchor: e,
      duration: n !== void 0 ? n : 250,
      easing: Bs
    });
  }
  class Lp extends Zr {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      super(), t = t || {}, this.delta_ = t.delta ? t.delta : 1, this.duration_ = t.duration !== void 0 ? t.duration : 250;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
     * doubleclick) and eventually zooms the map.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @override
     */
    handleEvent(t) {
      let e = !1;
      if (t.type == zt.DBLCLICK) {
        const n = (
          /** @type {MouseEvent} */
          t.originalEvent
        ), s = t.map, r = t.coordinate, a = n.shiftKey ? -this.delta_ : this.delta_, o = s.getView();
        Kh(o, a, r, this.duration_), n.preventDefault(), e = !0;
      }
      return !e;
    }
  }
  class qr extends Zr {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      t = t || {}, super(
        /** @type {import("./Interaction.js").InteractionOptions} */
        t
      ), t.handleDownEvent && (this.handleDownEvent = t.handleDownEvent), t.handleDragEvent && (this.handleDragEvent = t.handleDragEvent), t.handleMoveEvent && (this.handleMoveEvent = t.handleMoveEvent), t.handleUpEvent && (this.handleUpEvent = t.handleUpEvent), t.stopDown && (this.stopDown = t.stopDown), this.handlingDownUpSequence = !1, this.targetPointers = [];
    }
    /**
     * Returns the current number of pointers involved in the interaction,
     * e.g. `2` when two fingers are used.
     * @return {number} The number of pointers.
     * @api
     */
    getPointerCount() {
      return this.targetPointers.length;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @protected
     */
    handleDownEvent(t) {
      return !1;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @protected
     */
    handleDragEvent(t) {
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
     * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
     * detected.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @api
     * @override
     */
    handleEvent(t) {
      if (!t.originalEvent)
        return !0;
      let e = !1;
      if (this.updateTrackedPointers_(t), this.handlingDownUpSequence) {
        if (t.type == zt.POINTERDRAG)
          this.handleDragEvent(t), t.originalEvent.preventDefault();
        else if (t.type == zt.POINTERUP) {
          const n = this.handleUpEvent(t);
          this.handlingDownUpSequence = n && this.targetPointers.length > 0;
        }
      } else if (t.type == zt.POINTERDOWN) {
        const n = this.handleDownEvent(t);
        this.handlingDownUpSequence = n, e = this.stopDown(n);
      } else t.type == zt.POINTERMOVE && this.handleMoveEvent(t);
      return !e;
    }
    /**
     * Handle pointer move events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @protected
     */
    handleMoveEvent(t) {
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @protected
     */
    handleUpEvent(t) {
      return !1;
    }
    /**
     * This function is used to determine if "down" events should be propagated
     * to other interactions or should be stopped.
     * @param {boolean} handled Was the event handled by the interaction?
     * @return {boolean} Should the `down` event be stopped?
     */
    stopDown(t) {
      return t;
    }
    /**
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @private
     */
    updateTrackedPointers_(t) {
      t.activePointers && (this.targetPointers = t.activePointers);
    }
  }
  function jh(i) {
    const t = i.length;
    let e = 0, n = 0;
    for (let s = 0; s < t; s++)
      e += i[s].clientX, n += i[s].clientY;
    return { clientX: e / t, clientY: n / t };
  }
  function Bl(i) {
    const t = arguments;
    return function(e) {
      let n = !0;
      for (let s = 0, r = t.length; s < r && (n = n && t[s](e), !!n); ++s)
        ;
      return n;
    };
  }
  const Op = function(i) {
    const t = (
      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
      i.originalEvent
    );
    return t.altKey && !(t.metaKey || t.ctrlKey) && t.shiftKey;
  }, Np = function(i) {
    const t = i.map.getTargetElement(), e = t.getRootNode(), n = i.map.getOwnerDocument().activeElement;
    return e instanceof ShadowRoot ? e.host.contains(n) : t.contains(n);
  }, ff = function(i) {
    const t = i.map.getTargetElement(), e = t.getRootNode();
    return (e instanceof ShadowRoot ? e.host : t).hasAttribute("tabindex") ? Np(i) : !0;
  }, Fp = xr, gf = function(i) {
    const t = (
      /** @type {MouseEvent} */
      i.originalEvent
    );
    return t.button == 0 && !(Hd && Uh && t.ctrlKey);
  }, mf = function(i) {
    const t = (
      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
      i.originalEvent
    );
    return !t.altKey && !(t.metaKey || t.ctrlKey) && !t.shiftKey;
  }, Dp = function(i) {
    const t = (
      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
      i.originalEvent
    );
    return Uh ? t.metaKey : t.ctrlKey;
  }, kp = function(i) {
    const t = (
      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
      i.originalEvent
    );
    return !t.altKey && !(t.metaKey || t.ctrlKey) && t.shiftKey;
  }, _f = function(i) {
    const t = (
      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
      i.originalEvent
    ), e = (
      /** @type {Element} */
      t.target.tagName
    );
    return e !== "INPUT" && e !== "SELECT" && e !== "TEXTAREA" && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
    // different type like `SVGElement`.
    // @ts-ignore
    !t.target.isContentEditable;
  }, cl = function(i) {
    const t = (
      /** @type {import("../MapBrowserEvent").default} */
      i.originalEvent
    );
    return Mt(
      t !== void 0,
      "mapBrowserEvent must originate from a pointer event"
    ), t.pointerType == "mouse";
  }, Gp = function(i) {
    const t = (
      /** @type {import("../MapBrowserEvent").default} */
      i.originalEvent
    );
    return Mt(
      t !== void 0,
      "mapBrowserEvent must originate from a pointer event"
    ), t.isPrimary && t.button === 0;
  };
  class Up extends qr {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      super({
        stopDown: co
      }), t = t || {}, this.kinetic_ = t.kinetic, this.lastCentroid = null, this.lastPointersCount_, this.panning_ = !1;
      const e = t.condition ? t.condition : Bl(mf, Gp);
      this.condition_ = t.onFocusOnly ? Bl(ff, e) : e, this.noKinetic_ = !1;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @override
     */
    handleDragEvent(t) {
      const e = t.map;
      this.panning_ || (this.panning_ = !0, e.getView().beginInteraction());
      const n = this.targetPointers, s = e.getEventPixel(jh(n));
      if (n.length == this.lastPointersCount_) {
        if (this.kinetic_ && this.kinetic_.update(s[0], s[1]), this.lastCentroid) {
          const r = [
            this.lastCentroid[0] - s[0],
            s[1] - this.lastCentroid[1]
          ], o = t.map.getView();
          J0(r, o.getResolution()), mh(r, o.getRotation()), o.adjustCenterInternal(r);
        }
      } else this.kinetic_ && this.kinetic_.begin();
      this.lastCentroid = s, this.lastPointersCount_ = n.length, t.originalEvent.preventDefault();
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleUpEvent(t) {
      const e = t.map, n = e.getView();
      if (this.targetPointers.length === 0) {
        if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
          const s = this.kinetic_.getDistance(), r = this.kinetic_.getAngle(), a = n.getCenterInternal(), o = e.getPixelFromCoordinateInternal(a), l = e.getCoordinateFromPixelInternal([
            o[0] - s * Math.cos(r),
            o[1] - s * Math.sin(r)
          ]);
          n.animateInternal({
            center: n.getConstrainedCenter(l),
            duration: 500,
            easing: Bs
          });
        }
        return this.panning_ && (this.panning_ = !1, n.endInteraction()), !1;
      }
      return this.kinetic_ && this.kinetic_.begin(), this.lastCentroid = null, !0;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleDownEvent(t) {
      if (this.targetPointers.length > 0 && this.condition_(t)) {
        const n = t.map.getView();
        return this.lastCentroid = null, n.getAnimating() && n.cancelAnimations(), this.kinetic_ && this.kinetic_.begin(), this.noKinetic_ = this.targetPointers.length > 1, !0;
      }
      return !1;
    }
  }
  class zp extends qr {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      t = t || {}, super({
        stopDown: co
      }), this.condition_ = t.condition ? t.condition : Op, this.lastAngle_ = void 0, this.duration_ = t.duration !== void 0 ? t.duration : 250;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @override
     */
    handleDragEvent(t) {
      if (!cl(t))
        return;
      const e = t.map, n = e.getView();
      if (n.getConstraints().rotation === wh)
        return;
      const s = e.getSize(), r = t.pixel, a = Math.atan2(s[1] / 2 - r[1], r[0] - s[0] / 2);
      if (this.lastAngle_ !== void 0) {
        const o = a - this.lastAngle_;
        n.adjustRotationInternal(-o);
      }
      this.lastAngle_ = a;
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleUpEvent(t) {
      return cl(t) ? (t.map.getView().endInteraction(this.duration_), !1) : !0;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleDownEvent(t) {
      return cl(t) && gf(t) && this.condition_(t) ? (t.map.getView().beginInteraction(), this.lastAngle_ = void 0, !0) : !1;
    }
  }
  class Bp extends ho {
    /**
     * @param {string} className CSS class name.
     */
    constructor(t) {
      super(), this.geometry_ = null, this.element_ = document.createElement("div"), this.element_.style.position = "absolute", this.element_.style.pointerEvents = "auto", this.element_.className = "ol-box " + t, this.map_ = null, this.startPixel_ = null, this.endPixel_ = null;
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.setMap(null);
    }
    /**
     * @private
     */
    render_() {
      const t = this.startPixel_, e = this.endPixel_, n = "px", s = this.element_.style;
      s.left = Math.min(t[0], e[0]) + n, s.top = Math.min(t[1], e[1]) + n, s.width = Math.abs(e[0] - t[0]) + n, s.height = Math.abs(e[1] - t[1]) + n;
    }
    /**
     * @param {import("../Map.js").default|null} map Map.
     */
    setMap(t) {
      if (this.map_) {
        this.map_.getOverlayContainer().removeChild(this.element_);
        const e = this.element_.style;
        e.left = "inherit", e.top = "inherit", e.width = "inherit", e.height = "inherit";
      }
      this.map_ = t, this.map_ && this.map_.getOverlayContainer().appendChild(this.element_);
    }
    /**
     * @param {import("../pixel.js").Pixel} startPixel Start pixel.
     * @param {import("../pixel.js").Pixel} endPixel End pixel.
     */
    setPixels(t, e) {
      this.startPixel_ = t, this.endPixel_ = e, this.createOrUpdateGeometry(), this.render_();
    }
    /**
     * Creates or updates the cached geometry.
     */
    createOrUpdateGeometry() {
      if (!this.map_)
        return;
      const t = this.startPixel_, e = this.endPixel_, s = [
        t,
        [t[0], e[1]],
        e,
        [e[0], t[1]]
      ].map(
        this.map_.getCoordinateFromPixelInternal,
        this.map_
      );
      s[4] = s[0].slice(), this.geometry_ ? this.geometry_.setCoordinates([s]) : this.geometry_ = new gi([s]);
    }
    /**
     * @return {import("../geom/Polygon.js").default} Geometry.
     */
    getGeometry() {
      return this.geometry_;
    }
  }
  const Qn = {
    /**
     * Triggered upon drag box start.
     * @event DragBoxEvent#boxstart
     * @api
     */
    BOXSTART: "boxstart",
    /**
     * Triggered on drag when box is active.
     * @event DragBoxEvent#boxdrag
     * @api
     */
    BOXDRAG: "boxdrag",
    /**
     * Triggered upon drag box end.
     * @event DragBoxEvent#boxend
     * @api
     */
    BOXEND: "boxend",
    /**
     * Triggered upon drag box canceled.
     * @event DragBoxEvent#boxcancel
     * @api
     */
    BOXCANCEL: "boxcancel"
  };
  class Js extends Oi {
    /**
     * @param {string} type The event type.
     * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
     */
    constructor(t, e, n) {
      super(t), this.coordinate = e, this.mapBrowserEvent = n;
    }
  }
  class $p extends qr {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      super(), this.on, this.once, this.un, t = t ?? {}, this.box_ = new Bp(t.className || "ol-dragbox"), this.minArea_ = t.minArea ?? 64, t.onBoxEnd && (this.onBoxEnd = t.onBoxEnd), this.startPixel_ = null, this.condition_ = t.condition ?? gf, this.boxEndCondition_ = t.boxEndCondition ?? this.defaultBoxEndCondition;
    }
    /**
     * The default condition for determining whether the boxend event
     * should fire.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
     *     leading to the box end.
     * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
     * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
     * @return {boolean} Whether or not the boxend condition should be fired.
     */
    defaultBoxEndCondition(t, e, n) {
      const s = n[0] - e[0], r = n[1] - e[1];
      return s * s + r * r >= this.minArea_;
    }
    /**
     * Returns geometry of last drawn box.
     * @return {import("../geom/Polygon.js").default} Geometry.
     * @api
     */
    getGeometry() {
      return this.box_.getGeometry();
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @override
     */
    handleDragEvent(t) {
      this.startPixel_ && (this.box_.setPixels(this.startPixel_, t.pixel), this.dispatchEvent(
        new Js(
          Qn.BOXDRAG,
          t.coordinate,
          t
        )
      ));
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleUpEvent(t) {
      if (!this.startPixel_)
        return !1;
      const e = this.boxEndCondition_(
        t,
        this.startPixel_,
        t.pixel
      );
      return e && this.onBoxEnd(t), this.dispatchEvent(
        new Js(
          e ? Qn.BOXEND : Qn.BOXCANCEL,
          t.coordinate,
          t
        )
      ), this.box_.setMap(null), this.startPixel_ = null, !1;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleDownEvent(t) {
      return this.condition_(t) ? (this.startPixel_ = t.pixel, this.box_.setMap(t.map), this.box_.setPixels(this.startPixel_, this.startPixel_), this.dispatchEvent(
        new Js(
          Qn.BOXSTART,
          t.coordinate,
          t
        )
      ), !0) : !1;
    }
    /**
     * Function to execute just before `onboxend` is fired
     * @param {import("../MapBrowserEvent.js").default} event Event.
     */
    onBoxEnd(t) {
    }
    /**
     * Activate or deactivate the interaction.
     * @param {boolean} active Active.
     * @observable
     * @api
     * @override
     */
    setActive(t) {
      t || (this.box_.setMap(null), this.startPixel_ && (this.dispatchEvent(
        new Js(Qn.BOXCANCEL, this.startPixel_, null)
      ), this.startPixel_ = null)), super.setActive(t);
    }
    /**
     * @param {import("../Map.js").default|null} map Map.
     * @override
     */
    setMap(t) {
      this.getMap() && (this.box_.setMap(null), this.startPixel_ && (this.dispatchEvent(
        new Js(Qn.BOXCANCEL, this.startPixel_, null)
      ), this.startPixel_ = null)), super.setMap(t);
    }
  }
  class Xp extends $p {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      t = t || {};
      const e = t.condition ? t.condition : kp;
      super({
        condition: e,
        className: t.className || "ol-dragzoom",
        minArea: t.minArea
      }), this.duration_ = t.duration !== void 0 ? t.duration : 200, this.out_ = t.out !== void 0 ? t.out : !1;
    }
    /**
     * Function to execute just before `onboxend` is fired
     * @param {import("../MapBrowserEvent.js").default} event Event.
     * @override
     */
    onBoxEnd(t) {
      const n = (
        /** @type {!import("../View.js").default} */
        this.getMap().getView()
      );
      let s = this.getGeometry();
      if (this.out_) {
        const r = n.rotatedExtentForGeometry(s), a = n.getResolutionForExtentInternal(r), o = n.getResolution() / a;
        s = s.clone(), s.scale(o * o);
      }
      n.fitInternal(s, {
        duration: this.duration_,
        easing: Bs
      });
    }
  }
  const wn = {
    LEFT: "ArrowLeft",
    UP: "ArrowUp",
    RIGHT: "ArrowRight",
    DOWN: "ArrowDown"
  };
  class Wp extends Zr {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      super(), t = t || {}, this.defaultCondition_ = function(e) {
        return mf(e) && _f(e);
      }, this.condition_ = t.condition !== void 0 ? t.condition : this.defaultCondition_, this.duration_ = t.duration !== void 0 ? t.duration : 100, this.pixelDelta_ = t.pixelDelta !== void 0 ? t.pixelDelta : 128;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
     * `KeyEvent`, and decides the direction to pan to (if an arrow key was
     * pressed).
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @override
     */
    handleEvent(t) {
      let e = !1;
      if (t.type == ht.KEYDOWN) {
        const n = (
          /** @type {KeyboardEvent} */
          t.originalEvent
        ), s = n.key;
        if (this.condition_(t) && (s == wn.DOWN || s == wn.LEFT || s == wn.RIGHT || s == wn.UP)) {
          const a = t.map.getView(), o = a.getResolution() * this.pixelDelta_;
          let l = 0, h = 0;
          s == wn.DOWN ? h = -o : s == wn.LEFT ? l = -o : s == wn.RIGHT ? l = o : h = o;
          const c = [l, h];
          mh(c, a.getRotation()), bp(a, c, this.duration_), n.preventDefault(), e = !0;
        }
      }
      return !e;
    }
  }
  class Yp extends Zr {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      super(), t = t || {}, this.condition_ = t.condition ? t.condition : function(e) {
        return !Dp(e) && _f(e);
      }, this.delta_ = t.delta ? t.delta : 1, this.duration_ = t.duration !== void 0 ? t.duration : 100;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
     * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
     * key pressed was '+' or '-').
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @override
     */
    handleEvent(t) {
      let e = !1;
      if (t.type == ht.KEYDOWN || t.type == ht.KEYPRESS) {
        const n = (
          /** @type {KeyboardEvent} */
          t.originalEvent
        ), s = n.key;
        if (this.condition_(t) && (s === "+" || s === "-")) {
          const r = t.map, a = s === "+" ? this.delta_ : -this.delta_, o = r.getView();
          Kh(o, a, void 0, this.duration_), n.preventDefault(), e = !0;
        }
      }
      return !e;
    }
  }
  class Zp {
    /**
     * @param {number} decay Rate of decay (must be negative).
     * @param {number} minVelocity Minimum velocity (pixels/millisecond).
     * @param {number} delay Delay to consider to calculate the kinetic
     *     initial values (milliseconds).
     */
    constructor(t, e, n) {
      this.decay_ = t, this.minVelocity_ = e, this.delay_ = n, this.points_ = [], this.angle_ = 0, this.initialVelocity_ = 0;
    }
    /**
     * FIXME empty description for jsdoc
     */
    begin() {
      this.points_.length = 0, this.angle_ = 0, this.initialVelocity_ = 0;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     */
    update(t, e) {
      this.points_.push(t, e, Date.now());
    }
    /**
     * @return {boolean} Whether we should do kinetic animation.
     */
    end() {
      if (this.points_.length < 6)
        return !1;
      const t = Date.now() - this.delay_, e = this.points_.length - 3;
      if (this.points_[e + 2] < t)
        return !1;
      let n = e - 3;
      for (; n > 0 && this.points_[n + 2] > t; )
        n -= 3;
      const s = this.points_[e + 2] - this.points_[n + 2];
      if (s < 1e3 / 60)
        return !1;
      const r = this.points_[e] - this.points_[n], a = this.points_[e + 1] - this.points_[n + 1];
      return this.angle_ = Math.atan2(a, r), this.initialVelocity_ = Math.sqrt(r * r + a * a) / s, this.initialVelocity_ > this.minVelocity_;
    }
    /**
     * @return {number} Total distance travelled (pixels).
     */
    getDistance() {
      return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
    }
    /**
     * @return {number} Angle of the kinetic panning animation (radians).
     */
    getAngle() {
      return this.angle_;
    }
  }
  class qp extends Zr {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      t = t || {}, super(
        /** @type {import("./Interaction.js").InteractionOptions} */
        t
      ), this.totalDelta_ = 0, this.lastDelta_ = 0, this.maxDelta_ = t.maxDelta !== void 0 ? t.maxDelta : 1, this.duration_ = t.duration !== void 0 ? t.duration : 250, this.timeout_ = t.timeout !== void 0 ? t.timeout : 80, this.useAnchor_ = t.useAnchor !== void 0 ? t.useAnchor : !0, this.constrainResolution_ = t.constrainResolution !== void 0 ? t.constrainResolution : !1;
      const e = t.condition ? t.condition : Fp;
      this.condition_ = t.onFocusOnly ? Bl(ff, e) : e, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_, this.mode_ = void 0, this.trackpadEventGap_ = 400, this.trackpadTimeoutId_, this.deltaPerZoom_ = 300;
    }
    /**
     * @private
     */
    endInteraction_() {
      this.trackpadTimeoutId_ = void 0;
      const t = this.getMap();
      if (!t)
        return;
      t.getView().endInteraction(
        void 0,
        this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0,
        this.lastAnchor_ ? t.getCoordinateFromPixel(this.lastAnchor_) : null
      );
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
     * zooms the map.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @override
     */
    handleEvent(t) {
      if (!this.condition_(t) || t.type !== ht.WHEEL)
        return !0;
      const n = t.map, s = (
        /** @type {WheelEvent} */
        t.originalEvent
      );
      s.preventDefault(), this.useAnchor_ && (this.lastAnchor_ = t.pixel);
      let r;
      if (t.type == ht.WHEEL && (r = s.deltaY, jd && s.deltaMode === WheelEvent.DOM_DELTA_PIXEL && (r /= Co), s.deltaMode === WheelEvent.DOM_DELTA_LINE && (r *= 40)), r === 0)
        return !1;
      this.lastDelta_ = r;
      const a = Date.now();
      this.startTime_ === void 0 && (this.startTime_ = a), (!this.mode_ || a - this.startTime_ > this.trackpadEventGap_) && (this.mode_ = Math.abs(r) < 4 ? "trackpad" : "wheel");
      const o = n.getView();
      if (this.mode_ === "trackpad" && !(o.getConstrainResolution() || this.constrainResolution_))
        return this.trackpadTimeoutId_ ? clearTimeout(this.trackpadTimeoutId_) : (o.getAnimating() && o.cancelAnimations(), o.beginInteraction()), this.trackpadTimeoutId_ = setTimeout(
          this.endInteraction_.bind(this),
          this.timeout_
        ), o.adjustZoom(
          -r / this.deltaPerZoom_,
          this.lastAnchor_ ? n.getCoordinateFromPixel(this.lastAnchor_) : null
        ), this.startTime_ = a, !1;
      this.totalDelta_ += r;
      const l = Math.max(this.timeout_ - (a - this.startTime_), 0);
      return clearTimeout(this.timeoutId_), this.timeoutId_ = setTimeout(
        this.handleWheelZoom_.bind(this, n),
        l
      ), !1;
    }
    /**
     * @private
     * @param {import("../Map.js").default} map Map.
     */
    handleWheelZoom_(t) {
      const e = t.getView();
      e.getAnimating() && e.cancelAnimations();
      let n = -Gt(
        this.totalDelta_,
        -this.maxDelta_ * this.deltaPerZoom_,
        this.maxDelta_ * this.deltaPerZoom_
      ) / this.deltaPerZoom_;
      (e.getConstrainResolution() || this.constrainResolution_) && (n = n ? n > 0 ? 1 : -1 : 0), Kh(
        e,
        n,
        this.lastAnchor_ ? t.getCoordinateFromPixel(this.lastAnchor_) : null,
        this.duration_
      ), this.mode_ = void 0, this.totalDelta_ = 0, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_ = void 0;
    }
    /**
     * Enable or disable using the mouse's location as an anchor when zooming
     * @param {boolean} useAnchor true to zoom to the mouse's location, false
     * to zoom to the center of the map
     * @api
     */
    setMouseAnchor(t) {
      this.useAnchor_ = t, t || (this.lastAnchor_ = null);
    }
  }
  class Kp extends qr {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      t = t || {};
      const e = (
        /** @type {import("./Pointer.js").Options} */
        t
      );
      e.stopDown || (e.stopDown = co), super(e), this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.threshold_ = t.threshold !== void 0 ? t.threshold : 0.3, this.duration_ = t.duration !== void 0 ? t.duration : 250;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @override
     */
    handleDragEvent(t) {
      let e = 0;
      const n = this.targetPointers[0], s = this.targetPointers[1], r = Math.atan2(
        s.clientY - n.clientY,
        s.clientX - n.clientX
      );
      if (this.lastAngle_ !== void 0) {
        const l = r - this.lastAngle_;
        this.rotationDelta_ += l, !this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_ && (this.rotating_ = !0), e = l;
      }
      this.lastAngle_ = r;
      const a = t.map, o = a.getView();
      o.getConstraints().rotation !== wh && (this.anchor_ = a.getCoordinateFromPixelInternal(
        a.getEventPixel(jh(this.targetPointers))
      ), this.rotating_ && (a.render(), o.adjustRotationInternal(e, this.anchor_)));
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleUpEvent(t) {
      return this.targetPointers.length < 2 ? (t.map.getView().endInteraction(this.duration_), !1) : !0;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleDownEvent(t) {
      if (this.targetPointers.length >= 2) {
        const e = t.map;
        return this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.handlingDownUpSequence || e.getView().beginInteraction(), !0;
      }
      return !1;
    }
  }
  class jp extends qr {
    /**
     * @param {Options} [options] Options.
     */
    constructor(t) {
      t = t || {};
      const e = (
        /** @type {import("./Pointer.js").Options} */
        t
      );
      e.stopDown || (e.stopDown = co), super(e), this.anchor_ = null, this.duration_ = t.duration !== void 0 ? t.duration : 400, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @override
     */
    handleDragEvent(t) {
      let e = 1;
      const n = this.targetPointers[0], s = this.targetPointers[1], r = n.clientX - s.clientX, a = n.clientY - s.clientY, o = Math.sqrt(r * r + a * a);
      this.lastDistance_ !== void 0 && (e = this.lastDistance_ / o), this.lastDistance_ = o;
      const l = t.map, h = l.getView();
      e != 1 && (this.lastScaleDelta_ = e), this.anchor_ = l.getCoordinateFromPixelInternal(
        l.getEventPixel(jh(this.targetPointers))
      ), l.render(), h.adjustResolutionInternal(e, this.anchor_);
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleUpEvent(t) {
      if (this.targetPointers.length < 2) {
        const n = t.map.getView(), s = this.lastScaleDelta_ > 1 ? 1 : -1;
        return n.endInteraction(this.duration_, s), !1;
      }
      return !0;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleDownEvent(t) {
      if (this.targetPointers.length >= 2) {
        const e = t.map;
        return this.anchor_ = null, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1, this.handlingDownUpSequence || e.getView().beginInteraction(), !0;
      }
      return !1;
    }
  }
  function Vp(i) {
    i = i || {};
    const t = new hi(), e = new Zp(-5e-3, 0.05, 100);
    return (i.altShiftDragRotate !== void 0 ? i.altShiftDragRotate : !0) && t.push(new zp()), (i.doubleClickZoom !== void 0 ? i.doubleClickZoom : !0) && t.push(
      new Lp({
        delta: i.zoomDelta,
        duration: i.zoomDuration
      })
    ), (i.dragPan !== void 0 ? i.dragPan : !0) && t.push(
      new Up({
        onFocusOnly: i.onFocusOnly,
        kinetic: e
      })
    ), (i.pinchRotate !== void 0 ? i.pinchRotate : !0) && t.push(new Kp()), (i.pinchZoom !== void 0 ? i.pinchZoom : !0) && t.push(
      new jp({
        duration: i.zoomDuration
      })
    ), (i.keyboard !== void 0 ? i.keyboard : !0) && (t.push(new Wp()), t.push(
      new Yp({
        delta: i.zoomDelta,
        duration: i.zoomDuration
      })
    )), (i.mouseWheelZoom !== void 0 ? i.mouseWheelZoom : !0) && t.push(
      new qp({
        onFocusOnly: i.onFocusOnly,
        duration: i.zoomDuration
      })
    ), (i.shiftDragZoom !== void 0 ? i.shiftDragZoom : !0) && t.push(
      new Xp({
        duration: i.zoomDuration
      })
    ), t;
  }
  function pf(i) {
    if (i instanceof So) {
      i.setMapInternal(null);
      return;
    }
    i instanceof $s && i.getLayers().forEach(pf);
  }
  function yf(i, t) {
    if (i instanceof So) {
      i.setMapInternal(t);
      return;
    }
    if (i instanceof $s) {
      const e = i.getLayers().getArray();
      for (let n = 0, s = e.length; n < s; ++n)
        yf(e[n], t);
    }
  }
  let Hp = class extends si {
    /**
     * @param {MapOptions} [options] Map options.
     */
    constructor(t) {
      super(), t = t || {}, this.on, this.once, this.un;
      const e = Jp(t);
      this.renderComplete_ = !1, this.loaded_ = !0, this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this), this.maxTilesLoading_ = t.maxTilesLoading !== void 0 ? t.maxTilesLoading : 16, this.pixelRatio_ = t.pixelRatio !== void 0 ? t.pixelRatio : Co, this.postRenderTimeoutHandle_, this.animationDelayKey_, this.animationDelay_ = this.animationDelay_.bind(this), this.coordinateToPixelTransform_ = We(), this.pixelToCoordinateTransform_ = We(), this.frameIndex_ = 0, this.frameState_ = null, this.previousExtent_ = null, this.viewPropertyListenerKey_ = null, this.viewChangeListenerKey_ = null, this.layerGroupPropertyListenerKeys_ = null, this.viewport_ = document.createElement("div"), this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : ""), this.viewport_.style.position = "relative", this.viewport_.style.overflow = "hidden", this.viewport_.style.width = "100%", this.viewport_.style.height = "100%", this.overlayContainer_ = document.createElement("div"), this.overlayContainer_.style.position = "absolute", this.overlayContainer_.style.zIndex = "0", this.overlayContainer_.style.width = "100%", this.overlayContainer_.style.height = "100%", this.overlayContainer_.style.pointerEvents = "none", this.overlayContainer_.className = "ol-overlaycontainer", this.viewport_.appendChild(this.overlayContainer_), this.overlayContainerStopEvent_ = document.createElement("div"), this.overlayContainerStopEvent_.style.position = "absolute", this.overlayContainerStopEvent_.style.zIndex = "0", this.overlayContainerStopEvent_.style.width = "100%", this.overlayContainerStopEvent_.style.height = "100%", this.overlayContainerStopEvent_.style.pointerEvents = "none", this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent", this.viewport_.appendChild(this.overlayContainerStopEvent_), this.mapBrowserEventHandler_ = null, this.moveTolerance_ = t.moveTolerance, this.keyboardEventTarget_ = e.keyboardEventTarget, this.targetChangeHandlerKeys_ = null, this.targetElement_ = null, this.resizeObserver_ = new ResizeObserver(() => this.updateSize()), this.controls = e.controls || Pp(), this.interactions = e.interactions || Vp({
        onFocusOnly: !0
      }), this.overlays_ = e.overlays, this.overlayIdIndex_ = {}, this.renderer_ = null, this.postRenderFunctions_ = [], this.tileQueue_ = new Sp(
        this.getTilePriority.bind(this),
        this.handleTileChange_.bind(this)
      ), this.addChangeListener(
        re.LAYERGROUP,
        this.handleLayerGroupChanged_
      ), this.addChangeListener(re.VIEW, this.handleViewChanged_), this.addChangeListener(re.SIZE, this.handleSizeChanged_), this.addChangeListener(re.TARGET, this.handleTargetChanged_), this.setProperties(e.values);
      const n = this;
      t.view && !(t.view instanceof oi) && t.view.then(function(s) {
        n.setView(new oi(s));
      }), this.controls.addEventListener(
        we.ADD,
        /**
         * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
         */
        (s) => {
          s.element.setMap(this);
        }
      ), this.controls.addEventListener(
        we.REMOVE,
        /**
         * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
         */
        (s) => {
          s.element.setMap(null);
        }
      ), this.interactions.addEventListener(
        we.ADD,
        /**
         * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
         */
        (s) => {
          s.element.setMap(this);
        }
      ), this.interactions.addEventListener(
        we.REMOVE,
        /**
         * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
         */
        (s) => {
          s.element.setMap(null);
        }
      ), this.overlays_.addEventListener(
        we.ADD,
        /**
         * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
         */
        (s) => {
          this.addOverlayInternal_(s.element);
        }
      ), this.overlays_.addEventListener(
        we.REMOVE,
        /**
         * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
         */
        (s) => {
          const r = s.element.getId();
          r !== void 0 && delete this.overlayIdIndex_[r.toString()], s.element.setMap(null);
        }
      ), this.controls.forEach(
        /**
         * @param {import("./control/Control.js").default} control Control.
         */
        (s) => {
          s.setMap(this);
        }
      ), this.interactions.forEach(
        /**
         * @param {import("./interaction/Interaction.js").default} interaction Interaction.
         */
        (s) => {
          s.setMap(this);
        }
      ), this.overlays_.forEach(this.addOverlayInternal_.bind(this));
    }
    /**
     * Add the given control to the map.
     * @param {import("./control/Control.js").default} control Control.
     * @api
     */
    addControl(t) {
      this.getControls().push(t);
    }
    /**
     * Add the given interaction to the map. If you want to add an interaction
     * at another point of the collection use `getInteractions()` and the methods
     * available on {@link module:ol/Collection~Collection}. This can be used to
     * stop the event propagation from the handleEvent function. The interactions
     * get to handle the events in the reverse order of this collection.
     * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
     * @api
     */
    addInteraction(t) {
      this.getInteractions().push(t);
    }
    /**
     * Adds the given layer to the top of this map. If you want to add a layer
     * elsewhere in the stack, use `getLayers()` and the methods available on
     * {@link module:ol/Collection~Collection}.
     * @param {import("./layer/Base.js").default} layer Layer.
     * @api
     */
    addLayer(t) {
      this.getLayerGroup().getLayers().push(t);
    }
    /**
     * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
     * @private
     */
    handleLayerAdd_(t) {
      yf(t.layer, this);
    }
    /**
     * Add the given overlay to the map.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @api
     */
    addOverlay(t) {
      this.getOverlays().push(t);
    }
    /**
     * This deals with map's overlay collection changes.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @private
     */
    addOverlayInternal_(t) {
      const e = t.getId();
      e !== void 0 && (this.overlayIdIndex_[e.toString()] = t), t.setMap(this);
    }
    /**
     *
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.controls.clear(), this.interactions.clear(), this.overlays_.clear(), this.resizeObserver_.disconnect(), this.setTarget(null), super.disposeInternal();
    }
    /**
     * Detect features that intersect a pixel on the viewport, and execute a
     * callback with each intersecting feature. Layers included in the detection can
     * be configured through the `layerFilter` option in `options`.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
     *     called with two arguments. The first argument is one
     *     {@link module:ol/Feature~Feature feature} or
     *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
     *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
     *     unmanaged layers. To stop detection, callback functions can return a
     *     truthy value.
     * @param {AtPixelOptions} [options] Optional options.
     * @return {T|undefined} Callback result, i.e. the return value of last
     * callback execution, or the first truthy callback return value.
     * @template T
     * @api
     */
    forEachFeatureAtPixel(t, e, n) {
      if (!this.frameState_ || !this.renderer_)
        return;
      const s = this.getCoordinateFromPixelInternal(t);
      n = n !== void 0 ? n : {};
      const r = n.hitTolerance !== void 0 ? n.hitTolerance : 0, a = n.layerFilter !== void 0 ? n.layerFilter : xr, o = n.checkWrapped !== !1;
      return this.renderer_.forEachFeatureAtCoordinate(
        s,
        this.frameState_,
        r,
        o,
        e,
        null,
        a,
        null
      );
    }
    /**
     * Get all features that intersect a pixel on the viewport.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {AtPixelOptions} [options] Optional options.
     * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
     * an empty array if none were found.
     * @api
     */
    getFeaturesAtPixel(t, e) {
      const n = [];
      return this.forEachFeatureAtPixel(
        t,
        function(s) {
          n.push(s);
        },
        e
      ), n;
    }
    /**
     * Get all layers from all layer groups.
     * @return {Array<import("./layer/Layer.js").default>} Layers.
     * @api
     */
    getAllLayers() {
      const t = [];
      function e(n) {
        n.forEach(function(s) {
          s instanceof $s ? e(s.getLayers()) : t.push(s);
        });
      }
      return e(this.getLayers()), t;
    }
    /**
     * Detect if features intersect a pixel on the viewport. Layers included in the
     * detection can be configured through the `layerFilter` option.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {AtPixelOptions} [options] Optional options.
     * @return {boolean} Is there a feature at the given pixel?
     * @api
     */
    hasFeatureAtPixel(t, e) {
      if (!this.frameState_ || !this.renderer_)
        return !1;
      const n = this.getCoordinateFromPixelInternal(t);
      e = e !== void 0 ? e : {};
      const s = e.layerFilter !== void 0 ? e.layerFilter : xr, r = e.hitTolerance !== void 0 ? e.hitTolerance : 0, a = e.checkWrapped !== !1;
      return this.renderer_.hasFeatureAtCoordinate(
        n,
        this.frameState_,
        r,
        a,
        s,
        null
      );
    }
    /**
     * Returns the coordinate in user projection for a browser event.
     * @param {MouseEvent} event Event.
     * @return {import("./coordinate.js").Coordinate} Coordinate.
     * @api
     */
    getEventCoordinate(t) {
      return this.getCoordinateFromPixel(this.getEventPixel(t));
    }
    /**
     * Returns the coordinate in view projection for a browser event.
     * @param {MouseEvent} event Event.
     * @return {import("./coordinate.js").Coordinate} Coordinate.
     */
    getEventCoordinateInternal(t) {
      return this.getCoordinateFromPixelInternal(this.getEventPixel(t));
    }
    /**
     * Returns the map pixel position for a browser event relative to the viewport.
     * @param {UIEvent|{clientX: number, clientY: number}} event Event.
     * @return {import("./pixel.js").Pixel} Pixel.
     * @api
     */
    getEventPixel(t) {
      const n = this.viewport_.getBoundingClientRect(), s = this.getSize(), r = n.width / s[0], a = n.height / s[1], o = (
        //FIXME Are we really calling this with a TouchEvent anywhere?
        "changedTouches" in t ? (
          /** @type {TouchEvent} */
          t.changedTouches[0]
        ) : (
          /** @type {MouseEvent} */
          t
        )
      );
      return [
        (o.clientX - n.left) / r,
        (o.clientY - n.top) / a
      ];
    }
    /**
     * Get the target in which this map is rendered.
     * Note that this returns what is entered as an option or in setTarget:
     * if that was an element, it returns an element; if a string, it returns that.
     * @return {HTMLElement|string|undefined} The Element or id of the Element that the
     *     map is rendered in.
     * @observable
     * @api
     */
    getTarget() {
      return (
        /** @type {HTMLElement|string|undefined} */
        this.get(re.TARGET)
      );
    }
    /**
     * Get the DOM element into which this map is rendered. In contrast to
     * `getTarget` this method always return an `Element`, or `null` if the
     * map has no target.
     * @return {HTMLElement} The element that the map is rendered in.
     * @api
     */
    getTargetElement() {
      return this.targetElement_;
    }
    /**
     * Get the coordinate for a given pixel.  This returns a coordinate in the
     * user projection.
     * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
     * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
     * @api
     */
    getCoordinateFromPixel(t) {
      return Ol(
        this.getCoordinateFromPixelInternal(t),
        this.getView().getProjection()
      );
    }
    /**
     * Get the coordinate for a given pixel.  This returns a coordinate in the
     * map view projection.
     * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
     * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
     */
    getCoordinateFromPixelInternal(t) {
      const e = this.frameState_;
      return e ? Yt(e.pixelToCoordinateTransform, t.slice()) : null;
    }
    /**
     * Get the map controls. Modifying this collection changes the controls
     * associated with the map.
     * @return {Collection<import("./control/Control.js").default>} Controls.
     * @api
     */
    getControls() {
      return this.controls;
    }
    /**
     * Get the map overlays. Modifying this collection changes the overlays
     * associated with the map.
     * @return {Collection<import("./Overlay.js").default>} Overlays.
     * @api
     */
    getOverlays() {
      return this.overlays_;
    }
    /**
     * Get an overlay by its identifier (the value returned by overlay.getId()).
     * Note that the index treats string and numeric identifiers as the same. So
     * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
     * @param {string|number} id Overlay identifier.
     * @return {import("./Overlay.js").default|null} Overlay.
     * @api
     */
    getOverlayById(t) {
      const e = this.overlayIdIndex_[t.toString()];
      return e !== void 0 ? e : null;
    }
    /**
     * Get the map interactions. Modifying this collection changes the interactions
     * associated with the map.
     *
     * Interactions are used for e.g. pan, zoom and rotate.
     * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
     * @api
     */
    getInteractions() {
      return this.interactions;
    }
    /**
     * Get the layergroup associated with this map.
     * @return {LayerGroup} A layer group containing the layers in this map.
     * @observable
     * @api
     */
    getLayerGroup() {
      return (
        /** @type {LayerGroup} */
        this.get(re.LAYERGROUP)
      );
    }
    /**
     * Clear any existing layers and add layers to the map.
     * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
     * @api
     */
    setLayers(t) {
      const e = this.getLayerGroup();
      if (t instanceof hi) {
        e.setLayers(t);
        return;
      }
      const n = e.getLayers();
      n.clear(), n.extend(t);
    }
    /**
     * Get the collection of layers associated with this map.
     * @return {!Collection<import("./layer/Base.js").default>} Layers.
     * @api
     */
    getLayers() {
      return this.getLayerGroup().getLayers();
    }
    /**
     * @return {boolean} Layers have sources that are still loading.
     */
    getLoadingOrNotReady() {
      const t = this.getLayerGroup().getLayerStatesArray();
      for (let e = 0, n = t.length; e < n; ++e) {
        const s = t[e];
        if (!s.visible)
          continue;
        const r = s.layer.getRenderer();
        if (r && !r.ready)
          return !0;
        const a = s.layer.getSource();
        if (a && a.loading)
          return !0;
      }
      return !1;
    }
    /**
     * Get the pixel for a coordinate.  This takes a coordinate in the user
     * projection and returns the corresponding pixel.
     * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
     * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
     * @api
     */
    getPixelFromCoordinate(t) {
      const e = Si(
        t,
        this.getView().getProjection()
      );
      return this.getPixelFromCoordinateInternal(e);
    }
    /**
     * Get the pixel for a coordinate.  This takes a coordinate in the map view
     * projection and returns the corresponding pixel.
     * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
     * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
     */
    getPixelFromCoordinateInternal(t) {
      const e = this.frameState_;
      return e ? Yt(
        e.coordinateToPixelTransform,
        t.slice(0, 2)
      ) : null;
    }
    /**
     * Get the map renderer.
     * @return {import("./renderer/Map.js").default|null} Renderer
     */
    getRenderer() {
      return this.renderer_;
    }
    /**
     * Get the size of this map.
     * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
     * @observable
     * @api
     */
    getSize() {
      return (
        /** @type {import("./size.js").Size|undefined} */
        this.get(re.SIZE)
      );
    }
    /**
     * Get the view associated with this map. A view manages properties such as
     * center and resolution.
     * @return {View} The view that controls this map.
     * @observable
     * @api
     */
    getView() {
      return (
        /** @type {View} */
        this.get(re.VIEW)
      );
    }
    /**
     * Get the element that serves as the map viewport.
     * @return {HTMLElement} Viewport.
     * @api
     */
    getViewport() {
      return this.viewport_;
    }
    /**
     * Get the element that serves as the container for overlays.  Elements added to
     * this container will let mousedown and touchstart events through to the map,
     * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
     * events.
     * @return {!HTMLElement} The map's overlay container.
     */
    getOverlayContainer() {
      return this.overlayContainer_;
    }
    /**
     * Get the element that serves as a container for overlays that don't allow
     * event propagation. Elements added to this container won't let mousedown and
     * touchstart events through to the map, so clicks and gestures on an overlay
     * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     * @return {!HTMLElement} The map's overlay container that stops events.
     */
    getOverlayContainerStopEvent() {
      return this.overlayContainerStopEvent_;
    }
    /**
     * @return {!Document} The document where the map is displayed.
     */
    getOwnerDocument() {
      const t = this.getTargetElement();
      return t ? t.ownerDocument : document;
    }
    /**
     * @param {import("./Tile.js").default} tile Tile.
     * @param {string} tileSourceKey Tile source key.
     * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
     * @param {number} tileResolution Tile resolution.
     * @return {number} Tile priority.
     */
    getTilePriority(t, e, n, s) {
      return Cp(
        this.frameState_,
        t,
        e,
        n,
        s
      );
    }
    /**
     * @param {UIEvent} browserEvent Browser event.
     * @param {string} [type] Type.
     */
    handleBrowserEvent(t, e) {
      e = e || t.type;
      const n = new Vi(e, this, t);
      this.handleMapBrowserEvent(n);
    }
    /**
     * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
     */
    handleMapBrowserEvent(t) {
      if (!this.frameState_)
        return;
      const e = (
        /** @type {PointerEvent} */
        t.originalEvent
      ), n = e.type;
      if (n === zl.POINTERDOWN || n === ht.WHEEL || n === ht.KEYDOWN) {
        const s = this.getOwnerDocument(), r = this.viewport_.getRootNode ? this.viewport_.getRootNode() : s, a = (
          /** @type {Node} */
          e.target
        ), o = r instanceof ShadowRoot ? r.host === a ? r.host.ownerDocument : r : r === s ? s.documentElement : r;
        if (
          // Abort if the target is a child of the container for elements whose events are not meant
          // to be handled by map interactions.
          this.overlayContainerStopEvent_.contains(a) || // Abort if the event target is a child of the container that is no longer in the page.
          // It's possible for the target to no longer be in the page if it has been removed in an
          // event listener, this might happen in a Control that recreates it's content based on
          // user interaction either manually or via a render in something like https://reactjs.org/
          !o.contains(a)
        )
          return;
      }
      if (t.frameState = this.frameState_, this.dispatchEvent(t) !== !1) {
        const s = this.getInteractions().getArray().slice();
        for (let r = s.length - 1; r >= 0; r--) {
          const a = s[r];
          if (a.getMap() !== this || !a.getActive() || !this.getTargetElement())
            continue;
          if (!a.handleEvent(t) || t.propagationStopped)
            break;
        }
      }
    }
    /**
     * @protected
     */
    handlePostRender() {
      const t = this.frameState_, e = this.tileQueue_;
      if (!e.isEmpty()) {
        let s = this.maxTilesLoading_, r = s;
        if (t) {
          const a = t.viewHints;
          if (a[ae.ANIMATING] || a[ae.INTERACTING]) {
            const o = Date.now() - t.time > 8;
            s = o ? 0 : 8, r = o ? 0 : 2;
          }
        }
        e.getTilesLoading() < s && (e.reprioritize(), e.loadMoreTiles(s, r));
      }
      t && this.renderer_ && !t.animate && (this.renderComplete_ ? (this.hasListener(Be.RENDERCOMPLETE) && this.renderer_.dispatchRenderEvent(
        Be.RENDERCOMPLETE,
        t
      ), this.loaded_ === !1 && (this.loaded_ = !0, this.dispatchEvent(
        new os(Ti.LOADEND, this, t)
      ))) : this.loaded_ === !0 && (this.loaded_ = !1, this.dispatchEvent(
        new os(Ti.LOADSTART, this, t)
      )));
      const n = this.postRenderFunctions_;
      if (t)
        for (let s = 0, r = n.length; s < r; ++s)
          n[s](this, t);
      n.length = 0;
    }
    /**
     * @private
     */
    handleSizeChanged_() {
      this.getView() && !this.getView().getAnimating() && this.getView().resolveConstraints(0), this.render();
    }
    /**
     * @private
     */
    handleTargetChanged_() {
      if (this.mapBrowserEventHandler_) {
        for (let n = 0, s = this.targetChangeHandlerKeys_.length; n < s; ++n)
          bt(this.targetChangeHandlerKeys_[n]);
        this.targetChangeHandlerKeys_ = null, this.viewport_.removeEventListener(
          ht.CONTEXTMENU,
          this.boundHandleBrowserEvent_
        ), this.viewport_.removeEventListener(
          ht.WHEEL,
          this.boundHandleBrowserEvent_
        ), this.mapBrowserEventHandler_.dispose(), this.mapBrowserEventHandler_ = null, this.viewport_.remove();
      }
      if (this.targetElement_) {
        this.resizeObserver_.unobserve(this.targetElement_);
        const n = this.targetElement_.getRootNode();
        n instanceof ShadowRoot && this.resizeObserver_.unobserve(n.host), this.setSize(void 0);
      }
      const t = this.getTarget(), e = typeof t == "string" ? document.getElementById(t) : t;
      if (this.targetElement_ = e, !e)
        this.renderer_ && (clearTimeout(this.postRenderTimeoutHandle_), this.postRenderTimeoutHandle_ = void 0, this.postRenderFunctions_.length = 0, this.renderer_.dispose(), this.renderer_ = null), this.animationDelayKey_ && (cancelAnimationFrame(this.animationDelayKey_), this.animationDelayKey_ = void 0);
      else {
        e.appendChild(this.viewport_), this.renderer_ || (this.renderer_ = new Mp(this)), this.mapBrowserEventHandler_ = new wp(
          this,
          this.moveTolerance_
        );
        for (const r in zt)
          this.mapBrowserEventHandler_.addEventListener(
            zt[r],
            this.handleMapBrowserEvent.bind(this)
          );
        this.viewport_.addEventListener(
          ht.CONTEXTMENU,
          this.boundHandleBrowserEvent_,
          !1
        ), this.viewport_.addEventListener(
          ht.WHEEL,
          this.boundHandleBrowserEvent_,
          Bh ? { passive: !1 } : !1
        );
        let n;
        if (this.keyboardEventTarget_)
          n = this.keyboardEventTarget_;
        else {
          const r = e.getRootNode();
          n = r instanceof ShadowRoot ? r.host : e;
        }
        this.targetChangeHandlerKeys_ = [
          xt(
            n,
            ht.KEYDOWN,
            this.handleBrowserEvent,
            this
          ),
          xt(
            n,
            ht.KEYPRESS,
            this.handleBrowserEvent,
            this
          )
        ];
        const s = e.getRootNode();
        s instanceof ShadowRoot && this.resizeObserver_.observe(s.host), this.resizeObserver_.observe(e);
      }
      this.updateSize();
    }
    /**
     * @private
     */
    handleTileChange_() {
      this.render();
    }
    /**
     * @private
     */
    handleViewPropertyChanged_() {
      this.render();
    }
    /**
     * @private
     */
    handleViewChanged_() {
      this.viewPropertyListenerKey_ && (bt(this.viewPropertyListenerKey_), this.viewPropertyListenerKey_ = null), this.viewChangeListenerKey_ && (bt(this.viewChangeListenerKey_), this.viewChangeListenerKey_ = null);
      const t = this.getView();
      t && (this.updateViewportSize_(this.getSize()), this.viewPropertyListenerKey_ = xt(
        t,
        Ts.PROPERTYCHANGE,
        this.handleViewPropertyChanged_,
        this
      ), this.viewChangeListenerKey_ = xt(
        t,
        ht.CHANGE,
        this.handleViewPropertyChanged_,
        this
      ), t.resolveConstraints(0)), this.render();
    }
    /**
     * @private
     */
    handleLayerGroupChanged_() {
      this.layerGroupPropertyListenerKeys_ && (this.layerGroupPropertyListenerKeys_.forEach(bt), this.layerGroupPropertyListenerKeys_ = null);
      const t = this.getLayerGroup();
      t && (this.handleLayerAdd_(new Hi("addlayer", t)), this.layerGroupPropertyListenerKeys_ = [
        xt(t, Ts.PROPERTYCHANGE, this.render, this),
        xt(t, ht.CHANGE, this.render, this),
        xt(t, "addlayer", this.handleLayerAdd_, this),
        xt(t, "removelayer", this.handleLayerRemove_, this)
      ]), this.render();
    }
    /**
     * @return {boolean} Is rendered.
     */
    isRendered() {
      return !!this.frameState_;
    }
    /**
     * @private
     */
    animationDelay_() {
      this.animationDelayKey_ = void 0, this.renderFrame_(Date.now());
    }
    /**
     * Requests an immediate render in a synchronous manner.
     * @api
     */
    renderSync() {
      this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_), this.animationDelay_();
    }
    /**
     * Redraws all text after new fonts have loaded
     */
    redrawText() {
      const t = this.getLayerGroup().getLayerStatesArray();
      for (let e = 0, n = t.length; e < n; ++e) {
        const s = t[e].layer;
        s.hasRenderer() && s.getRenderer().handleFontsChanged();
      }
    }
    /**
     * Request a map rendering (at the next animation frame).
     * @api
     */
    render() {
      this.renderer_ && this.animationDelayKey_ === void 0 && (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_));
    }
    /**
     * Remove the given control from the map.
     * @param {import("./control/Control.js").default} control Control.
     * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
     *     if the control was not found).
     * @api
     */
    removeControl(t) {
      return this.getControls().remove(t);
    }
    /**
     * Remove the given interaction from the map.
     * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
     * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
     *     undefined if the interaction was not found).
     * @api
     */
    removeInteraction(t) {
      return this.getInteractions().remove(t);
    }
    /**
     * Removes the given layer from the map.
     * @param {import("./layer/Base.js").default} layer Layer.
     * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
     *     layer was not found).
     * @api
     */
    removeLayer(t) {
      return this.getLayerGroup().getLayers().remove(t);
    }
    /**
     * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
     * @private
     */
    handleLayerRemove_(t) {
      pf(t.layer);
    }
    /**
     * Remove the given overlay from the map.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
     *     if the overlay was not found).
     * @api
     */
    removeOverlay(t) {
      return this.getOverlays().remove(t);
    }
    /**
     * @param {number} time Time.
     * @private
     */
    renderFrame_(t) {
      const e = this.getSize(), n = this.getView(), s = this.frameState_;
      let r = null;
      if (e !== void 0 && ou(e) && n && n.isDef()) {
        const a = n.getHints(
          this.frameState_ ? this.frameState_.viewHints : void 0
        ), o = n.getState();
        if (r = {
          animate: !1,
          coordinateToPixelTransform: this.coordinateToPixelTransform_,
          declutter: null,
          extent: Ua(
            o.center,
            o.resolution,
            o.rotation,
            e
          ),
          index: this.frameIndex_++,
          layerIndex: 0,
          layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
          pixelRatio: this.pixelRatio_,
          pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
          postRenderFunctions: [],
          size: e,
          tileQueue: this.tileQueue_,
          time: t,
          usedTiles: {},
          viewState: o,
          viewHints: a,
          wantedTiles: {},
          mapId: St(this),
          renderTargets: {}
        }, o.nextCenter && o.nextResolution) {
          const l = isNaN(o.nextRotation) ? o.rotation : o.nextRotation;
          r.nextExtent = Ua(
            o.nextCenter,
            o.nextResolution,
            l,
            e
          );
        }
      }
      this.frameState_ = r, this.renderer_.renderFrame(r), r && (r.animate && this.render(), Array.prototype.push.apply(
        this.postRenderFunctions_,
        r.postRenderFunctions
      ), s && (!this.previousExtent_ || !zs(this.previousExtent_) && !Ps(r.extent, this.previousExtent_)) && (this.dispatchEvent(
        new os(Ti.MOVESTART, this, s)
      ), this.previousExtent_ = Ni(this.previousExtent_)), this.previousExtent_ && !r.viewHints[ae.ANIMATING] && !r.viewHints[ae.INTERACTING] && !Ps(r.extent, this.previousExtent_) && (this.dispatchEvent(
        new os(Ti.MOVEEND, this, r)
      ), ch(r.extent, this.previousExtent_))), this.dispatchEvent(new os(Ti.POSTRENDER, this, r)), this.renderComplete_ = (this.hasListener(Ti.LOADSTART) || this.hasListener(Ti.LOADEND) || this.hasListener(Be.RENDERCOMPLETE)) && !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady(), this.postRenderTimeoutHandle_ || (this.postRenderTimeoutHandle_ = setTimeout(() => {
        this.postRenderTimeoutHandle_ = void 0, this.handlePostRender();
      }, 0));
    }
    /**
     * Sets the layergroup of this map.
     * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
     * @observable
     * @api
     */
    setLayerGroup(t) {
      const e = this.getLayerGroup();
      e && this.handleLayerRemove_(new Hi("removelayer", e)), this.set(re.LAYERGROUP, t);
    }
    /**
     * Set the size of this map.
     * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
     * @observable
     * @api
     */
    setSize(t) {
      this.set(re.SIZE, t);
    }
    /**
     * Set the target element to render this map into.
     * For accessibility (focus and keyboard events for map navigation), the `target` element must have a
     *  properly configured `tabindex` attribute. If the `target` element is inside a Shadow DOM, the
     *  `tabindex` atribute must be set on the custom element's host element.
     * @param {HTMLElement|string} [target] The Element or id of the Element
     *     that the map is rendered in.
     * @observable
     * @api
     */
    setTarget(t) {
      this.set(re.TARGET, t);
    }
    /**
     * Set the view for this map.
     * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
     * It is also possible to pass a promise that resolves to options for constructing a view.  This
     * alternative allows view properties to be resolved by sources or other components that load
     * view-related metadata.
     * @observable
     * @api
     */
    setView(t) {
      if (!t || t instanceof oi) {
        this.set(re.VIEW, t);
        return;
      }
      this.set(re.VIEW, new oi());
      const e = this;
      t.then(function(n) {
        e.setView(new oi(n));
      });
    }
    /**
     * Force a recalculation of the map viewport size.  This should be called when
     * third-party code changes the size of the map viewport.
     * @api
     */
    updateSize() {
      const t = this.getTargetElement();
      let e;
      if (t) {
        const s = getComputedStyle(t), r = t.offsetWidth - parseFloat(s.borderLeftWidth) - parseFloat(s.paddingLeft) - parseFloat(s.paddingRight) - parseFloat(s.borderRightWidth), a = t.offsetHeight - parseFloat(s.borderTopWidth) - parseFloat(s.paddingTop) - parseFloat(s.paddingBottom) - parseFloat(s.borderBottomWidth);
        !isNaN(r) && !isNaN(a) && (e = [Math.max(0, r), Math.max(0, a)], !ou(e) && (t.offsetWidth || t.offsetHeight || t.getClientRects().length) && Ad(
          "No map visible because the map container's width or height are 0."
        ));
      }
      const n = this.getSize();
      e && (!n || !fn(e, n)) && (this.setSize(e), this.updateViewportSize_(e));
    }
    /**
     * Recomputes the viewport size and save it on the view object (if any)
     * @param {import("./size.js").Size|undefined} size The size.
     * @private
     */
    updateViewportSize_(t) {
      const e = this.getView();
      e && e.setViewportSize(t);
    }
  };
  function Jp(i) {
    let t = null;
    i.keyboardEventTarget !== void 0 && (t = typeof i.keyboardEventTarget == "string" ? document.getElementById(i.keyboardEventTarget) : i.keyboardEventTarget);
    const e = {}, n = i.layers && typeof /** @type {?} */
    i.layers.getLayers == "function" ? (
      /** @type {LayerGroup} */
      i.layers
    ) : new $s({
      layers: (
        /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */
        i.layers
      )
    });
    e[re.LAYERGROUP] = n, e[re.TARGET] = i.target, e[re.VIEW] = i.view instanceof oi ? i.view : new oi();
    let s;
    i.controls !== void 0 && (Array.isArray(i.controls) ? s = new hi(i.controls.slice()) : (Mt(
      typeof /** @type {?} */
      i.controls.getArray == "function",
      "Expected `controls` to be an array or an `ol/Collection.js`"
    ), s = i.controls));
    let r;
    i.interactions !== void 0 && (Array.isArray(i.interactions) ? r = new hi(i.interactions.slice()) : (Mt(
      typeof /** @type {?} */
      i.interactions.getArray == "function",
      "Expected `interactions` to be an array or an `ol/Collection.js`"
    ), r = i.interactions));
    let a;
    return i.overlays !== void 0 ? Array.isArray(i.overlays) ? a = new hi(i.overlays.slice()) : (Mt(
      typeof /** @type {?} */
      i.overlays.getArray == "function",
      "Expected `overlays` to be an array or an `ol/Collection.js`"
    ), a = i.overlays) : a = new hi(), {
      controls: s,
      interactions: r,
      keyboardEventTarget: t,
      overlays: a,
      values: e
    };
  }
  class Oo extends si {
    /**
     * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
     *     You may pass a Geometry object directly, or an object literal containing
     *     properties. If you pass an object literal, you may include a Geometry
     *     associated with a `geometry` key.
     */
    constructor(t) {
      if (super(), this.on, this.once, this.un, this.id_ = void 0, this.geometryName_ = "geometry", this.style_ = null, this.styleFunction_ = void 0, this.geometryChangeKey_ = null, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), t)
        if (typeof /** @type {?} */
        t.getSimplifiedGeometry == "function") {
          const e = (
            /** @type {Geometry} */
            t
          );
          this.setGeometry(e);
        } else {
          const e = t;
          this.setProperties(e);
        }
    }
    /**
     * Clone this feature. If the original feature has a geometry it
     * is also cloned. The feature id is not set in the clone.
     * @return {Feature<Geometry>} The clone.
     * @api
     */
    clone() {
      const t = (
        /** @type {Feature<Geometry>} */
        new Oo(this.hasProperties() ? this.getProperties() : null)
      );
      t.setGeometryName(this.getGeometryName());
      const e = this.getGeometry();
      e && t.setGeometry(
        /** @type {Geometry} */
        e.clone()
      );
      const n = this.getStyle();
      return n && t.setStyle(n), t;
    }
    /**
     * Get the feature's default geometry.  A feature may have any number of named
     * geometries.  The "default" geometry (the one that is rendered by default) is
     * set when calling {@link module:ol/Feature~Feature#setGeometry}.
     * @return {Geometry|undefined} The default geometry for the feature.
     * @api
     * @observable
     */
    getGeometry() {
      return (
        /** @type {Geometry|undefined} */
        this.get(this.geometryName_)
      );
    }
    /**
     * Get the feature identifier.  This is a stable identifier for the feature and
     * is either set when reading data from a remote source or set explicitly by
     * calling {@link module:ol/Feature~Feature#setId}.
     * @return {number|string|undefined} Id.
     * @api
     */
    getId() {
      return this.id_;
    }
    /**
     * Get the name of the feature's default geometry.  By default, the default
     * geometry is named `geometry`.
     * @return {string} Get the property name associated with the default geometry
     *     for this feature.
     * @api
     */
    getGeometryName() {
      return this.geometryName_;
    }
    /**
     * Get the feature's style. Will return what was provided to the
     * {@link module:ol/Feature~Feature#setStyle} method.
     * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
     * @api
     */
    getStyle() {
      return this.style_;
    }
    /**
     * Get the feature's style function.
     * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
     * representing the current style of this feature.
     * @api
     */
    getStyleFunction() {
      return this.styleFunction_;
    }
    /**
     * @private
     */
    handleGeometryChange_() {
      this.changed();
    }
    /**
     * @private
     */
    handleGeometryChanged_() {
      this.geometryChangeKey_ && (bt(this.geometryChangeKey_), this.geometryChangeKey_ = null);
      const t = this.getGeometry();
      t && (this.geometryChangeKey_ = xt(
        t,
        ht.CHANGE,
        this.handleGeometryChange_,
        this
      )), this.changed();
    }
    /**
     * Set the default geometry for the feature.  This will update the property
     * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
     * @param {Geometry|undefined} geometry The new geometry.
     * @api
     * @observable
     */
    setGeometry(t) {
      this.set(this.geometryName_, t);
    }
    /**
     * Set the style for the feature to override the layer style.  This can be a
     * single style object, an array of styles, or a function that takes a
     * resolution and returns an array of styles. To unset the feature style, call
     * `setStyle()` without arguments or a falsey value.
     * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
     * @api
     * @fires module:ol/events/Event~BaseEvent#event:change
     */
    setStyle(t) {
      this.style_ = t, this.styleFunction_ = t ? Qp(t) : void 0, this.changed();
    }
    /**
     * Set the feature id.  The feature id is considered stable and may be used when
     * requesting features or comparing identifiers returned from a remote source.
     * The feature id can be used with the
     * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
     * @param {number|string|undefined} id The feature id.
     * @api
     * @fires module:ol/events/Event~BaseEvent#event:change
     */
    setId(t) {
      this.id_ = t, this.changed();
    }
    /**
     * Set the property name to be used when getting the feature's default geometry.
     * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
     * this name will be returned.
     * @param {string} name The property name of the default geometry.
     * @api
     */
    setGeometryName(t) {
      this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_), this.geometryName_ = t, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), this.handleGeometryChanged_();
    }
  }
  function Qp(i) {
    if (typeof i == "function")
      return i;
    let t;
    return Array.isArray(i) ? t = i : (Mt(
      typeof /** @type {?} */
      i.getZIndex == "function",
      "Expected an `ol/style/Style` or an array of `ol/style/Style.js`"
    ), t = [
      /** @type {import("./style/Style.js").default} */
      i
    ]), function() {
      return t;
    };
  }
  function Va(i, t, e, n, s, r, a) {
    let o, l;
    const h = (e - t) / n;
    if (h === 1)
      o = t;
    else if (h === 2)
      o = t, l = s;
    else if (h !== 0) {
      let c = i[t], u = i[t + 1], d = 0;
      const m = [0];
      for (let E = t + n; E < e; E += n) {
        const x = i[E], M = i[E + 1];
        d += Math.sqrt((x - c) * (x - c) + (M - u) * (M - u)), m.push(d), c = x, u = M;
      }
      const f = s * d, y = R0(m, f);
      y < 0 ? (l = (f - m[-y - 2]) / (m[-y - 1] - m[-y - 2]), o = t + (-y - 2) * n) : o = t + y * n;
    }
    a = a > 1 ? a : 2, r = r || new Array(a);
    for (let c = 0; c < a; ++c)
      r[c] = o === void 0 ? NaN : l === void 0 ? i[o + c] : Fe(i[o + c], i[o + n + c], l);
    return r;
  }
  function $l(i, t, e, n, s, r) {
    if (e == t)
      return null;
    let a;
    if (s < i[t + n - 1])
      return r ? (a = i.slice(t, t + n), a[n - 1] = s, a) : null;
    if (i[e - 1] < s)
      return r ? (a = i.slice(e - n, e), a[n - 1] = s, a) : null;
    if (s == i[t + n - 1])
      return i.slice(t, t + n);
    let o = t / n, l = e / n;
    for (; o < l; ) {
      const d = o + l >> 1;
      s < i[(d + 1) * n - 1] ? l = d : o = d + 1;
    }
    const h = i[o * n - 1];
    if (s == h)
      return i.slice((o - 1) * n, (o - 1) * n + n);
    const c = i[(o + 1) * n - 1], u = (s - h) / (c - h);
    a = [];
    for (let d = 0; d < n - 1; ++d)
      a.push(
        Fe(
          i[(o - 1) * n + d],
          i[o * n + d],
          u
        )
      );
    return a.push(s), a;
  }
  function ty(i, t, e, n, s, r, a) {
    if (a)
      return $l(
        i,
        t,
        e[e.length - 1],
        n,
        s,
        r
      );
    let o;
    if (s < i[n - 1])
      return r ? (o = i.slice(0, n), o[n - 1] = s, o) : null;
    if (i[i.length - 1] < s)
      return r ? (o = i.slice(i.length - n), o[n - 1] = s, o) : null;
    for (let l = 0, h = e.length; l < h; ++l) {
      const c = e[l];
      if (t != c) {
        if (s < i[t + n - 1])
          return null;
        if (s <= i[c - 1])
          return $l(
            i,
            t,
            c,
            n,
            s,
            !1
          );
        t = c;
      }
    }
    return null;
  }
  function vf(i, t, e, n) {
    let s = i[t], r = i[t + 1], a = 0;
    for (let o = t + n; o < e; o += n) {
      const l = i[o], h = i[o + 1];
      a += Math.sqrt((l - s) * (l - s) + (h - r) * (h - r)), s = l, r = h;
    }
    return a;
  }
  class cn extends Fi {
    /**
     * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `layout` are also accepted.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    constructor(t, e) {
      super(), this.flatMidpoint_ = null, this.flatMidpointRevision_ = -1, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, e !== void 0 && !Array.isArray(t[0]) ? this.setFlatCoordinates(
        e,
        /** @type {Array<number>} */
        t
      ) : this.setCoordinates(
        /** @type {Array<import("../coordinate.js").Coordinate>} */
        t,
        e
      );
    }
    /**
     * Append the passed coordinate to the coordinates of the linestring.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @api
     */
    appendCoordinate(t) {
      pe(this.flatCoordinates, t), this.changed();
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!LineString} Clone.
     * @api
     * @override
     */
    clone() {
      const t = new cn(
        this.flatCoordinates.slice(),
        this.layout
      );
      return t.applyProperties(this), t;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(t, e, n, s) {
      return s < gn(this.getExtent(), t, e) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
        Sh(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          0
        )
      ), this.maxDeltaRevision_ = this.getRevision()), Th(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        this.maxDelta_,
        !1,
        t,
        e,
        n,
        s
      ));
    }
    /**
     * Iterate over each segment, calling the provided callback.
     * If the callback returns a truthy value the function returns that
     * value immediately. Otherwise the function returns `false`.
     *
     * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
     *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
     * @return {T|boolean} Value.
     * @template T,S
     * @api
     */
    forEachSegment(t) {
      return Bd(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        t
      );
    }
    /**
     * Returns the coordinate at `m` using linear interpolation, or `null` if no
     * such coordinate exists.
     *
     * `extrapolate` controls extrapolation beyond the range of Ms in the
     * MultiLineString. If `extrapolate` is `true` then Ms less than the first
     * M will return the first coordinate and Ms greater than the last M will
     * return the last coordinate.
     *
     * @param {number} m M.
     * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
     * @return {import("../coordinate.js").Coordinate|null} Coordinate.
     * @api
     */
    getCoordinateAtM(t, e) {
      return this.layout != "XYM" && this.layout != "XYZM" ? null : (e = e !== void 0 ? e : !1, $l(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        t,
        e
      ));
    }
    /**
     * Return the coordinates of the linestring.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     * @override
     */
    getCoordinates() {
      return en(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    /**
     * Return the coordinate at the provided fraction along the linestring.
     * The `fraction` is a number between 0 and 1, where 0 is the start of the
     * linestring and 1 is the end.
     * @param {number} fraction Fraction.
     * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
     *     be modified. If not provided, a new coordinate will be returned.
     * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
     * @api
     */
    getCoordinateAt(t, e) {
      return Va(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        t,
        e,
        this.stride
      );
    }
    /**
     * Return the length of the linestring on projected plane.
     * @return {number} Length (on projected plane).
     * @api
     */
    getLength() {
      return vf(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    /**
     * @return {Array<number>} Flat midpoint.
     */
    getFlatMidpoint() {
      return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(
        0.5,
        this.flatMidpoint_ ?? void 0
      ), this.flatMidpointRevision_ = this.getRevision()), /** @type {Array<number>} */
      this.flatMidpoint_;
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {LineString} Simplified LineString.
     * @protected
     * @override
     */
    getSimplifiedGeometryInternal(t) {
      const e = [];
      return e.length = wo(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        t,
        e,
        0
      ), new cn(e, "XY");
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "LineString";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(t) {
      return Ro(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        t
      );
    }
    /**
     * Set the coordinates of the linestring.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    setCoordinates(t, e) {
      this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Mo(
        this.flatCoordinates,
        0,
        t,
        this.stride
      ), this.changed();
    }
  }
  const nt = {
    BEGIN_GEOMETRY: 0,
    BEGIN_PATH: 1,
    CIRCLE: 2,
    CLOSE_PATH: 3,
    CUSTOM: 4,
    DRAW_CHARS: 5,
    DRAW_IMAGE: 6,
    END_GEOMETRY: 7,
    FILL: 8,
    MOVE_TO_LINE_TO: 9,
    SET_FILL_STYLE: 10,
    SET_STROKE_STYLE: 11,
    STROKE: 12
  }, xa = [nt.FILL], nn = [nt.STROKE], An = [nt.BEGIN_PATH], Mu = [nt.CLOSE_PATH];
  class Ef {
    /**
     * Render a geometry with a custom renderer.
     *
     * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {Function} renderer Renderer.
     * @param {Function} hitDetectionRenderer Renderer.
     * @param {number} [index] Render order index.
     */
    drawCustom(t, e, n, s, r) {
    }
    /**
     * Render a geometry.
     *
     * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
     */
    drawGeometry(t) {
    }
    /**
     * Set the rendering style.
     *
     * @param {import("../style/Style.js").default} style The rendering style.
     */
    setStyle(t) {
    }
    /**
     * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
     * @param {import("../Feature.js").default} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawCircle(t, e, n) {
    }
    /**
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("../style/Style.js").default} style Style.
     * @param {number} [index] Render order index.
     */
    drawFeature(t, e, n) {
    }
    /**
     * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
     * @param {import("../Feature.js").default} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawGeometryCollection(t, e, n) {
    }
    /**
     * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawLineString(t, e, n) {
    }
    /**
     * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawMultiLineString(t, e, n) {
    }
    /**
     * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawMultiPoint(t, e, n) {
    }
    /**
     * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawMultiPolygon(t, e, n) {
    }
    /**
     * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawPoint(t, e, n) {
    }
    /**
     * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawPolygon(t, e, n) {
    }
    /**
     * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawText(t, e, n) {
    }
    /**
     * @param {import("../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
     */
    setFillStrokeStyle(t, e) {
    }
    /**
     * @param {import("../style/Image.js").default} imageStyle Image style.
     * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
     */
    setImageStyle(t, e) {
    }
    /**
     * @param {import("../style/Text.js").default} textStyle Text style.
     * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
     */
    setTextStyle(t, e) {
    }
  }
  class Kr extends Ef {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(t, e, n, s) {
      super(), this.tolerance = t, this.maxExtent = e, this.pixelRatio = s, this.maxLineWidth = 0, this.resolution = n, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_ = null, this.bufferedMaxExtent_ = null, this.instructions = [], this.coordinates = [], this.tmpCoordinate_ = [], this.hitDetectionInstructions = [], this.state = /** @type {import("../canvas.js").FillStrokeState} */
      {};
    }
    /**
     * @protected
     * @param {Array<number>} dashArray Dash array.
     * @return {Array<number>} Dash array with pixel ratio applied
     */
    applyPixelRatio(t) {
      const e = this.pixelRatio;
      return e == 1 ? t : t.map(function(n) {
        return n * e;
      });
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} stride Stride.
     * @protected
     * @return {number} My end
     */
    appendFlatPointCoordinates(t, e) {
      const n = this.getBufferedMaxExtent(), s = this.tmpCoordinate_, r = this.coordinates;
      let a = r.length;
      for (let o = 0, l = t.length; o < l; o += e)
        s[0] = t[o], s[1] = t[o + 1], Fn(n, s) && (r[a++] = s[0], r[a++] = s[1]);
      return a;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {boolean} closed Last input coordinate equals first.
     * @param {boolean} skipFirst Skip first coordinate.
     * @protected
     * @return {number} My end.
     */
    appendFlatLineCoordinates(t, e, n, s, r, a) {
      const o = this.coordinates;
      let l = o.length;
      const h = this.getBufferedMaxExtent();
      a && (e += s);
      let c = t[e], u = t[e + 1];
      const d = this.tmpCoordinate_;
      let m = !0, f, y, E;
      for (f = e + s; f < n; f += s)
        d[0] = t[f], d[1] = t[f + 1], E = Ga(h, d), E !== y ? (m && (o[l++] = c, o[l++] = u, m = !1), o[l++] = d[0], o[l++] = d[1]) : E === Vt.INTERSECTING ? (o[l++] = d[0], o[l++] = d[1], m = !1) : m = !0, c = d[0], u = d[1], y = E;
      return (r && m || f === e + s) && (o[l++] = c, o[l++] = u), l;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {Array<number>} builderEnds Builder ends.
     * @return {number} Offset.
     */
    drawCustomCoordinates_(t, e, n, s, r) {
      for (let a = 0, o = n.length; a < o; ++a) {
        const l = n[a], h = this.appendFlatLineCoordinates(
          t,
          e,
          l,
          s,
          !1,
          !1
        );
        r.push(h), e = l;
      }
      return e;
    }
    /**
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {Function} renderer Renderer.
     * @param {Function} hitDetectionRenderer Renderer.
     * @param {number} [index] Render order index.
     * @override
     */
    drawCustom(t, e, n, s, r) {
      this.beginGeometry(t, e, r);
      const a = t.getType(), o = t.getStride(), l = this.coordinates.length;
      let h, c, u, d, m;
      switch (a) {
        case "MultiPolygon":
          h = /** @type {import("../../geom/MultiPolygon.js").default} */
          t.getOrientedFlatCoordinates(), d = [];
          const f = (
            /** @type {import("../../geom/MultiPolygon.js").default} */
            t.getEndss()
          );
          m = 0;
          for (let y = 0, E = f.length; y < E; ++y) {
            const x = [];
            m = this.drawCustomCoordinates_(
              h,
              m,
              f[y],
              o,
              x
            ), d.push(x);
          }
          this.instructions.push([
            nt.CUSTOM,
            l,
            d,
            t,
            n,
            Nl,
            r
          ]), this.hitDetectionInstructions.push([
            nt.CUSTOM,
            l,
            d,
            t,
            s || n,
            Nl,
            r
          ]);
          break;
        case "Polygon":
        case "MultiLineString":
          u = [], h = a == "Polygon" ? (
            /** @type {import("../../geom/Polygon.js").default} */
            t.getOrientedFlatCoordinates()
          ) : t.getFlatCoordinates(), m = this.drawCustomCoordinates_(
            h,
            0,
            /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
            t.getEnds(),
            o,
            u
          ), this.instructions.push([
            nt.CUSTOM,
            l,
            u,
            t,
            n,
            Mr,
            r
          ]), this.hitDetectionInstructions.push([
            nt.CUSTOM,
            l,
            u,
            t,
            s || n,
            Mr,
            r
          ]);
          break;
        case "LineString":
        case "Circle":
          h = t.getFlatCoordinates(), c = this.appendFlatLineCoordinates(
            h,
            0,
            h.length,
            o,
            !1,
            !1
          ), this.instructions.push([
            nt.CUSTOM,
            l,
            c,
            t,
            n,
            en,
            r
          ]), this.hitDetectionInstructions.push([
            nt.CUSTOM,
            l,
            c,
            t,
            s || n,
            en,
            r
          ]);
          break;
        case "MultiPoint":
          h = t.getFlatCoordinates(), c = this.appendFlatPointCoordinates(h, o), c > l && (this.instructions.push([
            nt.CUSTOM,
            l,
            c,
            t,
            n,
            en,
            r
          ]), this.hitDetectionInstructions.push([
            nt.CUSTOM,
            l,
            c,
            t,
            s || n,
            en,
            r
          ]));
          break;
        case "Point":
          h = t.getFlatCoordinates(), this.coordinates.push(h[0], h[1]), c = this.coordinates.length, this.instructions.push([
            nt.CUSTOM,
            l,
            c,
            t,
            n,
            void 0,
            r
          ]), this.hitDetectionInstructions.push([
            nt.CUSTOM,
            l,
            c,
            t,
            s || n,
            void 0,
            r
          ]);
          break;
      }
      this.endGeometry(e);
    }
    /**
     * @protected
     * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} index Render order index
     */
    beginGeometry(t, e, n) {
      this.beginGeometryInstruction1_ = [
        nt.BEGIN_GEOMETRY,
        e,
        0,
        t,
        n
      ], this.instructions.push(this.beginGeometryInstruction1_), this.beginGeometryInstruction2_ = [
        nt.BEGIN_GEOMETRY,
        e,
        0,
        t,
        n
      ], this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */
    finish() {
      return {
        instructions: this.instructions,
        hitDetectionInstructions: this.hitDetectionInstructions,
        coordinates: this.coordinates
      };
    }
    /**
     * Reverse the hit detection instructions.
     */
    reverseHitDetectionInstructions() {
      const t = this.hitDetectionInstructions;
      t.reverse();
      let e;
      const n = t.length;
      let s, r, a = -1;
      for (e = 0; e < n; ++e)
        s = t[e], r = /** @type {import("./Instruction.js").default} */
        s[0], r == nt.END_GEOMETRY ? a = e : r == nt.BEGIN_GEOMETRY && (s[2] = e, C0(this.hitDetectionInstructions, a, e), a = -1);
    }
    /**
     * @param {import("../../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
     * @override
     */
    setFillStrokeStyle(t, e) {
      const n = this.state;
      if (t) {
        const s = t.getColor();
        n.fillPatternScale = s && typeof s == "object" && "src" in s ? this.pixelRatio : 1, n.fillStyle = ci(
          s || Re
        );
      } else
        n.fillStyle = void 0;
      if (e) {
        const s = e.getColor();
        n.strokeStyle = ci(
          s || Cr
        );
        const r = e.getLineCap();
        n.lineCap = r !== void 0 ? r : Ns;
        const a = e.getLineDash();
        n.lineDash = a ? a.slice() : Ai;
        const o = e.getLineDashOffset();
        n.lineDashOffset = o || Pi;
        const l = e.getLineJoin();
        n.lineJoin = l !== void 0 ? l : Fs;
        const h = e.getWidth();
        n.lineWidth = h !== void 0 ? h : Ir;
        const c = e.getMiterLimit();
        n.miterLimit = c !== void 0 ? c : Sr, n.lineWidth > this.maxLineWidth && (this.maxLineWidth = n.lineWidth, this.bufferedMaxExtent_ = null);
      } else
        n.strokeStyle = void 0, n.lineCap = void 0, n.lineDash = null, n.lineDashOffset = void 0, n.lineJoin = void 0, n.lineWidth = void 0, n.miterLimit = void 0;
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @return {Array<*>} Fill instruction.
     */
    createFill(t) {
      const e = t.fillStyle, n = [nt.SET_FILL_STYLE, e];
      return typeof e != "string" && n.push(t.fillPatternScale), n;
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     */
    applyStroke(t) {
      this.instructions.push(this.createStroke(t));
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @return {Array<*>} Stroke instruction.
     */
    createStroke(t) {
      return [
        nt.SET_STROKE_STYLE,
        t.strokeStyle,
        t.lineWidth * this.pixelRatio,
        t.lineCap,
        t.lineJoin,
        t.miterLimit,
        this.applyPixelRatio(t.lineDash),
        t.lineDashOffset * this.pixelRatio
      ];
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
     */
    updateFillStyle(t, e) {
      const n = t.fillStyle;
      (typeof n != "string" || t.currentFillStyle != n) && (n !== void 0 && this.instructions.push(e.call(this, t)), t.currentFillStyle = n);
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
     */
    updateStrokeStyle(t, e) {
      const n = t.strokeStyle, s = t.lineCap, r = t.lineDash, a = t.lineDashOffset, o = t.lineJoin, l = t.lineWidth, h = t.miterLimit;
      (t.currentStrokeStyle != n || t.currentLineCap != s || r != t.currentLineDash && !fn(t.currentLineDash, r) || t.currentLineDashOffset != a || t.currentLineJoin != o || t.currentLineWidth != l || t.currentMiterLimit != h) && (n !== void 0 && e.call(this, t), t.currentStrokeStyle = n, t.currentLineCap = s, t.currentLineDash = r, t.currentLineDashOffset = a, t.currentLineJoin = o, t.currentLineWidth = l, t.currentMiterLimit = h);
    }
    /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
    endGeometry(t) {
      this.beginGeometryInstruction1_[2] = this.instructions.length, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length, this.beginGeometryInstruction2_ = null;
      const e = [nt.END_GEOMETRY, t];
      this.instructions.push(e), this.hitDetectionInstructions.push(e);
    }
    /**
     * Get the buffered rendering extent.  Rendering will be clipped to the extent
     * provided to the constructor.  To account for symbolizers that may intersect
     * this extent, we calculate a buffered extent (e.g. based on stroke width).
     * @return {import("../../extent.js").Extent} The buffered rendering extent.
     * @protected
     */
    getBufferedMaxExtent() {
      if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = ch(this.maxExtent), this.maxLineWidth > 0)) {
        const t = this.resolution * (this.maxLineWidth + 1) / 2;
        go(this.bufferedMaxExtent_, t, this.bufferedMaxExtent_);
      }
      return this.bufferedMaxExtent_;
    }
  }
  class ey extends Kr {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(t, e, n, s) {
      super(t, e, n, s), this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.anchorX_ = void 0, this.anchorY_ = void 0, this.height_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.scale_ = void 0, this.width_ = void 0, this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
    }
    /**
     * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     * @override
     */
    drawPoint(t, e, n) {
      if (!this.image_ || this.maxExtent && !Fn(this.maxExtent, t.getFlatCoordinates()))
        return;
      this.beginGeometry(t, e, n);
      const s = t.getFlatCoordinates(), r = t.getStride(), a = this.coordinates.length, o = this.appendFlatPointCoordinates(s, r);
      this.instructions.push([
        nt.DRAW_IMAGE,
        a,
        o,
        this.image_,
        // Remaining arguments to DRAW_IMAGE are in alphabetical order
        this.anchorX_ * this.imagePixelRatio_,
        this.anchorY_ * this.imagePixelRatio_,
        Math.ceil(this.height_ * this.imagePixelRatio_),
        this.opacity_,
        this.originX_ * this.imagePixelRatio_,
        this.originY_ * this.imagePixelRatio_,
        this.rotateWithView_,
        this.rotation_,
        [
          this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
          this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
        ],
        Math.ceil(this.width_ * this.imagePixelRatio_),
        this.declutterMode_,
        this.declutterImageWithText_
      ]), this.hitDetectionInstructions.push([
        nt.DRAW_IMAGE,
        a,
        o,
        this.hitDetectionImage_,
        // Remaining arguments to DRAW_IMAGE are in alphabetical order
        this.anchorX_,
        this.anchorY_,
        this.height_,
        1,
        this.originX_,
        this.originY_,
        this.rotateWithView_,
        this.rotation_,
        this.scale_,
        this.width_,
        this.declutterMode_,
        this.declutterImageWithText_
      ]), this.endGeometry(e);
    }
    /**
     * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     * @override
     */
    drawMultiPoint(t, e, n) {
      if (!this.image_)
        return;
      this.beginGeometry(t, e, n);
      const s = t.getFlatCoordinates(), r = [];
      for (let l = 0, h = s.length; l < h; l += t.getStride())
        (!this.maxExtent || Fn(this.maxExtent, s.slice(l, l + 2))) && r.push(
          s[l],
          s[l + 1]
        );
      const a = this.coordinates.length, o = this.appendFlatPointCoordinates(r, 2);
      this.instructions.push([
        nt.DRAW_IMAGE,
        a,
        o,
        this.image_,
        // Remaining arguments to DRAW_IMAGE are in alphabetical order
        this.anchorX_ * this.imagePixelRatio_,
        this.anchorY_ * this.imagePixelRatio_,
        Math.ceil(this.height_ * this.imagePixelRatio_),
        this.opacity_,
        this.originX_ * this.imagePixelRatio_,
        this.originY_ * this.imagePixelRatio_,
        this.rotateWithView_,
        this.rotation_,
        [
          this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
          this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
        ],
        Math.ceil(this.width_ * this.imagePixelRatio_),
        this.declutterMode_,
        this.declutterImageWithText_
      ]), this.hitDetectionInstructions.push([
        nt.DRAW_IMAGE,
        a,
        o,
        this.hitDetectionImage_,
        // Remaining arguments to DRAW_IMAGE are in alphabetical order
        this.anchorX_,
        this.anchorY_,
        this.height_,
        1,
        this.originX_,
        this.originY_,
        this.rotateWithView_,
        this.rotation_,
        this.scale_,
        this.width_,
        this.declutterMode_,
        this.declutterImageWithText_
      ]), this.endGeometry(e);
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     * @override
     */
    finish() {
      return this.reverseHitDetectionInstructions(), this.anchorX_ = void 0, this.anchorY_ = void 0, this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.height_ = void 0, this.scale_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.width_ = void 0, super.finish();
    }
    /**
     * @param {import("../../style/Image.js").default} imageStyle Image style.
     * @param {Object} [sharedData] Shared data.
     * @override
     */
    setImageStyle(t, e) {
      const n = t.getAnchor(), s = t.getSize(), r = t.getOrigin();
      this.imagePixelRatio_ = t.getPixelRatio(this.pixelRatio), this.anchorX_ = n[0], this.anchorY_ = n[1], this.hitDetectionImage_ = t.getHitDetectionImage(), this.image_ = t.getImage(this.pixelRatio), this.height_ = s[1], this.opacity_ = t.getOpacity(), this.originX_ = r[0], this.originY_ = r[1], this.rotateWithView_ = t.getRotateWithView(), this.rotation_ = t.getRotation(), this.scale_ = t.getScaleArray(), this.width_ = s[0], this.declutterMode_ = t.getDeclutterMode(), this.declutterImageWithText_ = e;
    }
  }
  class iy extends Kr {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(t, e, n, s) {
      super(t, e, n, s);
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @private
     * @return {number} end.
     */
    drawFlatCoordinates_(t, e, n, s) {
      const r = this.coordinates.length, a = this.appendFlatLineCoordinates(
        t,
        e,
        n,
        s,
        !1,
        !1
      ), o = [
        nt.MOVE_TO_LINE_TO,
        r,
        a
      ];
      return this.instructions.push(o), this.hitDetectionInstructions.push(o), n;
    }
    /**
     * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     * @override
     */
    drawLineString(t, e, n) {
      const s = this.state, r = s.strokeStyle, a = s.lineWidth;
      if (r === void 0 || a === void 0)
        return;
      this.updateStrokeStyle(s, this.applyStroke), this.beginGeometry(t, e, n), this.hitDetectionInstructions.push(
        [
          nt.SET_STROKE_STYLE,
          s.strokeStyle,
          s.lineWidth,
          s.lineCap,
          s.lineJoin,
          s.miterLimit,
          Ai,
          Pi
        ],
        An
      );
      const o = t.getFlatCoordinates(), l = t.getStride();
      this.drawFlatCoordinates_(
        o,
        0,
        o.length,
        l
      ), this.hitDetectionInstructions.push(nn), this.endGeometry(e);
    }
    /**
     * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     * @override
     */
    drawMultiLineString(t, e, n) {
      const s = this.state, r = s.strokeStyle, a = s.lineWidth;
      if (r === void 0 || a === void 0)
        return;
      this.updateStrokeStyle(s, this.applyStroke), this.beginGeometry(t, e, n), this.hitDetectionInstructions.push(
        [
          nt.SET_STROKE_STYLE,
          s.strokeStyle,
          s.lineWidth,
          s.lineCap,
          s.lineJoin,
          s.miterLimit,
          Ai,
          Pi
        ],
        An
      );
      const o = t.getEnds(), l = t.getFlatCoordinates(), h = t.getStride();
      let c = 0;
      for (let u = 0, d = o.length; u < d; ++u)
        c = this.drawFlatCoordinates_(
          l,
          c,
          /** @type {number} */
          o[u],
          h
        );
      this.hitDetectionInstructions.push(nn), this.endGeometry(e);
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     * @override
     */
    finish() {
      const t = this.state;
      return t.lastStroke != null && t.lastStroke != this.coordinates.length && this.instructions.push(nn), this.reverseHitDetectionInstructions(), this.state = null, super.finish();
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @override
     */
    applyStroke(t) {
      t.lastStroke != null && t.lastStroke != this.coordinates.length && (this.instructions.push(nn), t.lastStroke = this.coordinates.length), t.lastStroke = 0, super.applyStroke(t), this.instructions.push(An);
    }
  }
  class wu extends Kr {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(t, e, n, s) {
      super(t, e, n, s);
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @private
     * @return {number} End.
     */
    drawFlatCoordinatess_(t, e, n, s) {
      const r = this.state, a = r.fillStyle !== void 0, o = r.strokeStyle !== void 0, l = n.length;
      this.instructions.push(An), this.hitDetectionInstructions.push(An);
      for (let h = 0; h < l; ++h) {
        const c = n[h], u = this.coordinates.length, d = this.appendFlatLineCoordinates(
          t,
          e,
          c,
          s,
          !0,
          !o
        ), m = [
          nt.MOVE_TO_LINE_TO,
          u,
          d
        ];
        this.instructions.push(m), this.hitDetectionInstructions.push(m), o && (this.instructions.push(Mu), this.hitDetectionInstructions.push(Mu)), e = c;
      }
      return a && (this.instructions.push(xa), this.hitDetectionInstructions.push(xa)), o && (this.instructions.push(nn), this.hitDetectionInstructions.push(nn)), e;
    }
    /**
     * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
     * @param {import("../../Feature.js").default} feature Feature.
     * @param {number} [index] Render order index.
     * @override
     */
    drawCircle(t, e, n) {
      const s = this.state, r = s.fillStyle, a = s.strokeStyle;
      if (r === void 0 && a === void 0)
        return;
      this.setFillStrokeStyles_(), this.beginGeometry(t, e, n), s.fillStyle !== void 0 && this.hitDetectionInstructions.push([
        nt.SET_FILL_STYLE,
        Re
      ]), s.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
        nt.SET_STROKE_STYLE,
        s.strokeStyle,
        s.lineWidth,
        s.lineCap,
        s.lineJoin,
        s.miterLimit,
        Ai,
        Pi
      ]);
      const o = t.getFlatCoordinates(), l = t.getStride(), h = this.coordinates.length;
      this.appendFlatLineCoordinates(
        o,
        0,
        o.length,
        l,
        !1,
        !1
      );
      const c = [nt.CIRCLE, h];
      this.instructions.push(An, c), this.hitDetectionInstructions.push(An, c), s.fillStyle !== void 0 && (this.instructions.push(xa), this.hitDetectionInstructions.push(xa)), s.strokeStyle !== void 0 && (this.instructions.push(nn), this.hitDetectionInstructions.push(nn)), this.endGeometry(e);
    }
    /**
     * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     * @override
     */
    drawPolygon(t, e, n) {
      const s = this.state, r = s.fillStyle, a = s.strokeStyle;
      if (r === void 0 && a === void 0)
        return;
      this.setFillStrokeStyles_(), this.beginGeometry(t, e, n), s.fillStyle !== void 0 && this.hitDetectionInstructions.push([
        nt.SET_FILL_STYLE,
        Re
      ]), s.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
        nt.SET_STROKE_STYLE,
        s.strokeStyle,
        s.lineWidth,
        s.lineCap,
        s.lineJoin,
        s.miterLimit,
        Ai,
        Pi
      ]);
      const o = t.getEnds(), l = t.getOrientedFlatCoordinates(), h = t.getStride();
      this.drawFlatCoordinatess_(
        l,
        0,
        /** @type {Array<number>} */
        o,
        h
      ), this.endGeometry(e);
    }
    /**
     * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     * @override
     */
    drawMultiPolygon(t, e, n) {
      const s = this.state, r = s.fillStyle, a = s.strokeStyle;
      if (r === void 0 && a === void 0)
        return;
      this.setFillStrokeStyles_(), this.beginGeometry(t, e, n), s.fillStyle !== void 0 && this.hitDetectionInstructions.push([
        nt.SET_FILL_STYLE,
        Re
      ]), s.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
        nt.SET_STROKE_STYLE,
        s.strokeStyle,
        s.lineWidth,
        s.lineCap,
        s.lineJoin,
        s.miterLimit,
        Ai,
        Pi
      ]);
      const o = t.getEndss(), l = t.getOrientedFlatCoordinates(), h = t.getStride();
      let c = 0;
      for (let u = 0, d = o.length; u < d; ++u)
        c = this.drawFlatCoordinatess_(
          l,
          c,
          o[u],
          h
        );
      this.endGeometry(e);
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     * @override
     */
    finish() {
      this.reverseHitDetectionInstructions(), this.state = null;
      const t = this.tolerance;
      if (t !== 0) {
        const e = this.coordinates;
        for (let n = 0, s = e.length; n < s; ++n)
          e[n] = Rn(e[n], t);
      }
      return super.finish();
    }
    /**
     * @private
     */
    setFillStrokeStyles_() {
      const t = this.state;
      t.fillStyle !== void 0 && this.updateFillStyle(t, this.createFill), t.strokeStyle !== void 0 && this.updateStrokeStyle(t, this.applyStroke);
    }
  }
  function ny(i, t, e, n, s) {
    const r = [];
    let a = e, o = 0, l = t.slice(e, 2);
    for (; o < i && a + s < n; ) {
      const [h, c] = l.slice(-2), u = t[a + s], d = t[a + s + 1], m = Math.sqrt(
        (u - h) * (u - h) + (d - c) * (d - c)
      );
      if (o += m, o >= i) {
        const f = (i - o + m) / m, y = Fe(h, u, f), E = Fe(c, d, f);
        l.push(y, E), r.push(l), l = [y, E], o == i && (a += s), o = 0;
      } else if (o < i)
        l.push(
          t[a + s],
          t[a + s + 1]
        ), a += s;
      else {
        const f = m - o, y = Fe(h, u, f / m), E = Fe(c, d, f / m);
        l.push(y, E), r.push(l), l = [y, E], o = 0, a += s;
      }
    }
    return o > 0 && r.push(l), r;
  }
  function sy(i, t, e, n, s) {
    let r = e, a = e, o = 0, l = 0, h = e, c, u, d, m, f, y, E, x, M, C;
    for (u = e; u < n; u += s) {
      const R = t[u], S = t[u + 1];
      f !== void 0 && (M = R - f, C = S - y, m = Math.sqrt(M * M + C * C), E !== void 0 && (l += d, c = Math.acos((E * M + x * C) / (d * m)), c > i && (l > o && (o = l, r = h, a = u), l = 0, h = u - s)), d = m, E = M, x = C), f = R, y = S;
    }
    return l += m, l > o ? [h, u] : [r, a];
  }
  const Ha = {
    left: 0,
    center: 0.5,
    right: 1,
    top: 0,
    middle: 0.5,
    hanging: 0.2,
    alphabetic: 0.8,
    ideographic: 0.8,
    bottom: 1
  };
  class ry extends Kr {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(t, e, n, s) {
      super(t, e, n, s), this.labels_ = null, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = void 0, this.textKeepUpright_ = void 0, this.textRotation_ = 0, this.textFillState_ = null, this.fillStates = {}, this.fillStates[Re] = { fillStyle: Re }, this.textStrokeState_ = null, this.strokeStates = {}, this.textState_ = /** @type {import("../canvas.js").TextState} */
      {}, this.textStates = {}, this.textKey_ = "", this.fillKey_ = "", this.strokeKey_ = "", this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     * @override
     */
    finish() {
      const t = super.finish();
      return t.textStates = this.textStates, t.fillStates = this.fillStates, t.strokeStates = this.strokeStates, t;
    }
    /**
     * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     * @override
     */
    drawText(t, e, n) {
      const s = this.textFillState_, r = this.textStrokeState_, a = this.textState_;
      if (this.text_ === "" || !a || !s && !r)
        return;
      const o = this.coordinates;
      let l = o.length;
      const h = t.getType();
      let c = null, u = t.getStride();
      if (a.placement === "line" && (h == "LineString" || h == "MultiLineString" || h == "Polygon" || h == "MultiPolygon")) {
        if (!he(this.maxExtent, t.getExtent()))
          return;
        let d;
        if (c = t.getFlatCoordinates(), h == "LineString")
          d = [c.length];
        else if (h == "MultiLineString")
          d = /** @type {import("../../geom/MultiLineString.js").default} */
          t.getEnds();
        else if (h == "Polygon")
          d = /** @type {import("../../geom/Polygon.js").default} */
          t.getEnds().slice(0, 1);
        else if (h == "MultiPolygon") {
          const E = (
            /** @type {import("../../geom/MultiPolygon.js").default} */
            t.getEndss()
          );
          d = [];
          for (let x = 0, M = E.length; x < M; ++x)
            d.push(E[x][0]);
        }
        this.beginGeometry(t, e, n);
        const m = a.repeat, f = m ? void 0 : a.textAlign;
        let y = 0;
        for (let E = 0, x = d.length; E < x; ++E) {
          let M;
          m ? M = ny(
            m * this.resolution,
            c,
            y,
            d[E],
            u
          ) : M = [c.slice(y, d[E])];
          for (let C = 0, R = M.length; C < R; ++C) {
            const S = M[C];
            let A = 0, O = S.length;
            if (f == null) {
              const L = sy(
                a.maxAngle,
                S,
                0,
                S.length,
                2
              );
              A = L[0], O = L[1];
            }
            for (let L = A; L < O; L += u)
              o.push(S[L], S[L + 1]);
            const P = o.length;
            y = d[E], this.drawChars_(l, P), l = P;
          }
        }
        this.endGeometry(e);
      } else {
        let d = a.overflow ? null : [];
        switch (h) {
          case "Point":
          case "MultiPoint":
            c = /** @type {import("../../geom/MultiPoint.js").default} */
            t.getFlatCoordinates();
            break;
          case "LineString":
            c = /** @type {import("../../geom/LineString.js").default} */
            t.getFlatMidpoint();
            break;
          case "Circle":
            c = /** @type {import("../../geom/Circle.js").default} */
            t.getCenter();
            break;
          case "MultiLineString":
            c = /** @type {import("../../geom/MultiLineString.js").default} */
            t.getFlatMidpoints(), u = 2;
            break;
          case "Polygon":
            c = /** @type {import("../../geom/Polygon.js").default} */
            t.getFlatInteriorPoint(), a.overflow || d.push(c[2] / this.resolution), u = 3;
            break;
          case "MultiPolygon":
            const M = (
              /** @type {import("../../geom/MultiPolygon.js").default} */
              t.getFlatInteriorPoints()
            );
            c = [];
            for (let C = 0, R = M.length; C < R; C += 3)
              a.overflow || d.push(M[C + 2] / this.resolution), c.push(M[C], M[C + 1]);
            if (c.length === 0)
              return;
            u = 2;
            break;
        }
        const m = this.appendFlatPointCoordinates(c, u);
        if (m === l)
          return;
        if (d && (m - l) / 2 !== c.length / u) {
          let M = l / 2;
          d = d.filter((C, R) => {
            const S = o[(M + R) * 2] === c[R * u] && o[(M + R) * 2 + 1] === c[R * u + 1];
            return S || --M, S;
          });
        }
        this.saveTextStates_(), (a.backgroundFill || a.backgroundStroke) && (this.setFillStrokeStyle(
          a.backgroundFill,
          a.backgroundStroke
        ), a.backgroundFill && this.updateFillStyle(this.state, this.createFill), a.backgroundStroke && (this.updateStrokeStyle(this.state, this.applyStroke), this.hitDetectionInstructions.push(this.createStroke(this.state)))), this.beginGeometry(t, e, n);
        let f = a.padding;
        if (f != In && (a.scale[0] < 0 || a.scale[1] < 0)) {
          let M = a.padding[0], C = a.padding[1], R = a.padding[2], S = a.padding[3];
          a.scale[0] < 0 && (C = -C, S = -S), a.scale[1] < 0 && (M = -M, R = -R), f = [M, C, R, S];
        }
        const y = this.pixelRatio;
        this.instructions.push([
          nt.DRAW_IMAGE,
          l,
          m,
          null,
          NaN,
          NaN,
          NaN,
          1,
          0,
          0,
          this.textRotateWithView_,
          this.textRotation_,
          [1, 1],
          NaN,
          this.declutterMode_,
          this.declutterImageWithText_,
          f == In ? In : f.map(function(M) {
            return M * y;
          }),
          !!a.backgroundFill,
          !!a.backgroundStroke,
          this.text_,
          this.textKey_,
          this.strokeKey_,
          this.fillKey_,
          this.textOffsetX_,
          this.textOffsetY_,
          d
        ]);
        const E = 1 / y, x = this.state.fillStyle;
        a.backgroundFill && (this.state.fillStyle = Re, this.hitDetectionInstructions.push(this.createFill(this.state))), this.hitDetectionInstructions.push([
          nt.DRAW_IMAGE,
          l,
          m,
          null,
          NaN,
          NaN,
          NaN,
          1,
          0,
          0,
          this.textRotateWithView_,
          this.textRotation_,
          [E, E],
          NaN,
          this.declutterMode_,
          this.declutterImageWithText_,
          f,
          !!a.backgroundFill,
          !!a.backgroundStroke,
          this.text_,
          this.textKey_,
          this.strokeKey_,
          this.fillKey_ ? Re : this.fillKey_,
          this.textOffsetX_,
          this.textOffsetY_,
          d
        ]), a.backgroundFill && (this.state.fillStyle = x, this.hitDetectionInstructions.push(this.createFill(this.state))), this.endGeometry(e);
      }
    }
    /**
     * @private
     */
    saveTextStates_() {
      const t = this.textStrokeState_, e = this.textState_, n = this.textFillState_, s = this.strokeKey_;
      t && (s in this.strokeStates || (this.strokeStates[s] = {
        strokeStyle: t.strokeStyle,
        lineCap: t.lineCap,
        lineDashOffset: t.lineDashOffset,
        lineWidth: t.lineWidth,
        lineJoin: t.lineJoin,
        miterLimit: t.miterLimit,
        lineDash: t.lineDash
      }));
      const r = this.textKey_;
      r in this.textStates || (this.textStates[r] = {
        font: e.font,
        textAlign: e.textAlign || Tr,
        justify: e.justify,
        textBaseline: e.textBaseline || Ya,
        scale: e.scale
      });
      const a = this.fillKey_;
      n && (a in this.fillStates || (this.fillStates[a] = {
        fillStyle: n.fillStyle
      }));
    }
    /**
     * @private
     * @param {number} begin Begin.
     * @param {number} end End.
     */
    drawChars_(t, e) {
      const n = this.textStrokeState_, s = this.textState_, r = this.strokeKey_, a = this.textKey_, o = this.fillKey_;
      this.saveTextStates_();
      const l = this.pixelRatio, h = Ha[s.textBaseline], c = this.textOffsetY_ * l, u = this.text_, d = n ? n.lineWidth * Math.abs(s.scale[0]) / 2 : 0;
      this.instructions.push([
        nt.DRAW_CHARS,
        t,
        e,
        h,
        s.overflow,
        o,
        s.maxAngle,
        l,
        c,
        r,
        d * l,
        u,
        a,
        1,
        this.declutterMode_,
        this.textKeepUpright_
      ]), this.hitDetectionInstructions.push([
        nt.DRAW_CHARS,
        t,
        e,
        h,
        s.overflow,
        o && Re,
        s.maxAngle,
        l,
        c,
        r,
        d * l,
        u,
        a,
        1 / l,
        this.declutterMode_,
        this.textKeepUpright_
      ]);
    }
    /**
     * @param {import("../../style/Text.js").default} textStyle Text style.
     * @param {Object} [sharedData] Shared data.
     * @override
     */
    setTextStyle(t, e) {
      let n, s, r;
      if (!t)
        this.text_ = "";
      else {
        const a = t.getFill();
        a ? (s = this.textFillState_, s || (s = /** @type {import("../canvas.js").FillState} */
        {}, this.textFillState_ = s), s.fillStyle = ci(
          a.getColor() || Re
        )) : (s = null, this.textFillState_ = s);
        const o = t.getStroke();
        if (!o)
          r = null, this.textStrokeState_ = r;
        else {
          r = this.textStrokeState_, r || (r = /** @type {import("../canvas.js").StrokeState} */
          {}, this.textStrokeState_ = r);
          const y = o.getLineDash(), E = o.getLineDashOffset(), x = o.getWidth(), M = o.getMiterLimit();
          r.lineCap = o.getLineCap() || Ns, r.lineDash = y ? y.slice() : Ai, r.lineDashOffset = E === void 0 ? Pi : E, r.lineJoin = o.getLineJoin() || Fs, r.lineWidth = x === void 0 ? Ir : x, r.miterLimit = M === void 0 ? Sr : M, r.strokeStyle = ci(
            o.getColor() || Cr
          );
        }
        n = this.textState_;
        const l = t.getFont() || tf;
        I_(l);
        const h = t.getScaleArray();
        n.overflow = t.getOverflow(), n.font = l, n.maxAngle = t.getMaxAngle(), n.placement = t.getPlacement(), n.textAlign = t.getTextAlign(), n.repeat = t.getRepeat(), n.justify = t.getJustify(), n.textBaseline = t.getTextBaseline() || Ya, n.backgroundFill = t.getBackgroundFill(), n.backgroundStroke = t.getBackgroundStroke(), n.padding = t.getPadding() || In, n.scale = h === void 0 ? [1, 1] : h;
        const c = t.getOffsetX(), u = t.getOffsetY(), d = t.getRotateWithView(), m = t.getKeepUpright(), f = t.getRotation();
        this.text_ = t.getText() || "", this.textOffsetX_ = c === void 0 ? 0 : c, this.textOffsetY_ = u === void 0 ? 0 : u, this.textRotateWithView_ = d === void 0 ? !1 : d, this.textKeepUpright_ = m === void 0 ? !0 : m, this.textRotation_ = f === void 0 ? 0 : f, this.strokeKey_ = r ? (typeof r.strokeStyle == "string" ? r.strokeStyle : St(r.strokeStyle)) + r.lineCap + r.lineDashOffset + "|" + r.lineWidth + r.lineJoin + r.miterLimit + "[" + r.lineDash.join() + "]" : "", this.textKey_ = n.font + n.scale + (n.textAlign || "?") + (n.repeat || "?") + (n.justify || "?") + (n.textBaseline || "?"), this.fillKey_ = s && s.fillStyle ? typeof s.fillStyle == "string" ? s.fillStyle : "|" + St(s.fillStyle) : "";
      }
      this.declutterMode_ = t.getDeclutterMode(), this.declutterImageWithText_ = e;
    }
  }
  const ay = {
    Circle: wu,
    Default: Kr,
    Image: ey,
    LineString: iy,
    Polygon: wu,
    Text: ry
  };
  class oy {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Max extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(t, e, n, s) {
      this.tolerance_ = t, this.maxExtent_ = e, this.pixelRatio_ = s, this.resolution_ = n, this.buildersByZIndex_ = {};
    }
    /**
     * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
     */
    finish() {
      const t = {};
      for (const e in this.buildersByZIndex_) {
        t[e] = t[e] || {};
        const n = this.buildersByZIndex_[e];
        for (const s in n) {
          const r = n[s].finish();
          t[e][s] = r;
        }
      }
      return t;
    }
    /**
     * @param {number|undefined} zIndex Z index.
     * @param {import("../canvas.js").BuilderType} builderType Replay type.
     * @return {import("../VectorContext.js").default} Replay.
     */
    getBuilder(t, e) {
      const n = t !== void 0 ? t.toString() : "0";
      let s = this.buildersByZIndex_[n];
      s === void 0 && (s = {}, this.buildersByZIndex_[n] = s);
      let r = s[e];
      if (r === void 0) {
        const a = ay[e];
        r = new a(
          this.tolerance_,
          this.maxExtent_,
          this.resolution_,
          this.pixelRatio_
        ), s[e] = r;
      }
      return r;
    }
  }
  const ly = 5;
  class hy extends Dr {
    /**
     * @param {LayerType} layer Layer.
     */
    constructor(t) {
      super(), this.ready = !0, this.boundHandleImageChange_ = this.handleImageChange_.bind(this), this.layer_ = t, this.staleKeys_ = new Array(), this.maxStaleKeys = ly;
    }
    /**
     * @return {Array<string>} Get the list of stale keys.
     */
    getStaleKeys() {
      return this.staleKeys_;
    }
    /**
     * @param {string} key The new stale key.
     */
    prependStaleKey(t) {
      this.staleKeys_.unshift(t), this.staleKeys_.length > this.maxStaleKeys && (this.staleKeys_.length = this.maxStaleKeys);
    }
    /**
     * Asynchronous layer level hit detection.
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
     * an array of features.
     */
    getFeatures(t) {
      return ft();
    }
    /**
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     */
    getData(t) {
      return null;
    }
    /**
     * Determine whether render should be called.
     * @abstract
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */
    prepareFrame(t) {
      return ft();
    }
    /**
     * Render the layer.
     * @abstract
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement|null} target Target that may be used to render content to.
     * @return {HTMLElement|null} The rendered element.
     */
    renderFrame(t, e) {
      return ft();
    }
    /**
     * @abstract
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
     * @return {T|undefined} Callback result.
     * @template T
     */
    forEachFeatureAtCoordinate(t, e, n, s, r) {
    }
    /**
     * @return {LayerType} Layer.
     */
    getLayer() {
      return this.layer_;
    }
    /**
     * Perform action necessary to get the layer rendered after new fonts have loaded
     * @abstract
     */
    handleFontsChanged() {
    }
    /**
     * Handle changes in image state.
     * @param {import("../events/Event.js").default} event Image change event.
     * @private
     */
    handleImageChange_(t) {
      const e = (
        /** @type {import("../Image.js").default} */
        t.target
      );
      (e.getState() === mt.LOADED || e.getState() === mt.ERROR) && this.renderIfReadyAndVisible();
    }
    /**
     * Load the image if not already loaded, and register the image change
     * listener if needed.
     * @param {import("../Image.js").default} image Image.
     * @return {boolean} `true` if the image is already loaded, `false` otherwise.
     * @protected
     */
    loadImage(t) {
      let e = t.getState();
      return e != mt.LOADED && e != mt.ERROR && t.addEventListener(ht.CHANGE, this.boundHandleImageChange_), e == mt.IDLE && (t.load(), e = t.getState()), e == mt.LOADED;
    }
    /**
     * @protected
     */
    renderIfReadyAndVisible() {
      const t = this.getLayer();
      t && t.getVisible() && t.getSourceState() === "ready" && t.changed();
    }
    /**
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */
    renderDeferred(t) {
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      delete this.layer_, super.disposeInternal();
    }
  }
  class xf {
    constructor() {
      /**
       * @private
       * @param {...*} args Args.
       * @return {ZIndexContext} This.
       */
      Wi(this, "pushMethodArgs_", (...t) => (this.instructions_[this.zIndex + this.offset_].push(t), this));
      this.instructions_ = [], this.zIndex = 0, this.offset_ = 0, this.context_ = /** @type {ZIndexContextProxy} */
      new Proxy(Wa(), {
        get: (t, e) => {
          if (typeof /** @type {*} */
          Wa()[e] == "function")
            return this.instructions_[this.zIndex + this.offset_] || (this.instructions_[this.zIndex + this.offset_] = []), this.instructions_[this.zIndex + this.offset_].push(e), this.pushMethodArgs_;
        },
        set: (t, e, n) => (this.instructions_[this.zIndex + this.offset_] || (this.instructions_[this.zIndex + this.offset_] = []), this.instructions_[this.zIndex + this.offset_].push(e, n), !0)
      });
    }
    /**
     * Push a function that renders to the context directly.
     * @param {function(CanvasRenderingContext2D): void} render Function.
     */
    pushFunction(t) {
      this.instructions_[this.zIndex + this.offset_].push(t);
    }
    /**
     * Get a proxy for CanvasRenderingContext2D which does not support getting state
     * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a
     * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,
     * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.
     * @return {ZIndexContextProxy} Context.
     */
    getContext() {
      return this.context_;
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     */
    draw(t) {
      this.instructions_.forEach((e) => {
        for (let n = 0, s = e.length; n < s; ++n) {
          const r = e[n];
          if (typeof r == "function") {
            r(t);
            continue;
          }
          const a = e[++n];
          if (typeof /** @type {*} */
          t[r] == "function")
            t[r](...a);
          else {
            if (typeof a == "function") {
              t[r] = a(t);
              continue;
            }
            t[r] = a;
          }
        }
      });
    }
    clear() {
      this.instructions_.length = 0, this.zIndex = 0, this.offset_ = 0;
    }
    /**
     * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to
     * avoid conflicting context.clip() or context.save()/restore() calls.
     */
    offset() {
      this.offset_ = this.instructions_.length, this.zIndex = 0;
    }
  }
  const Ru = [];
  let ls = null;
  function cy() {
    ls = Xt(1, 1, void 0, {
      willReadFrequently: !0
    });
  }
  class Mf extends hy {
    /**
     * @param {LayerType} layer Layer.
     */
    constructor(t) {
      super(t), this.container = null, this.renderedResolution, this.tempTransform = We(), this.pixelTransform = We(), this.inversePixelTransform = We(), this.context = null, this.deferredContext_ = null, this.containerReused = !1, this.frameState = null;
    }
    /**
     * @param {import('../../DataTile.js').ImageLike} image Image.
     * @param {number} col The column index.
     * @param {number} row The row index.
     * @return {Uint8ClampedArray|null} The image data.
     */
    getImageData(t, e, n) {
      ls || cy(), ls.clearRect(0, 0, 1, 1);
      let s;
      try {
        ls.drawImage(t, e, n, 1, 1, 0, 0, 1, 1), s = ls.getImageData(0, 0, 1, 1).data;
      } catch {
        return ls = null, null;
      }
      return s;
    }
    /**
     * @param {import('../../Map.js').FrameState} frameState Frame state.
     * @return {string} Background color.
     */
    getBackground(t) {
      let n = this.getLayer().getBackground();
      return typeof n == "function" && (n = n(t.viewState.resolution)), n || void 0;
    }
    /**
     * Get a rendering container from an existing target, if compatible.
     * @param {HTMLElement} target Potential render target.
     * @param {string} transform CSS Transform.
     * @param {string} [backgroundColor] Background color.
     */
    useContainer(t, e, n) {
      const s = this.getLayer().getClassName();
      let r, a;
      if (t && t.className === s && (!n || t && t.style.backgroundColor && fn(
        Os(t.style.backgroundColor),
        Os(n)
      ))) {
        const o = t.firstElementChild;
        o instanceof HTMLCanvasElement && (a = o.getContext("2d"));
      }
      if (a && a.canvas.style.transform === e ? (this.container = t, this.context = a, this.containerReused = !0) : this.containerReused ? (this.container = null, this.context = null, this.containerReused = !1) : this.container && (this.container.style.backgroundColor = null), !this.container) {
        r = document.createElement("div"), r.className = s;
        let o = r.style;
        o.position = "absolute", o.width = "100%", o.height = "100%", a = Xt();
        const l = a.canvas;
        r.appendChild(l), o = l.style, o.position = "absolute", o.left = "0", o.transformOrigin = "top left", this.container = r, this.context = a;
      }
      !this.containerReused && n && !this.container.style.backgroundColor && (this.container.style.backgroundColor = n);
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {import("../../extent.js").Extent} extent Clip extent.
     * @protected
     */
    clipUnrotated(t, e, n) {
      const s = fi(n), r = Br(n), a = zr(n), o = Ur(n);
      Yt(e.coordinateToPixelTransform, s), Yt(e.coordinateToPixelTransform, r), Yt(e.coordinateToPixelTransform, a), Yt(e.coordinateToPixelTransform, o);
      const l = this.inversePixelTransform;
      Yt(l, s), Yt(l, r), Yt(l, a), Yt(l, o), t.save(), t.beginPath(), t.moveTo(Math.round(s[0]), Math.round(s[1])), t.lineTo(Math.round(r[0]), Math.round(r[1])), t.lineTo(Math.round(a[0]), Math.round(a[1])), t.lineTo(Math.round(o[0]), Math.round(o[1])), t.clip();
    }
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target that may be used to render content to.
     * @protected
     */
    prepareContainer(t, e) {
      const n = t.extent, s = t.viewState.resolution, r = t.viewState.rotation, a = t.pixelRatio, o = Math.round(_t(n) / s * a), l = Math.round($t(n) / s * a);
      Li(
        this.pixelTransform,
        t.size[0] / 2,
        t.size[1] / 2,
        1 / a,
        1 / a,
        r,
        -o / 2,
        -l / 2
      ), Nd(this.inversePixelTransform, this.pixelTransform);
      const h = Nm(this.pixelTransform);
      if (this.useContainer(e, h, this.getBackground(t)), !this.containerReused) {
        const c = this.context.canvas;
        c.width != o || c.height != l ? (c.width = o, c.height = l) : this.context.clearRect(0, 0, o, l), h !== c.style.transform && (c.style.transform = h);
      }
    }
    /**
     * @param {import("../../render/EventType.js").default} type Event type.
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @private
     */
    dispatchRenderEvent_(t, e, n) {
      const s = this.getLayer();
      if (s.hasListener(t)) {
        const r = new df(
          t,
          this.inversePixelTransform,
          n,
          e
        );
        s.dispatchEvent(r);
      }
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    preRender(t, e) {
      this.frameState = e, !e.declutter && this.dispatchRenderEvent_(Be.PRERENDER, t, e);
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    postRender(t, e) {
      e.declutter || this.dispatchRenderEvent_(Be.POSTRENDER, t, e);
    }
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     */
    renderDeferredInternal(t) {
    }
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.
     */
    getRenderContext(t) {
      return t.declutter && !this.deferredContext_ && (this.deferredContext_ = new xf()), t.declutter ? this.deferredContext_.getContext() : this.context;
    }
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @override
     */
    renderDeferred(t) {
      t.declutter && (this.dispatchRenderEvent_(
        Be.PRERENDER,
        this.context,
        t
      ), t.declutter && this.deferredContext_ && (this.deferredContext_.draw(this.context), this.deferredContext_.clear()), this.renderDeferredInternal(t), this.dispatchRenderEvent_(
        Be.POSTRENDER,
        this.context,
        t
      ));
    }
    /**
     * Creates a transform for rendering to an element that will be rotated after rendering.
     * @param {import("../../coordinate.js").Coordinate} center Center.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {number} pixelRatio Pixel ratio.
     * @param {number} width Width of the rendered element (in pixels).
     * @param {number} height Height of the rendered element (in pixels).
     * @param {number} offsetX Offset on the x-axis in view coordinates.
     * @protected
     * @return {!import("../../transform.js").Transform} Transform.
     */
    getRenderTransform(t, e, n, s, r, a, o) {
      const l = r / 2, h = a / 2, c = s / e, u = -c, d = -t[0] + o, m = -t[1];
      return Li(
        this.tempTransform,
        l,
        h,
        c,
        u,
        -n,
        d,
        m
      );
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      delete this.frameState, super.disposeInternal();
    }
  }
  function uy(i, t, e, n, s, r, a, o, l, h, c, u, d = !0) {
    let m = i[t], f = i[t + 1], y = 0, E = 0, x = 0, M = 0;
    function C() {
      y = m, E = f, t += n, m = i[t], f = i[t + 1], M += x, x = Math.sqrt((m - y) * (m - y) + (f - E) * (f - E));
    }
    do
      C();
    while (t < e - n && M + x < r);
    let R = x === 0 ? 0 : (r - M) / x;
    const S = Fe(y, m, R), A = Fe(E, f, R), O = t - n, P = M, L = r + o * l(h, s, c);
    for (; t < e - n && M + x < L; )
      C();
    R = x === 0 ? 0 : (L - M) / x;
    const F = Fe(y, m, R), z = Fe(E, f, R);
    let D = !1;
    if (d)
      if (u) {
        const X = [S, A, F, z];
        Rh(X, 0, 4, 2, u, X, X), D = X[0] > X[2];
      } else
        D = S > F;
    const j = Math.PI, Y = [], q = O + n === t;
    t = O, x = 0, M = P, m = i[t], f = i[t + 1];
    let J;
    if (q) {
      C(), J = Math.atan2(f - E, m - y), D && (J += J > 0 ? -j : j);
      const X = (F + S) / 2, et = (z + A) / 2;
      return Y[0] = [X, et, (L - r) / 2, J, s], Y;
    }
    s = s.replace(/\n/g, " ");
    for (let X = 0, et = s.length; X < et; ) {
      C();
      let lt = Math.atan2(f - E, m - y);
      if (D && (lt += lt > 0 ? -j : j), J !== void 0) {
        let ot = lt - J;
        if (ot += ot > j ? -2 * j : ot < -j ? 2 * j : 0, Math.abs(ot) > a)
          return null;
      }
      J = lt;
      const Q = X;
      let W = 0;
      for (; X < et; ++X) {
        const ot = D ? et - X - 1 : X, Ct = o * l(h, s[ot], c);
        if (t + n < e && M + x < r + W + Ct / 2)
          break;
        W += Ct;
      }
      if (X === Q)
        continue;
      const gt = D ? s.substring(et - Q, et - X) : s.substring(Q, X);
      R = x === 0 ? 0 : (r + W / 2 - M) / x;
      const it = Fe(y, m, R), T = Fe(E, f, R);
      Y.push([it, T, W / 2, lt, gt]), r += W;
    }
    return Y;
  }
  const ts = Ae(), Zi = [], wi = [], Ri = [], qi = [];
  function Su(i) {
    return i[3].declutterBox;
  }
  const Cu = new RegExp(
    /* eslint-disable prettier/prettier */
    "[-----]"
    /* eslint-enable prettier/prettier */
  );
  function ul(i, t) {
    return t === "start" ? t = Cu.test(i) ? "right" : "left" : t === "end" && (t = Cu.test(i) ? "left" : "right"), Ha[t];
  }
  function dy(i, t, e) {
    return e > 0 && i.push(`
`, ""), i.push(t, ""), i;
  }
  class fy {
    /**
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {boolean} overlaps The replay can have overlapping geometries.
     * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions.
     * @param {boolean} [deferredRendering] Enable deferred rendering.
     */
    constructor(t, e, n, s, r) {
      this.overlaps = n, this.pixelRatio = e, this.resolution = t, this.alignAndScaleFill_, this.instructions = s.instructions, this.coordinates = s.coordinates, this.coordinateCache_ = {}, this.renderedTransform_ = We(), this.hitDetectionInstructions = s.hitDetectionInstructions, this.pixelCoordinates_ = null, this.viewRotation_ = 0, this.fillStates = s.fillStates || {}, this.strokeStates = s.strokeStates || {}, this.textStates = s.textStates || {}, this.widths_ = {}, this.labels_ = {}, this.zIndexContext_ = r ? new xf() : null;
    }
    /**
     * @return {ZIndexContext} ZIndex context.
     */
    getZIndexContext() {
      return this.zIndexContext_;
    }
    /**
     * @param {string|Array<string>} text Text.
     * @param {string} textKey Text style key.
     * @param {string} fillKey Fill style key.
     * @param {string} strokeKey Stroke style key.
     * @return {import("../canvas.js").Label} Label.
     */
    createLabel(t, e, n, s) {
      const r = t + e + n + s;
      if (this.labels_[r])
        return this.labels_[r];
      const a = s ? this.strokeStates[s] : null, o = n ? this.fillStates[n] : null, l = this.textStates[e], h = this.pixelRatio, c = [
        l.scale[0] * h,
        l.scale[1] * h
      ], u = l.justify ? Ha[l.justify] : ul(
        Array.isArray(t) ? t[0] : t,
        l.textAlign || Tr
      ), d = s && a.lineWidth ? a.lineWidth : 0, m = Array.isArray(t) ? t : String(t).split(`
`).reduce(dy, []), { width: f, height: y, widths: E, heights: x, lineWidths: M } = P_(
        l,
        m
      ), C = f + d, R = [], S = (C + 2) * c[0], A = (y + d) * c[1], O = {
        width: S < 0 ? Math.floor(S) : Math.ceil(S),
        height: A < 0 ? Math.floor(A) : Math.ceil(A),
        contextInstructions: R
      };
      (c[0] != 1 || c[1] != 1) && R.push("scale", c), s && (R.push("strokeStyle", a.strokeStyle), R.push("lineWidth", d), R.push("lineCap", a.lineCap), R.push("lineJoin", a.lineJoin), R.push("miterLimit", a.miterLimit), R.push("setLineDash", [a.lineDash]), R.push("lineDashOffset", a.lineDashOffset)), n && R.push("fillStyle", o.fillStyle), R.push("textBaseline", "middle"), R.push("textAlign", "center");
      const P = 0.5 - u;
      let L = u * C + P * d;
      const F = [], z = [];
      let D = 0, j = 0, Y = 0, q = 0, J;
      for (let X = 0, et = m.length; X < et; X += 2) {
        const lt = m[X];
        if (lt === `
`) {
          j += D, D = 0, L = u * C + P * d, ++q;
          continue;
        }
        const Q = m[X + 1] || l.font;
        Q !== J && (s && F.push("font", Q), n && z.push("font", Q), J = Q), D = Math.max(D, x[Y]);
        const W = [
          lt,
          L + P * E[Y] + u * (E[Y] - M[q]),
          0.5 * (d + D) + j
        ];
        L += E[Y], s && F.push("strokeText", W), n && z.push("fillText", W), ++Y;
      }
      return Array.prototype.push.apply(R, F), Array.prototype.push.apply(R, z), this.labels_[r] = O, O;
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
     * @param {Array<*>} fillInstruction Fill instruction.
     * @param {Array<*>} strokeInstruction Stroke instruction.
     */
    replayTextBackground_(t, e, n, s, r, a, o) {
      t.beginPath(), t.moveTo.apply(t, e), t.lineTo.apply(t, n), t.lineTo.apply(t, s), t.lineTo.apply(t, r), t.lineTo.apply(t, e), a && (this.alignAndScaleFill_ = /** @type {number} */
      a[2], this.fill_(t)), o && (this.setStrokeStyle_(
        t,
        /** @type {Array<*>} */
        o
      ), t.stroke());
    }
    /**
     * @private
     * @param {number} sheetWidth Width of the sprite sheet.
     * @param {number} sheetHeight Height of the sprite sheet.
     * @param {number} centerX X.
     * @param {number} centerY Y.
     * @param {number} width Width.
     * @param {number} height Height.
     * @param {number} anchorX Anchor X.
     * @param {number} anchorY Anchor Y.
     * @param {number} originX Origin X.
     * @param {number} originY Origin Y.
     * @param {number} rotation Rotation.
     * @param {import("../../size.js").Size} scale Scale.
     * @param {boolean} snapToPixel Snap to pixel.
     * @param {Array<number>} padding Padding.
     * @param {boolean} fillStroke Background fill or stroke.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
     */
    calculateImageOrLabelDimensions_(t, e, n, s, r, a, o, l, h, c, u, d, m, f, y, E) {
      o *= d[0], l *= d[1];
      let x = n - o, M = s - l;
      const C = r + h > t ? t - h : r, R = a + c > e ? e - c : a, S = f[3] + C * d[0] + f[1], A = f[0] + R * d[1] + f[2], O = x - f[3], P = M - f[0];
      (y || u !== 0) && (Zi[0] = O, qi[0] = O, Zi[1] = P, wi[1] = P, wi[0] = O + S, Ri[0] = wi[0], Ri[1] = P + A, qi[1] = Ri[1]);
      let L;
      return u !== 0 ? (L = Li(
        We(),
        n,
        s,
        1,
        1,
        u,
        -n,
        -s
      ), Yt(L, Zi), Yt(L, wi), Yt(L, Ri), Yt(L, qi), ke(
        Math.min(Zi[0], wi[0], Ri[0], qi[0]),
        Math.min(Zi[1], wi[1], Ri[1], qi[1]),
        Math.max(Zi[0], wi[0], Ri[0], qi[0]),
        Math.max(Zi[1], wi[1], Ri[1], qi[1]),
        ts
      )) : ke(
        Math.min(O, O + S),
        Math.min(P, P + A),
        Math.max(O, O + S),
        Math.max(P, P + A),
        ts
      ), m && (x = Math.round(x), M = Math.round(M)), {
        drawImageX: x,
        drawImageY: M,
        drawImageW: C,
        drawImageH: R,
        originX: h,
        originY: c,
        declutterBox: {
          minX: ts[0],
          minY: ts[1],
          maxX: ts[2],
          maxY: ts[3],
          value: E
        },
        canvasTransform: L,
        scale: d
      };
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
     * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
     * @param {ImageOrLabelDimensions} dimensions Dimensions.
     * @param {number} opacity Opacity.
     * @param {Array<*>} fillInstruction Fill instruction.
     * @param {Array<*>} strokeInstruction Stroke instruction.
     * @return {boolean} The image or label was rendered.
     */
    replayImageOrLabel_(t, e, n, s, r, a, o) {
      const l = !!(a || o), h = s.declutterBox, c = o ? o[2] * s.scale[0] / 2 : 0;
      return h.minX - c <= e[0] && h.maxX + c >= 0 && h.minY - c <= e[1] && h.maxY + c >= 0 && (l && this.replayTextBackground_(
        t,
        Zi,
        wi,
        Ri,
        qi,
        /** @type {Array<*>} */
        a,
        /** @type {Array<*>} */
        o
      ), b_(
        t,
        s.canvasTransform,
        r,
        n,
        s.originX,
        s.originY,
        s.drawImageW,
        s.drawImageH,
        s.drawImageX,
        s.drawImageY,
        s.scale
      )), !0;
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     */
    fill_(t) {
      const e = this.alignAndScaleFill_;
      if (e) {
        const n = Yt(this.renderedTransform_, [0, 0]), s = 512 * this.pixelRatio;
        t.save(), t.translate(n[0] % s, n[1] % s), e !== 1 && t.scale(e, e), t.rotate(this.viewRotation_);
      }
      t.fill(), e && t.restore();
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {Array<*>} instruction Instruction.
     */
    setStrokeStyle_(t, e) {
      t.strokeStyle = /** @type {import("../../colorlike.js").ColorLike} */
      e[1], t.lineWidth = /** @type {number} */
      e[2], t.lineCap = /** @type {CanvasLineCap} */
      e[3], t.lineJoin = /** @type {CanvasLineJoin} */
      e[4], t.miterLimit = /** @type {number} */
      e[5], t.lineDashOffset = /** @type {number} */
      e[7], t.setLineDash(
        /** @type {Array<number>} */
        e[6]
      );
    }
    /**
     * @private
     * @param {string|Array<string>} text The text to draw.
     * @param {string} textKey The key of the text state.
     * @param {string} strokeKey The key for the stroke state.
     * @param {string} fillKey The key for the fill state.
     * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
     */
    drawLabelWithPointPlacement_(t, e, n, s) {
      const r = this.textStates[e], a = this.createLabel(t, e, s, n), o = this.strokeStates[n], l = this.pixelRatio, h = ul(
        Array.isArray(t) ? t[0] : t,
        r.textAlign || Tr
      ), c = Ha[r.textBaseline || Ya], u = o && o.lineWidth ? o.lineWidth : 0, d = a.width / l - 2 * r.scale[0], m = h * d + 2 * (0.5 - h) * u, f = c * a.height / l + 2 * (0.5 - c) * u;
      return {
        label: a,
        anchorX: m,
        anchorY: f
      };
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {Array<*>} instructions Instructions array.
     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
     * @param {FeatureCallback<T>} [featureCallback] Feature callback.
     * @param {import("../../extent.js").Extent} [hitExtent] Only check
     *     features that intersect this extent.
     * @param {import("rbush").default<DeclutterEntry>} [declutterTree] Declutter tree.
     * @return {T|undefined} Callback result.
     * @template T
     */
    execute_(t, e, n, s, r, a, o, l) {
      const h = this.zIndexContext_;
      let c;
      this.pixelCoordinates_ && fn(n, this.renderedTransform_) ? c = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), c = on(
        this.coordinates,
        0,
        this.coordinates.length,
        2,
        n,
        this.pixelCoordinates_
      ), bm(this.renderedTransform_, n));
      let u = 0;
      const d = s.length;
      let m = 0, f, y, E, x, M, C, R, S, A, O, P, L, F, z = 0, D = 0, j = null, Y = null;
      const q = this.coordinateCache_, J = this.viewRotation_, X = Math.round(Math.atan2(-n[1], n[0]) * 1e12) / 1e12, et = (
        /** @type {import("../../render.js").State} */
        {
          context: t,
          pixelRatio: this.pixelRatio,
          resolution: this.resolution,
          rotation: J
        }
      ), lt = this.instructions != s || this.overlaps ? 0 : 200;
      let Q, W, gt, it;
      for (; u < d; ) {
        const T = s[u];
        switch (
          /** @type {import("./Instruction.js").default} */
          T[0]
        ) {
          case nt.BEGIN_GEOMETRY:
            Q = /** @type {import("../../Feature.js").FeatureLike} */
            T[1], it = T[3], Q.getGeometry() ? o !== void 0 && !he(o, it.getExtent()) ? u = /** @type {number} */
            T[2] + 1 : ++u : u = /** @type {number} */
            T[2], h && (h.zIndex = T[4]);
            break;
          case nt.BEGIN_PATH:
            z > lt && (this.fill_(t), z = 0), D > lt && (t.stroke(), D = 0), !z && !D && (t.beginPath(), M = NaN, C = NaN), ++u;
            break;
          case nt.CIRCLE:
            m = /** @type {number} */
            T[1];
            const Ct = c[m], Lt = c[m + 1], Zt = c[m + 2], be = c[m + 3], Jt = Zt - Ct, Le = be - Lt, _i = Math.sqrt(Jt * Jt + Le * Le);
            t.moveTo(Ct + _i, Lt), t.arc(Ct, Lt, _i, 0, 2 * Math.PI, !0), ++u;
            break;
          case nt.CLOSE_PATH:
            t.closePath(), ++u;
            break;
          case nt.CUSTOM:
            m = /** @type {number} */
            T[1], f = T[2];
            const Ze = (
              /** @type {import("../../geom/SimpleGeometry.js").default} */
              T[3]
            ), _n = T[4], pi = T[5];
            et.geometry = Ze, et.feature = Q, u in q || (q[u] = []);
            const qe = q[u];
            pi ? pi(c, m, f, 2, qe) : (qe[0] = c[m], qe[1] = c[m + 1], qe.length = 2), h && (h.zIndex = T[6]), _n(qe, et), ++u;
            break;
          case nt.DRAW_IMAGE:
            m = /** @type {number} */
            T[1], f = /** @type {number} */
            T[2], A = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
            T[3], y = /** @type {number} */
            T[4], E = /** @type {number} */
            T[5];
            let ye = (
              /** @type {number} */
              T[6]
            );
            const Ge = (
              /** @type {number} */
              T[7]
            ), Gi = (
              /** @type {number} */
              T[8]
            ), Ke = (
              /** @type {number} */
              T[9]
            ), pn = (
              /** @type {boolean} */
              T[10]
            );
            let yi = (
              /** @type {number} */
              T[11]
            );
            const Ui = (
              /** @type {import("../../size.js").Size} */
              T[12]
            );
            let zi = (
              /** @type {number} */
              T[13]
            );
            x = T[14] || "declutter";
            const Bt = (
              /** @type {{args: import("../canvas.js").DeclutterImageWithText, declutterMode: import('../../style/Style.js').DeclutterMode}} */
              T[15]
            );
            if (!A && T.length >= 20) {
              O = /** @type {string} */
              T[19], P = /** @type {string} */
              T[20], L = /** @type {string} */
              T[21], F = /** @type {string} */
              T[22];
              const ve = this.drawLabelWithPointPlacement_(
                O,
                P,
                L,
                F
              );
              A = ve.label, T[3] = A;
              const ri = (
                /** @type {number} */
                T[23]
              );
              y = (ve.anchorX - ri) * this.pixelRatio, T[4] = y;
              const ne = (
                /** @type {number} */
                T[24]
              );
              E = (ve.anchorY - ne) * this.pixelRatio, T[5] = E, ye = A.height, T[6] = ye, zi = A.width, T[13] = zi;
            }
            let Xn;
            T.length > 25 && (Xn = /** @type {number} */
            T[25]);
            let Wn, Bi, $i;
            T.length > 17 ? (Wn = /** @type {Array<number>} */
            T[16], Bi = /** @type {boolean} */
            T[17], $i = /** @type {boolean} */
            T[18]) : (Wn = In, Bi = !1, $i = !1), pn && X ? yi += J : !pn && !X && (yi -= J);
            let Yn = 0;
            for (; m < f; m += 2) {
              if (Xn && Xn[Yn++] < zi / this.pixelRatio)
                continue;
              const ve = this.calculateImageOrLabelDimensions_(
                A.width,
                A.height,
                c[m],
                c[m + 1],
                zi,
                ye,
                y,
                E,
                Gi,
                Ke,
                yi,
                Ui,
                r,
                Wn,
                Bi || $i,
                Q
              ), ri = [
                t,
                e,
                A,
                ve,
                Ge,
                Bi ? (
                  /** @type {Array<*>} */
                  j
                ) : null,
                $i ? (
                  /** @type {Array<*>} */
                  Y
                ) : null
              ];
              if (l) {
                let ne, Ee, xe;
                if (Bt) {
                  const kt = f - m;
                  if (!Bt[kt]) {
                    Bt[kt] = { args: ri, declutterMode: x };
                    continue;
                  }
                  const qt = Bt[kt];
                  ne = qt.args, Ee = qt.declutterMode, delete Bt[kt], xe = Su(ne);
                }
                let je, Ve;
                if (ne && (Ee !== "declutter" || !l.collides(xe)) && (je = !0), (x !== "declutter" || !l.collides(ve.declutterBox)) && (Ve = !0), Ee === "declutter" && x === "declutter") {
                  const kt = je && Ve;
                  je = kt, Ve = kt;
                }
                je && (Ee !== "none" && l.insert(xe), this.replayImageOrLabel_.apply(this, ne)), Ve && (x !== "none" && l.insert(ve.declutterBox), this.replayImageOrLabel_.apply(this, ri));
              } else
                this.replayImageOrLabel_.apply(this, ri);
            }
            ++u;
            break;
          case nt.DRAW_CHARS:
            const Zn = (
              /** @type {number} */
              T[1]
            ), qn = (
              /** @type {number} */
              T[2]
            ), vi = (
              /** @type {number} */
              T[3]
            ), Go = (
              /** @type {number} */
              T[4]
            );
            F = /** @type {string} */
            T[5];
            const Uo = (
              /** @type {number} */
              T[6]
            ), Ws = (
              /** @type {number} */
              T[7]
            ), Ys = (
              /** @type {number} */
              T[8]
            );
            L = /** @type {string} */
            T[9];
            const yn = (
              /** @type {number} */
              T[10]
            );
            O = /** @type {string} */
            T[11], P = /** @type {string} */
            T[12];
            const Zs = [
              /** @type {number} */
              T[13],
              /** @type {number} */
              T[13]
            ];
            x = T[14] || "declutter";
            const zo = (
              /** @type {boolean} */
              T[15]
            ), Kn = this.textStates[P], Xi = Kn.font, Ei = [
              Kn.scale[0] * Ws,
              Kn.scale[1] * Ws
            ];
            let xi;
            Xi in this.widths_ ? xi = this.widths_[Xi] : (xi = {}, this.widths_[Xi] = xi);
            const qs = vf(c, Zn, qn, 2), ia = Math.abs(Ei[0]) * cu(Xi, O, xi);
            if (Go || ia <= qs) {
              const ve = this.textStates[P].textAlign, ri = (qs - ia) * ul(O, ve), ne = uy(
                c,
                Zn,
                qn,
                2,
                O,
                ri,
                Uo,
                Math.abs(Ei[0]),
                cu,
                Xi,
                xi,
                X ? 0 : this.viewRotation_,
                zo
              );
              t: if (ne) {
                const Ee = [];
                let xe, je, Ve, kt, qt;
                if (L)
                  for (xe = 0, je = ne.length; xe < je; ++xe) {
                    qt = ne[xe], Ve = /** @type {string} */
                    qt[4], kt = this.createLabel(Ve, P, "", L), y = /** @type {number} */
                    qt[2] + (Ei[0] < 0 ? -yn : yn), E = vi * kt.height + (0.5 - vi) * 2 * yn * Ei[1] / Ei[0] - Ys;
                    const He = this.calculateImageOrLabelDimensions_(
                      kt.width,
                      kt.height,
                      qt[0],
                      qt[1],
                      kt.width,
                      kt.height,
                      y,
                      E,
                      0,
                      0,
                      qt[3],
                      Zs,
                      !1,
                      In,
                      !1,
                      Q
                    );
                    if (l && x === "declutter" && l.collides(He.declutterBox))
                      break t;
                    Ee.push([
                      t,
                      e,
                      kt,
                      He,
                      1,
                      null,
                      null
                    ]);
                  }
                if (F)
                  for (xe = 0, je = ne.length; xe < je; ++xe) {
                    qt = ne[xe], Ve = /** @type {string} */
                    qt[4], kt = this.createLabel(Ve, P, F, ""), y = /** @type {number} */
                    qt[2], E = vi * kt.height - Ys;
                    const He = this.calculateImageOrLabelDimensions_(
                      kt.width,
                      kt.height,
                      qt[0],
                      qt[1],
                      kt.width,
                      kt.height,
                      y,
                      E,
                      0,
                      0,
                      qt[3],
                      Zs,
                      !1,
                      In,
                      !1,
                      Q
                    );
                    if (l && x === "declutter" && l.collides(He.declutterBox))
                      break t;
                    Ee.push([
                      t,
                      e,
                      kt,
                      He,
                      1,
                      null,
                      null
                    ]);
                  }
                l && x !== "none" && l.load(Ee.map(Su));
                for (let He = 0, na = Ee.length; He < na; ++He)
                  this.replayImageOrLabel_.apply(this, Ee[He]);
              }
            }
            ++u;
            break;
          case nt.END_GEOMETRY:
            if (a !== void 0) {
              Q = /** @type {import("../../Feature.js").FeatureLike} */
              T[1];
              const ve = a(
                Q,
                it,
                x
              );
              if (ve)
                return ve;
            }
            ++u;
            break;
          case nt.FILL:
            lt ? z++ : this.fill_(t), ++u;
            break;
          case nt.MOVE_TO_LINE_TO:
            for (m = /** @type {number} */
            T[1], f = /** @type {number} */
            T[2], W = c[m], gt = c[m + 1], t.moveTo(W, gt), M = W + 0.5 | 0, C = gt + 0.5 | 0, m += 2; m < f; m += 2)
              W = c[m], gt = c[m + 1], R = W + 0.5 | 0, S = gt + 0.5 | 0, (m == f - 2 || R !== M || S !== C) && (t.lineTo(W, gt), M = R, C = S);
            ++u;
            break;
          case nt.SET_FILL_STYLE:
            j = T, this.alignAndScaleFill_ = T[2], z && (this.fill_(t), z = 0, D && (t.stroke(), D = 0)), t.fillStyle = T[1], ++u;
            break;
          case nt.SET_STROKE_STYLE:
            Y = T, D && (t.stroke(), D = 0), this.setStrokeStyle_(
              t,
              /** @type {Array<*>} */
              T
            ), ++u;
            break;
          case nt.STROKE:
            lt ? D++ : t.stroke(), ++u;
            break;
          default:
            ++u;
            break;
        }
      }
      z && this.fill_(t), D && t.stroke();
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
     * @param {import("rbush").default<DeclutterEntry>} [declutterTree] Declutter tree.
     */
    execute(t, e, n, s, r, a) {
      this.viewRotation_ = s, this.execute_(
        t,
        e,
        n,
        this.instructions,
        r,
        void 0,
        void 0,
        a
      );
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {FeatureCallback<T>} [featureCallback] Feature callback.
     * @param {import("../../extent.js").Extent} [hitExtent] Only check
     *     features that intersect this extent.
     * @return {T|undefined} Callback result.
     * @template T
     */
    executeHitDetection(t, e, n, s, r) {
      return this.viewRotation_ = n, this.execute_(
        t,
        [t.canvas.width, t.canvas.height],
        e,
        this.hitDetectionInstructions,
        !0,
        s,
        r
      );
    }
  }
  const us = [
    "Polygon",
    "Circle",
    "LineString",
    "Image",
    "Text",
    "Default"
  ], wf = ["Image", "Text"], gy = us.filter(
    (i) => !wf.includes(i)
  );
  class my {
    /**
     * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
     * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
     * should be set here, unless the target context does not exceed that extent (which
     * can be the case when rendering to tiles).
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {boolean} overlaps The executor group can have overlapping geometries.
     * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
     * The serializable instructions.
     * @param {number} [renderBuffer] Optional rendering buffer.
     * @param {boolean} [deferredRendering] Enable deferred rendering with renderDeferred().
     */
    constructor(t, e, n, s, r, a, o) {
      this.maxExtent_ = t, this.overlaps_ = s, this.pixelRatio_ = n, this.resolution_ = e, this.renderBuffer_ = a, this.executorsByZIndex_ = {}, this.hitDetectionContext_ = null, this.hitDetectionTransform_ = We(), this.renderedContext_ = null, this.deferredZIndexContexts_ = {}, this.createExecutors_(r, o);
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../transform.js").Transform} transform Transform.
     */
    clip(t, e) {
      const n = this.getClipCoords(e);
      t.beginPath(), t.moveTo(n[0], n[1]), t.lineTo(n[2], n[3]), t.lineTo(n[4], n[5]), t.lineTo(n[6], n[7]), t.clip();
    }
    /**
     * Create executors and populate them using the provided instructions.
     * @private
     * @param {!Object<string, !Object<string, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
     * @param {boolean} deferredRendering Enable deferred rendering.
     */
    createExecutors_(t, e) {
      for (const n in t) {
        let s = this.executorsByZIndex_[n];
        s === void 0 && (s = {}, this.executorsByZIndex_[n] = s);
        const r = t[n];
        for (const a in r) {
          const o = r[a];
          s[a] = new fy(
            this.resolution_,
            this.pixelRatio_,
            this.overlaps_,
            o,
            e
          );
        }
      }
    }
    /**
     * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
     * @return {boolean} Has executors of the provided types.
     */
    hasExecutors(t) {
      for (const e in this.executorsByZIndex_) {
        const n = this.executorsByZIndex_[e];
        for (let s = 0, r = t.length; s < r; ++s)
          if (t[s] in n)
            return !0;
      }
      return !1;
    }
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
     * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
     * @return {T|undefined} Callback result.
     * @template T
     */
    forEachFeatureAtCoordinate(t, e, n, s, r, a) {
      s = Math.round(s);
      const o = s * 2 + 1, l = Li(
        this.hitDetectionTransform_,
        s + 0.5,
        s + 0.5,
        1 / e,
        -1 / e,
        -n,
        -t[0],
        -t[1]
      ), h = !this.hitDetectionContext_;
      h && (this.hitDetectionContext_ = Xt(
        o,
        o,
        void 0,
        { willReadFrequently: !0 }
      ));
      const c = this.hitDetectionContext_;
      c.canvas.width !== o || c.canvas.height !== o ? (c.canvas.width = o, c.canvas.height = o) : h || c.clearRect(0, 0, o, o);
      let u;
      this.renderBuffer_ !== void 0 && (u = Ae(), Ln(u, t), go(
        u,
        e * (this.renderBuffer_ + s),
        u
      ));
      const d = _y(s);
      let m;
      function f(S, A, O) {
        const P = c.getImageData(
          0,
          0,
          o,
          o
        ).data;
        for (let L = 0, F = d.length; L < F; L++)
          if (P[d[L]] > 0) {
            if (!a || O === "none" || m !== "Image" && m !== "Text" || a.includes(S)) {
              const z = (d[L] - 3) / 4, D = s - z % o, j = s - (z / o | 0), Y = r(S, A, D * D + j * j);
              if (Y)
                return Y;
            }
            c.clearRect(0, 0, o, o);
            break;
          }
      }
      const y = Object.keys(this.executorsByZIndex_).map(Number);
      y.sort(rn);
      let E, x, M, C, R;
      for (E = y.length - 1; E >= 0; --E) {
        const S = y[E].toString();
        for (M = this.executorsByZIndex_[S], x = us.length - 1; x >= 0; --x)
          if (m = us[x], C = M[m], C !== void 0 && (R = C.executeHitDetection(
            c,
            l,
            n,
            f,
            u
          ), R))
            return R;
      }
    }
    /**
     * @param {import("../../transform.js").Transform} transform Transform.
     * @return {Array<number>|null} Clip coordinates.
     */
    getClipCoords(t) {
      const e = this.maxExtent_;
      if (!e)
        return null;
      const n = e[0], s = e[1], r = e[2], a = e[3], o = [n, s, n, a, r, a, r, s];
      return on(o, 0, 8, 2, t, o), o;
    }
    /**
     * @return {boolean} Is empty.
     */
    isEmpty() {
      return As(this.executorsByZIndex_);
    }
    /**
     * @param {CanvasRenderingContext2D} targetContext Context.
     * @param {import('../../size.js').Size} scaledCanvasSize Scale of the context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
     * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
     *     Default is {@link module:ol/render/replay~ALL}
     * @param {import("rbush").default<import('./Executor.js').DeclutterEntry>|null} [declutterTree] Declutter tree.
     *     When set to null, no decluttering is done, even when the executor group has a `ZIndexContext`.
     */
    execute(t, e, n, s, r, a, o) {
      const l = Object.keys(this.executorsByZIndex_).map(Number);
      l.sort(o ? S0 : rn), a = a || us;
      const h = us.length;
      for (let c = 0, u = l.length; c < u; ++c) {
        const d = l[c].toString(), m = this.executorsByZIndex_[d];
        for (let f = 0, y = a.length; f < y; ++f) {
          const E = a[f], x = m[E];
          if (x !== void 0) {
            const M = o === null ? void 0 : x.getZIndexContext(), C = M ? M.getContext() : t, R = this.maxExtent_ && E !== "Image" && E !== "Text";
            if (R && (C.save(), this.clip(C, n)), !M || E === "Text" || E === "Image" ? x.execute(
              C,
              e,
              n,
              s,
              r,
              o
            ) : M.pushFunction(
              (S) => x.execute(
                S,
                e,
                n,
                s,
                r,
                o
              )
            ), R && C.restore(), M) {
              M.offset();
              const S = l[c] * h + f;
              this.deferredZIndexContexts_[S] || (this.deferredZIndexContexts_[S] = []), this.deferredZIndexContexts_[S].push(M);
            }
          }
        }
      }
      this.renderedContext_ = t;
    }
    getDeferredZIndexContexts() {
      return this.deferredZIndexContexts_;
    }
    getRenderedContext() {
      return this.renderedContext_;
    }
    renderDeferred() {
      const t = this.deferredZIndexContexts_, e = Object.keys(t).map(Number).sort(rn);
      for (let n = 0, s = e.length; n < s; ++n)
        t[e[n]].forEach((r) => {
          r.draw(this.renderedContext_), r.clear();
        }), t[e[n]].length = 0;
    }
  }
  const dl = {};
  function _y(i) {
    if (dl[i] !== void 0)
      return dl[i];
    const t = i * 2 + 1, e = i * i, n = new Array(e + 1);
    for (let r = 0; r <= i; ++r)
      for (let a = 0; a <= i; ++a) {
        const o = r * r + a * a;
        if (o > e)
          break;
        let l = n[o];
        l || (l = [], n[o] = l), l.push(((i + r) * t + (i + a)) * 4 + 3), r > 0 && l.push(((i - r) * t + (i + a)) * 4 + 3), a > 0 && (l.push(((i + r) * t + (i - a)) * 4 + 3), r > 0 && l.push(((i - r) * t + (i - a)) * 4 + 3));
      }
    const s = [];
    for (let r = 0, a = n.length; r < a; ++r)
      n[r] && s.push(...n[r]);
    return dl[i] = s, s;
  }
  class Vh extends Ef {
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../../extent.js").Extent} extent Extent.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
     * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
     */
    constructor(t, e, n, s, r, a, o) {
      super(), this.context_ = t, this.pixelRatio_ = e, this.extent_ = n, this.transform_ = s, this.transformRotation_ = s ? oh(Math.atan2(s[1], s[0]), 10) : 0, this.viewRotation_ = r, this.squaredTolerance_ = a, this.userTransform_ = o, this.contextFillState_ = null, this.contextStrokeState_ = null, this.contextTextState_ = null, this.fillState_ = null, this.strokeState_ = null, this.image_ = null, this.imageAnchorX_ = 0, this.imageAnchorY_ = 0, this.imageHeight_ = 0, this.imageOpacity_ = 0, this.imageOriginX_ = 0, this.imageOriginY_ = 0, this.imageRotateWithView_ = !1, this.imageRotation_ = 0, this.imageScale_ = [0, 0], this.imageWidth_ = 0, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = !1, this.textRotation_ = 0, this.textScale_ = [0, 0], this.textFillState_ = null, this.textStrokeState_ = null, this.textState_ = null, this.pixelCoordinates_ = [], this.tmpLocalTransform_ = We();
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @private
     */
    drawImages_(t, e, n, s) {
      if (!this.image_)
        return;
      const r = on(
        t,
        e,
        n,
        s,
        this.transform_,
        this.pixelCoordinates_
      ), a = this.context_, o = this.tmpLocalTransform_, l = a.globalAlpha;
      this.imageOpacity_ != 1 && (a.globalAlpha = l * this.imageOpacity_);
      let h = this.imageRotation_;
      this.transformRotation_ === 0 && (h -= this.viewRotation_), this.imageRotateWithView_ && (h += this.viewRotation_);
      for (let c = 0, u = r.length; c < u; c += 2) {
        const d = r[c] - this.imageAnchorX_, m = r[c + 1] - this.imageAnchorY_;
        if (h !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
          const f = d + this.imageAnchorX_, y = m + this.imageAnchorY_;
          Li(
            o,
            f,
            y,
            1,
            1,
            h,
            -f,
            -y
          ), a.save(), a.transform.apply(a, o), a.translate(f, y), a.scale(this.imageScale_[0], this.imageScale_[1]), a.drawImage(
            this.image_,
            this.imageOriginX_,
            this.imageOriginY_,
            this.imageWidth_,
            this.imageHeight_,
            -this.imageAnchorX_,
            -this.imageAnchorY_,
            this.imageWidth_,
            this.imageHeight_
          ), a.restore();
        } else
          a.drawImage(
            this.image_,
            this.imageOriginX_,
            this.imageOriginY_,
            this.imageWidth_,
            this.imageHeight_,
            d,
            m,
            this.imageWidth_,
            this.imageHeight_
          );
      }
      this.imageOpacity_ != 1 && (a.globalAlpha = l);
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @private
     */
    drawText_(t, e, n, s) {
      if (!this.textState_ || this.text_ === "")
        return;
      this.textFillState_ && this.setContextFillState_(this.textFillState_), this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_), this.setContextTextState_(this.textState_);
      const r = on(
        t,
        e,
        n,
        s,
        this.transform_,
        this.pixelCoordinates_
      ), a = this.context_;
      let o = this.textRotation_;
      for (this.transformRotation_ === 0 && (o -= this.viewRotation_), this.textRotateWithView_ && (o += this.viewRotation_); e < n; e += s) {
        const l = r[e] + this.textOffsetX_, h = r[e + 1] + this.textOffsetY_;
        o !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1 ? (a.save(), a.translate(l - this.textOffsetX_, h - this.textOffsetY_), a.rotate(o), a.translate(this.textOffsetX_, this.textOffsetY_), a.scale(this.textScale_[0], this.textScale_[1]), this.textStrokeState_ && a.strokeText(this.text_, 0, 0), this.textFillState_ && a.fillText(this.text_, 0, 0), a.restore()) : (this.textStrokeState_ && a.strokeText(this.text_, l, h), this.textFillState_ && a.fillText(this.text_, l, h));
      }
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {boolean} close Close.
     * @private
     * @return {number} end End.
     */
    moveToLineTo_(t, e, n, s, r) {
      const a = this.context_, o = on(
        t,
        e,
        n,
        s,
        this.transform_,
        this.pixelCoordinates_
      );
      a.moveTo(o[0], o[1]);
      let l = o.length;
      r && (l -= 2);
      for (let h = 2; h < l; h += 2)
        a.lineTo(o[h], o[h + 1]);
      return r && a.closePath(), n;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @private
     * @return {number} End.
     */
    drawRings_(t, e, n, s) {
      for (let r = 0, a = n.length; r < a; ++r)
        e = this.moveToLineTo_(
          t,
          e,
          n[r],
          s,
          !0
        );
      return e;
    }
    /**
     * Render a circle geometry into the canvas.  Rendering is immediate and uses
     * the current fill and stroke styles.
     *
     * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
     * @api
     * @override
     */
    drawCircle(t) {
      if (this.squaredTolerance_ && (t = /** @type {import("../../geom/Circle.js").default} */
      t.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      )), !!he(this.extent_, t.getExtent())) {
        if (this.fillState_ || this.strokeState_) {
          this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
          const e = Gm(
            t,
            this.transform_,
            this.pixelCoordinates_
          ), n = e[2] - e[0], s = e[3] - e[1], r = Math.sqrt(n * n + s * s), a = this.context_;
          a.beginPath(), a.arc(
            e[0],
            e[1],
            r,
            0,
            2 * Math.PI
          ), this.fillState_ && a.fill(), this.strokeState_ && a.stroke();
        }
        this.text_ !== "" && this.drawText_(t.getCenter(), 0, 2, 2);
      }
    }
    /**
     * Set the rendering style.  Note that since this is an immediate rendering API,
     * any `zIndex` on the provided style will be ignored.
     *
     * @param {import("../../style/Style.js").default} style The rendering style.
     * @api
     * @override
     */
    setStyle(t) {
      this.setFillStrokeStyle(t.getFill(), t.getStroke()), this.setImageStyle(t.getImage()), this.setTextStyle(t.getText());
    }
    /**
     * @param {import("../../transform.js").Transform} transform Transform.
     */
    setTransform(t) {
      this.transform_ = t;
    }
    /**
     * Render a geometry into the canvas.  Call
     * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
     *
     * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
     * @api
     * @override
     */
    drawGeometry(t) {
      switch (t.getType()) {
        case "Point":
          this.drawPoint(
            /** @type {import("../../geom/Point.js").default} */
            t
          );
          break;
        case "LineString":
          this.drawLineString(
            /** @type {import("../../geom/LineString.js").default} */
            t
          );
          break;
        case "Polygon":
          this.drawPolygon(
            /** @type {import("../../geom/Polygon.js").default} */
            t
          );
          break;
        case "MultiPoint":
          this.drawMultiPoint(
            /** @type {import("../../geom/MultiPoint.js").default} */
            t
          );
          break;
        case "MultiLineString":
          this.drawMultiLineString(
            /** @type {import("../../geom/MultiLineString.js").default} */
            t
          );
          break;
        case "MultiPolygon":
          this.drawMultiPolygon(
            /** @type {import("../../geom/MultiPolygon.js").default} */
            t
          );
          break;
        case "GeometryCollection":
          this.drawGeometryCollection(
            /** @type {import("../../geom/GeometryCollection.js").default} */
            t
          );
          break;
        case "Circle":
          this.drawCircle(
            /** @type {import("../../geom/Circle.js").default} */
            t
          );
          break;
      }
    }
    /**
     * Render a feature into the canvas.  Note that any `zIndex` on the provided
     * style will be ignored - features are rendered immediately in the order that
     * this method is called.  If you need `zIndex` support, you should be using an
     * {@link module:ol/layer/Vector~VectorLayer} instead.
     *
     * @param {import("../../Feature.js").default} feature Feature.
     * @param {import("../../style/Style.js").default} style Style.
     * @api
     * @override
     */
    drawFeature(t, e) {
      const n = e.getGeometryFunction()(t);
      n && (this.setStyle(e), this.drawGeometry(n));
    }
    /**
     * Render a GeometryCollection to the canvas.  Rendering is immediate and
     * uses the current styles appropriate for each geometry in the collection.
     *
     * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
     * @override
     */
    drawGeometryCollection(t) {
      const e = t.getGeometriesArray();
      for (let n = 0, s = e.length; n < s; ++n)
        this.drawGeometry(e[n]);
    }
    /**
     * Render a Point geometry into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
     * @override
     */
    drawPoint(t) {
      this.squaredTolerance_ && (t = /** @type {import("../../geom/Point.js").default} */
      t.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      ));
      const e = t.getFlatCoordinates(), n = t.getStride();
      this.image_ && this.drawImages_(e, 0, e.length, n), this.text_ !== "" && this.drawText_(e, 0, e.length, n);
    }
    /**
     * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
     * uses the current style.
     *
     * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
     * @override
     */
    drawMultiPoint(t) {
      this.squaredTolerance_ && (t = /** @type {import("../../geom/MultiPoint.js").default} */
      t.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      ));
      const e = t.getFlatCoordinates(), n = t.getStride();
      this.image_ && this.drawImages_(e, 0, e.length, n), this.text_ !== "" && this.drawText_(e, 0, e.length, n);
    }
    /**
     * Render a LineString into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
     * @override
     */
    drawLineString(t) {
      if (this.squaredTolerance_ && (t = /** @type {import("../../geom/LineString.js").default} */
      t.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      )), !!he(this.extent_, t.getExtent())) {
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
          const e = this.context_, n = t.getFlatCoordinates();
          e.beginPath(), this.moveToLineTo_(
            n,
            0,
            n.length,
            t.getStride(),
            !1
          ), e.stroke();
        }
        if (this.text_ !== "") {
          const e = t.getFlatMidpoint();
          this.drawText_(e, 0, 2, 2);
        }
      }
    }
    /**
     * Render a MultiLineString geometry into the canvas.  Rendering is immediate
     * and uses the current style.
     *
     * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
     * @override
     */
    drawMultiLineString(t) {
      this.squaredTolerance_ && (t = /** @type {import("../../geom/MultiLineString.js").default} */
      t.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      ));
      const e = t.getExtent();
      if (he(this.extent_, e)) {
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
          const n = this.context_, s = t.getFlatCoordinates();
          let r = 0;
          const a = (
            /** @type {Array<number>} */
            t.getEnds()
          ), o = t.getStride();
          n.beginPath();
          for (let l = 0, h = a.length; l < h; ++l)
            r = this.moveToLineTo_(
              s,
              r,
              a[l],
              o,
              !1
            );
          n.stroke();
        }
        if (this.text_ !== "") {
          const n = t.getFlatMidpoints();
          this.drawText_(n, 0, n.length, 2);
        }
      }
    }
    /**
     * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
     * @override
     */
    drawPolygon(t) {
      if (this.squaredTolerance_ && (t = /** @type {import("../../geom/Polygon.js").default} */
      t.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      )), !!he(this.extent_, t.getExtent())) {
        if (this.strokeState_ || this.fillState_) {
          this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
          const e = this.context_;
          e.beginPath(), this.drawRings_(
            t.getOrientedFlatCoordinates(),
            0,
            /** @type {Array<number>} */
            t.getEnds(),
            t.getStride()
          ), this.fillState_ && e.fill(), this.strokeState_ && e.stroke();
        }
        if (this.text_ !== "") {
          const e = t.getFlatInteriorPoint();
          this.drawText_(e, 0, 2, 2);
        }
      }
    }
    /**
     * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
     * uses the current style.
     * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
     * @override
     */
    drawMultiPolygon(t) {
      if (this.squaredTolerance_ && (t = /** @type {import("../../geom/MultiPolygon.js").default} */
      t.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      )), !!he(this.extent_, t.getExtent())) {
        if (this.strokeState_ || this.fillState_) {
          this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
          const e = this.context_, n = t.getOrientedFlatCoordinates();
          let s = 0;
          const r = t.getEndss(), a = t.getStride();
          e.beginPath();
          for (let o = 0, l = r.length; o < l; ++o) {
            const h = r[o];
            s = this.drawRings_(n, s, h, a);
          }
          this.fillState_ && e.fill(), this.strokeState_ && e.stroke();
        }
        if (this.text_ !== "") {
          const e = t.getFlatInteriorPoints();
          this.drawText_(e, 0, e.length, 2);
        }
      }
    }
    /**
     * @param {import("../canvas.js").FillState} fillState Fill state.
     * @private
     */
    setContextFillState_(t) {
      const e = this.context_, n = this.contextFillState_;
      n ? n.fillStyle != t.fillStyle && (n.fillStyle = t.fillStyle, e.fillStyle = t.fillStyle) : (e.fillStyle = t.fillStyle, this.contextFillState_ = {
        fillStyle: t.fillStyle
      });
    }
    /**
     * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
     * @private
     */
    setContextStrokeState_(t) {
      const e = this.context_, n = this.contextStrokeState_;
      n ? (n.lineCap != t.lineCap && (n.lineCap = t.lineCap, e.lineCap = t.lineCap), fn(n.lineDash, t.lineDash) || e.setLineDash(
        n.lineDash = t.lineDash
      ), n.lineDashOffset != t.lineDashOffset && (n.lineDashOffset = t.lineDashOffset, e.lineDashOffset = t.lineDashOffset), n.lineJoin != t.lineJoin && (n.lineJoin = t.lineJoin, e.lineJoin = t.lineJoin), n.lineWidth != t.lineWidth && (n.lineWidth = t.lineWidth, e.lineWidth = t.lineWidth), n.miterLimit != t.miterLimit && (n.miterLimit = t.miterLimit, e.miterLimit = t.miterLimit), n.strokeStyle != t.strokeStyle && (n.strokeStyle = t.strokeStyle, e.strokeStyle = t.strokeStyle)) : (e.lineCap = t.lineCap, e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset, e.lineJoin = t.lineJoin, e.lineWidth = t.lineWidth, e.miterLimit = t.miterLimit, e.strokeStyle = t.strokeStyle, this.contextStrokeState_ = {
        lineCap: t.lineCap,
        lineDash: t.lineDash,
        lineDashOffset: t.lineDashOffset,
        lineJoin: t.lineJoin,
        lineWidth: t.lineWidth,
        miterLimit: t.miterLimit,
        strokeStyle: t.strokeStyle
      });
    }
    /**
     * @param {import("../canvas.js").TextState} textState Text state.
     * @private
     */
    setContextTextState_(t) {
      const e = this.context_, n = this.contextTextState_, s = t.textAlign ? t.textAlign : Tr;
      n ? (n.font != t.font && (n.font = t.font, e.font = t.font), n.textAlign != s && (n.textAlign = s, e.textAlign = s), n.textBaseline != t.textBaseline && (n.textBaseline = t.textBaseline, e.textBaseline = t.textBaseline)) : (e.font = t.font, e.textAlign = s, e.textBaseline = t.textBaseline, this.contextTextState_ = {
        font: t.font,
        textAlign: s,
        textBaseline: t.textBaseline
      });
    }
    /**
     * Set the fill and stroke style for subsequent draw operations.  To clear
     * either fill or stroke styles, pass null for the appropriate parameter.
     *
     * @param {import("../../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
     * @override
     */
    setFillStrokeStyle(t, e) {
      if (!t)
        this.fillState_ = null;
      else {
        const n = t.getColor();
        this.fillState_ = {
          fillStyle: ci(
            n || Re
          )
        };
      }
      if (!e)
        this.strokeState_ = null;
      else {
        const n = e.getColor(), s = e.getLineCap(), r = e.getLineDash(), a = e.getLineDashOffset(), o = e.getLineJoin(), l = e.getWidth(), h = e.getMiterLimit(), c = r || Ai;
        this.strokeState_ = {
          lineCap: s !== void 0 ? s : Ns,
          lineDash: this.pixelRatio_ === 1 ? c : c.map((u) => u * this.pixelRatio_),
          lineDashOffset: (a || Pi) * this.pixelRatio_,
          lineJoin: o !== void 0 ? o : Fs,
          lineWidth: (l !== void 0 ? l : Ir) * this.pixelRatio_,
          miterLimit: h !== void 0 ? h : Sr,
          strokeStyle: ci(
            n || Cr
          )
        };
      }
    }
    /**
     * Set the image style for subsequent draw operations.  Pass null to remove
     * the image style.
     *
     * @param {import("../../style/Image.js").default} imageStyle Image style.
     * @override
     */
    setImageStyle(t) {
      let e;
      if (!t || !(e = t.getSize())) {
        this.image_ = null;
        return;
      }
      const n = t.getPixelRatio(this.pixelRatio_), s = t.getAnchor(), r = t.getOrigin();
      this.image_ = t.getImage(this.pixelRatio_), this.imageAnchorX_ = s[0] * n, this.imageAnchorY_ = s[1] * n, this.imageHeight_ = e[1] * n, this.imageOpacity_ = t.getOpacity(), this.imageOriginX_ = r[0], this.imageOriginY_ = r[1], this.imageRotateWithView_ = t.getRotateWithView(), this.imageRotation_ = t.getRotation();
      const a = t.getScaleArray();
      this.imageScale_ = [
        a[0] * this.pixelRatio_ / n,
        a[1] * this.pixelRatio_ / n
      ], this.imageWidth_ = e[0] * n;
    }
    /**
     * Set the text style for subsequent draw operations.  Pass null to
     * remove the text style.
     *
     * @param {import("../../style/Text.js").default} textStyle Text style.
     * @override
     */
    setTextStyle(t) {
      if (!t)
        this.text_ = "";
      else {
        const e = t.getFill();
        if (!e)
          this.textFillState_ = null;
        else {
          const m = e.getColor();
          this.textFillState_ = {
            fillStyle: ci(
              m || Re
            )
          };
        }
        const n = t.getStroke();
        if (!n)
          this.textStrokeState_ = null;
        else {
          const m = n.getColor(), f = n.getLineCap(), y = n.getLineDash(), E = n.getLineDashOffset(), x = n.getLineJoin(), M = n.getWidth(), C = n.getMiterLimit();
          this.textStrokeState_ = {
            lineCap: f !== void 0 ? f : Ns,
            lineDash: y || Ai,
            lineDashOffset: E || Pi,
            lineJoin: x !== void 0 ? x : Fs,
            lineWidth: M !== void 0 ? M : Ir,
            miterLimit: C !== void 0 ? C : Sr,
            strokeStyle: ci(
              m || Cr
            )
          };
        }
        const s = t.getFont(), r = t.getOffsetX(), a = t.getOffsetY(), o = t.getRotateWithView(), l = t.getRotation(), h = t.getScaleArray(), c = t.getText(), u = t.getTextAlign(), d = t.getTextBaseline();
        this.textState_ = {
          font: s !== void 0 ? s : tf,
          textAlign: u !== void 0 ? u : Tr,
          textBaseline: d !== void 0 ? d : Ya
        }, this.text_ = c !== void 0 ? Array.isArray(c) ? c.reduce((m, f, y) => m += y % 2 ? " " : f, "") : c : "", this.textOffsetX_ = r !== void 0 ? this.pixelRatio_ * r : 0, this.textOffsetY_ = a !== void 0 ? this.pixelRatio_ * a : 0, this.textRotateWithView_ = o !== void 0 ? o : !1, this.textRotation_ = l !== void 0 ? l : 0, this.textScale_ = [
          this.pixelRatio_ * h[0],
          this.pixelRatio_ * h[1]
        ];
      }
    }
  }
  const py = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Circle: Gn,
    Fill: ti,
    Icon: Wr,
    IconImage: $h,
    Image: $r,
    RegularShape: Xr,
    Stroke: Ne,
    Style: oe,
    Text: Po
  }, Symbol.toStringTag, { value: "Module" })), li = 0.5;
  function yy(i, t, e, n, s, r, a, o, l) {
    const h = s, c = i[0] * li, u = i[1] * li, d = Xt(c, u);
    d.imageSmoothingEnabled = !1;
    const m = d.canvas, f = new Vh(
      d,
      li,
      s,
      null,
      a,
      o,
      null
    ), y = e.length, E = Math.floor((256 * 256 * 256 - 1) / y), x = {};
    for (let C = 1; C <= y; ++C) {
      const R = e[C - 1], S = R.getStyleFunction() || n;
      if (!S)
        continue;
      let A = S(R, r);
      if (!A)
        continue;
      Array.isArray(A) || (A = [A]);
      const P = (C * E).toString(16).padStart(7, "#00000");
      for (let L = 0, F = A.length; L < F; ++L) {
        const z = A[L], D = z.getGeometryFunction()(R);
        if (!D || !he(h, D.getExtent()))
          continue;
        const j = z.clone(), Y = j.getFill();
        Y && Y.setColor(P);
        const q = j.getStroke();
        q && (q.setColor(P), q.setLineDash(null)), j.setText(void 0);
        const J = z.getImage();
        if (J) {
          const Q = J.getImageSize();
          if (!Q)
            continue;
          const W = Xt(
            Q[0],
            Q[1],
            void 0,
            { alpha: !1 }
          ), gt = W.canvas;
          W.fillStyle = P, W.fillRect(0, 0, gt.width, gt.height), j.setImage(
            new Wr({
              img: gt,
              anchor: J.getAnchor(),
              anchorXUnits: "pixels",
              anchorYUnits: "pixels",
              offset: J.getOrigin(),
              opacity: 1,
              size: J.getSize(),
              scale: J.getScale(),
              rotation: J.getRotation(),
              rotateWithView: J.getRotateWithView()
            })
          );
        }
        const X = j.getZIndex() || 0;
        let et = x[X];
        et || (et = {}, x[X] = et, et.Polygon = [], et.Circle = [], et.LineString = [], et.Point = []);
        const lt = D.getType();
        if (lt === "GeometryCollection") {
          const Q = (
            /** @type {import("../../geom/GeometryCollection.js").default} */
            D.getGeometriesArrayRecursive()
          );
          for (let W = 0, gt = Q.length; W < gt; ++W) {
            const it = Q[W];
            et[it.getType().replace("Multi", "")].push(
              it,
              j
            );
          }
        } else
          et[lt.replace("Multi", "")].push(D, j);
      }
    }
    const M = Object.keys(x).map(Number).sort(rn);
    for (let C = 0, R = M.length; C < R; ++C) {
      const S = x[M[C]];
      for (const A in S) {
        const O = S[A];
        for (let P = 0, L = O.length; P < L; P += 2) {
          f.setStyle(O[P + 1]);
          for (let F = 0, z = t.length; F < z; ++F)
            f.setTransform(t[F]), f.drawGeometry(O[P]);
        }
      }
    }
    return d.getImageData(0, 0, m.width, m.height);
  }
  function vy(i, t, e) {
    const n = [];
    if (e) {
      const s = Math.floor(Math.round(i[0]) * li), r = Math.floor(Math.round(i[1]) * li), a = (Gt(s, 0, e.width - 1) + Gt(r, 0, e.height - 1) * e.width) * 4, o = e.data[a], l = e.data[a + 1], c = e.data[a + 2] + 256 * (l + 256 * o), u = Math.floor((256 * 256 * 256 - 1) / t.length);
      c && c % u === 0 && n.push(t[c / u - 1]);
    }
    return n;
  }
  const Ey = 0.5, Rf = {
    Point: Iy,
    LineString: Sy,
    Polygon: Py,
    MultiPoint: Ay,
    MultiLineString: Cy,
    MultiPolygon: Ty,
    GeometryCollection: Ry,
    Circle: My
  };
  function xy(i, t) {
    return parseInt(St(i), 10) - parseInt(St(t), 10);
  }
  function Xl(i, t) {
    const e = Sf(i, t);
    return e * e;
  }
  function Sf(i, t) {
    return Ey * i / t;
  }
  function My(i, t, e, n, s) {
    const r = e.getFill(), a = e.getStroke();
    if (r || a) {
      const l = i.getBuilder(e.getZIndex(), "Circle");
      l.setFillStrokeStyle(r, a), l.drawCircle(t, n, s);
    }
    const o = e.getText();
    if (o && o.getText()) {
      const l = i.getBuilder(e.getZIndex(), "Text");
      l.setTextStyle(o), l.drawText(t, n);
    }
  }
  function Tu(i, t, e, n, s, r, a, o) {
    const l = [], h = e.getImage();
    if (h) {
      let d = !0;
      const m = h.getImageState();
      m == mt.LOADED || m == mt.ERROR ? d = !1 : m == mt.IDLE && h.load(), d && l.push(h.ready());
    }
    const c = e.getFill();
    c && c.loading() && l.push(c.ready());
    const u = l.length > 0;
    return u && Promise.all(l).then(() => s(null)), wy(
      i,
      t,
      e,
      n,
      r,
      a,
      o
    ), u;
  }
  function wy(i, t, e, n, s, r, a) {
    const o = e.getGeometryFunction()(t);
    if (!o)
      return;
    const l = o.simplifyTransformed(
      n,
      s
    );
    if (e.getRenderer())
      Cf(i, l, e, t, a);
    else {
      const c = Rf[l.getType()];
      c(
        i,
        l,
        e,
        t,
        a,
        r
      );
    }
  }
  function Cf(i, t, e, n, s) {
    if (t.getType() == "GeometryCollection") {
      const a = (
        /** @type {import("../geom/GeometryCollection.js").default} */
        t.getGeometries()
      );
      for (let o = 0, l = a.length; o < l; ++o)
        Cf(i, a[o], e, n, s);
      return;
    }
    i.getBuilder(e.getZIndex(), "Default").drawCustom(
      /** @type {import("../geom/SimpleGeometry.js").default} */
      t,
      n,
      e.getRenderer(),
      e.getHitDetectionRenderer(),
      s
    );
  }
  function Ry(i, t, e, n, s, r) {
    const a = t.getGeometriesArray();
    let o, l;
    for (o = 0, l = a.length; o < l; ++o) {
      const h = Rf[a[o].getType()];
      h(
        i,
        a[o],
        e,
        n,
        s,
        r
      );
    }
  }
  function Sy(i, t, e, n, s) {
    const r = e.getStroke();
    if (r) {
      const o = i.getBuilder(
        e.getZIndex(),
        "LineString"
      );
      o.setFillStrokeStyle(null, r), o.drawLineString(t, n, s);
    }
    const a = e.getText();
    if (a && a.getText()) {
      const o = i.getBuilder(e.getZIndex(), "Text");
      o.setTextStyle(a), o.drawText(t, n, s);
    }
  }
  function Cy(i, t, e, n, s) {
    const r = e.getStroke();
    if (r) {
      const o = i.getBuilder(
        e.getZIndex(),
        "LineString"
      );
      o.setFillStrokeStyle(null, r), o.drawMultiLineString(t, n, s);
    }
    const a = e.getText();
    if (a && a.getText()) {
      const o = i.getBuilder(e.getZIndex(), "Text");
      o.setTextStyle(a), o.drawText(t, n, s);
    }
  }
  function Ty(i, t, e, n, s) {
    const r = e.getFill(), a = e.getStroke();
    if (a || r) {
      const l = i.getBuilder(e.getZIndex(), "Polygon");
      l.setFillStrokeStyle(r, a), l.drawMultiPolygon(t, n, s);
    }
    const o = e.getText();
    if (o && o.getText()) {
      const l = i.getBuilder(e.getZIndex(), "Text");
      l.setTextStyle(o), l.drawText(t, n, s);
    }
  }
  function Iy(i, t, e, n, s, r) {
    const a = e.getImage(), o = e.getText(), l = o && o.getText(), h = r && a && l ? {} : void 0;
    if (a) {
      if (a.getImageState() != mt.LOADED)
        return;
      const c = i.getBuilder(e.getZIndex(), "Image");
      c.setImageStyle(a, h), c.drawPoint(t, n, s);
    }
    if (l) {
      const c = i.getBuilder(e.getZIndex(), "Text");
      c.setTextStyle(o, h), c.drawText(t, n, s);
    }
  }
  function Ay(i, t, e, n, s, r) {
    const a = e.getImage(), o = a && a.getOpacity() !== 0, l = e.getText(), h = l && l.getText(), c = r && o && h ? {} : void 0;
    if (o) {
      if (a.getImageState() != mt.LOADED)
        return;
      const u = i.getBuilder(e.getZIndex(), "Image");
      u.setImageStyle(a, c), u.drawMultiPoint(t, n, s);
    }
    if (h) {
      const u = i.getBuilder(e.getZIndex(), "Text");
      u.setTextStyle(l, c), u.drawText(t, n, s);
    }
  }
  function Py(i, t, e, n, s) {
    const r = e.getFill(), a = e.getStroke();
    if (r || a) {
      const l = i.getBuilder(e.getZIndex(), "Polygon");
      l.setFillStrokeStyle(r, a), l.drawPolygon(t, n, s);
    }
    const o = e.getText();
    if (o && o.getText()) {
      const l = i.getBuilder(e.getZIndex(), "Text");
      l.setTextStyle(o), l.drawText(t, n, s);
    }
  }
  class by extends Mf {
    /**
     * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
     */
    constructor(t) {
      super(t), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.animatingOrInteracting_, this.hitDetectionImageData_ = null, this.clipped_ = !1, this.renderedFeatures_ = null, this.renderedRevision_ = -1, this.renderedResolution_ = NaN, this.renderedExtent_ = Ae(), this.wrappedRenderedExtent_ = Ae(), this.renderedRotation_, this.renderedCenter_ = null, this.renderedProjection_ = null, this.renderedPixelRatio_ = 1, this.renderedRenderOrder_ = null, this.renderedFrameDeclutter_, this.replayGroup_ = null, this.replayGroupChanged = !0, this.clipping = !0, this.targetContext_ = null, this.opacity_ = 1;
    }
    /**
     * @param {ExecutorGroup} executorGroup Executor group.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {boolean} [declutterable] `true` to only render declutterable items,
     *     `false` to only render non-declutterable items, `undefined` to render all.
     */
    renderWorlds(t, e, n) {
      const s = e.extent, r = e.viewState, a = r.center, o = r.resolution, l = r.projection, h = r.rotation, c = l.getExtent(), u = this.getLayer().getSource(), d = this.getLayer().getDeclutter(), m = e.pixelRatio, f = e.viewHints, y = !(f[ae.ANIMATING] || f[ae.INTERACTING]), E = this.context, x = Math.round(_t(s) / o * m), M = Math.round($t(s) / o * m), C = u.getWrapX() && l.canWrapX(), R = C ? _t(c) : null, S = C ? Math.ceil((s[2] - c[2]) / R) + 1 : 1;
      let A = C ? Math.floor((s[0] - c[0]) / R) : 0;
      do {
        let O = this.getRenderTransform(
          a,
          o,
          0,
          m,
          x,
          M,
          A * R
        );
        e.declutter && (O = O.slice(0)), t.execute(
          E,
          [E.canvas.width, E.canvas.height],
          O,
          h,
          y,
          n === void 0 ? us : n ? wf : gy,
          n ? d && e.declutter[d] : void 0
        );
      } while (++A < S);
    }
    /**
     * @private
     */
    setDrawContext_() {
      this.opacity_ !== 1 && (this.targetContext_ = this.context, this.context = Xt(
        this.context.canvas.width,
        this.context.canvas.height,
        Ru
      ));
    }
    /**
     * @private
     */
    resetDrawContext_() {
      if (this.opacity_ !== 1) {
        const t = this.targetContext_.globalAlpha;
        this.targetContext_.globalAlpha = this.opacity_, this.targetContext_.drawImage(this.context.canvas, 0, 0), this.targetContext_.globalAlpha = t, Io(this.context), Ru.push(this.context.canvas), this.context = this.targetContext_, this.targetContext_ = null;
      }
    }
    /**
     * Render declutter items for this layer
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     */
    renderDeclutter(t) {
      !this.replayGroup_ || !this.getLayer().getDeclutter() || this.renderWorlds(this.replayGroup_, t, !0);
    }
    /**
     * Render deferred instructions.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @override
     */
    renderDeferredInternal(t) {
      this.replayGroup_ && (this.replayGroup_.renderDeferred(), this.clipped_ && this.context.restore(), this.resetDrawContext_());
    }
    /**
     * Render the layer.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement|null} target Target that may be used to render content to.
     * @return {HTMLElement|null} The rendered element.
     * @override
     */
    renderFrame(t, e) {
      const n = t.layerStatesArray[t.layerIndex];
      this.opacity_ = n.opacity;
      const s = t.viewState;
      this.prepareContainer(t, e);
      const r = this.context, a = this.replayGroup_;
      let o = a && !a.isEmpty();
      if (!o && !(this.getLayer().hasListener(Be.PRERENDER) || this.getLayer().hasListener(Be.POSTRENDER)))
        return null;
      if (this.setDrawContext_(), this.preRender(r, t), s.projection, this.clipped_ = !1, o && n.extent && this.clipping) {
        const l = tn(n.extent);
        o = he(l, t.extent), this.clipped_ = o && !Qi(l, t.extent), this.clipped_ && this.clipUnrotated(r, t, l);
      }
      return o && this.renderWorlds(
        a,
        t,
        this.getLayer().getDeclutter() ? !1 : void 0
      ), !t.declutter && this.clipped_ && r.restore(), this.postRender(r, t), this.renderedRotation_ !== s.rotation && (this.renderedRotation_ = s.rotation, this.hitDetectionImageData_ = null), t.declutter || this.resetDrawContext_(), this.container;
    }
    /**
     * Asynchronous layer level hit detection.
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../../Feature").default>>} Promise
     * that resolves with an array of features.
     * @override
     */
    getFeatures(t) {
      return new Promise((e) => {
        if (this.frameState && !this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
          const n = this.frameState.size.slice(), s = this.renderedCenter_, r = this.renderedResolution_, a = this.renderedRotation_, o = this.renderedProjection_, l = this.wrappedRenderedExtent_, h = this.getLayer(), c = [], u = n[0] * li, d = n[1] * li;
          c.push(
            this.getRenderTransform(
              s,
              r,
              a,
              li,
              u,
              d,
              0
            ).slice()
          );
          const m = h.getSource(), f = o.getExtent();
          if (m.getWrapX() && o.canWrapX() && !Qi(f, l)) {
            let y = l[0];
            const E = _t(f);
            let x = 0, M;
            for (; y < f[0]; )
              --x, M = E * x, c.push(
                this.getRenderTransform(
                  s,
                  r,
                  a,
                  li,
                  u,
                  d,
                  M
                ).slice()
              ), y += E;
            for (x = 0, y = l[2]; y > f[2]; )
              ++x, M = E * x, c.push(
                this.getRenderTransform(
                  s,
                  r,
                  a,
                  li,
                  u,
                  d,
                  M
                ).slice()
              ), y -= E;
          }
          this.hitDetectionImageData_ = yy(
            n,
            c,
            this.renderedFeatures_,
            h.getStyleFunction(),
            l,
            r,
            a,
            Xl(r, this.renderedPixelRatio_)
          );
        }
        e(
          vy(t, this.renderedFeatures_, this.hitDetectionImageData_)
        );
      });
    }
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
     * @return {T|undefined} Callback result.
     * @template T
     * @override
     */
    forEachFeatureAtCoordinate(t, e, n, s, r) {
      if (!this.replayGroup_)
        return;
      const a = e.viewState.resolution, o = e.viewState.rotation, l = this.getLayer(), h = {}, c = function(d, m, f) {
        const y = St(d), E = h[y];
        if (E) {
          if (E !== !0 && f < E.distanceSq) {
            if (f === 0)
              return h[y] = !0, r.splice(r.lastIndexOf(E), 1), s(d, l, m);
            E.geometry = m, E.distanceSq = f;
          }
        } else {
          if (f === 0)
            return h[y] = !0, s(d, l, m);
          r.push(
            h[y] = {
              feature: d,
              layer: l,
              geometry: m,
              distanceSq: f,
              callback: s
            }
          );
        }
      }, u = this.getLayer().getDeclutter();
      return this.replayGroup_.forEachFeatureAtCoordinate(
        t,
        a,
        o,
        n,
        c,
        u ? e.declutter[u].all().map((d) => d.value) : null
      );
    }
    /**
     * Perform action necessary to get the layer rendered after new fonts have loaded
     * @override
     */
    handleFontsChanged() {
      const t = this.getLayer();
      t.getVisible() && this.replayGroup_ && t.changed();
    }
    /**
     * Handle changes in image style state.
     * @param {import("../../events/Event.js").default} event Image style change event.
     * @private
     */
    handleStyleImageChange_(t) {
      this.renderIfReadyAndVisible();
    }
    /**
     * Determine whether render should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     * @override
     */
    prepareFrame(t) {
      const e = this.getLayer(), n = e.getSource();
      if (!n)
        return !1;
      const s = t.viewHints[ae.ANIMATING], r = t.viewHints[ae.INTERACTING], a = e.getUpdateWhileAnimating(), o = e.getUpdateWhileInteracting();
      if (this.ready && !a && s || !o && r)
        return this.animatingOrInteracting_ = !0, !0;
      this.animatingOrInteracting_ = !1;
      const l = t.extent, h = t.viewState, c = h.projection, u = h.resolution, d = t.pixelRatio, m = e.getRevision(), f = e.getRenderBuffer();
      let y = e.getRenderOrder();
      y === void 0 && (y = xy);
      const E = h.center.slice(), x = go(
        l,
        f * u
      ), M = x.slice(), C = [x.slice()], R = c.getExtent();
      if (n.getWrapX() && c.canWrapX() && !Qi(R, t.extent)) {
        const Y = _t(R), q = Math.max(_t(x) / 2, Y);
        x[0] = R[0] - q, x[2] = R[2] + q, Md(E, c);
        const J = gh(C[0], c);
        J[0] < R[0] && J[2] < R[2] ? C.push([
          J[0] + Y,
          J[1],
          J[2] + Y,
          J[3]
        ]) : J[0] > R[0] && J[2] > R[2] && C.push([
          J[0] - Y,
          J[1],
          J[2] - Y,
          J[3]
        ]);
      }
      if (this.ready && this.renderedResolution_ == u && this.renderedRevision_ == m && this.renderedRenderOrder_ == y && this.renderedFrameDeclutter_ === !!t.declutter && Qi(this.wrappedRenderedExtent_, x))
        return fn(this.renderedExtent_, M) || (this.hitDetectionImageData_ = null, this.renderedExtent_ = M), this.renderedCenter_ = E, this.replayGroupChanged = !1, !0;
      this.replayGroup_ = null;
      const S = new oy(
        Sf(u, d),
        x,
        u,
        d
      );
      let A;
      for (let Y = 0, q = C.length; Y < q; ++Y)
        n.loadFeatures(C[Y], u, c);
      const O = Xl(u, d);
      let P = !0;
      const L = (
        /**
         * @param {import("../../Feature.js").default} feature Feature.
         * @param {number} index Index.
         */
        (Y, q) => {
          let J;
          const X = Y.getStyleFunction() || e.getStyleFunction();
          if (X && (J = X(Y, u)), J) {
            const et = this.renderFeature(
              Y,
              O,
              J,
              S,
              A,
              this.getLayer().getDeclutter(),
              q
            );
            P = P && !et;
          }
        }
      ), F = bd(x), z = n.getFeaturesInExtent(F);
      y && z.sort(y);
      for (let Y = 0, q = z.length; Y < q; ++Y)
        L(z[Y], Y);
      this.renderedFeatures_ = z, this.ready = P;
      const D = S.finish(), j = new my(
        x,
        u,
        d,
        n.getOverlaps(),
        D,
        e.getRenderBuffer(),
        !!t.declutter
      );
      return this.renderedResolution_ = u, this.renderedRevision_ = m, this.renderedRenderOrder_ = y, this.renderedFrameDeclutter_ = !!t.declutter, this.renderedExtent_ = M, this.wrappedRenderedExtent_ = x, this.renderedCenter_ = E, this.renderedProjection_ = c, this.renderedPixelRatio_ = d, this.replayGroup_ = j, this.hitDetectionImageData_ = null, this.replayGroupChanged = !0, !0;
    }
    /**
     * @param {import("../../Feature.js").default} feature Feature.
     * @param {number} squaredTolerance Squared render tolerance.
     * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
     * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
     * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
     * @param {boolean} [declutter] Enable decluttering.
     * @param {number} [index] Render order index.
     * @return {boolean} `true` if an image is loading.
     */
    renderFeature(t, e, n, s, r, a, o) {
      if (!n)
        return !1;
      let l = !1;
      if (Array.isArray(n))
        for (let h = 0, c = n.length; h < c; ++h)
          l = Tu(
            s,
            t,
            n[h],
            e,
            this.boundHandleStyleImageChange_,
            r,
            a,
            o
          ) || l;
      else
        l = Tu(
          s,
          t,
          n,
          e,
          this.boundHandleStyleImageChange_,
          r,
          a,
          o
        );
      return l;
    }
  }
  class Ly extends uf {
    /**
     * @param {Options<VectorSourceType, FeatureType>} [options] Options.
     */
    constructor(t) {
      super(t);
    }
    /**
     * @override
     */
    createRenderer() {
      return new by(this);
    }
  }
  class Iu {
    /**
     * @param {number} [maxEntries] Max entries.
     */
    constructor(t) {
      this.rbush_ = new Zd(t), this.items_ = {};
    }
    /**
     * Insert a value into the RBush.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {T} value Value.
     */
    insert(t, e) {
      const n = {
        minX: t[0],
        minY: t[1],
        maxX: t[2],
        maxY: t[3],
        value: e
      };
      this.rbush_.insert(n), this.items_[St(e)] = n;
    }
    /**
     * Bulk-insert values into the RBush.
     * @param {Array<import("../extent.js").Extent>} extents Extents.
     * @param {Array<T>} values Values.
     */
    load(t, e) {
      const n = new Array(e.length);
      for (let s = 0, r = e.length; s < r; s++) {
        const a = t[s], o = e[s], l = {
          minX: a[0],
          minY: a[1],
          maxX: a[2],
          maxY: a[3],
          value: o
        };
        n[s] = l, this.items_[St(o)] = l;
      }
      this.rbush_.load(n);
    }
    /**
     * Remove a value from the RBush.
     * @param {T} value Value.
     * @return {boolean} Removed.
     */
    remove(t) {
      const e = St(t), n = this.items_[e];
      return delete this.items_[e], this.rbush_.remove(n) !== null;
    }
    /**
     * Update the extent of a value in the RBush.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {T} value Value.
     */
    update(t, e) {
      const n = this.items_[St(e)], s = [n.minX, n.minY, n.maxX, n.maxY];
      Ps(s, t) || (this.remove(e), this.insert(t, e));
    }
    /**
     * Return all values in the RBush.
     * @return {Array<T>} All.
     */
    getAll() {
      return this.rbush_.all().map(function(e) {
        return e.value;
      });
    }
    /**
     * Return all values in the given extent.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {Array<T>} All in extent.
     */
    getInExtent(t) {
      const e = {
        minX: t[0],
        minY: t[1],
        maxX: t[2],
        maxY: t[3]
      };
      return this.rbush_.search(e).map(function(s) {
        return s.value;
      });
    }
    /**
     * Calls a callback function with each value in the tree.
     * If the callback returns a truthy value, this value is returned without
     * checking the rest of the tree.
     * @param {function(T): R} callback Callback.
     * @return {R|undefined} Callback return value.
     * @template R
     */
    forEach(t) {
      return this.forEach_(this.getAll(), t);
    }
    /**
     * Calls a callback function with each value in the provided extent.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(T): R} callback Callback.
     * @return {R|undefined} Callback return value.
     * @template R
     */
    forEachInExtent(t, e) {
      return this.forEach_(this.getInExtent(t), e);
    }
    /**
     * @param {Array<T>} values Values.
     * @param {function(T): R} callback Callback.
     * @return {R|undefined} Callback return value.
     * @template R
     * @private
     */
    forEach_(t, e) {
      let n;
      for (let s = 0, r = t.length; s < r; s++)
        if (n = e(t[s]), n)
          return n;
      return n;
    }
    /**
     * @return {boolean} Is empty.
     */
    isEmpty() {
      return As(this.items_);
    }
    /**
     * Remove all values from the RBush.
     */
    clear() {
      this.rbush_.clear(), this.items_ = {};
    }
    /**
     * @param {import("../extent.js").Extent} [extent] Extent.
     * @return {import("../extent.js").Extent} Extent.
     */
    getExtent(t) {
      const e = this.rbush_.toJSON();
      return ke(e.minX, e.minY, e.maxX, e.maxY, t);
    }
    /**
     * @param {RBush<T>} rbush R-Tree.
     */
    concat(t) {
      this.rbush_.load(t.rbush_.all());
      for (const e in t.items_)
        this.items_[e] = t.items_[e];
    }
  }
  class No extends Fi {
    /**
     * @param {!import("../coordinate.js").Coordinate} center Center.
     *     For internal use, flat coordinates in combination with `layout` and no
     *     `radius` are also accepted.
     * @param {number} [radius] Radius in units of the projection.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    constructor(t, e, n) {
      super(), n !== void 0 && e === void 0 ? this.setFlatCoordinates(n, t) : (e = e || 0, this.setCenterAndRadius(t, e, n));
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!Circle} Clone.
     * @api
     * @override
     */
    clone() {
      const t = new No(
        this.flatCoordinates.slice(),
        void 0,
        this.layout
      );
      return t.applyProperties(this), t;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(t, e, n, s) {
      const r = this.flatCoordinates, a = t - r[0], o = e - r[1], l = a * a + o * o;
      if (l < s) {
        if (l === 0)
          for (let h = 0; h < this.stride; ++h)
            n[h] = r[h];
        else {
          const h = this.getRadius() / Math.sqrt(l);
          n[0] = r[0] + h * a, n[1] = r[1] + h * o;
          for (let c = 2; c < this.stride; ++c)
            n[c] = r[c];
        }
        return n.length = this.stride, l;
      }
      return s;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     * @override
     */
    containsXY(t, e) {
      const n = this.flatCoordinates, s = t - n[0], r = e - n[1];
      return s * s + r * r <= this.getRadiusSquared_();
    }
    /**
     * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
     * @return {import("../coordinate.js").Coordinate} Center.
     * @api
     */
    getCenter() {
      return this.flatCoordinates.slice(0, this.stride);
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     * @override
     */
    computeExtent(t) {
      const e = this.flatCoordinates, n = e[this.stride] - e[0];
      return ke(
        e[0] - n,
        e[1] - n,
        e[0] + n,
        e[1] + n,
        t
      );
    }
    /**
     * Return the radius of the circle.
     * @return {number} Radius.
     * @api
     */
    getRadius() {
      return Math.sqrt(this.getRadiusSquared_());
    }
    /**
     * @private
     * @return {number} Radius squared.
     */
    getRadiusSquared_() {
      const t = this.flatCoordinates[this.stride] - this.flatCoordinates[0], e = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
      return t * t + e * e;
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "Circle";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(t) {
      const e = this.getExtent();
      if (he(t, e)) {
        const n = this.getCenter();
        return t[0] <= n[0] && t[2] >= n[0] || t[1] <= n[1] && t[3] >= n[1] ? !0 : po(t, this.intersectsCoordinate.bind(this));
      }
      return !1;
    }
    /**
     * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
     * @param {import("../coordinate.js").Coordinate} center Center.
     * @api
     */
    setCenter(t) {
      const e = this.stride, n = this.flatCoordinates[e] - this.flatCoordinates[0], s = t.slice();
      s[e] = s[0] + n;
      for (let r = 1; r < e; ++r)
        s[e + r] = t[r];
      this.setFlatCoordinates(this.layout, s), this.changed();
    }
    /**
     * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
     * number) of the circle.
     * @param {!import("../coordinate.js").Coordinate} center Center.
     * @param {number} radius Radius.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     */
    setCenterAndRadius(t, e, n) {
      this.setLayout(n, t, 0), this.flatCoordinates || (this.flatCoordinates = []);
      const s = this.flatCoordinates;
      let r = Fd(s, 0, t, this.stride);
      s[r++] = s[0] + e;
      for (let a = 1, o = this.stride; a < o; ++a)
        s[r++] = s[a];
      s.length = r, this.changed();
    }
    /**
     * @override
     */
    getCoordinates() {
      return null;
    }
    /**
     * @override
     */
    setCoordinates(t, e) {
    }
    /**
     * Set the radius of the circle. The radius is in the units of the projection.
     * @param {number} radius Radius.
     * @api
     */
    setRadius(t) {
      this.flatCoordinates[this.stride] = this.flatCoordinates[0] + t, this.changed();
    }
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @param {number} angle Rotation angle in counter-clockwise radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     * @override
     */
    rotate(t, e) {
      const n = this.getCenter(), s = this.getStride();
      this.setCenter(
        Rh(n, 0, n.length, s, t, e, n)
      ), this.changed();
    }
  }
  No.prototype.transform;
  class Ja extends xo {
    /**
     * @param {Array<Geometry>} geometries Geometries.
     */
    constructor(t) {
      super(), this.geometries_ = t, this.changeEventsKeys_ = [], this.listenGeometriesChange_();
    }
    /**
     * @private
     */
    unlistenGeometriesChange_() {
      this.changeEventsKeys_.forEach(bt), this.changeEventsKeys_.length = 0;
    }
    /**
     * @private
     */
    listenGeometriesChange_() {
      const t = this.geometries_;
      for (let e = 0, n = t.length; e < n; ++e)
        this.changeEventsKeys_.push(
          xt(t[e], ht.CHANGE, this.changed, this)
        );
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!GeometryCollection} Clone.
     * @api
     * @override
     */
    clone() {
      const t = new Ja(
        fl(this.geometries_)
      );
      return t.applyProperties(this), t;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(t, e, n, s) {
      if (s < gn(this.getExtent(), t, e))
        return s;
      const r = this.geometries_;
      for (let a = 0, o = r.length; a < o; ++a)
        s = r[a].closestPointXY(
          t,
          e,
          n,
          s
        );
      return s;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     * @override
     */
    containsXY(t, e) {
      const n = this.geometries_;
      for (let s = 0, r = n.length; s < r; ++s)
        if (n[s].containsXY(t, e))
          return !0;
      return !1;
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     * @override
     */
    computeExtent(t) {
      Ni(t);
      const e = this.geometries_;
      for (let n = 0, s = e.length; n < s; ++n)
        Gr(t, e[n].getExtent());
      return t;
    }
    /**
     * Return the geometries that make up this geometry collection.
     * @return {Array<Geometry>} Geometries.
     * @api
     */
    getGeometries() {
      return fl(this.geometries_);
    }
    /**
     * @return {Array<Geometry>} Geometries.
     */
    getGeometriesArray() {
      return this.geometries_;
    }
    /**
     * @return {Array<Geometry>} Geometries.
     */
    getGeometriesArrayRecursive() {
      let t = [];
      const e = this.geometries_;
      for (let n = 0, s = e.length; n < s; ++n)
        e[n].getType() === this.getType() ? t = t.concat(
          /** @type {GeometryCollection} */
          e[n].getGeometriesArrayRecursive()
        ) : t.push(e[n]);
      return t;
    }
    /**
     * Create a simplified version of this geometry using the Douglas Peucker algorithm.
     * @param {number} squaredTolerance Squared tolerance.
     * @return {GeometryCollection} Simplified GeometryCollection.
     * @override
     */
    getSimplifiedGeometry(t) {
      if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && t < this.simplifiedGeometryMaxMinSquaredTolerance)
        return this;
      const e = [], n = this.geometries_;
      let s = !1;
      for (let r = 0, a = n.length; r < a; ++r) {
        const o = n[r], l = o.getSimplifiedGeometry(t);
        e.push(l), l !== o && (s = !0);
      }
      return s ? new Ja(
        e
      ) : (this.simplifiedGeometryMaxMinSquaredTolerance = t, this);
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "GeometryCollection";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(t) {
      const e = this.geometries_;
      for (let n = 0, s = e.length; n < s; ++n)
        if (e[n].intersectsExtent(t))
          return !0;
      return !1;
    }
    /**
     * @return {boolean} Is empty.
     */
    isEmpty() {
      return this.geometries_.length === 0;
    }
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @param {number} angle Rotation angle in radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     * @override
     */
    rotate(t, e) {
      const n = this.geometries_;
      for (let s = 0, r = n.length; s < r; ++s)
        n[s].rotate(t, e);
      this.changed();
    }
    /**
     * Scale the geometry (with an optional origin).  This modifies the geometry
     * coordinates in place.
     * @abstract
     * @param {number} sx The scaling factor in the x-direction.
     * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
     * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
     *     of the geometry extent).
     * @api
     * @override
     */
    scale(t, e, n) {
      n || (n = bi(this.getExtent()));
      const s = this.geometries_;
      for (let r = 0, a = s.length; r < a; ++r)
        s[r].scale(t, e, n);
      this.changed();
    }
    /**
     * Set the geometries that make up this geometry collection.
     * @param {Array<Geometry>} geometries Geometries.
     * @api
     */
    setGeometries(t) {
      this.setGeometriesArray(fl(t));
    }
    /**
     * @param {Array<Geometry>} geometries Geometries.
     */
    setGeometriesArray(t) {
      this.unlistenGeometriesChange_(), this.geometries_ = t, this.listenGeometriesChange_(), this.changed();
    }
    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     * Called with a flat array of geometry coordinates.
     * @api
     * @override
     */
    applyTransform(t) {
      const e = this.geometries_;
      for (let n = 0, s = e.length; n < s; ++n)
        e[n].applyTransform(t);
      this.changed();
    }
    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     * @override
     */
    translate(t, e) {
      const n = this.geometries_;
      for (let s = 0, r = n.length; s < r; ++s)
        n[s].translate(t, e);
      this.changed();
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.unlistenGeometriesChange_(), super.disposeInternal();
    }
  }
  function fl(i) {
    return i.map((t) => t.clone());
  }
  class Ds extends Fi {
    /**
     * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
     *     Coordinates or LineString geometries. (For internal use, flat coordinates in
     *     combination with `layout` and `ends` are also accepted.)
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @param {Array<number>} [ends] Flat coordinate ends for internal use.
     */
    constructor(t, e, n) {
      if (super(), this.ends_ = [], this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, Array.isArray(t[0]))
        this.setCoordinates(
          /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
          t,
          e
        );
      else if (e !== void 0 && n)
        this.setFlatCoordinates(
          e,
          /** @type {Array<number>} */
          t
        ), this.ends_ = n;
      else {
        const s = (
          /** @type {Array<LineString>} */
          t
        ), r = [], a = [];
        for (let l = 0, h = s.length; l < h; ++l) {
          const c = s[l];
          pe(r, c.getFlatCoordinates()), a.push(r.length);
        }
        const o = s.length === 0 ? this.getLayout() : s[0].getLayout();
        this.setFlatCoordinates(o, r), this.ends_ = a;
      }
    }
    /**
     * Append the passed linestring to the multilinestring.
     * @param {LineString} lineString LineString.
     * @api
     */
    appendLineString(t) {
      pe(this.flatCoordinates, t.getFlatCoordinates().slice()), this.ends_.push(this.flatCoordinates.length), this.changed();
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!MultiLineString} Clone.
     * @api
     * @override
     */
    clone() {
      const t = new Ds(
        this.flatCoordinates.slice(),
        this.layout,
        this.ends_.slice()
      );
      return t.applyProperties(this), t;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(t, e, n, s) {
      return s < gn(this.getExtent(), t, e) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
        Ch(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          0
        )
      ), this.maxDeltaRevision_ = this.getRevision()), Ih(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        this.maxDelta_,
        !1,
        t,
        e,
        n,
        s
      ));
    }
    /**
     * Returns the coordinate at `m` using linear interpolation, or `null` if no
     * such coordinate exists.
     *
     * `extrapolate` controls extrapolation beyond the range of Ms in the
     * MultiLineString. If `extrapolate` is `true` then Ms less than the first
     * M will return the first coordinate and Ms greater than the last M will
     * return the last coordinate.
     *
     * `interpolate` controls interpolation between consecutive LineStrings
     * within the MultiLineString. If `interpolate` is `true` the coordinates
     * will be linearly interpolated between the last coordinate of one LineString
     * and the first coordinate of the next LineString.  If `interpolate` is
     * `false` then the function will return `null` for Ms falling between
     * LineStrings.
     *
     * @param {number} m M.
     * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
     * @param {boolean} [interpolate] Interpolate. Default is `false`.
     * @return {import("../coordinate.js").Coordinate|null} Coordinate.
     * @api
     */
    getCoordinateAtM(t, e, n) {
      return this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0 ? null : (e = e !== void 0 ? e : !1, n = n !== void 0 ? n : !1, ty(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        t,
        e,
        n
      ));
    }
    /**
     * Return the coordinates of the multilinestring.
     * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
     * @api
     * @override
     */
    getCoordinates() {
      return Mr(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride
      );
    }
    /**
     * @return {Array<number>} Ends.
     */
    getEnds() {
      return this.ends_;
    }
    /**
     * Return the linestring at the specified index.
     * @param {number} index Index.
     * @return {LineString} LineString.
     * @api
     */
    getLineString(t) {
      return t < 0 || this.ends_.length <= t ? null : new cn(
        this.flatCoordinates.slice(
          t === 0 ? 0 : this.ends_[t - 1],
          this.ends_[t]
        ),
        this.layout
      );
    }
    /**
     * Return the linestrings of this multilinestring.
     * @return {Array<LineString>} LineStrings.
     * @api
     */
    getLineStrings() {
      const t = this.flatCoordinates, e = this.ends_, n = this.layout, s = [];
      let r = 0;
      for (let a = 0, o = e.length; a < o; ++a) {
        const l = e[a], h = new cn(
          t.slice(r, l),
          n
        );
        s.push(h), r = l;
      }
      return s;
    }
    /**
     * @return {Array<number>} Flat midpoints.
     */
    getFlatMidpoints() {
      const t = [], e = this.flatCoordinates;
      let n = 0;
      const s = this.ends_, r = this.stride;
      for (let a = 0, o = s.length; a < o; ++a) {
        const l = s[a], h = Va(
          e,
          n,
          l,
          r,
          0.5
        );
        pe(t, h), n = l;
      }
      return t;
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {MultiLineString} Simplified MultiLineString.
     * @protected
     * @override
     */
    getSimplifiedGeometryInternal(t) {
      const e = [], n = [];
      return e.length = Dd(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        t,
        e,
        0,
        n
      ), new Ds(e, "XY", n);
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "MultiLineString";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(t) {
      return qm(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        t
      );
    }
    /**
     * Set the coordinates of the multilinestring.
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    setCoordinates(t, e) {
      this.setLayout(e, t, 2), this.flatCoordinates || (this.flatCoordinates = []);
      const n = Ah(
        this.flatCoordinates,
        0,
        t,
        this.stride,
        this.ends_
      );
      this.flatCoordinates.length = n.length === 0 ? 0 : n[n.length - 1], this.changed();
    }
  }
  class jr extends Fi {
    /**
     * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `layout` are also accepted.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    constructor(t, e) {
      super(), e && !Array.isArray(t[0]) ? this.setFlatCoordinates(
        e,
        /** @type {Array<number>} */
        t
      ) : this.setCoordinates(
        /** @type {Array<import("../coordinate.js").Coordinate>} */
        t,
        e
      );
    }
    /**
     * Append the passed point to this multipoint.
     * @param {Point} point Point.
     * @api
     */
    appendPoint(t) {
      pe(this.flatCoordinates, t.getFlatCoordinates()), this.changed();
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!MultiPoint} Clone.
     * @api
     * @override
     */
    clone() {
      const t = new jr(
        this.flatCoordinates.slice(),
        this.layout
      );
      return t.applyProperties(this), t;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(t, e, n, s) {
      if (s < gn(this.getExtent(), t, e))
        return s;
      const r = this.flatCoordinates, a = this.stride;
      for (let o = 0, l = r.length; o < l; o += a) {
        const h = bn(
          t,
          e,
          r[o],
          r[o + 1]
        );
        if (h < s) {
          s = h;
          for (let c = 0; c < a; ++c)
            n[c] = r[o + c];
          n.length = a;
        }
      }
      return s;
    }
    /**
     * Return the coordinates of the multipoint.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     * @override
     */
    getCoordinates() {
      return en(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    /**
     * Return the point at the specified index.
     * @param {number} index Index.
     * @return {Point} Point.
     * @api
     */
    getPoint(t) {
      const e = this.flatCoordinates.length / this.stride;
      return t < 0 || e <= t ? null : new wr(
        this.flatCoordinates.slice(
          t * this.stride,
          (t + 1) * this.stride
        ),
        this.layout
      );
    }
    /**
     * Return the points of this multipoint.
     * @return {Array<Point>} Points.
     * @api
     */
    getPoints() {
      const t = this.flatCoordinates, e = this.layout, n = this.stride, s = [];
      for (let r = 0, a = t.length; r < a; r += n) {
        const o = new wr(t.slice(r, r + n), e);
        s.push(o);
      }
      return s;
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "MultiPoint";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(t) {
      const e = this.flatCoordinates, n = this.stride;
      for (let s = 0, r = e.length; s < r; s += n) {
        const a = e[s], o = e[s + 1];
        if (mo(t, a, o))
          return !0;
      }
      return !1;
    }
    /**
     * Set the coordinates of the multipoint.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    setCoordinates(t, e) {
      this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Mo(
        this.flatCoordinates,
        0,
        t,
        this.stride
      ), this.changed();
    }
  }
  function Tf(i, t, e, n) {
    const s = [];
    let r = Ae();
    for (let a = 0, o = e.length; a < o; ++a) {
      const l = e[a];
      r = _o(
        i,
        t,
        l[0],
        n
      ), s.push((r[0] + r[2]) / 2, (r[1] + r[3]) / 2), t = l[l.length - 1];
    }
    return s;
  }
  class ks extends Fi {
    /**
     * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
     */
    constructor(t, e, n) {
      if (super(), this.endss_ = [], this.flatInteriorPointsRevision_ = -1, this.flatInteriorPoints_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, !n && !Array.isArray(t[0])) {
        const s = (
          /** @type {Array<Polygon>} */
          t
        ), r = [], a = [];
        for (let o = 0, l = s.length; o < l; ++o) {
          const h = s[o], c = r.length, u = h.getEnds();
          for (let d = 0, m = u.length; d < m; ++d)
            u[d] += c;
          pe(r, h.getFlatCoordinates()), a.push(u);
        }
        e = s.length === 0 ? this.getLayout() : s[0].getLayout(), t = r, n = a;
      }
      e !== void 0 && n ? (this.setFlatCoordinates(
        e,
        /** @type {Array<number>} */
        t
      ), this.endss_ = n) : this.setCoordinates(
        /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
        t,
        e
      );
    }
    /**
     * Append the passed polygon to this multipolygon.
     * @param {Polygon} polygon Polygon.
     * @api
     */
    appendPolygon(t) {
      let e;
      if (!this.flatCoordinates)
        this.flatCoordinates = t.getFlatCoordinates().slice(), e = t.getEnds().slice(), this.endss_.push();
      else {
        const n = this.flatCoordinates.length;
        pe(this.flatCoordinates, t.getFlatCoordinates()), e = t.getEnds().slice();
        for (let s = 0, r = e.length; s < r; ++s)
          e[s] += n;
      }
      this.endss_.push(e), this.changed();
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!MultiPolygon} Clone.
     * @api
     * @override
     */
    clone() {
      const t = this.endss_.length, e = new Array(t);
      for (let s = 0; s < t; ++s)
        e[s] = this.endss_[s].slice();
      const n = new ks(
        this.flatCoordinates.slice(),
        this.layout,
        e
      );
      return n.applyProperties(this), n;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(t, e, n, s) {
      return s < gn(this.getExtent(), t, e) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
        Um(
          this.flatCoordinates,
          0,
          this.endss_,
          this.stride,
          0
        )
      ), this.maxDeltaRevision_ = this.getRevision()), zm(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        this.maxDelta_,
        !0,
        t,
        e,
        n,
        s
      ));
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     * @override
     */
    containsXY(t, e) {
      return Zm(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        t,
        e
      );
    }
    /**
     * Return the area of the multipolygon on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */
    getArea() {
      return Wm(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride
      );
    }
    /**
     * Get the coordinate array for this geometry.  This array has the structure
     * of a GeoJSON coordinate array for multi-polygons.
     *
     * @param {boolean} [right] Orient coordinates according to the right-hand
     *     rule (counter-clockwise for exterior and clockwise for interior rings).
     *     If `false`, coordinates will be oriented according to the left-hand rule
     *     (clockwise for exterior and counter-clockwise for interior rings).
     *     By default, coordinate orientation will depend on how the geometry was
     *     constructed.
     * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
     * @api
     * @override
     */
    getCoordinates(t) {
      let e;
      return t !== void 0 ? (e = this.getOrientedFlatCoordinates().slice(), tu(
        e,
        0,
        this.endss_,
        this.stride,
        t
      )) : e = this.flatCoordinates, Nl(
        e,
        0,
        this.endss_,
        this.stride
      );
    }
    /**
     * @return {Array<Array<number>>} Endss.
     */
    getEndss() {
      return this.endss_;
    }
    /**
     * @return {Array<number>} Flat interior points.
     */
    getFlatInteriorPoints() {
      if (this.flatInteriorPointsRevision_ != this.getRevision()) {
        const t = Tf(
          this.flatCoordinates,
          0,
          this.endss_,
          this.stride
        );
        this.flatInteriorPoints_ = zd(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride,
          t
        ), this.flatInteriorPointsRevision_ = this.getRevision();
      }
      return (
        /** @type {Array<number>} */
        this.flatInteriorPoints_
      );
    }
    /**
     * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
     * @return {MultiPoint} Interior points as XYM coordinates, where M is
     * the length of the horizontal intersection that the point belongs to.
     * @api
     */
    getInteriorPoints() {
      return new jr(this.getFlatInteriorPoints().slice(), "XYM");
    }
    /**
     * @return {Array<number>} Oriented flat coordinates.
     */
    getOrientedFlatCoordinates() {
      if (this.orientedRevision_ != this.getRevision()) {
        const t = this.flatCoordinates;
        Vm(t, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = tu(
          this.orientedFlatCoordinates_,
          0,
          this.endss_,
          this.stride
        )), this.orientedRevision_ = this.getRevision();
      }
      return (
        /** @type {Array<number>} */
        this.orientedFlatCoordinates_
      );
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {MultiPolygon} Simplified MultiPolygon.
     * @protected
     * @override
     */
    getSimplifiedGeometryInternal(t) {
      const e = [], n = [];
      return e.length = Xm(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride,
        Math.sqrt(t),
        e,
        0,
        n
      ), new ks(e, "XY", n);
    }
    /**
     * Return the polygon at the specified index.
     * @param {number} index Index.
     * @return {Polygon} Polygon.
     * @api
     */
    getPolygon(t) {
      if (t < 0 || this.endss_.length <= t)
        return null;
      let e;
      if (t === 0)
        e = 0;
      else {
        const r = this.endss_[t - 1];
        e = r[r.length - 1];
      }
      const n = this.endss_[t].slice(), s = n[n.length - 1];
      if (e !== 0)
        for (let r = 0, a = n.length; r < a; ++r)
          n[r] -= e;
      return new gi(
        this.flatCoordinates.slice(e, s),
        this.layout,
        n
      );
    }
    /**
     * Return the polygons of this multipolygon.
     * @return {Array<Polygon>} Polygons.
     * @api
     */
    getPolygons() {
      const t = this.layout, e = this.flatCoordinates, n = this.endss_, s = [];
      let r = 0;
      for (let a = 0, o = n.length; a < o; ++a) {
        const l = n[a].slice(), h = l[l.length - 1];
        if (r !== 0)
          for (let u = 0, d = l.length; u < d; ++u)
            l[u] -= r;
        const c = new gi(
          e.slice(r, h),
          t,
          l
        );
        s.push(c), r = h;
      }
      return s;
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "MultiPolygon";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(t) {
      return Km(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        t
      );
    }
    /**
     * Set the coordinates of the multipolygon.
     * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    setCoordinates(t, e) {
      this.setLayout(e, t, 3), this.flatCoordinates || (this.flatCoordinates = []);
      const n = Bm(
        this.flatCoordinates,
        0,
        t,
        this.stride,
        this.endss_
      );
      if (n.length === 0)
        this.flatCoordinates.length = 0;
      else {
        const s = n[n.length - 1];
        this.flatCoordinates.length = s.length === 0 ? 0 : s[s.length - 1];
      }
      this.changed();
    }
  }
  const Oy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Circle: No,
    Geometry: xo,
    GeometryCollection: Ja,
    LineString: cn,
    LinearRing: kn,
    MultiLineString: Ds,
    MultiPoint: jr,
    MultiPolygon: ks,
    Point: wr,
    Polygon: gi,
    SimpleGeometry: Fi
  }, Symbol.toStringTag, { value: "Module" })), Au = We();
  class Qe {
    /**
     * @param {Type} type Geometry type.
     * @param {Array<number>} flatCoordinates Flat coordinates. These always need
     *     to be right-handed for polygons.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {Object<string, *>} properties Properties.
     * @param {number|string|undefined} id Feature id.
     */
    constructor(t, e, n, s, r, a) {
      this.styleFunction, this.extent_, this.id_ = a, this.type_ = t, this.flatCoordinates_ = e, this.flatInteriorPoints_ = null, this.flatMidpoints_ = null, this.ends_ = n || null, this.properties_ = r, this.squaredTolerance_, this.stride_ = s, this.simplifiedGeometry_;
    }
    /**
     * Get a feature property by its key.
     * @param {string} key Key
     * @return {*} Value for the requested key.
     * @api
     */
    get(t) {
      return this.properties_[t];
    }
    /**
     * Get the extent of this feature's geometry.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getExtent() {
      return this.extent_ || (this.extent_ = this.type_ === "Point" ? uh(this.flatCoordinates_) : _o(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2
      )), this.extent_;
    }
    /**
     * @return {Array<number>} Flat interior points.
     */
    getFlatInteriorPoint() {
      if (!this.flatInteriorPoints_) {
        const t = bi(this.getExtent());
        this.flatInteriorPoints_ = Lh(
          this.flatCoordinates_,
          0,
          this.ends_,
          2,
          t,
          0
        );
      }
      return this.flatInteriorPoints_;
    }
    /**
     * @return {Array<number>} Flat interior points.
     */
    getFlatInteriorPoints() {
      if (!this.flatInteriorPoints_) {
        const t = Hm(this.flatCoordinates_, this.ends_), e = Tf(this.flatCoordinates_, 0, t, 2);
        this.flatInteriorPoints_ = zd(
          this.flatCoordinates_,
          0,
          t,
          2,
          e
        );
      }
      return this.flatInteriorPoints_;
    }
    /**
     * @return {Array<number>} Flat midpoint.
     */
    getFlatMidpoint() {
      return this.flatMidpoints_ || (this.flatMidpoints_ = Va(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2,
        0.5
      )), this.flatMidpoints_;
    }
    /**
     * @return {Array<number>} Flat midpoints.
     */
    getFlatMidpoints() {
      if (!this.flatMidpoints_) {
        this.flatMidpoints_ = [];
        const t = this.flatCoordinates_;
        let e = 0;
        const n = (
          /** @type {Array<number>} */
          this.ends_
        );
        for (let s = 0, r = n.length; s < r; ++s) {
          const a = n[s], o = Va(t, e, a, 2, 0.5);
          pe(this.flatMidpoints_, o), e = a;
        }
      }
      return this.flatMidpoints_;
    }
    /**
     * Get the feature identifier.  This is a stable identifier for the feature and
     * is set when reading data from a remote source.
     * @return {number|string|undefined} Id.
     * @api
     */
    getId() {
      return this.id_;
    }
    /**
     * @return {Array<number>} Flat coordinates.
     */
    getOrientedFlatCoordinates() {
      return this.flatCoordinates_;
    }
    /**
     * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
     * determining the geometry type in style function (see {@link #getType}).
     * @return {RenderFeature} Feature.
     * @api
     */
    getGeometry() {
      return this;
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {RenderFeature} Simplified geometry.
     */
    getSimplifiedGeometry(t) {
      return this;
    }
    /**
     * Get a transformed and simplified version of the geometry.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
     * @return {RenderFeature} Simplified geometry.
     */
    simplifyTransformed(t, e) {
      return this;
    }
    /**
     * Get the feature properties.
     * @return {Object<string, *>} Feature properties.
     * @api
     */
    getProperties() {
      return this.properties_;
    }
    /**
     * Get an object of all property names and values.  This has the same behavior as getProperties,
     * but is here to conform with the {@link module:ol/Feature~Feature} interface.
     * @return {Object<string, *>?} Object.
     */
    getPropertiesInternal() {
      return this.properties_;
    }
    /**
     * @return {number} Stride.
     */
    getStride() {
      return this.stride_;
    }
    /**
     * @return {import('../style/Style.js').StyleFunction|undefined} Style
     */
    getStyleFunction() {
      return this.styleFunction;
    }
    /**
     * Get the type of this feature's geometry.
     * @return {Type} Geometry type.
     * @api
     */
    getType() {
      return this.type_;
    }
    /**
     * Transform geometry coordinates from tile pixel space to projected.
     *
     * @param {import("../proj.js").ProjectionLike} projection The data projection
     */
    transform(t) {
      t = Pt(t);
      const e = t.getExtent(), n = t.getWorldExtent();
      if (e && n) {
        const s = $t(n) / $t(e);
        Li(
          Au,
          n[0],
          n[3],
          s,
          -s,
          0,
          0,
          0
        ), on(
          this.flatCoordinates_,
          0,
          this.flatCoordinates_.length,
          2,
          Au,
          this.flatCoordinates_
        );
      }
    }
    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     */
    applyTransform(t) {
      t(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
    }
    /**
     * @return {RenderFeature} A cloned render feature.
     */
    clone() {
      var t;
      return new Qe(
        this.type_,
        this.flatCoordinates_.slice(),
        (t = this.ends_) == null ? void 0 : t.slice(),
        this.stride_,
        Object.assign({}, this.properties_),
        this.id_
      );
    }
    /**
     * @return {Array<number>|null} Ends.
     */
    getEnds() {
      return this.ends_;
    }
    /**
     * Add transform and resolution based geometry simplification to this instance.
     * @return {RenderFeature} This render feature.
     */
    enableSimplifyTransformed() {
      return this.simplifyTransformed = fd((t, e) => {
        if (t === this.squaredTolerance_)
          return this.simplifiedGeometry_;
        this.simplifiedGeometry_ = this.clone(), e && this.simplifiedGeometry_.applyTransform(e);
        const n = this.simplifiedGeometry_.getFlatCoordinates();
        let s;
        switch (this.type_) {
          case "LineString":
            n.length = wo(
              n,
              0,
              this.simplifiedGeometry_.flatCoordinates_.length,
              this.simplifiedGeometry_.stride_,
              t,
              n,
              0
            ), s = [n.length];
            break;
          case "MultiLineString":
            s = [], n.length = Dd(
              n,
              0,
              this.simplifiedGeometry_.ends_,
              this.simplifiedGeometry_.stride_,
              t,
              n,
              0,
              s
            );
            break;
          case "Polygon":
            s = [], n.length = Ph(
              n,
              0,
              this.simplifiedGeometry_.ends_,
              this.simplifiedGeometry_.stride_,
              Math.sqrt(t),
              n,
              0,
              s
            );
            break;
        }
        return s && (this.simplifiedGeometry_ = new Qe(
          this.type_,
          n,
          s,
          2,
          this.properties_,
          this.id_
        )), this.squaredTolerance_ = t, this.simplifiedGeometry_;
      }), this;
    }
  }
  Qe.prototype.getFlatCoordinates = Qe.prototype.getOrientedFlatCoordinates;
  class If extends si {
    /**
     * @param {Options} options Source options.
     */
    constructor(t) {
      super(), this.projection = Pt(t.projection), this.attributions_ = Pu(t.attributions), this.attributionsCollapsible_ = t.attributionsCollapsible ?? !0, this.loading = !1, this.state_ = t.state !== void 0 ? t.state : "ready", this.wrapX_ = t.wrapX !== void 0 ? t.wrapX : !1, this.interpolate_ = !!t.interpolate, this.viewResolver = null, this.viewRejector = null;
      const e = this;
      this.viewPromise_ = new Promise(function(n, s) {
        e.viewResolver = n, e.viewRejector = s;
      });
    }
    /**
     * Get the attribution function for the source.
     * @return {?Attribution} Attribution function.
     * @api
     */
    getAttributions() {
      return this.attributions_;
    }
    /**
     * @return {boolean} Attributions are collapsible.
     * @api
     */
    getAttributionsCollapsible() {
      return this.attributionsCollapsible_;
    }
    /**
     * Get the projection of the source.
     * @return {import("../proj/Projection.js").default|null} Projection.
     * @api
     */
    getProjection() {
      return this.projection;
    }
    /**
     * @param {import("../proj/Projection").default} [projection] Projection.
     * @return {Array<number>|null} Resolutions.
     */
    getResolutions(t) {
      return null;
    }
    /**
     * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
     */
    getView() {
      return this.viewPromise_;
    }
    /**
     * Get the state of the source, see {@link import("./Source.js").State} for possible states.
     * @return {import("./Source.js").State} State.
     * @api
     */
    getState() {
      return this.state_;
    }
    /**
     * @return {boolean|undefined} Wrap X.
     */
    getWrapX() {
      return this.wrapX_;
    }
    /**
     * @return {boolean} Use linear interpolation when resampling.
     */
    getInterpolate() {
      return this.interpolate_;
    }
    /**
     * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
     * @api
     */
    refresh() {
      this.changed();
    }
    /**
     * Set the attributions of the source.
     * @param {AttributionLike|undefined} attributions Attributions.
     *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
     *     or `undefined`.
     * @api
     */
    setAttributions(t) {
      this.attributions_ = Pu(t), this.changed();
    }
    /**
     * Set the state of the source.
     * @param {import("./Source.js").State} state State.
     */
    setState(t) {
      this.state_ = t, this.changed();
    }
  }
  function Pu(i) {
    return i ? typeof i == "function" ? i : (Array.isArray(i) || (i = [i]), (t) => i) : null;
  }
  const Ue = {
    /**
     * Triggered when a feature is added to the source.
     * @event module:ol/source/Vector.VectorSourceEvent#addfeature
     * @api
     */
    ADDFEATURE: "addfeature",
    /**
     * Triggered when a feature is updated.
     * @event module:ol/source/Vector.VectorSourceEvent#changefeature
     * @api
     */
    CHANGEFEATURE: "changefeature",
    /**
     * Triggered when the clear method is called on the source.
     * @event module:ol/source/Vector.VectorSourceEvent#clear
     * @api
     */
    CLEAR: "clear",
    /**
     * Triggered when a feature is removed from the source.
     * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
     * @event module:ol/source/Vector.VectorSourceEvent#removefeature
     * @api
     */
    REMOVEFEATURE: "removefeature",
    /**
     * Triggered when features starts loading.
     * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
     * @api
     */
    FEATURESLOADSTART: "featuresloadstart",
    /**
     * Triggered when features finishes loading.
     * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
     * @api
     */
    FEATURESLOADEND: "featuresloadend",
    /**
     * Triggered if feature loading results in an error.
     * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
     * @api
     */
    FEATURESLOADERROR: "featuresloaderror"
  };
  function Ny(i, t) {
    return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]];
  }
  let Fy = !1;
  function Dy(i, t, e, n, s, r, a) {
    const o = new XMLHttpRequest();
    o.open(
      "GET",
      typeof i == "function" ? i(e, n, s) : i,
      !0
    ), t.getType() == "arraybuffer" && (o.responseType = "arraybuffer"), o.withCredentials = Fy, o.onload = function(l) {
      if (!o.status || o.status >= 200 && o.status < 300) {
        const h = t.getType();
        try {
          let c;
          h == "text" || h == "json" ? c = o.responseText : h == "xml" ? c = o.responseXML || o.responseText : h == "arraybuffer" && (c = /** @type {ArrayBuffer} */
          o.response), c ? r(
            /** @type {Array<FeatureType>} */
            t.readFeatures(c, {
              extent: e,
              featureProjection: s
            }),
            t.readProjection(c)
          ) : a();
        } catch {
          a();
        }
      } else
        a();
    }, o.onerror = a, o.send();
  }
  function bu(i, t) {
    return function(e, n, s, r, a) {
      const o = (
        /** @type {import("./source/Vector").default<FeatureType>} */
        this
      );
      Dy(
        i,
        t,
        e,
        n,
        s,
        /**
         * @param {Array<FeatureType>} features The loaded features.
         * @param {import("./proj/Projection.js").default} dataProjection Data
         * projection.
         */
        function(l, h) {
          o.addFeatures(l), r !== void 0 && r(l);
        },
        /* FIXME handle error */
        a || Is
      );
    };
  }
  class Ki extends Oi {
    /**
     * @param {string} type Type.
     * @param {FeatureType} [feature] Feature.
     * @param {Array<FeatureType>} [features] Features.
     */
    constructor(t, e, n) {
      super(t), this.feature = e, this.features = n;
    }
  }
  class ky extends If {
    /**
     * @param {Options<FeatureType>} [options] Vector source options.
     */
    constructor(t) {
      t = t || {}, super({
        attributions: t.attributions,
        interpolate: !0,
        projection: void 0,
        state: "ready",
        wrapX: t.wrapX !== void 0 ? t.wrapX : !0
      }), this.on, this.once, this.un, this.loader_ = Is, this.format_ = t.format || null, this.overlaps_ = t.overlaps === void 0 ? !0 : t.overlaps, this.url_ = t.url, t.loader !== void 0 ? this.loader_ = t.loader : this.url_ !== void 0 && (Mt(this.format_, "`format` must be set when `url` is set"), this.loader_ = bu(this.url_, this.format_)), this.strategy_ = t.strategy !== void 0 ? t.strategy : Ny;
      const e = t.useSpatialIndex !== void 0 ? t.useSpatialIndex : !0;
      this.featuresRtree_ = e ? new Iu() : null, this.loadedExtentsRtree_ = new Iu(), this.loadingExtentsCount_ = 0, this.nullGeometryFeatures_ = {}, this.idIndex_ = {}, this.uidIndex_ = {}, this.featureChangeKeys_ = {}, this.featuresCollection_ = null;
      let n, s;
      Array.isArray(t.features) ? s = t.features : t.features && (n = t.features, s = n.getArray()), !e && n === void 0 && (n = new hi(s)), s !== void 0 && this.addFeaturesInternal(s), n !== void 0 && this.bindFeaturesCollection_(n);
    }
    /**
     * Add a single feature to the source.  If you want to add a batch of features
     * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
     * instead. A feature will not be added to the source if feature with
     * the same id is already there. The reason for this behavior is to avoid
     * feature duplication when using bbox or tile loading strategies.
     * Note: this also applies if a {@link module:ol/Collection~Collection} is used for features,
     * meaning that if a feature with a duplicate id is added in the collection, it will
     * be removed from it right away.
     * @param {FeatureType} feature Feature to add.
     * @api
     */
    addFeature(t) {
      this.addFeatureInternal(t), this.changed();
    }
    /**
     * Add a feature without firing a `change` event.
     * @param {FeatureType} feature Feature.
     * @protected
     */
    addFeatureInternal(t) {
      const e = St(t);
      if (!this.addToIndex_(e, t)) {
        this.featuresCollection_ && this.featuresCollection_.remove(t);
        return;
      }
      this.setupChangeEvents_(e, t);
      const n = t.getGeometry();
      if (n) {
        const s = n.getExtent();
        this.featuresRtree_ && this.featuresRtree_.insert(s, t);
      } else
        this.nullGeometryFeatures_[e] = t;
      this.dispatchEvent(
        new Ki(Ue.ADDFEATURE, t)
      );
    }
    /**
     * @param {string} featureKey Unique identifier for the feature.
     * @param {FeatureType} feature The feature.
     * @private
     */
    setupChangeEvents_(t, e) {
      e instanceof Qe || (this.featureChangeKeys_[t] = [
        xt(e, ht.CHANGE, this.handleFeatureChange_, this),
        xt(
          e,
          Ts.PROPERTYCHANGE,
          this.handleFeatureChange_,
          this
        )
      ]);
    }
    /**
     * @param {string} featureKey Unique identifier for the feature.
     * @param {FeatureType} feature The feature.
     * @return {boolean} The feature is "valid", in the sense that it is also a
     *     candidate for insertion into the Rtree.
     * @private
     */
    addToIndex_(t, e) {
      let n = !0;
      if (e.getId() !== void 0) {
        const s = String(e.getId());
        if (!(s in this.idIndex_))
          this.idIndex_[s] = e;
        else if (e instanceof Qe) {
          const r = this.idIndex_[s];
          r instanceof Qe ? Array.isArray(r) ? r.push(e) : this.idIndex_[s] = [r, e] : n = !1;
        } else
          n = !1;
      }
      return n && (Mt(
        !(t in this.uidIndex_),
        "The passed `feature` was already added to the source"
      ), this.uidIndex_[t] = e), n;
    }
    /**
     * Add a batch of features to the source.
     * @param {Array<FeatureType>} features Features to add.
     * @api
     */
    addFeatures(t) {
      this.addFeaturesInternal(t), this.changed();
    }
    /**
     * Add features without firing a `change` event.
     * @param {Array<FeatureType>} features Features.
     * @protected
     */
    addFeaturesInternal(t) {
      const e = [], n = [], s = [];
      for (let r = 0, a = t.length; r < a; r++) {
        const o = t[r], l = St(o);
        this.addToIndex_(l, o) && n.push(o);
      }
      for (let r = 0, a = n.length; r < a; r++) {
        const o = n[r], l = St(o);
        this.setupChangeEvents_(l, o);
        const h = o.getGeometry();
        if (h) {
          const c = h.getExtent();
          e.push(c), s.push(o);
        } else
          this.nullGeometryFeatures_[l] = o;
      }
      if (this.featuresRtree_ && this.featuresRtree_.load(e, s), this.hasListener(Ue.ADDFEATURE))
        for (let r = 0, a = n.length; r < a; r++)
          this.dispatchEvent(
            new Ki(Ue.ADDFEATURE, n[r])
          );
    }
    /**
     * @param {!Collection<FeatureType>} collection Collection.
     * @private
     */
    bindFeaturesCollection_(t) {
      let e = !1;
      this.addEventListener(
        Ue.ADDFEATURE,
        /**
         * @param {VectorSourceEvent<FeatureType>} evt The vector source event
         */
        function(n) {
          e || (e = !0, t.push(n.feature), e = !1);
        }
      ), this.addEventListener(
        Ue.REMOVEFEATURE,
        /**
         * @param {VectorSourceEvent<FeatureType>} evt The vector source event
         */
        function(n) {
          e || (e = !0, t.remove(n.feature), e = !1);
        }
      ), t.addEventListener(
        we.ADD,
        /**
         * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
         */
        (n) => {
          e || (e = !0, this.addFeature(n.element), e = !1);
        }
      ), t.addEventListener(
        we.REMOVE,
        /**
         * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
         */
        (n) => {
          e || (e = !0, this.removeFeature(n.element), e = !1);
        }
      ), this.featuresCollection_ = t;
    }
    /**
     * Remove all features from the source.
     * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
     * @api
     */
    clear(t) {
      if (t) {
        for (const n in this.featureChangeKeys_)
          this.featureChangeKeys_[n].forEach(bt);
        this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.uidIndex_ = {});
      } else if (this.featuresRtree_) {
        this.featuresRtree_.forEach((n) => {
          this.removeFeatureInternal(n);
        });
        for (const n in this.nullGeometryFeatures_)
          this.removeFeatureInternal(this.nullGeometryFeatures_[n]);
      }
      this.featuresCollection_ && this.featuresCollection_.clear(), this.featuresRtree_ && this.featuresRtree_.clear(), this.nullGeometryFeatures_ = {};
      const e = new Ki(Ue.CLEAR);
      this.dispatchEvent(e), this.changed();
    }
    /**
     * Iterate through all features on the source, calling the provided callback
     * with each one.  If the callback returns any "truthy" value, iteration will
     * stop and the function will return the same value.
     * Note: this function only iterate through the feature that have a defined geometry.
     *
     * @param {function(FeatureType): T} callback Called with each feature
     *     on the source.  Return a truthy value to stop iteration.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */
    forEachFeature(t) {
      if (this.featuresRtree_)
        return this.featuresRtree_.forEach(t);
      this.featuresCollection_ && this.featuresCollection_.forEach(t);
    }
    /**
     * Iterate through all features whose geometries contain the provided
     * coordinate, calling the callback with each feature.  If the callback returns
     * a "truthy" value, iteration will stop and the function will return the same
     * value.
     *
     * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be
     * called for all features.
     *
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {function(FeatureType): T} callback Called with each feature
     *     whose goemetry contains the provided coordinate.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     */
    forEachFeatureAtCoordinateDirect(t, e) {
      const n = [t[0], t[1], t[0], t[1]];
      return this.forEachFeatureInExtent(n, function(s) {
        const r = s.getGeometry();
        if (r instanceof Qe || r.intersectsCoordinate(t))
          return e(s);
      });
    }
    /**
     * Iterate through all features whose bounding box intersects the provided
     * extent (note that the feature's geometry may not intersect the extent),
     * calling the callback with each feature.  If the callback returns a "truthy"
     * value, iteration will stop and the function will return the same value.
     *
     * If you are interested in features whose geometry intersects an extent, call
     * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
     *
     * When `useSpatialIndex` is set to false, this method will loop through all
     * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(FeatureType): T} callback Called with each feature
     *     whose bounding box intersects the provided extent.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */
    forEachFeatureInExtent(t, e) {
      if (this.featuresRtree_)
        return this.featuresRtree_.forEachInExtent(t, e);
      this.featuresCollection_ && this.featuresCollection_.forEach(e);
    }
    /**
     * Iterate through all features whose geometry intersects the provided extent,
     * calling the callback with each feature.  If the callback returns a "truthy"
     * value, iteration will stop and the function will return the same value.
     *
     * If you only want to test for bounding box intersection, call the
     * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(FeatureType): T} callback Called with each feature
     *     whose geometry intersects the provided extent.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */
    forEachFeatureIntersectingExtent(t, e) {
      return this.forEachFeatureInExtent(
        t,
        /**
         * @param {FeatureType} feature Feature.
         * @return {T|undefined} The return value from the last call to the callback.
         */
        function(n) {
          const s = n.getGeometry();
          if (s instanceof Qe || s.intersectsExtent(t)) {
            const r = e(n);
            if (r)
              return r;
          }
        }
      );
    }
    /**
     * Get the features collection associated with this source. Will be `null`
     * unless the source was configured with `useSpatialIndex` set to `false`, or
     * with a {@link module:ol/Collection~Collection} as `features`.
     * @return {Collection<FeatureType>|null} The collection of features.
     * @api
     */
    getFeaturesCollection() {
      return this.featuresCollection_;
    }
    /**
     * Get a snapshot of the features currently on the source in random order. The returned array
     * is a copy, the features are references to the features in the source.
     * @return {Array<FeatureType>} Features.
     * @api
     */
    getFeatures() {
      let t;
      return this.featuresCollection_ ? t = this.featuresCollection_.getArray().slice(0) : this.featuresRtree_ && (t = this.featuresRtree_.getAll(), As(this.nullGeometryFeatures_) || pe(t, Object.values(this.nullGeometryFeatures_))), t;
    }
    /**
     * Get all features whose geometry intersects the provided coordinate.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {Array<FeatureType>} Features.
     * @api
     */
    getFeaturesAtCoordinate(t) {
      const e = [];
      return this.forEachFeatureAtCoordinateDirect(t, function(n) {
        e.push(n);
      }), e;
    }
    /**
     * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
     * all features intersecting the given extent in random order (so it may include
     * features whose geometries do not intersect the extent).
     *
     * When `useSpatialIndex` is set to false, this method will return all
     * features.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {import("../proj/Projection.js").default} [projection] Include features
     * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
     * @return {Array<FeatureType>} Features.
     * @api
     */
    getFeaturesInExtent(t, e) {
      if (this.featuresRtree_) {
        if (!(e && e.canWrapX() && this.getWrapX()))
          return this.featuresRtree_.getInExtent(t);
        const s = yo(t, e);
        return [].concat(
          ...s.map((r) => this.featuresRtree_.getInExtent(r))
        );
      }
      return this.featuresCollection_ ? this.featuresCollection_.getArray().slice(0) : [];
    }
    /**
     * Get the closest feature to the provided coordinate.
     *
     * This method is not available when the source is configured with
     * `useSpatialIndex` set to `false` and the features in this source are of type
     * {@link module:ol/Feature~Feature}.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {function(FeatureType):boolean} [filter] Feature filter function.
     *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
     *     and it should return a boolean value. By default, no filtering is made.
     * @return {FeatureType} Closest feature.
     * @api
     */
    getClosestFeatureToCoordinate(t, e) {
      const n = t[0], s = t[1];
      let r = null;
      const a = [NaN, NaN];
      let o = 1 / 0;
      const l = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
      return e = e || xr, this.featuresRtree_.forEachInExtent(
        l,
        /**
         * @param {FeatureType} feature Feature.
         */
        function(h) {
          if (e(h)) {
            const c = h.getGeometry(), u = o;
            if (o = c instanceof Qe ? 0 : c.closestPointXY(n, s, a, o), o < u) {
              r = h;
              const d = Math.sqrt(o);
              l[0] = n - d, l[1] = s - d, l[2] = n + d, l[3] = s + d;
            }
          }
        }
      ), r;
    }
    /**
     * Get the extent of the features currently in the source.
     *
     * This method is not available when the source is configured with
     * `useSpatialIndex` set to `false`.
     * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
     *     will be created. Instead, that extent's coordinates will be overwritten.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getExtent(t) {
      return this.featuresRtree_.getExtent(t);
    }
    /**
     * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s
     * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling
     * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per
     * `GeometryCollection` member.
     * Note that the index treats string and numeric identifiers as the same.  So
     * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
     *
     * @param {string|number} id Feature identifier.
     * @return {FeatureClassOrArrayOfRenderFeatures<FeatureType>|null} The feature (or `null` if not found).
     * @api
     */
    getFeatureById(t) {
      const e = this.idIndex_[t.toString()];
      return e !== void 0 ? (
        /** @type {FeatureClassOrArrayOfRenderFeatures<FeatureType>} */
        e
      ) : null;
    }
    /**
     * Get a feature by its internal unique identifier (using `getUid`).
     *
     * @param {string} uid Feature identifier.
     * @return {FeatureType|null} The feature (or `null` if not found).
     */
    getFeatureByUid(t) {
      const e = this.uidIndex_[t];
      return e !== void 0 ? e : null;
    }
    /**
     * Get the format associated with this source.
     *
     * @return {import("../format/Feature.js").default<FeatureType>|null}} The feature format.
     * @api
     */
    getFormat() {
      return this.format_;
    }
    /**
     * @return {boolean} The source can have overlapping geometries.
     */
    getOverlaps() {
      return this.overlaps_;
    }
    /**
     * Get the url associated with this source.
     *
     * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
     * @api
     */
    getUrl() {
      return this.url_;
    }
    /**
     * @param {Event} event Event.
     * @private
     */
    handleFeatureChange_(t) {
      const e = (
        /** @type {FeatureType} */
        t.target
      ), n = St(e), s = e.getGeometry();
      if (!s)
        n in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(e), this.nullGeometryFeatures_[n] = e);
      else {
        const a = s.getExtent();
        n in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[n], this.featuresRtree_ && this.featuresRtree_.insert(a, e)) : this.featuresRtree_ && this.featuresRtree_.update(a, e);
      }
      const r = e.getId();
      if (r !== void 0) {
        const a = r.toString();
        this.idIndex_[a] !== e && (this.removeFromIdIndex_(e), this.idIndex_[a] = e);
      } else
        this.removeFromIdIndex_(e), this.uidIndex_[n] = e;
      this.changed(), this.dispatchEvent(
        new Ki(Ue.CHANGEFEATURE, e)
      );
    }
    /**
     * Returns true if the feature is contained within the source.
     * @param {FeatureType} feature Feature.
     * @return {boolean} Has feature.
     * @api
     */
    hasFeature(t) {
      const e = t.getId();
      return e !== void 0 ? e in this.idIndex_ : St(t) in this.uidIndex_;
    }
    /**
     * @return {boolean} Is empty.
     */
    isEmpty() {
      return this.featuresRtree_ ? this.featuresRtree_.isEmpty() && As(this.nullGeometryFeatures_) : this.featuresCollection_ ? this.featuresCollection_.getLength() === 0 : !0;
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */
    loadFeatures(t, e, n) {
      const s = this.loadedExtentsRtree_, r = this.strategy_(t, e, n);
      for (let a = 0, o = r.length; a < o; ++a) {
        const l = r[a];
        s.forEachInExtent(
          l,
          /**
           * @param {{extent: import("../extent.js").Extent}} object Object.
           * @return {boolean} Contains.
           */
          function(c) {
            return Qi(c.extent, l);
          }
        ) || (++this.loadingExtentsCount_, this.dispatchEvent(
          new Ki(Ue.FEATURESLOADSTART)
        ), this.loader_.call(
          this,
          l,
          e,
          n,
          /**
           * @param {Array<FeatureType>} features Loaded features
           */
          (c) => {
            --this.loadingExtentsCount_, this.dispatchEvent(
              new Ki(
                Ue.FEATURESLOADEND,
                void 0,
                c
              )
            );
          },
          () => {
            --this.loadingExtentsCount_, this.dispatchEvent(
              new Ki(Ue.FEATURESLOADERROR)
            );
          }
        ), s.insert(l, { extent: l.slice() }));
      }
      this.loading = this.loader_.length < 4 ? !1 : this.loadingExtentsCount_ > 0;
    }
    /**
     * @override
     */
    refresh() {
      this.clear(!0), this.loadedExtentsRtree_.clear(), super.refresh();
    }
    /**
     * Remove an extent from the list of loaded extents.
     * @param {import("../extent.js").Extent} extent Extent.
     * @api
     */
    removeLoadedExtent(t) {
      const e = this.loadedExtentsRtree_, n = e.forEachInExtent(t, function(s) {
        if (Ps(s.extent, t))
          return s;
      });
      n && e.remove(n);
    }
    /**
     * Batch remove features from the source.  If you want to remove all features
     * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
     * instead.
     * @param {Array<FeatureType>} features Features to remove.
     * @api
     */
    removeFeatures(t) {
      let e = !1;
      for (let n = 0, s = t.length; n < s; ++n)
        e = this.removeFeatureInternal(t[n]) || e;
      e && this.changed();
    }
    /**
     * Remove a single feature from the source. If you want to batch remove
     * features, use the {@link module:ol/source/Vector~VectorSource#removeFeatures #removeFeatures()} method
     * instead.
     * @param {FeatureType} feature Feature to remove.
     * @api
     */
    removeFeature(t) {
      if (!t)
        return;
      this.removeFeatureInternal(t) && this.changed();
    }
    /**
     * Remove feature without firing a `change` event.
     * @param {FeatureType} feature Feature.
     * @return {boolean} True if the feature was removed, false if it was not found.
     * @protected
     */
    removeFeatureInternal(t) {
      const e = St(t);
      if (!(e in this.uidIndex_))
        return !1;
      e in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[e] : this.featuresRtree_ && this.featuresRtree_.remove(t);
      const n = this.featureChangeKeys_[e];
      n == null || n.forEach(bt), delete this.featureChangeKeys_[e];
      const s = t.getId();
      if (s !== void 0) {
        const r = s.toString(), a = this.idIndex_[r];
        a === t ? delete this.idIndex_[r] : Array.isArray(a) && (a.splice(a.indexOf(t), 1), a.length === 1 && (this.idIndex_[r] = a[0]));
      }
      return delete this.uidIndex_[e], this.hasListener(Ue.REMOVEFEATURE) && this.dispatchEvent(
        new Ki(Ue.REMOVEFEATURE, t)
      ), !0;
    }
    /**
     * Remove a feature from the id index.  Called internally when the feature id
     * may have changed.
     * @param {FeatureType} feature The feature.
     * @private
     */
    removeFromIdIndex_(t) {
      for (const e in this.idIndex_)
        if (this.idIndex_[e] === t) {
          delete this.idIndex_[e];
          break;
        }
    }
    /**
     * Set the new loader of the source. The next render cycle will use the
     * new loader.
     * @param {import("../featureloader.js").FeatureLoader<FeatureType>} loader The loader to set.
     * @api
     */
    setLoader(t) {
      this.loader_ = t;
    }
    /**
     * Points the source to a new url. The next render cycle will use the new url.
     * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
     * @api
     */
    setUrl(t) {
      Mt(this.format_, "`format` must be set when `url` is set"), this.url_ = t, this.setLoader(bu(t, this.format_));
    }
    /**
     * @param {boolean} overlaps The source can have overlapping geometries.
     */
    setOverlaps(t) {
      this.overlaps_ = t, this.changed();
    }
  }
  function Gy(i, t) {
    const e = i.canvas;
    t = t || {};
    const n = t.pixelRatio || Co, s = t.size;
    s && (e.width = s[0] * n, e.height = s[1] * n, e.style.width = s[0] + "px", e.style.height = s[1] + "px");
    const r = [0, 0, e.width, e.height], a = Lm(We(), n, n);
    return new Vh(i, n, r, a, 0);
  }
  function Uy(i) {
    if (!(i.context instanceof CanvasRenderingContext2D))
      throw new Error("Only works for render events from Canvas 2D layers");
    const t = i.inversePixelTransform[0], e = i.inversePixelTransform[1], n = Math.sqrt(t * t + e * e), s = i.frameState, r = Od(
      i.inversePixelTransform.slice(),
      s.coordinateToPixelTransform
    ), a = Xl(
      s.viewState.resolution,
      n
    );
    let o;
    return new Vh(
      i.context,
      n,
      s.extent,
      r,
      s.viewState.rotation,
      a,
      o
    );
  }
  function zy(i, t) {
    return Yt(i.inversePixelTransform, t.slice(0));
  }
  const By = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    getRenderPixel: zy,
    getVectorContext: Uy,
    toContext: Gy
  }, Symbol.toStringTag, { value: "Module" }));
  function Fo() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  function Wl(i, t, e, n, s, r, a) {
    a = a ?? Fo();
    const o = 1 / (i - t), l = 1 / (e - n), h = 1 / (s - r);
    return a[0] = -2 * o, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = -2 * l, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 2 * h, a[11] = 0, a[12] = (i + t) * o, a[13] = (n + e) * l, a[14] = (r + s) * h, a[15] = 1, a;
  }
  function Lu(i, t, e, n, s) {
    return s = s ?? Fo(), s[0] = i[0] * t, s[1] = i[1] * t, s[2] = i[2] * t, s[3] = i[3] * t, s[4] = i[4] * e, s[5] = i[5] * e, s[6] = i[6] * e, s[7] = i[7] * e, s[8] = i[8] * n, s[9] = i[9] * n, s[10] = i[10] * n, s[11] = i[11] * n, s[12] = i[12], s[13] = i[13], s[14] = i[14], s[15] = i[15], s;
  }
  function $y(i, t, e, n, s) {
    s = s ?? Fo();
    let r, a, o, l, h, c, u, d, m, f, y, E;
    return i === s ? (s[12] = i[0] * t + i[4] * e + i[8] * n + i[12], s[13] = i[1] * t + i[5] * e + i[9] * n + i[13], s[14] = i[2] * t + i[6] * e + i[10] * n + i[14], s[15] = i[3] * t + i[7] * e + i[11] * n + i[15]) : (r = i[0], a = i[1], o = i[2], l = i[3], h = i[4], c = i[5], u = i[6], d = i[7], m = i[8], f = i[9], y = i[10], E = i[11], s[0] = r, s[1] = a, s[2] = o, s[3] = l, s[4] = h, s[5] = c, s[6] = u, s[7] = d, s[8] = m, s[9] = f, s[10] = y, s[11] = E, s[12] = r * t + h * e + m * n + i[12], s[13] = a * t + c * e + f * n + i[13], s[14] = o * t + u * e + y * n + i[14], s[15] = l * t + d * e + E * n + i[15]), s;
  }
  function Xy(i, t, e, n) {
    return n = n ?? Fo(), n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 1, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 1, n[11] = 0, n[12] = i, n[13] = t, n[14] = e, n[15] = 1, n;
  }
  const Af = 0.5;
  class Hh extends uo {
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("./TileState.js").default} state State.
     * @param {Options} [options] Tile options.
     */
    constructor(t, e, n) {
      super(), n = n || {}, this.tileCoord = t, this.state = e, this.key = "", this.transition_ = n.transition === void 0 ? 250 : n.transition, this.transitionStarts_ = {}, this.interpolate = !!n.interpolate;
    }
    /**
     * @protected
     */
    changed() {
      this.dispatchEvent(ht.CHANGE);
    }
    /**
     * Called by the tile cache when the tile is removed from the cache due to expiry
     */
    release() {
      this.state === V.ERROR && this.setState(V.EMPTY);
    }
    /**
     * @return {string} Key.
     */
    getKey() {
      return this.key + "/" + this.tileCoord;
    }
    /**
     * Get the tile coordinate for this tile.
     * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
     * @api
     */
    getTileCoord() {
      return this.tileCoord;
    }
    /**
     * @return {import("./TileState.js").default} State.
     */
    getState() {
      return this.state;
    }
    /**
     * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
     * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
     * when the tile cannot be loaded. Otherwise the tile cannot be removed from
     * the tile queue and will block other requests.
     * @param {import("./TileState.js").default} state State.
     * @api
     */
    setState(t) {
      if (this.state !== V.ERROR && this.state > t)
        throw new Error("Tile load sequence violation");
      this.state = t, this.changed();
    }
    /**
     * Load the image or retry if loading previously failed.
     * Loading is taken care of by the tile queue, and calling this method is
     * only needed for preloading or for reloading in case of an error.
     * @abstract
     * @api
     */
    load() {
      ft();
    }
    /**
     * Get the alpha value for rendering.
     * @param {string} id An id for the renderer.
     * @param {number} time The render frame time.
     * @return {number} A number between 0 and 1.
     */
    getAlpha(t, e) {
      if (!this.transition_)
        return 1;
      let n = this.transitionStarts_[t];
      if (!n)
        n = e, this.transitionStarts_[t] = n;
      else if (n === -1)
        return 1;
      const s = e - n + 1e3 / 60;
      return s >= this.transition_ ? 1 : Ld(s / this.transition_);
    }
    /**
     * Determine if a tile is in an alpha transition.  A tile is considered in
     * transition if tile.getAlpha() has not yet been called or has been called
     * and returned 1.
     * @param {string} id An id for the renderer.
     * @return {boolean} The tile is in transition.
     */
    inTransition(t) {
      return this.transition_ ? this.transitionStarts_[t] !== -1 : !1;
    }
    /**
     * Mark a transition as complete.
     * @param {string} id An id for the renderer.
     */
    endTransition(t) {
      this.transition_ && (this.transitionStarts_[t] = -1);
    }
    /**
     * @override
     */
    disposeInternal() {
      this.release(), super.disposeInternal();
    }
  }
  function Qa(i) {
    return i instanceof Image || i instanceof HTMLCanvasElement || i instanceof HTMLVideoElement || i instanceof ImageBitmap ? i : null;
  }
  function Wy(i) {
    return i instanceof Uint8Array || i instanceof Uint8ClampedArray || i instanceof Float32Array || i instanceof DataView ? i : null;
  }
  const Yy = new Error("disposed");
  let es = null;
  function Zy(i) {
    es || (es = Xt(
      i.width,
      i.height,
      void 0,
      { willReadFrequently: !0 }
    ));
    const t = es.canvas, e = i.width;
    t.width !== e && (t.width = e);
    const n = i.height;
    return t.height !== n && (t.height = n), es.clearRect(0, 0, e, n), es.drawImage(i, 0, 0), es.getImageData(0, 0, e, n).data;
  }
  const qy = [256, 256];
  class Yl extends Hh {
    /**
     * @param {Options} options Tile options.
     */
    constructor(t) {
      const e = V.IDLE;
      super(t.tileCoord, e, {
        transition: t.transition,
        interpolate: t.interpolate
      }), this.loader_ = t.loader, this.data_ = null, this.error_ = null, this.size_ = t.size || null, this.controller_ = t.controller || null;
    }
    /**
     * Get the tile size.
     * @return {import('./size.js').Size} Tile size.
     */
    getSize() {
      if (this.size_)
        return this.size_;
      const t = Qa(this.data_);
      return t ? [t.width, t.height] : qy;
    }
    /**
     * Get the data for the tile.
     * @return {Data} Tile data.
     * @api
     */
    getData() {
      return this.data_;
    }
    /**
     * Get any loading error.
     * @return {Error} Loading error.
     * @api
     */
    getError() {
      return this.error_;
    }
    /**
     * Load the tile data.
     * @api
     * @override
     */
    load() {
      if (this.state !== V.IDLE && this.state !== V.ERROR)
        return;
      this.state = V.LOADING, this.changed();
      const t = this;
      this.loader_().then(function(e) {
        t.data_ = e, t.state = V.LOADED, t.changed();
      }).catch(function(e) {
        t.error_ = e, t.state = V.ERROR, t.changed();
      });
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.controller_ && (this.controller_.abort(Yy), this.controller_ = null), super.disposeInternal();
    }
  }
  const Ky = 10, Ou = 0.25;
  class Pf {
    /**
     * @param {import("../proj/Projection.js").default} sourceProj Source projection.
     * @param {import("../proj/Projection.js").default} targetProj Target projection.
     * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
     * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
     * @param {number} errorThreshold Acceptable error (in source units).
     * @param {?number} destinationResolution The (optional) resolution of the destination.
     * @param {import("../transform.js").Transform} [sourceMatrix] Source transform matrix.
     */
    constructor(t, e, n, s, r, a, o) {
      this.sourceProj_ = t, this.targetProj_ = e;
      let l = {};
      const h = o ? Ll(
        (C) => Yt(
          o,
          Pd(C, this.targetProj_, this.sourceProj_)
        )
      ) : Ls(this.targetProj_, this.sourceProj_);
      this.transformInv_ = function(C) {
        const R = C[0] + "/" + C[1];
        return l[R] || (l[R] = h(C)), l[R];
      }, this.maxSourceExtent_ = s, this.errorThresholdSquared_ = r * r, this.triangles_ = [], this.wrapsXInSource_ = !1, this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!s && !!this.sourceProj_.getExtent() && _t(s) >= _t(this.sourceProj_.getExtent()), this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? _t(this.sourceProj_.getExtent()) : null, this.targetWorldWidth_ = this.targetProj_.getExtent() ? _t(this.targetProj_.getExtent()) : null;
      const c = fi(n), u = Br(n), d = zr(n), m = Ur(n), f = this.transformInv_(c), y = this.transformInv_(u), E = this.transformInv_(d), x = this.transformInv_(m), M = Ky + (a ? Math.max(
        0,
        Math.ceil(
          Math.log2(
            Dn(n) / (a * a * 256 * 256)
          )
        )
      ) : 0);
      if (this.addQuad_(
        c,
        u,
        d,
        m,
        f,
        y,
        E,
        x,
        M
      ), this.wrapsXInSource_) {
        let C = 1 / 0;
        this.triangles_.forEach(function(R, S, A) {
          C = Math.min(
            C,
            R.source[0][0],
            R.source[1][0],
            R.source[2][0]
          );
        }), this.triangles_.forEach((R) => {
          if (Math.max(
            R.source[0][0],
            R.source[1][0],
            R.source[2][0]
          ) - C > this.sourceWorldWidth_ / 2) {
            const S = [
              [R.source[0][0], R.source[0][1]],
              [R.source[1][0], R.source[1][1]],
              [R.source[2][0], R.source[2][1]]
            ];
            S[0][0] - C > this.sourceWorldWidth_ / 2 && (S[0][0] -= this.sourceWorldWidth_), S[1][0] - C > this.sourceWorldWidth_ / 2 && (S[1][0] -= this.sourceWorldWidth_), S[2][0] - C > this.sourceWorldWidth_ / 2 && (S[2][0] -= this.sourceWorldWidth_);
            const A = Math.min(
              S[0][0],
              S[1][0],
              S[2][0]
            );
            Math.max(
              S[0][0],
              S[1][0],
              S[2][0]
            ) - A < this.sourceWorldWidth_ / 2 && (R.source = S);
          }
        });
      }
      l = {};
    }
    /**
     * Adds triangle to the triangulation.
     * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
     * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
     * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
     * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
     * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
     * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
     * @private
     */
    addTriangle_(t, e, n, s, r, a) {
      this.triangles_.push({
        source: [s, r, a],
        target: [t, e, n]
      });
    }
    /**
     * Adds quad (points in clock-wise order) to the triangulation
     * (and reprojects the vertices) if valid.
     * Performs quad subdivision if needed to increase precision.
     *
     * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
     * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
     * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
     * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
     * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
     * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
     * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
     * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
     * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
     * @private
     */
    addQuad_(t, e, n, s, r, a, o, l, h) {
      const c = Il([r, a, o, l]), u = this.sourceWorldWidth_ ? _t(c) / this.sourceWorldWidth_ : null, d = (
        /** @type {number} */
        this.sourceWorldWidth_
      ), m = this.sourceProj_.canWrapX() && u > 0.5 && u < 1;
      let f = !1;
      if (h > 0) {
        if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
          const E = Il([t, e, n, s]);
          f = _t(E) / this.targetWorldWidth_ > Ou || f;
        }
        !m && this.sourceProj_.isGlobal() && u && (f = u > Ou || f);
      }
      if (!f && this.maxSourceExtent_ && isFinite(c[0]) && isFinite(c[1]) && isFinite(c[2]) && isFinite(c[3]) && !he(c, this.maxSourceExtent_))
        return;
      let y = 0;
      if (!f && (!isFinite(r[0]) || !isFinite(r[1]) || !isFinite(a[0]) || !isFinite(a[1]) || !isFinite(o[0]) || !isFinite(o[1]) || !isFinite(l[0]) || !isFinite(l[1]))) {
        if (h > 0)
          f = !0;
        else if (y = (!isFinite(r[0]) || !isFinite(r[1]) ? 8 : 0) + (!isFinite(a[0]) || !isFinite(a[1]) ? 4 : 0) + (!isFinite(o[0]) || !isFinite(o[1]) ? 2 : 0) + (!isFinite(l[0]) || !isFinite(l[1]) ? 1 : 0), y != 1 && y != 2 && y != 4 && y != 8)
          return;
      }
      if (h > 0) {
        if (!f) {
          const E = [(t[0] + n[0]) / 2, (t[1] + n[1]) / 2], x = this.transformInv_(E);
          let M;
          m ? M = (ps(r[0], d) + ps(o[0], d)) / 2 - ps(x[0], d) : M = (r[0] + o[0]) / 2 - x[0];
          const C = (r[1] + o[1]) / 2 - x[1];
          f = M * M + C * C > this.errorThresholdSquared_;
        }
        if (f) {
          if (Math.abs(t[0] - n[0]) <= Math.abs(t[1] - n[1])) {
            const E = [(e[0] + n[0]) / 2, (e[1] + n[1]) / 2], x = this.transformInv_(E), M = [(s[0] + t[0]) / 2, (s[1] + t[1]) / 2], C = this.transformInv_(M);
            this.addQuad_(
              t,
              e,
              E,
              M,
              r,
              a,
              x,
              C,
              h - 1
            ), this.addQuad_(
              M,
              E,
              n,
              s,
              C,
              x,
              o,
              l,
              h - 1
            );
          } else {
            const E = [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2], x = this.transformInv_(E), M = [(n[0] + s[0]) / 2, (n[1] + s[1]) / 2], C = this.transformInv_(M);
            this.addQuad_(
              t,
              E,
              M,
              s,
              r,
              x,
              C,
              l,
              h - 1
            ), this.addQuad_(
              E,
              e,
              n,
              M,
              x,
              a,
              o,
              C,
              h - 1
            );
          }
          return;
        }
      }
      if (m) {
        if (!this.canWrapXInSource_)
          return;
        this.wrapsXInSource_ = !0;
      }
      y & 11 || this.addTriangle_(t, n, s, r, o, l), y & 14 || this.addTriangle_(t, n, e, r, o, a), y && (y & 13 || this.addTriangle_(e, s, t, a, l, r), y & 7 || this.addTriangle_(e, s, n, a, l, o));
    }
    /**
     * Calculates extent of the `source` coordinates from all the triangles.
     *
     * @return {import("../extent.js").Extent} Calculated extent.
     */
    calculateSourceExtent() {
      const t = Ae();
      return this.triangles_.forEach(function(e, n, s) {
        const r = e.source;
        Ln(t, r[0]), Ln(t, r[1]), Ln(t, r[2]);
      }), t;
    }
    /**
     * @return {Array<Triangle>} Array of the calculated triangles.
     */
    getTriangles() {
      return this.triangles_;
    }
  }
  let gl;
  const Es = [];
  function Nu(i, t, e, n, s) {
    i.beginPath(), i.moveTo(0, 0), i.lineTo(t, e), i.lineTo(n, s), i.closePath(), i.save(), i.clip(), i.fillRect(0, 0, Math.max(t, n) + 1, Math.max(e, s)), i.restore();
  }
  function ml(i, t) {
    return Math.abs(i[t * 4] - 210) > 2 || Math.abs(i[t * 4 + 3] - 0.75 * 255) > 2;
  }
  function jy() {
    if (gl === void 0) {
      const i = Xt(6, 6, Es);
      i.globalCompositeOperation = "lighter", i.fillStyle = "rgba(210, 0, 0, 0.75)", Nu(i, 4, 5, 4, 0), Nu(i, 4, 5, 0, 5);
      const t = i.getImageData(0, 0, 3, 3).data;
      gl = ml(t, 0) || ml(t, 4) || ml(t, 8), Io(i), Es.push(i.canvas);
    }
    return gl;
  }
  function Fu(i, t, e, n) {
    const s = Pd(e, t, i);
    let r = Pl(
      t,
      n,
      e
    );
    const a = t.getMetersPerUnit();
    a !== void 0 && (r *= a);
    const o = i.getMetersPerUnit();
    o !== void 0 && (r /= o);
    const l = i.getExtent();
    if (!l || Fn(l, s)) {
      const h = Pl(i, r, s) / r;
      isFinite(h) && h > 0 && (r /= h);
    }
    return r;
  }
  function bf(i, t, e, n) {
    const s = bi(e);
    let r = Fu(
      i,
      t,
      s,
      n
    );
    return (!isFinite(r) || r <= 0) && po(e, function(a) {
      return r = Fu(
        i,
        t,
        a,
        n
      ), isFinite(r) && r > 0;
    }), r;
  }
  function Vy(i, t, e, n, s, r, a, o, l, h, c, u, d, m) {
    const f = Xt(
      Math.round(e * i),
      Math.round(e * t),
      Es
    );
    if (u || (f.imageSmoothingEnabled = !1), l.length === 0)
      return f.canvas;
    f.scale(e, e);
    function y(S) {
      return Math.round(S * e) / e;
    }
    f.globalCompositeOperation = "lighter";
    const E = Ae();
    l.forEach(function(S, A, O) {
      Gr(E, S.extent);
    });
    let x;
    const M = e / n, C = (u ? 1 : 1 + Math.pow(2, -24)) / M;
    x = Xt(
      Math.round(_t(E) * M),
      Math.round($t(E) * M),
      Es
    ), u || (x.imageSmoothingEnabled = !1), l.forEach(function(S, A, O) {
      if (S.image.width > 0 && S.image.height > 0) {
        if (S.clipExtent) {
          x.save();
          const D = (S.clipExtent[0] - E[0]) * M, j = -(S.clipExtent[3] - E[3]) * M, Y = _t(S.clipExtent) * M, q = $t(S.clipExtent) * M;
          x.rect(
            u ? D : Math.round(D),
            u ? j : Math.round(j),
            u ? Y : Math.round(D + Y) - Math.round(D),
            u ? q : Math.round(j + q) - Math.round(j)
          ), x.clip();
        }
        const P = (S.extent[0] - E[0]) * M, L = -(S.extent[3] - E[3]) * M, F = _t(S.extent) * M, z = $t(S.extent) * M;
        x.drawImage(
          S.image,
          h,
          h,
          S.image.width - 2 * h,
          S.image.height - 2 * h,
          u ? P : Math.round(P),
          u ? L : Math.round(L),
          u ? F : Math.round(P + F) - Math.round(P),
          u ? z : Math.round(L + z) - Math.round(L)
        ), S.clipExtent && x.restore();
      }
    });
    const R = fi(a);
    return o.getTriangles().forEach(function(S, A, O) {
      const P = S.source, L = S.target;
      let F = P[0][0], z = P[0][1], D = P[1][0], j = P[1][1], Y = P[2][0], q = P[2][1];
      const J = y((L[0][0] - R[0]) / r), X = y(
        -(L[0][1] - R[1]) / r
      ), et = y((L[1][0] - R[0]) / r), lt = y(
        -(L[1][1] - R[1]) / r
      ), Q = y((L[2][0] - R[0]) / r), W = y(
        -(L[2][1] - R[1]) / r
      ), gt = F, it = z;
      F = 0, z = 0, D -= gt, j -= it, Y -= gt, q -= it;
      const T = [
        [D, j, 0, 0, et - J],
        [Y, q, 0, 0, Q - J],
        [0, 0, D, j, lt - X],
        [0, 0, Y, q, W - X]
      ], ot = L0(T);
      if (!ot)
        return;
      if (f.save(), f.beginPath(), jy() || !u) {
        f.moveTo(et, lt);
        const Lt = 4, Zt = J - et, be = X - lt;
        for (let Jt = 0; Jt < Lt; Jt++)
          f.lineTo(
            et + y((Jt + 1) * Zt / Lt),
            lt + y(Jt * be / (Lt - 1))
          ), Jt != Lt - 1 && f.lineTo(
            et + y((Jt + 1) * Zt / Lt),
            lt + y((Jt + 1) * be / (Lt - 1))
          );
        f.lineTo(Q, W);
      } else
        f.moveTo(et, lt), f.lineTo(J, X), f.lineTo(Q, W);
      f.clip(), f.transform(
        ot[0],
        ot[2],
        ot[1],
        ot[3],
        J,
        X
      ), f.translate(
        E[0] - gt,
        E[3] - it
      );
      let Ct;
      if (x)
        Ct = x.canvas, f.scale(C, -C);
      else {
        const Lt = l[0], Zt = Lt.extent;
        Ct = Lt.image, f.scale(
          _t(Zt) / Ct.width,
          -$t(Zt) / Ct.height
        );
      }
      f.drawImage(Ct, 0, 0), f.restore();
    }), x && (Io(x), Es.push(x.canvas)), c && (f.save(), f.globalCompositeOperation = "source-over", f.strokeStyle = "black", f.lineWidth = 1, o.getTriangles().forEach(function(S, A, O) {
      const P = S.target, L = (P[0][0] - R[0]) / r, F = -(P[0][1] - R[1]) / r, z = (P[1][0] - R[0]) / r, D = -(P[1][1] - R[1]) / r, j = (P[2][0] - R[0]) / r, Y = -(P[2][1] - R[1]) / r;
      f.beginPath(), f.moveTo(z, D), f.lineTo(L, F), f.lineTo(j, Y), f.closePath(), f.stroke();
    }), f.restore()), f.canvas;
  }
  const Hy = `
  attribute vec4 a_position;
  attribute vec4 a_texcoord;

  uniform mat4 u_matrix;
  uniform mat4 u_textureMatrix;

  varying vec2 v_texcoord;

  void main() {
    gl_Position = u_matrix * a_position;
    vec2 texcoord = (u_textureMatrix * a_texcoord).xy;
    v_texcoord = texcoord;
  }
`, Jy = `
  precision mediump float;

  varying vec2 v_texcoord;

  uniform sampler2D u_texture;

  void main() {
    if (
      v_texcoord.x < 0.0 ||
      v_texcoord.y < 0.0 ||
      v_texcoord.x > 1.0 ||
      v_texcoord.y > 1.0
    ) {
      discard;
    }
    gl_FragColor = texture2D(u_texture, v_texcoord);
  }
`;
  class Qy {
    /**
     * @param {WebGLRenderingContext} gl Context to render in.
     */
    constructor(t) {
      this.gl_ = t, this.program_ = Zl(t, Jy, Hy), this.positionLocation = t.getAttribLocation(this.program_, "a_position"), this.texcoordLocation = t.getAttribLocation(this.program_, "a_texcoord"), this.matrixLocation = t.getUniformLocation(this.program_, "u_matrix"), this.textureMatrixLocation = t.getUniformLocation(
        this.program_,
        "u_textureMatrix"
      ), this.textureLocation = t.getUniformLocation(this.program_, "u_texture"), this.positionBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this.positionBuffer), this.positions = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1], t.bufferData(
        t.ARRAY_BUFFER,
        new Float32Array(this.positions),
        t.STATIC_DRAW
      ), this.texcoordBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this.texcoordBuffer), this.texcoords = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1], t.bufferData(
        t.ARRAY_BUFFER,
        new Float32Array(this.texcoords),
        t.STATIC_DRAW
      );
    }
    /**
     * 2dContext drawImage call implemented in webgl.
     * Unlike images, textures do not have a width and height associated
     * with them so we'll pass in the width and height of the texture.
     *
     * @param {WebGLTexture} tex Image to draw.
     * @param {number} texWidth Image width.
     * @param {number} texHeight Image height.
     * @param {number} srcX Top-left x-point to read src image.
     * @param {number} srcY Top-left y-point to read src image.
     * @param {number} [srcWidth] Width of source to read.
     * @param {number} [srcHeight] Height of source to read.
     * @param {number} [dstX] Top-left x-point of destination.
     * @param {number} [dstY] Top-left y-point of destination.
     * @param {number} [dstWidth] Width of written image in destination.
     * @param {number} [dstHeight] Height of written image in destination.
     * @param {number} [width] Width of canvas.
     * @param {number} [height] Height of canvas.
     */
    drawImage(t, e, n, s, r, a, o, l, h, c, u, d, m) {
      const f = this.gl_;
      l === void 0 && (l = s), h === void 0 && (h = r), a === void 0 && (a = e), o === void 0 && (o = n), c === void 0 && (c = a), u === void 0 && (u = o), d === void 0 && (d = f.canvas.width), m === void 0 && (m = f.canvas.height), f.bindTexture(f.TEXTURE_2D, t), f.useProgram(this.program_), f.bindBuffer(f.ARRAY_BUFFER, this.positionBuffer), f.enableVertexAttribArray(this.positionLocation), f.vertexAttribPointer(this.positionLocation, 2, f.FLOAT, !1, 0, 0), f.bindBuffer(f.ARRAY_BUFFER, this.texcoordBuffer), f.enableVertexAttribArray(this.texcoordLocation), f.vertexAttribPointer(this.texcoordLocation, 2, f.FLOAT, !1, 0, 0);
      let y = Wl(0, d, 0, m, -1, 1);
      y = $y(y, l, h, 0), y = Lu(y, c, u, 1), f.uniformMatrix4fv(this.matrixLocation, !1, y);
      let E = Xy(s / e, r / n, 0);
      E = Lu(
        E,
        a / e,
        o / n,
        1
      ), f.uniformMatrix4fv(this.textureMatrixLocation, !1, E), f.uniform1i(this.textureLocation, 0), f.drawArrays(f.TRIANGLES, 0, this.positions.length / 2);
    }
  }
  function Du(i, t, e) {
    const n = i.createShader(t);
    if (n === null)
      throw new Error("Shader compilation failed");
    if (i.shaderSource(n, e), i.compileShader(n), !i.getShaderParameter(n, i.COMPILE_STATUS)) {
      const s = i.getShaderInfoLog(n);
      throw s === null ? new Error("Shader info log creation failed") : new Error(s);
    }
    return n;
  }
  function Zl(i, t, e) {
    const n = i.createProgram(), s = Du(i, i.VERTEX_SHADER, e), r = Du(i, i.FRAGMENT_SHADER, t);
    if (n === null)
      throw new Error("Program creation failed");
    if (i.attachShader(n, s), i.attachShader(n, r), i.linkProgram(n), !i.getProgramParameter(n, i.LINK_STATUS))
      throw i.getProgramInfoLog(n) === null ? new Error("Program info log creation failed") : new Error();
    return n;
  }
  const t1 = `
  attribute vec4 a_position;

  uniform mat4 u_matrix;

  void main() {
     gl_Position = u_matrix * a_position;
  }
`, e1 = `
  precision mediump float;

  uniform vec4 u_val;
  void main() {
     gl_FragColor = u_val;
  }
`, i1 = `
  attribute vec4 a_position;
  attribute vec2 a_texcoord;

  varying vec2 v_texcoord;

  uniform mat4 u_matrix;

  void main() {
     gl_Position = u_matrix * a_position;
     v_texcoord = a_texcoord;
  }
`, n1 = `
  precision mediump float;

  varying vec2 v_texcoord;

  uniform sampler2D u_texture;

  void main() {
    if (v_texcoord.x < 0.0 || v_texcoord.x > 1.0 || v_texcoord.y < 0.0 || v_texcoord.y > 1.0) {
      discard;
    }
    gl_FragColor = texture2D(u_texture, v_texcoord);
  }
`;
  function s1(i, t, e, n) {
    let s;
    return e.length ? s = /** @type {HTMLCanvasElement} */
    e.shift() : To ? s = new OffscreenCanvas(i || 300, t || 300) : s = document.createElement("canvas"), i && (s.width = i), t && (s.height = t), /** @type {WebGLRenderingContext} */
    s.getContext("webgl", n);
  }
  function r1(i) {
    const t = i.canvas;
    t.width = 1, t.height = 1, i.clear(i.COLOR_BUFFER_BIT | i.DEPTH_BUFFER_BIT | i.STENCIL_BUFFER_BIT);
  }
  const ku = [];
  function a1(i, t, e, n, s, r, a, o, l, h, c, u, d, m) {
    const f = Math.round(n * t), y = Math.round(n * e);
    i.canvas.width = f, i.canvas.height = y;
    let E, x;
    if (x = i.createTexture(), i.bindTexture(i.TEXTURE_2D, x), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), d ? (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.LINEAR)) : (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.NEAREST)), i.texImage2D(
      i.TEXTURE_2D,
      0,
      i.RGBA,
      f,
      y,
      0,
      i.RGBA,
      c,
      null
    ), E = i.createFramebuffer(), i.bindFramebuffer(i.FRAMEBUFFER, E), i.framebufferTexture2D(
      i.FRAMEBUFFER,
      i.COLOR_ATTACHMENT0,
      i.TEXTURE_2D,
      x,
      0
    ), E === null)
      throw new Error("Could not create framebuffer");
    if (x === null)
      throw new Error("Could not create texture");
    if (l.length === 0)
      return {
        width: f,
        height: y,
        framebuffer: E,
        texture: x
      };
    const M = Ae();
    l.forEach(function(F, z, D) {
      Gr(M, F.extent);
    });
    let C, R, S;
    const A = 1 / s;
    {
      if (C = i.createTexture(), x === null)
        throw new Error("Could not create texture");
      R = Math.round(_t(M) * A), S = Math.round($t(M) * A);
      const F = i.getParameter(i.MAX_TEXTURE_SIZE), z = Math.max(R, S), D = z > F ? F / z : 1, j = Math.round(R * D), Y = Math.round(S * D);
      i.bindTexture(i.TEXTURE_2D, C), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), d ? (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.LINEAR)) : (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.NEAREST)), i.texImage2D(
        i.TEXTURE_2D,
        0,
        i.RGBA,
        j,
        Y,
        0,
        i.RGBA,
        c,
        null
      );
      const q = i.createFramebuffer();
      i.bindFramebuffer(i.FRAMEBUFFER, q), i.framebufferTexture2D(
        i.FRAMEBUFFER,
        i.COLOR_ATTACHMENT0,
        i.TEXTURE_2D,
        C,
        0
      );
      const J = new Qy(i);
      l.forEach(function(X, et, lt) {
        const Q = (X.extent[0] - M[0]) * A * D, W = -(X.extent[3] - M[3]) * A * D, gt = _t(X.extent) * A * D, it = $t(X.extent) * A * D;
        if (i.bindFramebuffer(i.FRAMEBUFFER, q), i.viewport(0, 0, j, Y), X.clipExtent) {
          const T = (X.clipExtent[0] - M[0]) * A * D, ot = -(X.clipExtent[3] - M[3]) * A * D, Ct = _t(X.clipExtent) * A * D, Lt = $t(X.clipExtent) * A * D;
          i.enable(i.SCISSOR_TEST), i.scissor(
            d ? T : Math.round(T),
            d ? ot : Math.round(ot),
            d ? Ct : Math.round(T + Ct) - Math.round(T),
            d ? Lt : Math.round(ot + Lt) - Math.round(ot)
          );
        }
        J.drawImage(
          X.texture,
          X.width,
          X.height,
          h,
          h,
          X.width - 2 * h,
          X.height - 2 * h,
          d ? Q : Math.round(Q),
          d ? W : Math.round(W),
          d ? gt : Math.round(Q + gt) - Math.round(Q),
          d ? it : Math.round(W + it) - Math.round(W),
          j,
          Y
        ), i.disable(i.SCISSOR_TEST);
      }), i.deleteFramebuffer(q);
    }
    const O = fi(a), P = fi(M), L = (F) => {
      const z = (F[0][0] - O[0]) / r * n, D = -(F[0][1] - O[1]) / r * n, j = (F[1][0] - O[0]) / r * n, Y = -(F[1][1] - O[1]) / r * n, q = (F[2][0] - O[0]) / r * n, J = -(F[2][1] - O[1]) / r * n;
      return { u1: j, v1: Y, u0: z, v0: D, u2: q, v2: J };
    };
    i.bindFramebuffer(i.FRAMEBUFFER, E), i.viewport(0, 0, f, y);
    {
      const F = [], z = [], D = Zl(
        i,
        n1,
        i1
      );
      i.useProgram(D);
      const j = i.getUniformLocation(D, "u_texture");
      i.bindTexture(i.TEXTURE_2D, C), i.uniform1i(j, 0), o.getTriangles().forEach(function(Q, W, gt) {
        const it = Q.source, T = Q.target, { u1: ot, v1: Ct, u0: Lt, v0: Zt, u2: be, v2: Jt } = L(T), Le = (it[0][0] - P[0]) / s / R, _i = -(it[0][1] - P[1]) / s / S, Ze = (it[1][0] - P[0]) / s / R, _n = -(it[1][1] - P[1]) / s / S, pi = (it[2][0] - P[0]) / s / R, qe = -(it[2][1] - P[1]) / s / S;
        F.push(ot, Ct, Lt, Zt, be, Jt), z.push(Ze, _n, Le, _i, pi, qe);
      });
      const Y = Wl(0, f, y, 0, -1, 1), q = i.getUniformLocation(D, "u_matrix");
      i.uniformMatrix4fv(q, !1, Y);
      const J = i.getAttribLocation(D, "a_position"), X = i.createBuffer();
      i.bindBuffer(i.ARRAY_BUFFER, X), i.bufferData(i.ARRAY_BUFFER, new Float32Array(F), i.STATIC_DRAW), i.vertexAttribPointer(J, 2, i.FLOAT, !1, 0, 0), i.enableVertexAttribArray(J);
      const et = i.getAttribLocation(D, "a_texcoord"), lt = i.createBuffer();
      i.bindBuffer(i.ARRAY_BUFFER, lt), i.bufferData(i.ARRAY_BUFFER, new Float32Array(z), i.STATIC_DRAW), i.vertexAttribPointer(et, 2, i.FLOAT, !1, 0, 0), i.enableVertexAttribArray(et), i.drawArrays(i.TRIANGLES, 0, F.length / 2);
    }
    if (u) {
      const F = Zl(
        i,
        e1,
        t1
      );
      i.useProgram(F);
      const z = Wl(0, f, y, 0, -1, 1), D = i.getUniformLocation(F, "u_matrix");
      i.uniformMatrix4fv(D, !1, z);
      const j = Array.isArray(u) ? u : [0, 0, 0, 255], Y = i.getUniformLocation(F, "u_val");
      i.uniform4fv(Y, j);
      const q = i.getAttribLocation(F, "a_position"), J = i.createBuffer();
      i.bindBuffer(i.ARRAY_BUFFER, J), i.vertexAttribPointer(q, 2, i.FLOAT, !1, 0, 0), i.enableVertexAttribArray(q);
      const X = o.getTriangles().reduce(function(et, lt) {
        const Q = lt.target, { u1: W, v1: gt, u0: it, v0: T, u2: ot, v2: Ct } = L(Q);
        return et.concat([W, gt, it, T, it, T, ot, Ct, ot, Ct, W, gt]);
      }, []);
      i.bufferData(i.ARRAY_BUFFER, new Float32Array(X), i.STATIC_DRAW), i.drawArrays(i.LINES, 0, X.length / 2);
    }
    return {
      width: f,
      height: y,
      framebuffer: E,
      texture: x
    };
  }
  class o1 extends Yl {
    /**
     * @param {Options} options Tile options.
     */
    constructor(t) {
      super({
        tileCoord: t.tileCoord,
        loader: () => Promise.resolve(new Uint8ClampedArray(4)),
        interpolate: t.interpolate,
        transition: t.transition
      }), this.renderEdges_ = t.renderEdges !== void 0 ? t.renderEdges : !1, this.pixelRatio_ = t.pixelRatio, this.gutter_ = t.gutter, this.reprojData_ = null, this.reprojError_ = null, this.reprojSize_ = void 0, this.sourceTileGrid_ = t.sourceTileGrid, this.targetTileGrid_ = t.targetTileGrid, this.wrappedTileCoord_ = t.wrappedTileCoord || t.tileCoord, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0;
      const e = t.sourceProj, n = e.getExtent(), s = t.sourceTileGrid.getExtent();
      this.clipExtent_ = e.canWrapX() ? s ? De(n, s) : n : s;
      const r = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      ), a = this.targetTileGrid_.getExtent();
      let o = this.sourceTileGrid_.getExtent();
      const l = a ? De(r, a) : r;
      if (Dn(l) === 0) {
        this.state = V.EMPTY;
        return;
      }
      n && (o ? o = De(o, n) : o = n);
      const h = this.targetTileGrid_.getResolution(
        this.wrappedTileCoord_[0]
      ), c = t.targetProj, u = bf(
        e,
        c,
        l,
        h
      );
      if (!isFinite(u) || u <= 0) {
        this.state = V.EMPTY;
        return;
      }
      const d = t.errorThreshold !== void 0 ? t.errorThreshold : Af;
      if (this.triangulation_ = new Pf(
        e,
        c,
        l,
        o,
        u * d,
        h,
        t.transformMatrix
      ), this.triangulation_.getTriangles().length === 0) {
        this.state = V.EMPTY;
        return;
      }
      this.sourceZ_ = this.sourceTileGrid_.getZForResolution(u);
      let m = this.triangulation_.calculateSourceExtent();
      if (o && (e.canWrapX() ? (m[1] = Gt(
        m[1],
        o[1],
        o[3]
      ), m[3] = Gt(
        m[3],
        o[1],
        o[3]
      )) : m = De(m, o)), !Dn(m))
        this.state = V.EMPTY;
      else {
        let f = 0, y = 0;
        e.canWrapX() && (f = _t(n), y = Math.floor(
          (m[0] - n[0]) / f
        )), yo(
          m.slice(),
          e,
          !0
        ).forEach((x) => {
          const M = this.sourceTileGrid_.getTileRangeForExtentAndZ(
            x,
            this.sourceZ_
          ), C = t.getTileFunction;
          for (let R = M.minX; R <= M.maxX; R++)
            for (let S = M.minY; S <= M.maxY; S++) {
              const A = C(this.sourceZ_, R, S, this.pixelRatio_);
              if (A) {
                const O = y * f;
                this.sourceTiles_.push({ tile: A, offset: O });
              }
            }
          ++y;
        }), this.sourceTiles_.length === 0 && (this.state = V.EMPTY);
      }
    }
    /**
     * Get the tile size.
     * @return {import('../size.js').Size} Tile size.
     * @override
     */
    getSize() {
      return this.reprojSize_;
    }
    /**
     * Get the data for the tile.
     * @return {import("../DataTile.js").Data} Tile data.
     * @override
     */
    getData() {
      return this.reprojData_;
    }
    /**
     * Get any loading error.
     * @return {Error} Loading error.
     * @override
     */
    getError() {
      return this.reprojError_;
    }
    /**
     * @private
     */
    reproject_() {
      const t = [];
      let e = !1;
      if (this.sourceTiles_.forEach((R) => {
        var W;
        const S = R.tile;
        if (!S || S.getState() !== V.LOADED)
          return;
        const A = S.getSize(), O = this.gutter_;
        let P;
        const L = Wy(S.getData());
        L ? P = L : (e = !0, P = Zy(Qa(S.getData())));
        const F = [A[0] + 2 * O, A[1] + 2 * O], z = P instanceof Float32Array, D = F[0] * F[1], j = z ? Float32Array : Uint8ClampedArray, Y = new j(P.buffer), q = j.BYTES_PER_ELEMENT, J = q * Y.length / D, X = Y.byteLength / F[1], et = Math.floor(
          X / q / F[0]
        ), lt = this.sourceTileGrid_.getTileCoordExtent(S.tileCoord);
        lt[0] += R.offset, lt[2] += R.offset;
        const Q = (W = this.clipExtent_) == null ? void 0 : W.slice();
        Q && (Q[0] += R.offset, Q[2] += R.offset), t.push({
          extent: lt,
          clipExtent: Q,
          data: Y,
          dataType: j,
          bytesPerPixel: J,
          pixelSize: F,
          bandCount: et
        });
      }), this.sourceTiles_.length = 0, t.length === 0) {
        this.state = V.ERROR, this.changed();
        return;
      }
      const n = this.wrappedTileCoord_[0], s = this.targetTileGrid_.getTileSize(n), r = typeof s == "number" ? s : s[0], a = typeof s == "number" ? s : s[1], o = r * this.pixelRatio_, l = a * this.pixelRatio_, h = this.targetTileGrid_.getResolution(n), c = this.sourceTileGrid_.getResolution(this.sourceZ_), u = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      ), d = t[0].bandCount, m = new t[0].dataType(d * o * l), f = s1(o, l, ku, {
        premultipliedAlpha: !1,
        antialias: !1
      });
      let y;
      const E = f.RGBA;
      let x;
      t[0].dataType == Float32Array ? (x = f.FLOAT, f.getExtension("WEBGL_color_buffer_float"), f.getExtension("OES_texture_float"), f.getExtension("EXT_float_blend"), y = f.getExtension("OES_texture_float_linear") !== null && this.interpolate) : (x = f.UNSIGNED_BYTE, y = this.interpolate);
      const M = 4, C = Math.ceil(d / M);
      for (let R = C - 1; R >= 0; --R) {
        const S = [];
        for (let j = 0, Y = t.length; j < Y; ++j) {
          const q = t[j], J = q.pixelSize, X = J[0], et = J[1], lt = new q.dataType(M * X * et), Q = q.data;
          let W = R * M;
          for (let it = 0, T = lt.length; it < T; it += M)
            lt[it] = Q[W], lt[it + 1] = Q[W + 1], lt[it + 2] = Q[W + 2], lt[it + 3] = Q[W + 3], W += d;
          const gt = f.createTexture();
          f.bindTexture(f.TEXTURE_2D, gt), y ? (f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, f.LINEAR), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, f.LINEAR)) : (f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, f.NEAREST), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, f.NEAREST)), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, f.CLAMP_TO_EDGE), f.texImage2D(
            f.TEXTURE_2D,
            0,
            E,
            X,
            et,
            0,
            E,
            x,
            lt
          ), S.push({
            extent: q.extent,
            clipExtent: q.clipExtent,
            texture: gt,
            width: X,
            height: et
          });
        }
        const { framebuffer: A, width: O, height: P } = a1(
          f,
          r,
          a,
          this.pixelRatio_,
          c,
          h,
          u,
          this.triangulation_,
          S,
          this.gutter_,
          x,
          this.renderEdges_,
          y
        ), L = O, F = P * M, z = new t[0].dataType(L * F);
        f.bindFramebuffer(f.FRAMEBUFFER, A), f.readPixels(0, 0, O, P, f.RGBA, x, z);
        let D = R * M;
        for (let j = 0, Y = z.length; j < Y; j += M) {
          const q = (L - 1 - (j / F | 0)) * F + j % F;
          m[D] = z[q], m[D + 1] = z[q + 1], m[D + 2] = z[q + 2], m[D + 3] = z[q + 3], D += d;
        }
      }
      if (r1(f), ku.push(f.canvas), e) {
        const R = Xt(r, a), S = new ImageData(m, r);
        R.putImageData(S, 0, 0), this.reprojData_ = R.canvas;
      } else
        this.reprojData_ = m;
      this.reprojSize_ = [Math.round(o), Math.round(l)], this.state = V.LOADED, this.changed();
    }
    /**
     * Load not yet loaded URI.
     * @override
     */
    load() {
      if (this.state !== V.IDLE && this.state !== V.ERROR)
        return;
      this.state = V.LOADING, this.changed();
      let t = 0;
      this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach(({ tile: e }) => {
        const n = e.getState();
        if (n !== V.IDLE && n !== V.LOADING)
          return;
        t++;
        const s = xt(e, ht.CHANGE, () => {
          const r = e.getState();
          (r == V.LOADED || r == V.ERROR || r == V.EMPTY) && (bt(s), t--, t === 0 && (this.unlistenSources_(), this.reproject_()));
        });
        this.sourcesListenerKeys_.push(s);
      }), t === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function({ tile: e }) {
        e.getState() == V.IDLE && e.load();
      });
    }
    /**
     * @private
     */
    unlistenSources_() {
      this.sourcesListenerKeys_.forEach(bt), this.sourcesListenerKeys_ = null;
    }
  }
  class ql extends Hh {
    /**
     * @param {import("../proj/Projection.js").default} sourceProj Source projection.
     * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
     * @param {import("../proj/Projection.js").default} targetProj Target projection.
     * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
     * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
     * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
     * @param {number} pixelRatio Pixel ratio.
     * @param {number} gutter Gutter of the source tiles.
     * @param {FunctionType} getTileFunction
     *     Function returning source tiles (z, x, y, pixelRatio).
     * @param {number} [errorThreshold] Acceptable reprojection error (in px).
     * @param {boolean} [renderEdges] Render reprojection edges.
     * @param {import("../Tile.js").Options} [options] Tile options.
     */
    constructor(t, e, n, s, r, a, o, l, h, c, u, d) {
      super(r, V.IDLE, d), this.renderEdges_ = u !== void 0 ? u : !1, this.pixelRatio_ = o, this.gutter_ = l, this.canvas_ = null, this.sourceTileGrid_ = e, this.targetTileGrid_ = s, this.wrappedTileCoord_ = a || r, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0, this.clipExtent_ = t.canWrapX() ? t.getExtent() : void 0;
      const m = s.getTileCoordExtent(
        this.wrappedTileCoord_
      ), f = this.targetTileGrid_.getExtent();
      let y = this.sourceTileGrid_.getExtent();
      const E = f ? De(m, f) : m;
      if (Dn(E) === 0) {
        this.state = V.EMPTY;
        return;
      }
      const x = t.getExtent();
      x && (y ? y = De(y, x) : y = x);
      const M = s.getResolution(
        this.wrappedTileCoord_[0]
      ), C = bf(
        t,
        n,
        E,
        M
      );
      if (!isFinite(C) || C <= 0) {
        this.state = V.EMPTY;
        return;
      }
      const R = c !== void 0 ? c : Af;
      if (this.triangulation_ = new Pf(
        t,
        n,
        E,
        y,
        C * R,
        M
      ), this.triangulation_.getTriangles().length === 0) {
        this.state = V.EMPTY;
        return;
      }
      this.sourceZ_ = e.getZForResolution(C);
      let S = this.triangulation_.calculateSourceExtent();
      if (y && (t.canWrapX() ? (S[1] = Gt(
        S[1],
        y[1],
        y[3]
      ), S[3] = Gt(
        S[3],
        y[1],
        y[3]
      )) : S = De(S, y)), !Dn(S))
        this.state = V.EMPTY;
      else {
        let A = 0, O = 0;
        t.canWrapX() && (A = _t(x), O = Math.floor(
          (S[0] - x[0]) / A
        )), yo(
          S.slice(),
          t,
          !0
        ).forEach((L) => {
          const F = e.getTileRangeForExtentAndZ(
            L,
            this.sourceZ_
          );
          for (let z = F.minX; z <= F.maxX; z++)
            for (let D = F.minY; D <= F.maxY; D++) {
              const j = h(this.sourceZ_, z, D, o);
              if (j) {
                const Y = O * A;
                this.sourceTiles_.push({ tile: j, offset: Y });
              }
            }
          ++O;
        }), this.sourceTiles_.length === 0 && (this.state = V.EMPTY);
      }
    }
    /**
     * Get the HTML Canvas element for this tile.
     * @return {HTMLCanvasElement} Canvas.
     */
    getImage() {
      return this.canvas_;
    }
    /**
     * @private
     */
    reproject_() {
      const t = [];
      if (this.sourceTiles_.forEach((e) => {
        var s;
        const n = e.tile;
        if (n && n.getState() == V.LOADED) {
          const r = this.sourceTileGrid_.getTileCoordExtent(n.tileCoord);
          r[0] += e.offset, r[2] += e.offset;
          const a = (s = this.clipExtent_) == null ? void 0 : s.slice();
          a && (a[0] += e.offset, a[2] += e.offset), t.push({
            extent: r,
            clipExtent: a,
            image: n.getImage()
          });
        }
      }), this.sourceTiles_.length = 0, t.length === 0)
        this.state = V.ERROR;
      else {
        const e = this.wrappedTileCoord_[0], n = this.targetTileGrid_.getTileSize(e), s = typeof n == "number" ? n : n[0], r = typeof n == "number" ? n : n[1], a = this.targetTileGrid_.getResolution(e), o = this.sourceTileGrid_.getResolution(
          this.sourceZ_
        ), l = this.targetTileGrid_.getTileCoordExtent(
          this.wrappedTileCoord_
        );
        this.canvas_ = Vy(
          s,
          r,
          this.pixelRatio_,
          o,
          this.sourceTileGrid_.getExtent(),
          a,
          l,
          this.triangulation_,
          t,
          this.gutter_,
          this.renderEdges_,
          this.interpolate
        ), this.state = V.LOADED;
      }
      this.changed();
    }
    /**
     * Load not yet loaded URI.
     * @override
     */
    load() {
      if (this.state == V.IDLE) {
        this.state = V.LOADING, this.changed();
        let t = 0;
        this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach(({ tile: e }) => {
          const n = e.getState();
          if (n == V.IDLE || n == V.LOADING) {
            t++;
            const s = xt(e, ht.CHANGE, (r) => {
              const a = e.getState();
              (a == V.LOADED || a == V.ERROR || a == V.EMPTY) && (bt(s), t--, t === 0 && (this.unlistenSources_(), this.reproject_()));
            });
            this.sourcesListenerKeys_.push(s);
          }
        }), t === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function({ tile: e }, n, s) {
          e.getState() == V.IDLE && e.load();
        });
      }
    }
    /**
     * @private
     */
    unlistenSources_() {
      this.sourcesListenerKeys_.forEach(bt), this.sourcesListenerKeys_ = null;
    }
    /**
     * Remove from the cache due to expiry
     * @override
     */
    release() {
      this.canvas_ && (Io(this.canvas_.getContext("2d")), Es.push(this.canvas_), this.canvas_ = null), super.release();
    }
  }
  class Lf extends Hh {
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("./TileState.js").default} state State.
     * @param {string} src Image source URI.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
     * @param {import("./Tile.js").Options} [options] Tile options.
     */
    constructor(t, e, n, s, r, a) {
      super(t, e, a), this.crossOrigin_ = s, this.src_ = n, this.key = n, this.image_ = new Image(), s !== null && (this.image_.crossOrigin = s), this.unlisten_ = null, this.tileLoadFunction_ = r;
    }
    /**
     * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
     * @api
     */
    getImage() {
      return this.image_;
    }
    /**
     * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
     * @param {HTMLCanvasElement|HTMLImageElement} element Element.
     */
    setImage(t) {
      this.image_ = t, this.state = V.LOADED, this.unlistenImage_(), this.changed();
    }
    /**
     * Tracks loading or read errors.
     *
     * @private
     */
    handleImageError_() {
      this.state = V.ERROR, this.unlistenImage_(), this.image_ = l1(), this.changed();
    }
    /**
     * Tracks successful image load.
     *
     * @private
     */
    handleImageLoad_() {
      const t = (
        /** @type {HTMLImageElement} */
        this.image_
      );
      t.naturalWidth && t.naturalHeight ? this.state = V.LOADED : this.state = V.EMPTY, this.unlistenImage_(), this.changed();
    }
    /**
     * Load the image or retry if loading previously failed.
     * Loading is taken care of by the tile queue, and calling this method is
     * only needed for preloading or for reloading in case of an error.
     *
     * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
     * that checks for error status codes and reloads only when the status code is
     * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
     * made already:
     *
     * ```js
     * const retryCodes = [408, 429, 500, 502, 503, 504];
     * const retries = {};
     * source.setTileLoadFunction((tile, src) => {
     *   const image = tile.getImage();
     *   fetch(src)
     *     .then((response) => {
     *       if (retryCodes.includes(response.status)) {
     *         retries[src] = (retries[src] || 0) + 1;
     *         if (retries[src] <= 3) {
     *           setTimeout(() => tile.load(), retries[src] * 1000);
     *         }
     *         return Promise.reject();
     *       }
     *       return response.blob();
     *     })
     *     .then((blob) => {
     *       const imageUrl = URL.createObjectURL(blob);
     *       image.src = imageUrl;
     *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
     *     })
     *     .catch(() => tile.setState(3)); // error
     * });
     * ```
     * @api
     * @override
     */
    load() {
      this.state == V.ERROR && (this.state = V.IDLE, this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_)), this.state == V.IDLE && (this.state = V.LOADING, this.changed(), this.tileLoadFunction_(this, this.src_), this.unlisten_ = E_(
        this.image_,
        this.handleImageLoad_.bind(this),
        this.handleImageError_.bind(this)
      ));
    }
    /**
     * Discards event handlers which listen for load completion or errors.
     *
     * @private
     */
    unlistenImage_() {
      this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
    }
    /**
     * @override
     */
    disposeInternal() {
      this.unlistenImage_(), this.image_ = null, super.disposeInternal();
    }
  }
  function l1() {
    const i = Xt(1, 1);
    return i.fillStyle = "rgba(0,0,0,0)", i.fillRect(0, 0, 1, 1), i.canvas;
  }
  class h1 {
    /**
     * @param {number} [highWaterMark] High water mark.
     */
    constructor(t) {
      this.highWaterMark = t !== void 0 ? t : 2048, this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
    }
    deleteOldest() {
      const t = this.pop();
      t instanceof ho && t.dispose();
    }
    /**
     * @return {boolean} Can expire cache.
     */
    canExpireCache() {
      return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
    }
    /**
     * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},
     * the entry will be disposed.
     * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
     */
    expireCache(t) {
      for (; this.canExpireCache(); )
        this.deleteOldest();
    }
    /**
     * FIXME empty description for jsdoc
     */
    clear() {
      for (; this.oldest_; )
        this.deleteOldest();
    }
    /**
     * @param {string} key Key.
     * @return {boolean} Contains key.
     */
    containsKey(t) {
      return this.entries_.hasOwnProperty(t);
    }
    /**
     * @param {function(T, string, LRUCache<T>): ?} f The function
     *     to call for every entry from the oldest to the newer. This function takes
     *     3 arguments (the entry value, the entry key and the LRUCache object).
     *     The return value is ignored.
     */
    forEach(t) {
      let e = this.oldest_;
      for (; e; )
        t(e.value_, e.key_, this), e = e.newer;
    }
    /**
     * @param {string} key Key.
     * @param {*} [options] Options (reserved for subclasses).
     * @return {T} Value.
     */
    get(t, e) {
      const n = this.entries_[t];
      return Mt(
        n !== void 0,
        "Tried to get a value for a key that does not exist in the cache"
      ), n === this.newest_ || (n === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
      this.oldest_.newer, this.oldest_.older = null) : (n.newer.older = n.older, n.older.newer = n.newer), n.newer = null, n.older = this.newest_, this.newest_.newer = n, this.newest_ = n), n.value_;
    }
    /**
     * Remove an entry from the cache.
     * @param {string} key The entry key.
     * @return {T} The removed entry.
     */
    remove(t) {
      const e = this.entries_[t];
      return Mt(
        e !== void 0,
        "Tried to get a value for a key that does not exist in the cache"
      ), e === this.newest_ ? (this.newest_ = /** @type {Entry} */
      e.older, this.newest_ && (this.newest_.newer = null)) : e === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
      e.newer, this.oldest_ && (this.oldest_.older = null)) : (e.newer.older = e.older, e.older.newer = e.newer), delete this.entries_[t], --this.count_, e.value_;
    }
    /**
     * @return {number} Count.
     */
    getCount() {
      return this.count_;
    }
    /**
     * @return {Array<string>} Keys.
     */
    getKeys() {
      const t = new Array(this.count_);
      let e = 0, n;
      for (n = this.newest_; n; n = n.older)
        t[e++] = n.key_;
      return t;
    }
    /**
     * @return {Array<T>} Values.
     */
    getValues() {
      const t = new Array(this.count_);
      let e = 0, n;
      for (n = this.newest_; n; n = n.older)
        t[e++] = n.value_;
      return t;
    }
    /**
     * @return {T} Last value.
     */
    peekLast() {
      return this.oldest_.value_;
    }
    /**
     * @return {string} Last key.
     */
    peekLastKey() {
      return this.oldest_.key_;
    }
    /**
     * Get the key of the newest item in the cache.  Throws if the cache is empty.
     * @return {string} The newest key.
     */
    peekFirstKey() {
      return this.newest_.key_;
    }
    /**
     * Return an entry without updating least recently used time.
     * @param {string} key Key.
     * @return {T|undefined} Value.
     */
    peek(t) {
      var e;
      return (e = this.entries_[t]) == null ? void 0 : e.value_;
    }
    /**
     * @return {T} value Value.
     */
    pop() {
      const t = this.oldest_;
      return delete this.entries_[t.key_], t.newer && (t.newer.older = null), this.oldest_ = /** @type {Entry} */
      t.newer, this.oldest_ || (this.newest_ = null), --this.count_, t.value_;
    }
    /**
     * @param {string} key Key.
     * @param {T} value Value.
     */
    replace(t, e) {
      this.get(t), this.entries_[t].value_ = e;
    }
    /**
     * @param {string} key Key.
     * @param {T} value Value.
     */
    set(t, e) {
      Mt(
        !(t in this.entries_),
        "Tried to set a value for a key that is used already"
      );
      const n = {
        key_: t,
        newer: null,
        older: this.newest_,
        value_: e
      };
      this.newest_ ? this.newest_.newer = n : this.oldest_ = n, this.newest_ = n, this.entries_[t] = n, ++this.count_;
    }
    /**
     * Set a maximum number of entries for the cache.
     * @param {number} size Cache size.
     * @api
     */
    setSize(t) {
      this.highWaterMark = t;
    }
  }
  class Jh {
    /**
     * @param {number} minX Minimum X.
     * @param {number} maxX Maximum X.
     * @param {number} minY Minimum Y.
     * @param {number} maxY Maximum Y.
     */
    constructor(t, e, n, s) {
      this.minX = t, this.maxX = e, this.minY = n, this.maxY = s;
    }
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @return {boolean} Contains tile coordinate.
     */
    contains(t) {
      return this.containsXY(t[1], t[2]);
    }
    /**
     * @param {TileRange} tileRange Tile range.
     * @return {boolean} Contains.
     */
    containsTileRange(t) {
      return this.minX <= t.minX && t.maxX <= this.maxX && this.minY <= t.minY && t.maxY <= this.maxY;
    }
    /**
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @return {boolean} Contains coordinate.
     */
    containsXY(t, e) {
      return this.minX <= t && t <= this.maxX && this.minY <= e && e <= this.maxY;
    }
    /**
     * @param {TileRange} tileRange Tile range.
     * @return {boolean} Equals.
     */
    equals(t) {
      return this.minX == t.minX && this.minY == t.minY && this.maxX == t.maxX && this.maxY == t.maxY;
    }
    /**
     * @param {TileRange} tileRange Tile range.
     */
    extend(t) {
      t.minX < this.minX && (this.minX = t.minX), t.maxX > this.maxX && (this.maxX = t.maxX), t.minY < this.minY && (this.minY = t.minY), t.maxY > this.maxY && (this.maxY = t.maxY);
    }
    /**
     * @return {number} Height.
     */
    getHeight() {
      return this.maxY - this.minY + 1;
    }
    /**
     * @return {import("./size.js").Size} Size.
     */
    getSize() {
      return [this.getWidth(), this.getHeight()];
    }
    /**
     * @return {number} Width.
     */
    getWidth() {
      return this.maxX - this.minX + 1;
    }
    /**
     * @param {TileRange} tileRange Tile range.
     * @return {boolean} Intersects.
     */
    intersects(t) {
      return this.minX <= t.maxX && this.maxX >= t.minX && this.minY <= t.maxY && this.maxY >= t.minY;
    }
  }
  function is(i, t, e, n, s) {
    return s !== void 0 ? (s.minX = i, s.maxX = t, s.minY = e, s.maxY = n, s) : new Jh(i, t, e, n);
  }
  function to(i, t, e, n) {
    return n !== void 0 ? (n[0] = i, n[1] = t, n[2] = e, n) : [i, t, e];
  }
  function c1(i, t, e) {
    return i + "/" + t + "/" + e;
  }
  function u1(i) {
    return d1(i[0], i[1], i[2]);
  }
  function d1(i, t, e) {
    return (t << i) + e;
  }
  function f1(i, t) {
    const e = i[0], n = i[1], s = i[2];
    if (t.getMinZoom() > e || e > t.getMaxZoom())
      return !1;
    const r = t.getFullTileRange(e);
    return r ? r.containsXY(n, s) : !0;
  }
  const Ma = {
    PRELOAD: "preload",
    USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
  };
  class g1 extends So {
    /**
     * @param {Options<TileSourceType>} [options] Tile layer options.
     */
    constructor(t) {
      t = t || {};
      const e = Object.assign({}, t), n = t.cacheSize;
      delete t.cacheSize, delete e.preload, delete e.useInterimTilesOnError, super(e), this.on, this.once, this.un, this.cacheSize_ = n, this.setPreload(t.preload !== void 0 ? t.preload : 0), this.setUseInterimTilesOnError(
        t.useInterimTilesOnError !== void 0 ? t.useInterimTilesOnError : !0
      );
    }
    /**
     * @return {number|undefined} The suggested cache size
     * @protected
     */
    getCacheSize() {
      return this.cacheSize_;
    }
    /**
     * Return the level as number to which we will preload tiles up to.
     * @return {number} The level to preload tiles up to.
     * @observable
     * @api
     */
    getPreload() {
      return (
        /** @type {number} */
        this.get(Ma.PRELOAD)
      );
    }
    /**
     * Set the level as number to which we will preload tiles up to.
     * @param {number} preload The level to preload tiles up to.
     * @observable
     * @api
     */
    setPreload(t) {
      this.set(Ma.PRELOAD, t);
    }
    /**
     * Deprecated.  Whether we use interim tiles on error.
     * @return {boolean} Use interim tiles on error.
     * @observable
     * @api
     */
    getUseInterimTilesOnError() {
      return (
        /** @type {boolean} */
        this.get(Ma.USE_INTERIM_TILES_ON_ERROR)
      );
    }
    /**
     * Deprecated.  Set whether we use interim tiles on error.
     * @param {boolean} useInterimTilesOnError Use interim tiles on error.
     * @observable
     * @api
     */
    setUseInterimTilesOnError(t) {
      this.set(Ma.USE_INTERIM_TILES_ON_ERROR, t);
    }
    /**
     * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
     * a four element RGBA array will be returned.  For data tiles, the array length will match the
     * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
     * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
     *
     * ```js
     * // display layer data on every pointer move
     * map.on('pointermove', (event) => {
     *   console.log(layer.getData(event.pixel));
     * });
     * ```
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     * @api
     * @override
     */
    getData(t) {
      return super.getData(t);
    }
  }
  function _l(i, t, e, n) {
    return `${i},${c1(t, e, n)}`;
  }
  function pl(i, t, e) {
    if (!(e in i))
      return i[e] = /* @__PURE__ */ new Set([t]), !0;
    const n = i[e], s = n.has(t);
    return s || n.add(t), !s;
  }
  function m1(i, t, e) {
    const n = i[e];
    return n ? n.delete(t) : !1;
  }
  function Gu(i, t) {
    const e = i.layerStatesArray[i.layerIndex];
    e.extent && (t = De(
      t,
      tn(e.extent, i.viewState.projection)
    ));
    const n = (
      /** @type {import("../../source/Tile.js").default} */
      e.layer.getRenderSource()
    );
    if (!n.getWrapX()) {
      const s = n.getTileGridForProjection(i.viewState.projection).getExtent();
      s && (t = De(t, s));
    }
    return t;
  }
  class _1 extends Mf {
    /**
     * @param {LayerType} tileLayer Tile layer.
     * @param {Options} [options] Options.
     */
    constructor(t, e) {
      super(t), e = e || {}, this.extentChanged = !0, this.renderComplete = !1, this.renderedExtent_ = null, this.renderedPixelRatio, this.renderedProjection = null, this.renderedRevision, this.renderedTiles = [], this.renderedSourceKey_, this.renderedSourceRevision_, this.tempExtent = Ae(), this.tempTileRange_ = new Jh(0, 0, 0, 0), this.tempTileCoord_ = to(0, 0, 0);
      const n = e.cacheSize !== void 0 ? e.cacheSize : 512;
      this.tileCache_ = new h1(n), this.maxStaleKeys = n * 0.5;
    }
    /**
     * @return {LRUCache} Tile cache.
     */
    getTileCache() {
      return this.tileCache_;
    }
    /**
     * Get a tile from the cache or create one if needed.
     *
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
     * @protected
     */
    getOrCreateTile(t, e, n, s) {
      const r = this.tileCache_, o = this.getLayer().getSource(), l = _l(o.getKey(), t, e, n);
      let h;
      if (r.containsKey(l))
        h = r.get(l);
      else {
        if (h = o.getTile(
          t,
          e,
          n,
          s.pixelRatio,
          s.viewState.projection
        ), !h)
          return null;
        r.set(l, h);
      }
      return h;
    }
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
     * @protected
     */
    getTile(t, e, n, s) {
      const r = this.getOrCreateTile(t, e, n, s);
      return r || null;
    }
    /**
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray} Data at the pixel location.
     * @override
     */
    getData(t) {
      const e = this.frameState;
      if (!e)
        return null;
      const n = this.getLayer(), s = Yt(
        e.pixelToCoordinateTransform,
        t.slice()
      ), r = n.getExtent();
      if (r && !Fn(r, s))
        return null;
      const a = e.viewState, o = n.getRenderSource(), l = o.getTileGridForProjection(a.projection), h = o.getTilePixelRatio(e.pixelRatio);
      for (let c = l.getZForResolution(a.resolution); c >= l.getMinZoom(); --c) {
        const u = l.getTileCoordForCoordAndZ(s, c), d = this.getTile(c, u[1], u[2], e);
        if (!d || d.getState() !== V.LOADED)
          continue;
        const m = l.getOrigin(c), f = Ie(l.getTileSize(c)), y = l.getResolution(c);
        let E;
        if (d instanceof Lf || d instanceof ql)
          E = d.getImage();
        else if (d instanceof Yl) {
          if (E = Qa(d.getData()), !E)
            continue;
        } else
          continue;
        const x = Math.floor(
          h * ((s[0] - m[0]) / y - u[1] * f[0])
        ), M = Math.floor(
          h * ((m[1] - s[1]) / y - u[2] * f[1])
        ), C = Math.round(
          h * o.getGutterForProjection(a.projection)
        );
        return this.getImageData(E, x + C, M + C);
      }
      return null;
    }
    /**
     * Determine whether render should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     * @override
     */
    prepareFrame(t) {
      this.renderedProjection ? t.viewState.projection !== this.renderedProjection && (this.tileCache_.clear(), this.renderedProjection = t.viewState.projection) : this.renderedProjection = t.viewState.projection;
      const e = this.getLayer().getSource();
      if (!e)
        return !1;
      const n = e.getRevision();
      return this.renderedRevision_ ? this.renderedRevision_ !== n && (this.renderedRevision_ = n, this.renderedSourceKey_ === e.getKey() && this.tileCache_.clear()) : this.renderedRevision_ = n, !0;
    }
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {import("../../extent.js").Extent} extent The extent to be rendered.
     * @param {number} initialZ The zoom level.
     * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
     * @param {number} preload Number of additional levels to load.
     */
    enqueueTiles(t, e, n, s, r) {
      const a = t.viewState, o = this.getLayer(), l = o.getRenderSource(), h = l.getTileGridForProjection(a.projection), c = St(l);
      c in t.wantedTiles || (t.wantedTiles[c] = {});
      const u = t.wantedTiles[c], d = o.getMapInternal(), m = Math.max(
        n - r,
        h.getMinZoom(),
        h.getZForResolution(
          Math.min(
            o.getMaxResolution(),
            d ? d.getView().getResolutionForZoom(Math.max(o.getMinZoom(), 0)) : h.getResolution(0)
          ),
          l.zDirection
        )
      );
      for (let f = n; f >= m; --f) {
        const y = h.getTileRangeForExtentAndZ(
          e,
          f,
          this.tempTileRange_
        ), E = h.getResolution(f);
        for (let x = y.minX; x <= y.maxX; ++x)
          for (let M = y.minY; M <= y.maxY; ++M) {
            const C = this.getTile(f, x, M, t);
            if (!C || !pl(s, C, f))
              continue;
            const S = C.getKey();
            if (u[S] = !0, C.getState() === V.IDLE && !t.tileQueue.isKeyQueued(S)) {
              const A = to(f, x, M, this.tempTileCoord_);
              t.tileQueue.enqueue([
                C,
                c,
                h.getTileCoordCenter(A),
                E
              ]);
            }
          }
      }
    }
    /**
     * Look for tiles covering the provided tile coordinate at an alternate
     * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
     * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
     * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
     * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
     * @private
     */
    findStaleTile_(t, e) {
      const n = this.tileCache_, s = t[0], r = t[1], a = t[2], o = this.getStaleKeys();
      for (let l = 0; l < o.length; ++l) {
        const h = _l(o[l], s, r, a);
        if (n.containsKey(h)) {
          const c = n.get(h);
          if (c.getState() === V.LOADED)
            return c.endTransition(St(this)), pl(e, c, s), !0;
        }
      }
      return !1;
    }
    /**
     * Look for tiles covering the provided tile coordinate at an alternate
     * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
     * @param {import("../../tilegrid/TileGrid.js").default} tileGrid The tile grid.
     * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
     * @param {number} altZ The alternate zoom level.
     * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
     * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
     * @private
     */
    findAltTiles_(t, e, n, s) {
      const r = t.getTileRangeForTileCoordAndZ(
        e,
        n,
        this.tempTileRange_
      );
      if (!r)
        return !1;
      let a = !0;
      const o = this.tileCache_, h = this.getLayer().getRenderSource().getKey();
      for (let c = r.minX; c <= r.maxX; ++c)
        for (let u = r.minY; u <= r.maxY; ++u) {
          const d = _l(h, n, c, u);
          let m = !1;
          if (o.containsKey(d)) {
            const f = o.get(d);
            f.getState() === V.LOADED && (pl(s, f, n), m = !0);
          }
          m || (a = !1);
        }
      return a;
    }
    /**
     * Render the layer.
     *
     * The frame rendering logic has three parts:
     *
     *  1. Enqueue tiles
     *  2. Find alt tiles for those that are not yet loaded
     *  3. Render loaded tiles
     *
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target that may be used to render content to.
     * @return {HTMLElement} The rendered element.
     * @override
     */
    renderFrame(t, e) {
      let n = !0;
      this.renderComplete = !0;
      const s = t.layerStatesArray[t.layerIndex], r = t.viewState, a = r.projection, o = r.resolution, l = r.center, h = t.pixelRatio, c = this.getLayer(), u = c.getSource(), d = u.getRevision(), m = u.getTileGridForProjection(a), f = m.getZForResolution(o, u.zDirection), y = m.getResolution(f), E = u.getKey();
      this.renderedSourceKey_ ? this.renderedSourceKey_ !== E && (this.prependStaleKey(this.renderedSourceKey_), this.renderedSourceKey_ = E) : this.renderedSourceKey_ = E;
      let x = t.extent;
      const M = u.getTilePixelRatio(h);
      this.prepareContainer(t, e);
      const C = this.context.canvas.width, R = this.context.canvas.height, S = s.extent && tn(s.extent);
      S && (x = De(
        x,
        tn(s.extent)
      ));
      const A = y * C / 2 / M, O = y * R / 2 / M, P = [
        l[0] - A,
        l[1] - O,
        l[0] + A,
        l[1] + O
      ], L = {};
      this.renderedTiles.length = 0;
      const F = c.getPreload();
      if (t.nextExtent) {
        const Q = m.getZForResolution(
          r.nextResolution,
          u.zDirection
        ), W = Gu(t, t.nextExtent);
        this.enqueueTiles(t, W, Q, L, F);
      }
      const z = Gu(t, x);
      if (this.enqueueTiles(t, z, f, L, 0), F > 0 && setTimeout(() => {
        this.enqueueTiles(
          t,
          z,
          f - 1,
          L,
          F - 1
        );
      }, 0), !(f in L))
        return this.container;
      const D = St(this), j = t.time;
      for (const Q of L[f]) {
        const W = Q.getState();
        if ((Q instanceof ql || Q instanceof o1) && W === V.EMPTY)
          continue;
        const gt = Q.tileCoord;
        if (W === V.LOADED && Q.getAlpha(D, j) === 1) {
          Q.endTransition(D);
          continue;
        }
        if (W !== V.IDLE && (n = !1), W !== V.ERROR && (this.renderComplete = !1), this.findStaleTile_(gt, L)) {
          m1(L, Q, f), t.animate = !0;
          continue;
        }
        if (this.findAltTiles_(
          m,
          gt,
          f + 1,
          L
        ))
          continue;
        const ot = m.getMinZoom();
        for (let Ct = f - 1; Ct >= ot && !this.findAltTiles_(
          m,
          gt,
          Ct,
          L
        ); --Ct)
          ;
      }
      const Y = y / o * h / M, q = this.getRenderContext(t);
      Li(
        this.tempTransform,
        C / 2,
        R / 2,
        Y,
        Y,
        0,
        -C / 2,
        -R / 2
      ), s.extent && this.clipUnrotated(q, t, S), u.getInterpolate() || (q.imageSmoothingEnabled = !1), this.preRender(q, t);
      const J = Object.keys(L).map(Number);
      J.sort(rn);
      let X;
      const et = [], lt = [];
      for (let Q = J.length - 1; Q >= 0; --Q) {
        const W = J[Q], gt = u.getTilePixelSize(
          W,
          h,
          a
        ), T = m.getResolution(W) / y, ot = gt[0] * T * Y, Ct = gt[1] * T * Y, Lt = m.getTileCoordForCoordAndZ(
          fi(P),
          W
        ), Zt = m.getTileCoordExtent(Lt), be = Yt(this.tempTransform, [
          M * (Zt[0] - P[0]) / y,
          M * (P[3] - Zt[3]) / y
        ]), Jt = M * u.getGutterForProjection(a);
        for (const Le of L[W]) {
          if (Le.getState() !== V.LOADED)
            continue;
          const _i = Le.tileCoord, Ze = Lt[1] - _i[1], _n = Math.round(be[0] - (Ze - 1) * ot), pi = Lt[2] - _i[2], qe = Math.round(be[1] - (pi - 1) * Ct), ye = Math.round(be[0] - Ze * ot), Ge = Math.round(be[1] - pi * Ct), Gi = _n - ye, Ke = qe - Ge, pn = J.length === 1;
          let yi = !1;
          X = [ye, Ge, ye + Gi, Ge, ye + Gi, Ge + Ke, ye, Ge + Ke];
          for (let Ui = 0, zi = et.length; Ui < zi; ++Ui)
            if (!pn && W < lt[Ui]) {
              const Bt = et[Ui];
              he(
                [ye, Ge, ye + Gi, Ge + Ke],
                [Bt[0], Bt[3], Bt[4], Bt[7]]
              ) && (yi || (q.save(), yi = !0), q.beginPath(), q.moveTo(X[0], X[1]), q.lineTo(X[2], X[3]), q.lineTo(X[4], X[5]), q.lineTo(X[6], X[7]), q.moveTo(Bt[6], Bt[7]), q.lineTo(Bt[4], Bt[5]), q.lineTo(Bt[2], Bt[3]), q.lineTo(Bt[0], Bt[1]), q.clip());
            }
          et.push(X), lt.push(W), this.drawTile(Le, t, ye, Ge, Gi, Ke, Jt, pn), yi && q.restore(), this.renderedTiles.unshift(Le), this.updateUsedTiles(t.usedTiles, u, Le);
        }
      }
      if (this.renderedRevision = d, this.renderedResolution = y, this.extentChanged = !this.renderedExtent_ || !Ps(this.renderedExtent_, P), this.renderedExtent_ = P, this.renderedPixelRatio = h, this.postRender(this.context, t), s.extent && q.restore(), q.imageSmoothingEnabled = !0, this.renderComplete) {
        const Q = (W, gt) => {
          const it = St(u), T = gt.wantedTiles[it], ot = T ? Object.keys(T).length : 0;
          this.updateCacheSize(ot), this.tileCache_.expireCache();
        };
        t.postRenderFunctions.push(Q);
      }
      return !this.renderComplete && !n && (t.animate = !0), this.container;
    }
    /**
     * Increases the cache size if needed
     * @param {number} tileCount Minimum number of tiles needed.
     */
    updateCacheSize(t) {
      this.tileCache_.highWaterMark = Math.max(
        this.tileCache_.highWaterMark,
        t * 2
      );
    }
    /**
     * @param {import("../../Tile.js").default} tile Tile.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {number} x Left of the tile.
     * @param {number} y Top of the tile.
     * @param {number} w Width of the tile.
     * @param {number} h Height of the tile.
     * @param {number} gutter Tile gutter.
     * @param {boolean} transition Apply an alpha transition.
     * @protected
     */
    drawTile(t, e, n, s, r, a, o, l) {
      let h;
      if (t instanceof Yl) {
        if (h = Qa(t.getData()), !h)
          throw new Error("Rendering array data is not yet supported");
      } else
        h = this.getTileImage(
          /** @type {import("../../ImageTile.js").default} */
          t
        );
      if (!h)
        return;
      const c = this.getRenderContext(e), u = St(this), d = e.layerStatesArray[e.layerIndex], m = d.opacity * (l ? t.getAlpha(u, e.time) : 1), f = m !== c.globalAlpha;
      f && (c.save(), c.globalAlpha = m), c.drawImage(
        h,
        o,
        o,
        h.width - 2 * o,
        h.height - 2 * o,
        n,
        s,
        r,
        a
      ), f && c.restore(), m !== d.opacity ? e.animate = !0 : l && t.endTransition(u);
    }
    /**
     * @return {HTMLCanvasElement} Image
     */
    getImage() {
      const t = this.context;
      return t ? t.canvas : null;
    }
    /**
     * Get the image from a tile.
     * @param {import("../../ImageTile.js").default} tile Tile.
     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
     * @protected
     */
    getTileImage(t) {
      return t.getImage();
    }
    /**
     * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
     * @param {import("../../source/Tile.js").default} tileSource Tile source.
     * @param {import('../../Tile.js').default} tile Tile.
     * @protected
     */
    updateUsedTiles(t, e, n) {
      const s = St(e);
      s in t || (t[s] = {}), t[s][n.getKey()] = !0;
    }
  }
  class p1 extends g1 {
    /**
     * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
     */
    constructor(t) {
      super(t);
    }
    /**
     * @override
     */
    createRenderer() {
      return new _1(this, {
        cacheSize: this.getCacheSize()
      });
    }
  }
  const yl = {
    /**
     * Triggered when a tile starts loading.
     * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
     * @api
     */
    TILELOADSTART: "tileloadstart",
    /**
     * Triggered when a tile finishes loading, either when its data is loaded,
     * or when loading was aborted because the tile is no longer needed.
     * @event module:ol/source/Tile.TileSourceEvent#tileloadend
     * @api
     */
    TILELOADEND: "tileloadend",
    /**
     * Triggered if tile loading results in an error. Note that this is not the
     * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
     * for details.
     * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
     * @api
     */
    TILELOADERROR: "tileloaderror"
  }, ns = [0, 0, 0], ji = 5;
  class Of {
    /**
     * @param {Options} options Tile grid options.
     */
    constructor(t) {
      this.minZoom = t.minZoom !== void 0 ? t.minZoom : 0, this.resolutions_ = t.resolutions, Mt(
        T0(
          this.resolutions_,
          /**
           * @param {number} a First resolution
           * @param {number} b Second resolution
           * @return {number} Comparison result
           */
          (s, r) => r - s
        ),
        "`resolutions` must be sorted in descending order"
      );
      let e;
      if (!t.origins) {
        for (let s = 0, r = this.resolutions_.length - 1; s < r; ++s)
          if (!e)
            e = this.resolutions_[s] / this.resolutions_[s + 1];
          else if (this.resolutions_[s] / this.resolutions_[s + 1] !== e) {
            e = void 0;
            break;
          }
      }
      this.zoomFactor_ = e, this.maxZoom = this.resolutions_.length - 1, this.origin_ = t.origin !== void 0 ? t.origin : null, this.origins_ = null, t.origins !== void 0 && (this.origins_ = t.origins, Mt(
        this.origins_.length == this.resolutions_.length,
        "Number of `origins` and `resolutions` must be equal"
      ));
      const n = t.extent;
      n !== void 0 && !this.origin_ && !this.origins_ && (this.origin_ = fi(n)), Mt(
        !this.origin_ && this.origins_ || this.origin_ && !this.origins_,
        "Either `origin` or `origins` must be configured, never both"
      ), this.tileSizes_ = null, t.tileSizes !== void 0 && (this.tileSizes_ = t.tileSizes, Mt(
        this.tileSizes_.length == this.resolutions_.length,
        "Number of `tileSizes` and `resolutions` must be equal"
      )), this.tileSize_ = t.tileSize !== void 0 ? t.tileSize : this.tileSizes_ ? null : lh, Mt(
        !this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_,
        "Either `tileSize` or `tileSizes` must be configured, never both"
      ), this.extent_ = n !== void 0 ? n : null, this.fullTileRanges_ = null, this.tmpSize_ = [0, 0], this.tmpExtent_ = [0, 0, 0, 0], t.sizes !== void 0 ? this.fullTileRanges_ = t.sizes.map((s, r) => {
        const a = new Jh(
          Math.min(0, s[0]),
          Math.max(s[0] - 1, -1),
          Math.min(0, s[1]),
          Math.max(s[1] - 1, -1)
        );
        if (n) {
          const o = this.getTileRangeForExtentAndZ(n, r);
          a.minX = Math.max(o.minX, a.minX), a.maxX = Math.min(o.maxX, a.maxX), a.minY = Math.max(o.minY, a.minY), a.maxY = Math.min(o.maxY, a.maxY);
        }
        return a;
      }) : n && this.calculateTileRanges_(n);
    }
    /**
     * Call a function with each tile coordinate for a given extent and zoom level.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} zoom Integer zoom level.
     * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
     * @api
     */
    forEachTileCoord(t, e, n) {
      const s = this.getTileRangeForExtentAndZ(t, e);
      for (let r = s.minX, a = s.maxX; r <= a; ++r)
        for (let o = s.minY, l = s.maxY; o <= l; ++o)
          n([e, r, o]);
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
     * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
     * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
     * @return {boolean} Callback succeeded.
     */
    forEachTileCoordParentTileRange(t, e, n, s) {
      let r, a, o, l = null, h = t[0] - 1;
      for (this.zoomFactor_ === 2 ? (a = t[1], o = t[2]) : l = this.getTileCoordExtent(t, s); h >= this.minZoom; ) {
        if (a !== void 0 && o !== void 0 ? (a = Math.floor(a / 2), o = Math.floor(o / 2), r = is(a, a, o, o, n)) : r = this.getTileRangeForExtentAndZ(
          l,
          h,
          n
        ), e(h, r))
          return !0;
        --h;
      }
      return !1;
    }
    /**
     * Get the extent for this tile grid, if it was configured.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getExtent() {
      return this.extent_;
    }
    /**
     * Get the maximum zoom level for the grid.
     * @return {number} Max zoom.
     * @api
     */
    getMaxZoom() {
      return this.maxZoom;
    }
    /**
     * Get the minimum zoom level for the grid.
     * @return {number} Min zoom.
     * @api
     */
    getMinZoom() {
      return this.minZoom;
    }
    /**
     * Get the origin for the grid at the given zoom level.
     * @param {number} z Integer zoom level.
     * @return {import("../coordinate.js").Coordinate} Origin.
     * @api
     */
    getOrigin(t) {
      return this.origin_ ? this.origin_ : this.origins_[t];
    }
    /**
     * Get the resolution for the given zoom level.
     * @param {number} z Integer zoom level.
     * @return {number} Resolution.
     * @api
     */
    getResolution(t) {
      return this.resolutions_[t];
    }
    /**
     * Get the list of resolutions for the tile grid.
     * @return {Array<number>} Resolutions.
     * @api
     */
    getResolutions() {
      return this.resolutions_;
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
     * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
     * @return {import("../TileRange.js").default|null} Tile range.
     */
    getTileCoordChildTileRange(t, e, n) {
      if (t[0] < this.maxZoom) {
        if (this.zoomFactor_ === 2) {
          const r = t[1] * 2, a = t[2] * 2;
          return is(
            r,
            r + 1,
            a,
            a + 1,
            e
          );
        }
        const s = this.getTileCoordExtent(
          t,
          n || this.tmpExtent_
        );
        return this.getTileRangeForExtentAndZ(
          s,
          t[0] + 1,
          e
        );
      }
      return null;
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {number} z Integer zoom level.
     * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
     * @return {import("../TileRange.js").default|null} Tile range.
     */
    getTileRangeForTileCoordAndZ(t, e, n) {
      if (e > this.maxZoom || e < this.minZoom)
        return null;
      const s = t[0], r = t[1], a = t[2];
      if (e === s)
        return is(
          r,
          a,
          r,
          a,
          n
        );
      if (this.zoomFactor_) {
        const l = Math.pow(this.zoomFactor_, e - s), h = Math.floor(r * l), c = Math.floor(a * l);
        if (e < s)
          return is(h, h, c, c, n);
        const u = Math.floor(l * (r + 1)) - 1, d = Math.floor(l * (a + 1)) - 1;
        return is(h, u, c, d, n);
      }
      const o = this.getTileCoordExtent(t, this.tmpExtent_);
      return this.getTileRangeForExtentAndZ(o, e, n);
    }
    /**
     * Get a tile range for the given extent and integer zoom level.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} z Integer zoom level.
     * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
     * @return {import("../TileRange.js").default} Tile range.
     */
    getTileRangeForExtentAndZ(t, e, n) {
      this.getTileCoordForXYAndZ_(t[0], t[3], e, !1, ns);
      const s = ns[1], r = ns[2];
      this.getTileCoordForXYAndZ_(t[2], t[1], e, !0, ns);
      const a = ns[1], o = ns[2];
      return is(s, a, r, o, n);
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @return {import("../coordinate.js").Coordinate} Tile center.
     */
    getTileCoordCenter(t) {
      const e = this.getOrigin(t[0]), n = this.getResolution(t[0]), s = Ie(this.getTileSize(t[0]), this.tmpSize_);
      return [
        e[0] + (t[1] + 0.5) * s[0] * n,
        e[1] - (t[2] + 0.5) * s[1] * n
      ];
    }
    /**
     * Get the extent of a tile coordinate.
     *
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getTileCoordExtent(t, e) {
      const n = this.getOrigin(t[0]), s = this.getResolution(t[0]), r = Ie(this.getTileSize(t[0]), this.tmpSize_), a = n[0] + t[1] * r[0] * s, o = n[1] - (t[2] + 1) * r[1] * s, l = a + r[0] * s, h = o + r[1] * s;
      return ke(a, o, l, h, e);
    }
    /**
     * Get the tile coordinate for the given map coordinate and resolution.  This
     * method considers that coordinates that intersect tile boundaries should be
     * assigned the higher tile coordinate.
     *
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @api
     */
    getTileCoordForCoordAndResolution(t, e, n) {
      return this.getTileCoordForXYAndResolution_(
        t[0],
        t[1],
        e,
        !1,
        n
      );
    }
    /**
     * Note that this method should not be called for resolutions that correspond
     * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
     * @param {number} x X.
     * @param {number} y Y.
     * @param {number} resolution Resolution (for a non-integer zoom level).
     * @param {boolean} reverseIntersectionPolicy Instead of letting edge
     *     intersections go to the higher tile coordinate, let edge intersections
     *     go to the lower tile coordinate.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @private
     */
    getTileCoordForXYAndResolution_(t, e, n, s, r) {
      const a = this.getZForResolution(n), o = n / this.getResolution(a), l = this.getOrigin(a), h = Ie(this.getTileSize(a), this.tmpSize_);
      let c = o * (t - l[0]) / n / h[0], u = o * (l[1] - e) / n / h[1];
      return s ? (c = ga(c, ji) - 1, u = ga(u, ji) - 1) : (c = fa(c, ji), u = fa(u, ji)), to(a, c, u, r);
    }
    /**
     * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
     * they should have separate implementations.  This method is for integer zoom
     * levels.  The other method should only be called for resolutions corresponding
     * to non-integer zoom levels.
     * @param {number} x Map x coordinate.
     * @param {number} y Map y coordinate.
     * @param {number} z Integer zoom level.
     * @param {boolean} reverseIntersectionPolicy Instead of letting edge
     *     intersections go to the higher tile coordinate, let edge intersections
     *     go to the lower tile coordinate.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @private
     */
    getTileCoordForXYAndZ_(t, e, n, s, r) {
      const a = this.getOrigin(n), o = this.getResolution(n), l = Ie(this.getTileSize(n), this.tmpSize_);
      let h = (t - a[0]) / o / l[0], c = (a[1] - e) / o / l[1];
      return s ? (h = ga(h, ji) - 1, c = ga(c, ji) - 1) : (h = fa(h, ji), c = fa(c, ji)), to(n, h, c, r);
    }
    /**
     * Get a tile coordinate given a map coordinate and zoom level.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @api
     */
    getTileCoordForCoordAndZ(t, e, n) {
      return this.getTileCoordForXYAndZ_(
        t[0],
        t[1],
        e,
        !1,
        n
      );
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @return {number} Tile resolution.
     */
    getTileCoordResolution(t) {
      return this.resolutions_[t[0]];
    }
    /**
     * Get the tile size for a zoom level. The type of the return value matches the
     * `tileSize` or `tileSizes` that the tile grid was configured with. To always
     * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
     * @param {number} z Z.
     * @return {number|import("../size.js").Size} Tile size.
     * @api
     */
    getTileSize(t) {
      return this.tileSize_ ? this.tileSize_ : this.tileSizes_[t];
    }
    /**
     * @param {number} z Zoom level.
     * @return {import("../TileRange.js").default|null} Extent tile range for the specified zoom level.
     */
    getFullTileRange(t) {
      return this.fullTileRanges_ ? this.fullTileRanges_[t] : this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, t) : null;
    }
    /**
     * @param {number} resolution Resolution.
     * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
     *     If 0, the nearest resolution will be used.
     *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
     *     nearest lower resolution (higher Z) will be used. Default is 0.
     *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
     *
     * For example to change tile Z at the midpoint of zoom levels
     * ```js
     * function(value, high, low) {
     *   return value - low * Math.sqrt(high / low);
     * }
     * ```
     * @return {number} Z.
     * @api
     */
    getZForResolution(t, e) {
      const n = ah(
        this.resolutions_,
        t,
        e || 0
      );
      return Gt(n, this.minZoom, this.maxZoom);
    }
    /**
     * The tile with the provided tile coordinate intersects the given viewport.
     * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
     * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
     * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
     */
    tileCoordIntersectsViewport(t, e) {
      return $d(
        e,
        0,
        e.length,
        2,
        this.getTileCoordExtent(t)
      );
    }
    /**
     * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
     * @private
     */
    calculateTileRanges_(t) {
      const e = this.resolutions_.length, n = new Array(e);
      for (let s = this.minZoom; s < e; ++s)
        n[s] = this.getTileRangeForExtentAndZ(t, s);
      this.fullTileRanges_ = n;
    }
  }
  class y1 extends Of {
    /**
     * @param {Options} options WMTS options.
     */
    constructor(t) {
      super({
        extent: t.extent,
        origin: t.origin,
        origins: t.origins,
        resolutions: t.resolutions,
        tileSize: t.tileSize,
        tileSizes: t.tileSizes,
        sizes: t.sizes
      }), this.matrixIds_ = t.matrixIds;
    }
    /**
     * @param {number} z Z.
     * @return {string} MatrixId..
     */
    getMatrixId(t) {
      return this.matrixIds_[t];
    }
    /**
     * Get the list of matrix identifiers.
     * @return {Array<string>} MatrixIds.
     * @api
     */
    getMatrixIds() {
      return this.matrixIds_;
    }
  }
  function Nf(i) {
    let t = i.getDefaultTileGrid();
    return t || (t = M1(i), i.setDefaultTileGrid(t)), t;
  }
  function v1(i, t, e) {
    const n = t[0], s = i.getTileCoordCenter(t), r = Ff(e);
    if (!Fn(r, s)) {
      const a = _t(r), o = Math.ceil(
        (r[0] - s[0]) / a
      );
      return s[0] += a * o, i.getTileCoordForCoordAndZ(s, n);
    }
    return t;
  }
  function E1(i, t, e, n) {
    n = n !== void 0 ? n : "top-left";
    const s = x1(i, t, e);
    return new Of({
      extent: i,
      origin: pd(i, n),
      resolutions: s,
      tileSize: e
    });
  }
  function x1(i, t, e, n) {
    t = t !== void 0 ? t : O0, e = Ie(e !== void 0 ? e : lh);
    const s = $t(i), r = _t(i);
    n = n > 0 ? n : Math.max(r / e[0], s / e[1]);
    const a = t + 1, o = new Array(a);
    for (let l = 0; l < a; ++l)
      o[l] = n / Math.pow(2, l);
    return o;
  }
  function M1(i, t, e, n) {
    const s = Ff(i);
    return E1(s, t, e, n);
  }
  function Ff(i) {
    i = Pt(i);
    let t = i.getExtent();
    if (!t) {
      const e = 180 * hh.degrees / i.getMetersPerUnit();
      t = ke(-e, -e, e, e);
    }
    return t;
  }
  class w1 extends If {
    /**
     * @param {Options} options SourceTile source options.
     */
    constructor(t) {
      super({
        attributions: t.attributions,
        attributionsCollapsible: t.attributionsCollapsible,
        projection: t.projection,
        state: t.state,
        wrapX: t.wrapX,
        interpolate: t.interpolate
      }), this.on, this.once, this.un, this.tilePixelRatio_ = t.tilePixelRatio !== void 0 ? t.tilePixelRatio : 1, this.tileGrid = t.tileGrid !== void 0 ? t.tileGrid : null;
      const e = [256, 256];
      this.tileGrid && Ie(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), e), this.tmpSize = [0, 0], this.key_ = t.key || St(this), this.tileOptions = {
        transition: t.transition,
        interpolate: t.interpolate
      }, this.zDirection = t.zDirection ? t.zDirection : 0;
    }
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {number} Gutter.
     */
    getGutterForProjection(t) {
      return 0;
    }
    /**
     * Return the key to be used for all tiles in the source.
     * @return {string} The key for all tiles.
     */
    getKey() {
      return this.key_;
    }
    /**
     * Set the value to be used as the key for all tiles in the source.
     * @param {string} key The key for tiles.
     * @protected
     */
    setKey(t) {
      this.key_ !== t && (this.key_ = t, this.changed());
    }
    /**
     * @param {import("../proj/Projection").default} [projection] Projection.
     * @return {Array<number>|null} Resolutions.
     * @override
     */
    getResolutions(t) {
      const e = t ? this.getTileGridForProjection(t) : this.tileGrid;
      return e ? e.getResolutions() : null;
    }
    /**
     * @abstract
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {TileType|null} Tile.
     */
    getTile(t, e, n, s, r) {
      return ft();
    }
    /**
     * Return the tile grid of the tile source.
     * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
     * @api
     */
    getTileGrid() {
      return this.tileGrid;
    }
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
     */
    getTileGridForProjection(t) {
      return this.tileGrid ? this.tileGrid : Nf(t);
    }
    /**
     * Get the tile pixel ratio for this source. Subclasses may override this
     * method, which is meant to return a supported pixel ratio that matches the
     * provided `pixelRatio` as close as possible.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Tile pixel ratio.
     */
    getTilePixelRatio(t) {
      return this.tilePixelRatio_;
    }
    /**
     * @param {number} z Z.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../size.js").Size} Tile size.
     */
    getTilePixelSize(t, e, n) {
      const s = this.getTileGridForProjection(n), r = this.getTilePixelRatio(e), a = Ie(s.getTileSize(t), this.tmpSize);
      return r == 1 ? a : R_(a, r, this.tmpSize);
    }
    /**
     * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
     * is outside the resolution and extent range of the tile grid, `null` will be
     * returned.
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../proj/Projection.js").default} [projection] Projection.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
     *     null if no tile URL should be created for the passed `tileCoord`.
     */
    getTileCoordForTileUrlFunction(t, e) {
      const n = e !== void 0 ? e : this.getProjection(), s = e !== void 0 ? this.getTileGridForProjection(n) : this.tileGrid || this.getTileGridForProjection(n);
      return this.getWrapX() && n.isGlobal() && (t = v1(s, t, n)), f1(t, s) ? t : null;
    }
    /**
     * Remove all cached reprojected tiles from the source. The next render cycle will create new tiles.
     * @api
     */
    clear() {
    }
    /**
     * @override
     */
    refresh() {
      this.clear(), super.refresh();
    }
  }
  class R1 extends Oi {
    /**
     * @param {string} type Type.
     * @param {import("../Tile.js").default} tile The tile.
     */
    constructor(t, e) {
      super(t), this.tile = e;
    }
  }
  function Uu(i, t) {
    const e = [];
    Object.keys(t).forEach(function(s) {
      t[s] !== null && t[s] !== void 0 && e.push(s + "=" + encodeURIComponent(t[s]));
    });
    const n = e.join("&");
    return i = i.replace(/[?&]$/, ""), i += i.includes("?") ? "&" : "?", i + n;
  }
  const S1 = /\{z\}/g, C1 = /\{x\}/g, T1 = /\{y\}/g, I1 = /\{-y\}/g;
  function A1(i, t, e, n, s) {
    return i.replace(S1, t.toString()).replace(C1, e.toString()).replace(T1, n.toString()).replace(I1, function() {
      if (s === void 0)
        throw new Error(
          "If the URL template has a {-y} placeholder, the grid extent must be known"
        );
      return (s - n).toString();
    });
  }
  function Df(i) {
    const t = [];
    let e = /\{([a-z])-([a-z])\}/.exec(i);
    if (e) {
      const n = e[1].charCodeAt(0), s = e[2].charCodeAt(0);
      let r;
      for (r = n; r <= s; ++r)
        t.push(i.replace(e[0], String.fromCharCode(r)));
      return t;
    }
    if (e = /\{(\d+)-(\d+)\}/.exec(i), e) {
      const n = parseInt(e[2], 10);
      for (let s = parseInt(e[1], 10); s <= n; s++)
        t.push(i.replace(e[0], s.toString()));
      return t;
    }
    return t.push(i), t;
  }
  function P1(i, t) {
    return (
      /**
       * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("./proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      function(e, n, s) {
        if (!e)
          return;
        let r;
        const a = e[0];
        if (t) {
          const o = t.getFullTileRange(a);
          o && (r = o.getHeight() - 1);
        }
        return A1(i, a, e[1], e[2], r);
      }
    );
  }
  function b1(i, t) {
    const e = i.length, n = new Array(e);
    for (let s = 0; s < e; ++s)
      n[s] = P1(i[s], t);
    return Kl(n);
  }
  function Kl(i) {
    return i.length === 1 ? i[0] : (
      /**
       * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("./proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      function(t, e, n) {
        if (!t)
          return;
        const s = u1(t), r = ps(s, i.length);
        return i[r](t, e, n);
      }
    );
  }
  class Qh extends w1 {
    /**
     * @param {Options} options Image tile options.
     */
    constructor(t) {
      super({
        attributions: t.attributions,
        cacheSize: t.cacheSize,
        projection: t.projection,
        state: t.state,
        tileGrid: t.tileGrid,
        tilePixelRatio: t.tilePixelRatio,
        wrapX: t.wrapX,
        transition: t.transition,
        interpolate: t.interpolate,
        key: t.key,
        attributionsCollapsible: t.attributionsCollapsible,
        zDirection: t.zDirection
      }), this.generateTileUrlFunction_ = this.tileUrlFunction === Qh.prototype.tileUrlFunction, this.tileLoadFunction = t.tileLoadFunction, t.tileUrlFunction && (this.tileUrlFunction = t.tileUrlFunction), this.urls = null, t.urls ? this.setUrls(t.urls) : t.url && this.setUrl(t.url), this.tileLoadingKeys_ = {};
    }
    /**
     * Deprecated.  Use an ImageTile source instead.
     * Return the tile load function of the source.
     * @return {import("../Tile.js").LoadFunction} TileLoadFunction
     * @api
     */
    getTileLoadFunction() {
      return this.tileLoadFunction;
    }
    /**
     * Deprecated.  Use an ImageTile source instead.
     * Return the tile URL function of the source.
     * @return {import("../Tile.js").UrlFunction} TileUrlFunction
     * @api
     */
    getTileUrlFunction() {
      return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
    }
    /**
     * Deprecated.  Use an ImageTile source instead.
     * Return the URLs used for this source.
     * When a tileUrlFunction is used instead of url or urls,
     * null will be returned.
     * @return {!Array<string>|null} URLs.
     * @api
     */
    getUrls() {
      return this.urls;
    }
    /**
     * Handle tile change events.
     * @param {import("../events/Event.js").default} event Event.
     * @protected
     */
    handleTileChange(t) {
      const e = (
        /** @type {import("../Tile.js").default} */
        t.target
      ), n = St(e), s = e.getState();
      let r;
      s == V.LOADING ? (this.tileLoadingKeys_[n] = !0, r = yl.TILELOADSTART) : n in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[n], r = s == V.ERROR ? yl.TILELOADERROR : s == V.LOADED ? yl.TILELOADEND : void 0), r != null && this.dispatchEvent(new R1(r, e));
    }
    /**
     * Deprecated.  Use an ImageTile source instead.
     * Set the tile load function of the source.
     * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
     * @api
     */
    setTileLoadFunction(t) {
      this.tileLoadFunction = t, this.changed();
    }
    /**
     * Deprecated.  Use an ImageTile source instead.
     * Set the tile URL function of the source.
     * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
     * @param {string} [key] Optional new tile key for the source.
     * @api
     */
    setTileUrlFunction(t, e) {
      this.tileUrlFunction = t, typeof e < "u" ? this.setKey(e) : this.changed();
    }
    /**
     * Set the URL to use for requests.
     * @param {string} url URL.
     * @api
     */
    setUrl(t) {
      const e = Df(t);
      this.urls = e, this.setUrls(e);
    }
    /**
     * Deprecated.  Use an ImageTile source instead.
     * Set the URLs to use for requests.
     * @param {Array<string>} urls URLs.
     * @api
     */
    setUrls(t) {
      this.urls = t;
      const e = t.join(`
`);
      this.generateTileUrlFunction_ ? this.setTileUrlFunction(b1(t, this.tileGrid), e) : this.setKey(e);
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    tileUrlFunction(t, e, n) {
    }
  }
  class L1 extends Qh {
    /**
     * @param {!Options} options Image tile options.
     */
    constructor(t) {
      super({
        attributions: t.attributions,
        cacheSize: t.cacheSize,
        projection: t.projection,
        state: t.state,
        tileGrid: t.tileGrid,
        tileLoadFunction: t.tileLoadFunction ? t.tileLoadFunction : O1,
        tilePixelRatio: t.tilePixelRatio,
        tileUrlFunction: t.tileUrlFunction,
        url: t.url,
        urls: t.urls,
        wrapX: t.wrapX,
        transition: t.transition,
        interpolate: t.interpolate !== void 0 ? t.interpolate : !0,
        key: t.key,
        attributionsCollapsible: t.attributionsCollapsible,
        zDirection: t.zDirection
      }), this.crossOrigin = t.crossOrigin !== void 0 ? t.crossOrigin : null, this.tileClass = t.tileClass !== void 0 ? t.tileClass : Lf, this.tileGridForProjection = {}, this.reprojectionErrorThreshold_ = t.reprojectionErrorThreshold, this.renderReprojectionEdges_ = !1;
    }
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {number} Gutter.
     * @override
     */
    getGutterForProjection(t) {
      return this.getProjection() && t && !dr(this.getProjection(), t) ? 0 : this.getGutter();
    }
    /**
     * @return {number} Gutter.
     */
    getGutter() {
      return 0;
    }
    /**
     * Return the key to be used for all tiles in the source.
     * @return {string} The key for all tiles.
     * @override
     */
    getKey() {
      let t = super.getKey();
      return this.getInterpolate() || (t += ":disable-interpolation"), t;
    }
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
     * @override
     */
    getTileGridForProjection(t) {
      const e = this.getProjection();
      if (this.tileGrid && (!e || dr(e, t)))
        return this.tileGrid;
      const n = St(t);
      return n in this.tileGridForProjection || (this.tileGridForProjection[n] = Nf(t)), this.tileGridForProjection[n];
    }
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {string} key The key set on the tile.
     * @return {!ImageTile} Tile.
     * @private
     */
    createTile_(t, e, n, s, r, a) {
      const o = [t, e, n], l = this.getTileCoordForTileUrlFunction(
        o,
        r
      ), h = l ? this.tileUrlFunction(l, s, r) : void 0, c = new this.tileClass(
        o,
        h !== void 0 ? V.IDLE : V.EMPTY,
        h !== void 0 ? h : "",
        this.crossOrigin,
        this.tileLoadFunction,
        this.tileOptions
      );
      return c.key = a, c.addEventListener(ht.CHANGE, this.handleTileChange.bind(this)), c;
    }
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!(ImageTile|ReprojTile)} Tile.
     * @override
     */
    getTile(t, e, n, s, r) {
      const a = this.getProjection();
      if (!a || !r || dr(a, r))
        return this.getTileInternal(
          t,
          e,
          n,
          s,
          a || r
        );
      const o = [t, e, n], l = this.getKey(), h = this.getTileGridForProjection(a), c = this.getTileGridForProjection(r), u = this.getTileCoordForTileUrlFunction(
        o,
        r
      ), d = new ql(
        a,
        h,
        r,
        c,
        o,
        u,
        this.getTilePixelRatio(s),
        this.getGutter(),
        (m, f, y, E) => this.getTileInternal(m, f, y, E, a),
        this.reprojectionErrorThreshold_,
        this.renderReprojectionEdges_,
        this.tileOptions
      );
      return d.key = l, d;
    }
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {!import("../proj/Projection.js").default} projection Projection.
     * @return {!ImageTile} Tile.
     * @protected
     */
    getTileInternal(t, e, n, s, r) {
      const a = this.getKey();
      return this.createTile_(t, e, n, s, r, a);
    }
    /**
     * Sets whether to render reprojection edges or not (usually for debugging).
     * @param {boolean} render Render the edges.
     * @api
     */
    setRenderReprojectionEdges(t) {
      this.renderReprojectionEdges_ != t && (this.renderReprojectionEdges_ = t, this.changed());
    }
    /**
     * Sets the tile grid to use when reprojecting the tiles to the given
     * projection instead of the default tile grid for the projection.
     *
     * This can be useful when the default tile grid cannot be created
     * (e.g. projection has no extent defined) or
     * for optimization reasons (custom tile size, resolutions, ...).
     *
     * @param {import("../proj.js").ProjectionLike} projection Projection.
     * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
     * @api
     */
    setTileGridForProjection(t, e) {
      const n = Pt(t);
      if (n) {
        const s = St(n);
        s in this.tileGridForProjection || (this.tileGridForProjection[s] = e);
      }
    }
  }
  function O1(i, t) {
    i.getImage().src = t;
  }
  function Vr(i) {
    if (i.__esModule) return i;
    var t = i.default;
    if (typeof t == "function") {
      var e = function n() {
        return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
      };
      e.prototype = t.prototype;
    } else e = {};
    return Object.defineProperty(e, "__esModule", { value: !0 }), Object.keys(i).forEach(function(n) {
      var s = Object.getOwnPropertyDescriptor(i, n);
      Object.defineProperty(e, n, s.get ? s : {
        enumerable: !0,
        get: function() {
          return i[n];
        }
      });
    }), e;
  }
  class N1 extends L1 {
    /**
     * @param {Options} options WMTS options.
     */
    constructor(t) {
      const e = t.requestEncoding !== void 0 ? t.requestEncoding : "KVP", n = t.tileGrid;
      let s = t.urls;
      s === void 0 && t.url !== void 0 && (s = Df(t.url)), super({
        attributions: t.attributions,
        attributionsCollapsible: t.attributionsCollapsible,
        cacheSize: t.cacheSize,
        crossOrigin: t.crossOrigin,
        interpolate: t.interpolate,
        projection: t.projection,
        reprojectionErrorThreshold: t.reprojectionErrorThreshold,
        tileClass: t.tileClass,
        tileGrid: n,
        tileLoadFunction: t.tileLoadFunction,
        tilePixelRatio: t.tilePixelRatio,
        urls: s,
        wrapX: t.wrapX !== void 0 ? t.wrapX : !1,
        transition: t.transition,
        zDirection: t.zDirection
      }), this.version_ = t.version !== void 0 ? t.version : "1.0.0", this.format_ = t.format !== void 0 ? t.format : "image/jpeg", this.dimensions_ = t.dimensions !== void 0 ? t.dimensions : {}, this.layer_ = t.layer, this.matrixSet_ = t.matrixSet, this.style_ = t.style, this.requestEncoding_ = e, this.setKey(this.getKeyForDimensions_()), s && s.length > 0 && (this.tileUrlFunction = Kl(
        s.map(this.createFromWMTSTemplate.bind(this))
      ));
    }
    /**
     * Set the URLs to use for requests.
     * URLs may contain OGC conform URL Template Variables: {TileMatrix}, {TileRow}, {TileCol}.
     * @param {Array<string>} urls URLs.
     * @override
     */
    setUrls(t) {
      this.urls = t;
      const e = t.join(`
`);
      this.setTileUrlFunction(
        Kl(
          t.map(this.createFromWMTSTemplate.bind(this))
        ),
        e
      );
    }
    /**
     * Get the dimensions, i.e. those passed to the constructor through the
     * "dimensions" option, and possibly updated using the updateDimensions
     * method.
     * @return {!Object} Dimensions.
     * @api
     */
    getDimensions() {
      return this.dimensions_;
    }
    /**
     * Return the image format of the WMTS source.
     * @return {string} Format.
     * @api
     */
    getFormat() {
      return this.format_;
    }
    /**
     * Return the layer of the WMTS source.
     * @return {string} Layer.
     * @api
     */
    getLayer() {
      return this.layer_;
    }
    /**
     * Return the matrix set of the WMTS source.
     * @return {string} MatrixSet.
     * @api
     */
    getMatrixSet() {
      return this.matrixSet_;
    }
    /**
     * Return the request encoding, either "KVP" or "REST".
     * @return {RequestEncoding} Request encoding.
     * @api
     */
    getRequestEncoding() {
      return this.requestEncoding_;
    }
    /**
     * Return the style of the WMTS source.
     * @return {string} Style.
     * @api
     */
    getStyle() {
      return this.style_;
    }
    /**
     * Return the version of the WMTS source.
     * @return {string} Version.
     * @api
     */
    getVersion() {
      return this.version_;
    }
    /**
     * @private
     * @return {string} The key for the current dimensions.
     */
    getKeyForDimensions_() {
      const t = this.urls ? this.urls.slice(0) : [];
      for (const e in this.dimensions_)
        t.push(e + "-" + this.dimensions_[e]);
      return t.join("/");
    }
    /**
     * Update the dimensions.
     * @param {Object} dimensions Dimensions.
     * @api
     */
    updateDimensions(t) {
      Object.assign(this.dimensions_, t), this.setKey(this.getKeyForDimensions_());
    }
    /**
     * @param {string} template Template.
     * @return {import("../Tile.js").UrlFunction} Tile URL function.
     */
    createFromWMTSTemplate(t) {
      const e = this.requestEncoding_, n = {
        layer: this.layer_,
        style: this.style_,
        tilematrixset: this.matrixSet_
      };
      e == "KVP" && Object.assign(n, {
        Service: "WMTS",
        Request: "GetTile",
        Version: this.version_,
        Format: this.format_
      }), t = e == "KVP" ? Uu(t, n) : t.replace(/\{(\w+?)\}/g, function(a, o) {
        return o.toLowerCase() in n ? n[o.toLowerCase()] : a;
      });
      const s = (
        /** @type {import("../tilegrid/WMTS.js").default} */
        this.tileGrid
      ), r = this.dimensions_;
      return (
        /**
         * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
         * @param {number} pixelRatio Pixel ratio.
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @return {string|undefined} Tile URL.
         */
        function(a, o, l) {
          if (!a)
            return;
          const h = {
            TileMatrix: s.getMatrixId(a[0]),
            TileCol: a[1],
            TileRow: a[2]
          };
          Object.assign(h, r);
          let c = t;
          return e == "KVP" ? c = Uu(c, h) : c = c.replace(/\{(\w+?)\}/g, function(u, d) {
            return encodeURIComponent(h[d]);
          }), c;
        }
      );
    }
  }
  class F1 {
    constructor() {
      this.dataProjection = void 0, this.defaultFeatureProjection = void 0, this.featureClass = /** @type {FeatureToFeatureClass<FeatureType>} */
      Oo, this.supportedMediaTypes = null;
    }
    /**
     * Adds the data projection to the read options.
     * @param {Document|Element|Object|string} source Source.
     * @param {ReadOptions} [options] Options.
     * @return {ReadOptions|undefined} Options.
     * @protected
     */
    getReadOptions(t, e) {
      if (e) {
        let n = e.dataProjection ? Pt(e.dataProjection) : this.readProjection(t);
        e.extent && n && n.getUnits() === "tile-pixels" && (n = Pt(n), n.setWorldExtent(e.extent)), e = {
          dataProjection: n,
          featureProjection: e.featureProjection
        };
      }
      return this.adaptOptions(e);
    }
    /**
     * Sets the `dataProjection` on the options, if no `dataProjection`
     * is set.
     * @param {WriteOptions|ReadOptions|undefined} options
     *     Options.
     * @protected
     * @return {WriteOptions|ReadOptions|undefined}
     *     Updated options.
     */
    adaptOptions(t) {
      return Object.assign(
        {
          dataProjection: this.dataProjection,
          featureProjection: this.defaultFeatureProjection,
          featureClass: this.featureClass
        },
        t
      );
    }
    /**
     * @abstract
     * @return {Type} The format type.
     */
    getType() {
      return ft();
    }
    /**
     * Read a single feature from a source.
     *
     * @abstract
     * @param {Document|Element|Object|string} source Source.
     * @param {ReadOptions} [options] Read options.
     * @return {FeatureType|Array<FeatureType>} Feature.
     */
    readFeature(t, e) {
      return ft();
    }
    /**
     * Read all features from a source.
     *
     * @abstract
     * @param {Document|Element|ArrayBuffer|Object|string} source Source.
     * @param {ReadOptions} [options] Read options.
     * @return {Array<FeatureType>} Features.
     */
    readFeatures(t, e) {
      return ft();
    }
    /**
     * Read a single geometry from a source.
     *
     * @abstract
     * @param {Document|Element|Object|string} source Source.
     * @param {ReadOptions} [options] Read options.
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    readGeometry(t, e) {
      return ft();
    }
    /**
     * Read the projection from a source.
     *
     * @abstract
     * @param {Document|Element|Object|string} source Source.
     * @return {import("../proj/Projection.js").default|undefined} Projection.
     */
    readProjection(t) {
      return ft();
    }
    /**
     * Encode a feature in this format.
     *
     * @abstract
     * @param {Feature} feature Feature.
     * @param {WriteOptions} [options] Write options.
     * @return {string|ArrayBuffer} Result.
     */
    writeFeature(t, e) {
      return ft();
    }
    /**
     * Encode an array of features in this format.
     *
     * @abstract
     * @param {Array<Feature>} features Features.
     * @param {WriteOptions} [options] Write options.
     * @return {string|ArrayBuffer} Result.
     */
    writeFeatures(t, e) {
      return ft();
    }
    /**
     * Write a single geometry in this format.
     *
     * @abstract
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {WriteOptions} [options] Write options.
     * @return {string|ArrayBuffer} Result.
     */
    writeGeometry(t, e) {
      return ft();
    }
  }
  function tc(i, t, e) {
    const n = e ? Pt(e.featureProjection) : null, s = e ? Pt(e.dataProjection) : null;
    let r = i;
    if (n && s && !dr(n, s)) {
      t && (r = /** @type {T} */
      i.clone());
      const a = t ? n : s, o = t ? s : n;
      a.getUnits() === "tile-pixels" ? r.transform(a, o) : r.applyTransform(Ls(a, o));
    }
    if (t && e && /** @type {WriteOptions} */
    e.decimals !== void 0) {
      const a = Math.pow(
        10,
        /** @type {WriteOptions} */
        e.decimals
      ), o = function(l) {
        for (let h = 0, c = l.length; h < c; ++h)
          l[h] = Math.round(l[h] * a) / a;
        return l;
      };
      r === i && (r = /** @type {T} */
      i.clone()), r.applyTransform(o);
    }
    return r;
  }
  function ec(i, t) {
    const e = t ? Pt(t.featureProjection) : null, n = t ? Pt(t.dataProjection) : null;
    return e && n && !dr(e, n) ? Em(i, n, e) : i;
  }
  const D1 = "http://www.w3.org/2001/XMLSchema-instance";
  function Ft(i, t) {
    return zf().createElementNS(i, t);
  }
  function eo(i, t) {
    return kf(i, t, []).join("");
  }
  function kf(i, t, e) {
    if (i.nodeType == Node.CDATA_SECTION_NODE || i.nodeType == Node.TEXT_NODE)
      e.push(i.nodeValue);
    else {
      let n;
      for (n = i.firstChild; n; n = n.nextSibling)
        kf(n, t, e);
    }
    return e;
  }
  function wa(i) {
    return "documentElement" in i;
  }
  function k1(i, t, e) {
    return i.getAttributeNS(t, e) || "";
  }
  function Ra(i) {
    return new DOMParser().parseFromString(i, "application/xml");
  }
  function Gf(i, t) {
    return (
      /**
       * @param {Node} node Node.
       * @param {Array<*>} objectStack Object stack.
       * @this {*}
       */
      function(e, n) {
        const s = i.call(this, e, n);
        if (s !== void 0) {
          const r = (
            /** @type {Array<*>} */
            n[n.length - 1]
          );
          pe(r, s);
        }
      }
    );
  }
  function ut(i, t) {
    return (
      /**
       * @param {Element} node Node.
       * @param {Array<*>} objectStack Object stack.
       * @this {*}
       */
      function(e, n) {
        const s = i.call(t ?? this, e, n);
        s !== void 0 && /** @type {Array<*>} */
        n[n.length - 1].push(s);
      }
    );
  }
  function st(i, t) {
    return (
      /**
       * @param {Node} node Node.
       * @param {Array<*>} objectStack Object stack.
       * @this {*}
       */
      function(e, n) {
        const s = i.call(t ?? this, e, n);
        s !== void 0 && (n[n.length - 1] = s);
      }
    );
  }
  function H(i, t) {
    return (
      /**
       * @param {Element} node Node.
       * @param {*} value Value to be written.
       * @param {Array<*>} objectStack Object stack.
       * @this {*}
       */
      function(e, n, s) {
        i.call(t ?? this, e, n, s), /** @type {NodeStackItem} */
        s[s.length - 1].node.appendChild(e);
      }
    );
  }
  function xs(i, t) {
    return (
      /**
       * @param {*} value Value.
       * @param {Array<*>} objectStack Object stack.
       * @param {string} [newNodeName] Node name.
       * @return {Node} Node.
       */
      function(e, n, s) {
        const a = /** @type {NodeStackItem} */ n[n.length - 1].node;
        let o = i;
        o === void 0 && (o = s);
        const l = t !== void 0 ? t : a.namespaceURI;
        return Ft(
          l,
          /** @type {string} */
          o
        );
      }
    );
  }
  const Uf = xs();
  function Ms(i, t, e, n) {
    let s;
    for (s = t.firstElementChild; s; s = s.nextElementSibling) {
      const r = i[s.namespaceURI];
      if (r !== void 0) {
        const a = r[s.localName];
        a !== void 0 && a.call(n, s, e);
      }
    }
  }
  function Dt(i, t, e, n, s) {
    return n.push(i), Ms(t, e, n, s), /** @type {T} */
    n.pop();
  }
  function G1(i, t, e, n, s, r) {
    const a = (s !== void 0 ? s : e).length;
    let o, l;
    for (let h = 0; h < a; ++h)
      o = e[h], o !== void 0 && (l = t.call(
        r,
        o,
        n,
        s !== void 0 ? s[h] : void 0
      ), l !== void 0 && i[l.namespaceURI][l.localName].call(
        r,
        l,
        o,
        n
      ));
  }
  function ge(i, t, e, n, s, r, a) {
    return s.push(i), G1(t, e, n, s, r, a), /** @type {O|undefined} */
    s.pop();
  }
  let vl;
  function U1() {
    return vl === void 0 && typeof XMLSerializer < "u" && (vl = new XMLSerializer()), vl;
  }
  let El;
  function zf() {
    return El === void 0 && typeof document < "u" && (El = document.implementation.createDocument("", "", null)), El;
  }
  class z1 extends F1 {
    constructor() {
      super(), this.xmlSerializer_ = U1();
    }
    /**
     * @return {import("./Feature.js").Type} Format.
     * @override
     */
    getType() {
      return "xml";
    }
    /**
     * Read a single feature.
     *
     * @param {Document|Element|Object|string} source Source.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @return {import("../Feature.js").default} Feature.
     * @api
     * @override
     */
    readFeature(t, e) {
      if (!t)
        return null;
      if (typeof t == "string") {
        const n = Ra(t);
        return this.readFeatureFromDocument(n, e);
      }
      return wa(t) ? this.readFeatureFromDocument(
        /** @type {Document} */
        t,
        e
      ) : this.readFeatureFromNode(
        /** @type {Element} */
        t,
        e
      );
    }
    /**
     * @param {Document} doc Document.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @return {import("../Feature.js").default} Feature.
     */
    readFeatureFromDocument(t, e) {
      const n = this.readFeaturesFromDocument(t, e);
      return n.length > 0 ? n[0] : null;
    }
    /**
     * @param {Element} node Node.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @return {import("../Feature.js").default} Feature.
     */
    readFeatureFromNode(t, e) {
      return null;
    }
    /**
     * Read all features from a feature collection.
     *
     * @param {Document|Element|Object|string} source Source.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @return {Array<import("../Feature.js").default>} Features.
     * @api
     * @override
     */
    readFeatures(t, e) {
      if (!t)
        return [];
      if (typeof t == "string") {
        const n = Ra(t);
        return this.readFeaturesFromDocument(n, e);
      }
      return wa(t) ? this.readFeaturesFromDocument(
        /** @type {Document} */
        t,
        e
      ) : this.readFeaturesFromNode(
        /** @type {Element} */
        t,
        e
      );
    }
    /**
     * @param {Document} doc Document.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @protected
     * @return {Array<import("../Feature.js").default>} Features.
     */
    readFeaturesFromDocument(t, e) {
      const n = [];
      for (let s = t.firstChild; s; s = s.nextSibling)
        s.nodeType == Node.ELEMENT_NODE && pe(
          n,
          this.readFeaturesFromNode(
            /** @type {Element} */
            s,
            e
          )
        );
      return n;
    }
    /**
     * @abstract
     * @param {Element} node Node.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @protected
     * @return {Array<import("../Feature.js").default>} Features.
     */
    readFeaturesFromNode(t, e) {
      return ft();
    }
    /**
     * Read a single geometry from a source.
     *
     * @param {Document|Element|Object|string} source Source.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @return {import("../geom/Geometry.js").default} Geometry.
     * @override
     */
    readGeometry(t, e) {
      if (!t)
        return null;
      if (typeof t == "string") {
        const n = Ra(t);
        return this.readGeometryFromDocument(n, e);
      }
      return wa(t) ? this.readGeometryFromDocument(
        /** @type {Document} */
        t,
        e
      ) : this.readGeometryFromNode(
        /** @type {Element} */
        t,
        e
      );
    }
    /**
     * @param {Document} doc Document.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @protected
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    readGeometryFromDocument(t, e) {
      return null;
    }
    /**
     * @param {Element} node Node.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @protected
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    readGeometryFromNode(t, e) {
      return null;
    }
    /**
     * Read the projection from the source.
     *
     * @param {Document|Element|Object|string} source Source.
     * @return {import("../proj/Projection.js").default} Projection.
     * @api
     * @override
     */
    readProjection(t) {
      if (!t)
        return null;
      if (typeof t == "string") {
        const e = Ra(t);
        return this.readProjectionFromDocument(e);
      }
      return wa(t) ? this.readProjectionFromDocument(
        /** @type {Document} */
        t
      ) : this.readProjectionFromNode(
        /** @type {Element} */
        t
      );
    }
    /**
     * @param {Document} doc Document.
     * @protected
     * @return {import("../proj/Projection.js").default} Projection.
     */
    readProjectionFromDocument(t) {
      return this.dataProjection;
    }
    /**
     * @param {Element} node Node.
     * @protected
     * @return {import("../proj/Projection.js").default} Projection.
     */
    readProjectionFromNode(t) {
      return this.dataProjection;
    }
    /**
     * Encode a feature as string.
     *
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {string} Encoded feature.
     * @override
     */
    writeFeature(t, e) {
      const n = this.writeFeatureNode(t, e);
      return this.xmlSerializer_.serializeToString(n);
    }
    /**
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("./Feature.js").WriteOptions} [options] Options.
     * @protected
     * @return {Node} Node.
     */
    writeFeatureNode(t, e) {
      return null;
    }
    /**
     * Encode an array of features as string.
     *
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {string} Result.
     * @api
     * @override
     */
    writeFeatures(t, e) {
      const n = this.writeFeaturesNode(t, e);
      return this.xmlSerializer_.serializeToString(n);
    }
    /**
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Options.
     * @return {Node} Node.
     */
    writeFeaturesNode(t, e) {
      return null;
    }
    /**
     * Encode a geometry as string.
     *
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {string} Encoded geometry.
     * @override
     */
    writeGeometry(t, e) {
      const n = this.writeGeometryNode(t, e);
      return this.xmlSerializer_.serializeToString(n);
    }
    /**
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [options] Options.
     * @return {Node} Node.
     */
    writeGeometryNode(t, e) {
      return null;
    }
  }
  const Do = "http://www.opengis.net/gml", B1 = /^\s*$/;
  class tt extends z1 {
    /**
     * @param {Options} [options] Optional configuration object.
     */
    constructor(t) {
      super(), t = t || {}, this.featureType = t.featureType, this.featureNS = t.featureNS, this.srsName = t.srsName, this.schemaLocation = "", this.FEATURE_COLLECTION_PARSERS = {}, this.FEATURE_COLLECTION_PARSERS[this.namespace] = {
        featureMember: ut(this.readFeaturesInternal),
        featureMembers: st(this.readFeaturesInternal)
      }, this.supportedMediaTypes = ["application/gml+xml"];
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<Feature> | undefined} Features.
     */
    readFeaturesInternal(t, e) {
      const n = t.localName;
      let s = null;
      if (n == "FeatureCollection")
        s = Dt(
          [],
          this.FEATURE_COLLECTION_PARSERS,
          t,
          e,
          this
        );
      else if (n == "featureMembers" || n == "featureMember" || n == "member") {
        const r = e[0];
        let a = r.featureType, o = r.featureNS;
        const l = "p", h = "p0";
        if (!a && t.childNodes) {
          a = [], o = {};
          for (let d = 0, m = t.childNodes.length; d < m; ++d) {
            const f = (
              /** @type {Element} */
              t.childNodes[d]
            );
            if (f.nodeType === 1) {
              const y = f.nodeName.split(":").pop();
              if (!a.includes(y)) {
                let E = "", x = 0;
                const M = f.namespaceURI;
                for (const C in o) {
                  if (o[C] === M) {
                    E = C;
                    break;
                  }
                  ++x;
                }
                E || (E = l + x, o[E] = M), a.push(E + ":" + y);
              }
            }
          }
          n != "featureMember" && (r.featureType = a, r.featureNS = o);
        }
        if (typeof o == "string") {
          const d = o;
          o = {}, o[h] = d;
        }
        const c = {}, u = Array.isArray(a) ? a : [a];
        for (const d in o) {
          const m = {};
          for (let f = 0, y = u.length; f < y; ++f)
            (u[f].includes(":") ? u[f].split(":")[0] : h) === d && (m[u[f].split(":").pop()] = n == "featureMembers" ? ut(this.readFeatureElement, this) : st(this.readFeatureElement, this));
          c[o[d]] = m;
        }
        n == "featureMember" || n == "member" ? s = Dt(void 0, c, t, e) : s = Dt([], c, t, e);
      }
      return s === null && (s = []), s;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {import("../geom/Geometry.js").default|import("../extent.js").Extent|undefined} Geometry.
     */
    readGeometryOrExtent(t, e) {
      const n = (
        /** @type {Object} */
        e[0]
      );
      return n.srsName = t.firstElementChild.getAttribute("srsName"), n.srsDimension = t.firstElementChild.getAttribute("srsDimension"), Dt(
        null,
        this.GEOMETRY_PARSERS,
        t,
        e,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {import("../extent.js").Extent|undefined} Geometry.
     */
    readExtentElement(t, e) {
      const n = (
        /** @type {Object} */
        e[0]
      ), s = (
        /** @type {import("../extent.js").Extent} */
        this.readGeometryOrExtent(t, e)
      );
      return s ? ec(s, n) : void 0;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {import("../geom/Geometry.js").default|undefined} Geometry.
     */
    readGeometryElement(t, e) {
      const n = (
        /** @type {Object} */
        e[0]
      ), s = (
        /** @type {import("../geom/Geometry.js").default} */
        this.readGeometryOrExtent(t, e)
      );
      return s ? tc(s, !1, n) : void 0;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @param {boolean} asFeature whether result should be wrapped as a feature.
     * @return {Feature|Object} Feature
     */
    readFeatureElementInternal(t, e, n) {
      let s;
      const r = {};
      for (let l = t.firstElementChild; l; l = l.nextElementSibling) {
        let h;
        const c = l.localName;
        l.childNodes.length === 0 || l.childNodes.length === 1 && (l.firstChild.nodeType === 3 || l.firstChild.nodeType === 4) ? (h = eo(l, !1), B1.test(h) && (h = void 0)) : (n && (h = c === "boundedBy" ? this.readExtentElement(l, e) : this.readGeometryElement(l, e)), h ? c !== "boundedBy" && (s = c) : h = this.readFeatureElementInternal(l, e, !1));
        const u = l.attributes.length;
        if (u > 0 && !(h instanceof xo)) {
          h = { _content_: h };
          for (let d = 0; d < u; d++) {
            const m = l.attributes[d].name;
            h[m] = l.attributes[d].value;
          }
        }
        r[c] ? (r[c] instanceof Array || (r[c] = [r[c]]), r[c].push(h)) : r[c] = h;
      }
      if (!n)
        return r;
      const a = new Oo(r);
      s && a.setGeometryName(s);
      const o = t.getAttribute("fid") || k1(t, this.namespace, "id");
      return o && a.setId(o), a;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Feature} Feature.
     */
    readFeatureElement(t, e) {
      return this.readFeatureElementInternal(t, e, !0);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Point|undefined} Point.
     */
    readPoint(t, e) {
      const n = this.readFlatCoordinatesFromNode(t, e);
      if (n)
        return new wr(n, "XYZ");
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {MultiPoint|undefined} MultiPoint.
     */
    readMultiPoint(t, e) {
      const n = Dt(
        [],
        this.MULTIPOINT_PARSERS,
        t,
        e,
        this
      );
      if (n)
        return new jr(n);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {MultiLineString|undefined} MultiLineString.
     */
    readMultiLineString(t, e) {
      const n = Dt(
        [],
        this.MULTILINESTRING_PARSERS,
        t,
        e,
        this
      );
      if (n)
        return new Ds(n);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {MultiPolygon|undefined} MultiPolygon.
     */
    readMultiPolygon(t, e) {
      const n = Dt(
        [],
        this.MULTIPOLYGON_PARSERS,
        t,
        e,
        this
      );
      if (n)
        return new ks(n);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    pointMemberParser(t, e) {
      Ms(this.POINTMEMBER_PARSERS, t, e, this);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    lineStringMemberParser(t, e) {
      Ms(this.LINESTRINGMEMBER_PARSERS, t, e, this);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    polygonMemberParser(t, e) {
      Ms(this.POLYGONMEMBER_PARSERS, t, e, this);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {LineString|undefined} LineString.
     */
    readLineString(t, e) {
      const n = this.readFlatCoordinatesFromNode(t, e);
      if (n)
        return new cn(n, "XYZ");
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} LinearRing flat coordinates.
     */
    readFlatLinearRing(t, e) {
      const n = Dt(
        null,
        this.GEOMETRY_FLAT_COORDINATES_PARSERS,
        t,
        e,
        this
      );
      if (n)
        return n;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {LinearRing|undefined} LinearRing.
     */
    readLinearRing(t, e) {
      const n = this.readFlatCoordinatesFromNode(t, e);
      if (n)
        return new kn(n, "XYZ");
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Polygon|undefined} Polygon.
     */
    readPolygon(t, e) {
      const n = Dt(
        [null],
        this.FLAT_LINEAR_RINGS_PARSERS,
        t,
        e,
        this
      );
      if (n && n[0]) {
        const s = n[0], r = [s.length];
        let a, o;
        for (a = 1, o = n.length; a < o; ++a)
          pe(s, n[a]), r.push(s.length);
        return new gi(s, "XYZ", r);
      }
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>} Flat coordinates.
     */
    readFlatCoordinatesFromNode(t, e) {
      return Dt(
        null,
        this.GEOMETRY_FLAT_COORDINATES_PARSERS,
        t,
        e,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @protected
     * @return {import("../geom/Geometry.js").default} Geometry.
     * @override
     */
    readGeometryFromNode(t, e) {
      const n = this.readGeometryElement(t, [
        this.getReadOptions(t, e || {})
      ]);
      return n || null;
    }
    /**
     * @param {Element} node Node.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @return {Array<import("../Feature.js").default>} Features.
     * @override
     */
    readFeaturesFromNode(t, e) {
      const n = {
        featureType: this.featureType,
        featureNS: this.featureNS
      };
      return Object.assign(n, this.getReadOptions(t, e)), this.readFeaturesInternal(t, [n]) || [];
    }
    /**
     * @param {Element} node Node.
     * @return {import("../proj/Projection.js").default} Projection.
     * @override
     */
    readProjectionFromNode(t) {
      return Pt(
        this.srsName ? this.srsName : t.firstElementChild.getAttribute("srsName")
      );
    }
  }
  tt.prototype.namespace = Do;
  tt.prototype.FLAT_LINEAR_RINGS_PARSERS = {
    "http://www.opengis.net/gml": {}
  };
  tt.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
    "http://www.opengis.net/gml": {}
  };
  tt.prototype.GEOMETRY_PARSERS = {
    "http://www.opengis.net/gml": {}
  };
  tt.prototype.MULTIPOINT_PARSERS = {
    "http://www.opengis.net/gml": {
      pointMember: ut(tt.prototype.pointMemberParser),
      pointMembers: ut(tt.prototype.pointMemberParser)
    }
  };
  tt.prototype.MULTILINESTRING_PARSERS = {
    "http://www.opengis.net/gml": {
      lineStringMember: ut(
        tt.prototype.lineStringMemberParser
      ),
      lineStringMembers: ut(
        tt.prototype.lineStringMemberParser
      )
    }
  };
  tt.prototype.MULTIPOLYGON_PARSERS = {
    "http://www.opengis.net/gml": {
      polygonMember: ut(tt.prototype.polygonMemberParser),
      polygonMembers: ut(tt.prototype.polygonMemberParser)
    }
  };
  tt.prototype.POINTMEMBER_PARSERS = {
    "http://www.opengis.net/gml": {
      Point: ut(tt.prototype.readFlatCoordinatesFromNode)
    }
  };
  tt.prototype.LINESTRINGMEMBER_PARSERS = {
    "http://www.opengis.net/gml": {
      LineString: ut(tt.prototype.readLineString)
    }
  };
  tt.prototype.POLYGONMEMBER_PARSERS = {
    "http://www.opengis.net/gml": {
      Polygon: ut(tt.prototype.readPolygon)
    }
  };
  tt.prototype.RING_PARSERS = {
    "http://www.opengis.net/gml": {
      LinearRing: st(tt.prototype.readFlatLinearRing)
    }
  };
  function Sa(i) {
    const t = /^\s*(\d+)\s*$/.exec(i);
    if (t)
      return parseInt(t[1], 10);
  }
  function Ye(i, t) {
    i.appendChild(zf().createTextNode(t));
  }
  const $1 = Do + " http://schemas.opengis.net/gml/2.1.2/feature.xsd", X1 = {
    MultiLineString: "lineStringMember",
    MultiCurve: "curveMember",
    MultiPolygon: "polygonMember",
    MultiSurface: "surfaceMember"
  };
  class vt extends tt {
    /**
     * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
     */
    constructor(t) {
      t = t || {}, super(t), this.FEATURE_COLLECTION_PARSERS[Do].featureMember = ut(
        this.readFeaturesInternal
      ), this.schemaLocation = t.schemaLocation ? t.schemaLocation : $1;
    }
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} Flat coordinates.
     */
    readFlatCoordinates(t, e) {
      const n = eo(t, !1).replace(/^\s*|\s*$/g, ""), r = /** @type {import("../xml.js").NodeStackItem} */ e[0].srsName;
      let a = "enu";
      if (r) {
        const h = Pt(r);
        h && (a = h.getAxisOrientation());
      }
      const o = n.trim().split(/\s+/), l = [];
      for (let h = 0, c = o.length; h < c; h++) {
        const u = o[h].split(/,+/), d = parseFloat(u[0]), m = parseFloat(u[1]), f = u.length === 3 ? parseFloat(u[2]) : 0;
        a.startsWith("en") ? l.push(d, m, f) : l.push(m, d, f);
      }
      return l;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {import("../extent.js").Extent|undefined} Envelope.
     */
    readBox(t, e) {
      const n = Dt(
        [null],
        this.BOX_PARSERS_,
        t,
        e,
        this
      );
      return ke(
        n[1][0],
        n[1][1],
        n[1][3],
        n[1][4]
      );
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    innerBoundaryIsParser(t, e) {
      const n = Dt(
        void 0,
        this.RING_PARSERS,
        t,
        e,
        this
      );
      n && /** @type {Array<Array<number>>} */
      e[e.length - 1].push(n);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    outerBoundaryIsParser(t, e) {
      const n = Dt(
        void 0,
        this.RING_PARSERS,
        t,
        e,
        this
      );
      if (n) {
        const s = (
          /** @type {Array<Array<number>>} */
          e[e.length - 1]
        );
        s[0] = n;
      }
    }
    /**
     * @const
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [nodeName] Node name.
     * @return {Element|undefined} Node.
     * @private
     */
    GEOMETRY_NODE_FACTORY_(t, e, n) {
      const s = e[e.length - 1], r = s.multiSurface, a = s.surface, o = s.multiCurve;
      return Array.isArray(t) ? n = "Envelope" : (n = /** @type {import("../geom/Geometry.js").default} */
      t.getType(), n === "MultiPolygon" && r === !0 ? n = "MultiSurface" : n === "Polygon" && a === !0 ? n = "Surface" : n === "MultiLineString" && o === !0 && (n = "MultiCurve")), Ft("http://www.opengis.net/gml", n);
    }
    /**
     * @param {Element} node Node.
     * @param {import("../Feature.js").default} feature Feature.
     * @param {Array<*>} objectStack Node stack.
     */
    writeFeatureElement(t, e, n) {
      const s = e.getId();
      s && t.setAttribute(
        "fid",
        /** @type {string} */
        s
      );
      const r = (
        /** @type {Object} */
        n[n.length - 1]
      ), a = r.featureNS, o = e.getGeometryName();
      r.serializers || (r.serializers = {}, r.serializers[a] = {});
      const l = [], h = [];
      if (e.hasProperties()) {
        const u = e.getProperties();
        for (const d in u) {
          const m = u[d];
          m != null && (l.push(d), h.push(m), d == o || typeof /** @type {?} */
          m.getSimplifiedGeometry == "function" ? d in r.serializers[a] || (r.serializers[a][d] = H(
            this.writeGeometryElement,
            this
          )) : d in r.serializers[a] || (r.serializers[a][d] = H(Ye)));
        }
      }
      const c = Object.assign({}, r);
      c.node = t, ge(
        /** @type {import("../xml.js").NodeStackItem} */
        c,
        r.serializers,
        xs(void 0, a),
        h,
        n,
        l
      );
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LineString.js").default} geometry LineString geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeCurveOrLineString(t, e, n) {
      const r = n[n.length - 1].srsName;
      if (t.nodeName !== "LineStringSegment" && r && t.setAttribute("srsName", r), t.nodeName === "LineString" || t.nodeName === "LineStringSegment") {
        const a = this.createCoordinatesNode_(t.namespaceURI);
        t.appendChild(a), this.writeCoordinates_(a, e, n);
      } else if (t.nodeName === "Curve") {
        const a = Ft(t.namespaceURI, "segments");
        t.appendChild(a), this.writeCurveSegments_(a, e, n);
      }
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LineString.js").default} line LineString geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeLineStringOrCurveMember(t, e, n) {
      const s = this.GEOMETRY_NODE_FACTORY_(e, n);
      s && (t.appendChild(s), this.writeCurveOrLineString(s, e, n));
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/MultiLineString.js").default} geometry MultiLineString geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeMultiCurveOrLineString(t, e, n) {
      const s = n[n.length - 1], r = s.hasZ, a = s.srsName, o = s.curve;
      a && t.setAttribute("srsName", a);
      const l = e.getLineStrings();
      ge(
        { node: t, hasZ: r, srsName: a, curve: o },
        this.LINESTRINGORCURVEMEMBER_SERIALIZERS,
        this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
        l,
        n,
        void 0,
        this
      );
    }
    /**
     * @param {Node} node Node.
     * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeGeometryElement(t, e, n) {
      const s = (
        /** @type {import("./Feature.js").WriteOptions} */
        n[n.length - 1]
      ), r = Object.assign({}, s);
      r.node = t;
      let a;
      Array.isArray(e) ? a = ec(
        /** @type {import("../extent.js").Extent} */
        e,
        s
      ) : a = tc(
        /** @type {import("../geom/Geometry.js").default} */
        e,
        !0,
        s
      ), ge(
        /** @type {import("../xml.js").NodeStackItem} */
        r,
        this.GEOMETRY_SERIALIZERS,
        this.GEOMETRY_NODE_FACTORY_,
        [a],
        n,
        void 0,
        this
      );
    }
    /**
     * @param {string} namespaceURI XML namespace.
     * @return {Element} coordinates node.
     * @private
     */
    createCoordinatesNode_(t) {
      const e = Ft(t, "coordinates");
      return e.setAttribute("decimal", "."), e.setAttribute("cs", ","), e.setAttribute("ts", " "), e;
    }
    /**
     * @param {Node} node Node.
     * @param {import("../geom/LineString.js").default|import("../geom/LinearRing.js").default} value Geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    writeCoordinates_(t, e, n) {
      const s = n[n.length - 1], r = s.hasZ, a = s.srsName, o = e.getCoordinates(), l = o.length, h = new Array(l);
      for (let c = 0; c < l; ++c) {
        const u = o[c];
        h[c] = this.getCoords_(u, a, r);
      }
      Ye(t, h.join(" "));
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LineString.js").default} line LineString geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    writeCurveSegments_(t, e, n) {
      const s = Ft(t.namespaceURI, "LineStringSegment");
      t.appendChild(s), this.writeCurveOrLineString(s, e, n);
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeSurfaceOrPolygon(t, e, n) {
      const s = n[n.length - 1], r = s.hasZ, a = s.srsName;
      if (t.nodeName !== "PolygonPatch" && a && t.setAttribute("srsName", a), t.nodeName === "Polygon" || t.nodeName === "PolygonPatch") {
        const o = e.getLinearRings();
        ge(
          { node: t, hasZ: r, srsName: a },
          this.RING_SERIALIZERS,
          this.RING_NODE_FACTORY_,
          o,
          n,
          void 0,
          this
        );
      } else if (t.nodeName === "Surface") {
        const o = Ft(t.namespaceURI, "patches");
        t.appendChild(o), this.writeSurfacePatches_(o, e, n);
      }
    }
    /**
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [nodeName] Node name.
     * @return {Node} Node.
     * @private
     */
    RING_NODE_FACTORY_(t, e, n) {
      const s = e[e.length - 1], r = s.node, a = s.exteriorWritten;
      return a === void 0 && (s.exteriorWritten = !0), Ft(
        r.namespaceURI,
        a !== void 0 ? "innerBoundaryIs" : "outerBoundaryIs"
      );
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    writeSurfacePatches_(t, e, n) {
      const s = Ft(t.namespaceURI, "PolygonPatch");
      t.appendChild(s), this.writeSurfaceOrPolygon(s, e, n);
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeRing(t, e, n) {
      const s = Ft(t.namespaceURI, "LinearRing");
      t.appendChild(s), this.writeLinearRing(s, e, n);
    }
    /**
     * @param {Array<number>} point Point geometry.
     * @param {string} [srsName] Optional srsName
     * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
     * @return {string} The coords string.
     * @private
     */
    getCoords_(t, e, n) {
      let r = (e ? Pt(e).getAxisOrientation() : "enu").startsWith("en") ? t[0] + "," + t[1] : t[1] + "," + t[0];
      if (n) {
        const a = t[2] || 0;
        r += "," + a;
      }
      return r;
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Point.js").default} geometry Point geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writePoint(t, e, n) {
      const s = n[n.length - 1], r = s.hasZ, a = s.srsName;
      a && t.setAttribute("srsName", a);
      const o = this.createCoordinatesNode_(t.namespaceURI);
      t.appendChild(o);
      const l = e.getCoordinates(), h = this.getCoords_(l, a, r);
      Ye(o, h);
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeMultiPoint(t, e, n) {
      const s = n[n.length - 1], r = s.hasZ, a = s.srsName;
      a && t.setAttribute("srsName", a);
      const o = e.getPoints();
      ge(
        { node: t, hasZ: r, srsName: a },
        this.POINTMEMBER_SERIALIZERS,
        xs("pointMember"),
        o,
        n,
        void 0,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Point.js").default} point Point geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writePointMember(t, e, n) {
      const s = Ft(t.namespaceURI, "Point");
      t.appendChild(s), this.writePoint(s, e, n);
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeLinearRing(t, e, n) {
      const r = n[n.length - 1].srsName;
      r && t.setAttribute("srsName", r);
      const a = this.createCoordinatesNode_(t.namespaceURI);
      t.appendChild(a), this.writeCoordinates_(a, e, n);
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeMultiSurfaceOrPolygon(t, e, n) {
      const s = n[n.length - 1], r = s.hasZ, a = s.srsName, o = s.surface;
      a && t.setAttribute("srsName", a);
      const l = e.getPolygons();
      ge(
        { node: t, hasZ: r, srsName: a, surface: o },
        this.SURFACEORPOLYGONMEMBER_SERIALIZERS,
        this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
        l,
        n,
        void 0,
        this
      );
    }
    /**
     * @param {Node} node Node.
     * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeSurfaceOrPolygonMember(t, e, n) {
      const s = this.GEOMETRY_NODE_FACTORY_(e, n);
      s && (t.appendChild(s), this.writeSurfaceOrPolygon(s, e, n));
    }
    /**
     * @param {Element} node Node.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {Array<*>} objectStack Node stack.
     */
    writeEnvelope(t, e, n) {
      const r = n[n.length - 1].srsName;
      r && t.setAttribute("srsName", r);
      const a = ["lowerCorner", "upperCorner"], o = [e[0] + " " + e[1], e[2] + " " + e[3]];
      ge(
        /** @type {import("../xml.js").NodeStackItem} */
        { node: t },
        this.ENVELOPE_SERIALIZERS,
        Uf,
        o,
        n,
        a,
        this
      );
    }
    /**
     * @const
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [nodeName] Node name.
     * @return {Node|undefined} Node.
     * @private
     */
    MULTIGEOMETRY_MEMBER_NODE_FACTORY_(t, e, n) {
      const s = e[e.length - 1].node;
      return Ft(
        "http://www.opengis.net/gml",
        X1[s.nodeName]
      );
    }
  }
  vt.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
    "http://www.opengis.net/gml": {
      coordinates: st(vt.prototype.readFlatCoordinates)
    }
  };
  vt.prototype.FLAT_LINEAR_RINGS_PARSERS = {
    "http://www.opengis.net/gml": {
      innerBoundaryIs: vt.prototype.innerBoundaryIsParser,
      outerBoundaryIs: vt.prototype.outerBoundaryIsParser
    }
  };
  vt.prototype.BOX_PARSERS_ = {
    "http://www.opengis.net/gml": {
      coordinates: ut(vt.prototype.readFlatCoordinates)
    }
  };
  vt.prototype.GEOMETRY_PARSERS = {
    "http://www.opengis.net/gml": {
      Point: st(tt.prototype.readPoint),
      MultiPoint: st(tt.prototype.readMultiPoint),
      LineString: st(tt.prototype.readLineString),
      MultiLineString: st(tt.prototype.readMultiLineString),
      LinearRing: st(tt.prototype.readLinearRing),
      Polygon: st(tt.prototype.readPolygon),
      MultiPolygon: st(tt.prototype.readMultiPolygon),
      Box: st(vt.prototype.readBox)
    }
  };
  vt.prototype.GEOMETRY_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      Curve: H(vt.prototype.writeCurveOrLineString),
      MultiCurve: H(vt.prototype.writeMultiCurveOrLineString),
      Point: H(vt.prototype.writePoint),
      MultiPoint: H(vt.prototype.writeMultiPoint),
      LineString: H(vt.prototype.writeCurveOrLineString),
      MultiLineString: H(
        vt.prototype.writeMultiCurveOrLineString
      ),
      LinearRing: H(vt.prototype.writeLinearRing),
      Polygon: H(vt.prototype.writeSurfaceOrPolygon),
      MultiPolygon: H(
        vt.prototype.writeMultiSurfaceOrPolygon
      ),
      Surface: H(vt.prototype.writeSurfaceOrPolygon),
      MultiSurface: H(
        vt.prototype.writeMultiSurfaceOrPolygon
      ),
      Envelope: H(vt.prototype.writeEnvelope)
    }
  };
  vt.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      lineStringMember: H(
        vt.prototype.writeLineStringOrCurveMember
      ),
      curveMember: H(
        vt.prototype.writeLineStringOrCurveMember
      )
    }
  };
  vt.prototype.RING_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      outerBoundaryIs: H(vt.prototype.writeRing),
      innerBoundaryIs: H(vt.prototype.writeRing)
    }
  };
  vt.prototype.POINTMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      pointMember: H(vt.prototype.writePointMember)
    }
  };
  vt.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      surfaceMember: H(
        vt.prototype.writeSurfaceOrPolygonMember
      ),
      polygonMember: H(
        vt.prototype.writeSurfaceOrPolygonMember
      )
    }
  };
  vt.prototype.ENVELOPE_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      lowerCorner: H(Ye),
      upperCorner: H(Ye)
    }
  };
  const W1 = Do + " http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd", Y1 = {
    MultiLineString: "lineStringMember",
    MultiCurve: "curveMember",
    MultiPolygon: "polygonMember",
    MultiSurface: "surfaceMember"
  };
  class G extends tt {
    /**
     * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
     */
    constructor(t) {
      t = t || {}, super(t), this.surface_ = t.surface !== void 0 ? t.surface : !1, this.curve_ = t.curve !== void 0 ? t.curve : !1, this.multiCurve_ = t.multiCurve !== void 0 ? t.multiCurve : !0, this.multiSurface_ = t.multiSurface !== void 0 ? t.multiSurface : !0, this.schemaLocation = t.schemaLocation ? t.schemaLocation : W1, this.hasZ = t.hasZ !== void 0 ? t.hasZ : !1;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {MultiLineString|undefined} MultiLineString.
     */
    readMultiCurve(t, e) {
      const n = Dt(
        [],
        this.MULTICURVE_PARSERS,
        t,
        e,
        this
      );
      if (n)
        return new Ds(n);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} Polygon.
     */
    readFlatCurveRing(t, e) {
      const n = Dt(
        [],
        this.MULTICURVE_PARSERS,
        t,
        e,
        this
      ), s = [];
      for (let r = 0, a = n.length; r < a; ++r)
        pe(s, n[r].getFlatCoordinates());
      return s;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {MultiPolygon|undefined} MultiPolygon.
     */
    readMultiSurface(t, e) {
      const n = Dt(
        [],
        this.MULTISURFACE_PARSERS,
        t,
        e,
        this
      );
      if (n)
        return new ks(n);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    curveMemberParser(t, e) {
      Ms(this.CURVEMEMBER_PARSERS, t, e, this);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    surfaceMemberParser(t, e) {
      Ms(this.SURFACEMEMBER_PARSERS, t, e, this);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<(Array<number>)>|undefined} flat coordinates.
     */
    readPatch(t, e) {
      return Dt(
        [null],
        this.PATCHES_PARSERS,
        t,
        e,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} flat coordinates.
     */
    readSegment(t, e) {
      return Dt([], this.SEGMENTS_PARSERS, t, e, this);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<(Array<number>)>|undefined} flat coordinates.
     */
    readPolygonPatch(t, e) {
      return Dt(
        [null],
        this.FLAT_LINEAR_RINGS_PARSERS,
        t,
        e,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} flat coordinates.
     */
    readLineStringSegment(t, e) {
      return Dt(
        [null],
        this.GEOMETRY_FLAT_COORDINATES_PARSERS,
        t,
        e,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    interiorParser(t, e) {
      const n = Dt(
        void 0,
        this.RING_PARSERS,
        t,
        e,
        this
      );
      n && /** @type {Array<Array<number>>} */
      e[e.length - 1].push(n);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    exteriorParser(t, e) {
      const n = Dt(
        void 0,
        this.RING_PARSERS,
        t,
        e,
        this
      );
      if (n) {
        const s = (
          /** @type {Array<Array<number>>} */
          e[e.length - 1]
        );
        s[0] = n;
      }
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Polygon|undefined} Polygon.
     */
    readSurface(t, e) {
      const n = Dt(
        [null],
        this.SURFACE_PARSERS,
        t,
        e,
        this
      );
      if (n && n[0]) {
        const s = n[0], r = [s.length];
        let a, o;
        for (a = 1, o = n.length; a < o; ++a)
          pe(s, n[a]), r.push(s.length);
        return new gi(s, "XYZ", r);
      }
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {LineString|undefined} LineString.
     */
    readCurve(t, e) {
      const n = Dt(
        [null],
        this.CURVE_PARSERS,
        t,
        e,
        this
      );
      if (n)
        return new cn(n, "XYZ");
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {import("../extent.js").Extent|undefined} Envelope.
     */
    readEnvelope(t, e) {
      const n = Dt(
        [null],
        this.ENVELOPE_PARSERS,
        t,
        e,
        this
      );
      return ke(
        n[1][0],
        n[1][1],
        n[2][0],
        n[2][1]
      );
    }
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} Flat coordinates.
     */
    readFlatPos(t, e) {
      let n = eo(t, !1);
      const s = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/, r = [];
      let a;
      for (; a = s.exec(n); )
        r.push(parseFloat(a[1])), n = n.substr(a[0].length);
      if (n !== "")
        return;
      const l = e[0].srsName;
      if ((l ? Pt(l).getAxisOrientation() : "enu") === "neu")
        for (let u = 0, d = r.length; u < d; u += 3) {
          const m = r[u], f = r[u + 1];
          r[u] = f, r[u + 1] = m;
        }
      const c = r.length;
      if (c == 2 && r.push(0), c !== 0)
        return r;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} Flat coordinates.
     */
    readFlatPosList(t, e) {
      const n = eo(t, !1).replace(/^\s*|\s*$/g, ""), s = e[0], r = s.srsName, a = s.srsDimension, o = r ? Pt(r).getAxisOrientation() : "enu", l = n.split(/\s+/);
      let h = 2;
      t.getAttribute("srsDimension") ? h = Sa(t.getAttribute("srsDimension")) : t.getAttribute("dimension") ? h = Sa(t.getAttribute("dimension")) : /** @type {Element} */ t.parentNode.getAttribute("srsDimension") ? h = Sa(
        /** @type {Element} */
        t.parentNode.getAttribute("srsDimension")
      ) : a && (h = Sa(a));
      const c = o.startsWith("en");
      let u, d, m;
      const f = [];
      for (let y = 0, E = l.length; y < E; y += h)
        u = parseFloat(l[y]), d = parseFloat(l[y + 1]), m = h === 3 ? parseFloat(l[y + 2]) : 0, c ? f.push(u, d, m) : f.push(d, u, m);
      return f;
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Point.js").default} value Point geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    writePos_(t, e, n) {
      const s = n[n.length - 1], r = s.hasZ, a = r ? "3" : "2";
      t.setAttribute("srsDimension", a);
      const o = s.srsName, l = o ? Pt(o).getAxisOrientation() : "enu", h = e.getCoordinates();
      let c = l.startsWith("en") ? h[0] + " " + h[1] : h[1] + " " + h[0];
      if (r) {
        const u = h[2] || 0;
        c += " " + u;
      }
      Ye(t, c);
    }
    /**
     * @param {Array<number>} point Point geometry.
     * @param {string} [srsName] Optional srsName
     * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
     * @return {string} The coords string.
     * @private
     */
    getCoords_(t, e, n) {
      let r = (e ? Pt(e).getAxisOrientation() : "enu").startsWith("en") ? t[0] + " " + t[1] : t[1] + " " + t[0];
      if (n) {
        const a = t[2] || 0;
        r += " " + a;
      }
      return r;
    }
    /**
     * @param {Element} node Node.
     * @param {LineString|import("../geom/LinearRing.js").default} value Geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    writePosList_(t, e, n) {
      const s = n[n.length - 1], r = s.hasZ, a = r ? "3" : "2";
      t.setAttribute("srsDimension", a);
      const o = s.srsName, l = e.getCoordinates(), h = l.length, c = new Array(h);
      let u;
      for (let d = 0; d < h; ++d)
        u = l[d], c[d] = this.getCoords_(u, o, r);
      Ye(t, c.join(" "));
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Point.js").default} geometry Point geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writePoint(t, e, n) {
      const r = n[n.length - 1].srsName;
      r && t.setAttribute("srsName", r);
      const a = Ft(t.namespaceURI, "pos");
      t.appendChild(a), this.writePos_(a, e, n);
    }
    /**
     * @param {Element} node Node.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {Array<*>} objectStack Node stack.
     */
    writeEnvelope(t, e, n) {
      const r = n[n.length - 1].srsName;
      r && t.setAttribute("srsName", r);
      const a = ["lowerCorner", "upperCorner"], o = [e[0] + " " + e[1], e[2] + " " + e[3]];
      ge(
        /** @type {import("../xml.js").NodeStackItem} */
        { node: t },
        this.ENVELOPE_SERIALIZERS,
        Uf,
        o,
        n,
        a,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeLinearRing(t, e, n) {
      const r = n[n.length - 1].srsName;
      r && t.setAttribute("srsName", r);
      const a = Ft(t.namespaceURI, "posList");
      t.appendChild(a), this.writePosList_(a, e, n);
    }
    /**
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [nodeName] Node name.
     * @return {Node} Node.
     * @private
     */
    RING_NODE_FACTORY_(t, e, n) {
      const s = e[e.length - 1], r = s.node, a = s.exteriorWritten;
      return a === void 0 && (s.exteriorWritten = !0), Ft(
        r.namespaceURI,
        a !== void 0 ? "interior" : "exterior"
      );
    }
    /**
     * @param {Element} node Node.
     * @param {Polygon} geometry Polygon geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeSurfaceOrPolygon(t, e, n) {
      const s = n[n.length - 1], r = s.hasZ, a = s.srsName;
      if (t.nodeName !== "PolygonPatch" && a && t.setAttribute("srsName", a), t.nodeName === "Polygon" || t.nodeName === "PolygonPatch") {
        const o = e.getLinearRings();
        ge(
          { node: t, hasZ: r, srsName: a },
          this.RING_SERIALIZERS,
          this.RING_NODE_FACTORY_,
          o,
          n,
          void 0,
          this
        );
      } else if (t.nodeName === "Surface") {
        const o = Ft(t.namespaceURI, "patches");
        t.appendChild(o), this.writeSurfacePatches_(o, e, n);
      }
    }
    /**
     * @param {Element} node Node.
     * @param {LineString} geometry LineString geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeCurveOrLineString(t, e, n) {
      const r = n[n.length - 1].srsName;
      if (t.nodeName !== "LineStringSegment" && r && t.setAttribute("srsName", r), t.nodeName === "LineString" || t.nodeName === "LineStringSegment") {
        const a = Ft(t.namespaceURI, "posList");
        t.appendChild(a), this.writePosList_(a, e, n);
      } else if (t.nodeName === "Curve") {
        const a = Ft(t.namespaceURI, "segments");
        t.appendChild(a), this.writeCurveSegments_(a, e, n);
      }
    }
    /**
     * @param {Element} node Node.
     * @param {MultiPolygon} geometry MultiPolygon geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeMultiSurfaceOrPolygon(t, e, n) {
      const s = n[n.length - 1], r = s.hasZ, a = s.srsName, o = s.surface;
      a && t.setAttribute("srsName", a);
      const l = e.getPolygons();
      ge(
        { node: t, hasZ: r, srsName: a, surface: o },
        this.SURFACEORPOLYGONMEMBER_SERIALIZERS,
        this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
        l,
        n,
        void 0,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeMultiPoint(t, e, n) {
      const s = n[n.length - 1], r = s.srsName, a = s.hasZ;
      r && t.setAttribute("srsName", r);
      const o = e.getPoints();
      ge(
        { node: t, hasZ: a, srsName: r },
        this.POINTMEMBER_SERIALIZERS,
        xs("pointMember"),
        o,
        n,
        void 0,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {MultiLineString} geometry MultiLineString geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeMultiCurveOrLineString(t, e, n) {
      const s = n[n.length - 1], r = s.hasZ, a = s.srsName, o = s.curve;
      a && t.setAttribute("srsName", a);
      const l = e.getLineStrings();
      ge(
        { node: t, hasZ: r, srsName: a, curve: o },
        this.LINESTRINGORCURVEMEMBER_SERIALIZERS,
        this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
        l,
        n,
        void 0,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeRing(t, e, n) {
      const s = Ft(t.namespaceURI, "LinearRing");
      t.appendChild(s), this.writeLinearRing(s, e, n);
    }
    /**
     * @param {Node} node Node.
     * @param {Polygon} polygon Polygon geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeSurfaceOrPolygonMember(t, e, n) {
      const s = this.GEOMETRY_NODE_FACTORY_(e, n);
      s && (t.appendChild(s), this.writeSurfaceOrPolygon(s, e, n));
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Point.js").default} point Point geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writePointMember(t, e, n) {
      const s = Ft(t.namespaceURI, "Point");
      t.appendChild(s), this.writePoint(s, e, n);
    }
    /**
     * @param {Node} node Node.
     * @param {LineString} line LineString geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeLineStringOrCurveMember(t, e, n) {
      const s = this.GEOMETRY_NODE_FACTORY_(e, n);
      s && (t.appendChild(s), this.writeCurveOrLineString(s, e, n));
    }
    /**
     * @param {Element} node Node.
     * @param {Polygon} polygon Polygon geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    writeSurfacePatches_(t, e, n) {
      const s = Ft(t.namespaceURI, "PolygonPatch");
      t.appendChild(s), this.writeSurfaceOrPolygon(s, e, n);
    }
    /**
     * @param {Element} node Node.
     * @param {LineString} line LineString geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    writeCurveSegments_(t, e, n) {
      const s = Ft(t.namespaceURI, "LineStringSegment");
      t.appendChild(s), this.writeCurveOrLineString(s, e, n);
    }
    /**
     * @param {Node} node Node.
     * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeGeometryElement(t, e, n) {
      const s = (
        /** @type {import("./Feature.js").WriteOptions} */
        n[n.length - 1]
      ), r = Object.assign({}, s);
      r.node = t;
      let a;
      Array.isArray(e) ? a = ec(
        /** @type {import("../extent.js").Extent} */
        e,
        s
      ) : a = tc(
        /** @type {import("../geom/Geometry.js").default} */
        e,
        !0,
        s
      ), ge(
        /** @type {import("../xml.js").NodeStackItem} */
        r,
        this.GEOMETRY_SERIALIZERS,
        this.GEOMETRY_NODE_FACTORY_,
        [a],
        n,
        void 0,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {import("../Feature.js").default} feature Feature.
     * @param {Array<*>} objectStack Node stack.
     */
    writeFeatureElement(t, e, n) {
      const s = e.getId();
      s && t.setAttribute(
        "fid",
        /** @type {string} */
        s
      );
      const r = (
        /** @type {Object} */
        n[n.length - 1]
      ), a = r.featureNS, o = e.getGeometryName();
      r.serializers || (r.serializers = {}, r.serializers[a] = {});
      const l = [], h = [];
      if (e.hasProperties()) {
        const u = e.getProperties();
        for (const d in u) {
          const m = u[d];
          m != null && (l.push(d), h.push(m), d == o || typeof /** @type {?} */
          m.getSimplifiedGeometry == "function" ? d in r.serializers[a] || (r.serializers[a][d] = H(
            this.writeGeometryElement,
            this
          )) : d in r.serializers[a] || (r.serializers[a][d] = H(Ye)));
        }
      }
      const c = Object.assign({}, r);
      c.node = t, ge(
        /** @type {import("../xml.js").NodeStackItem} */
        c,
        r.serializers,
        xs(void 0, a),
        h,
        n,
        l
      );
    }
    /**
     * @param {Node} node Node.
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    writeFeatureMembers_(t, e, n) {
      const s = (
        /** @type {Object} */
        n[n.length - 1]
      ), r = s.featureType, a = s.featureNS, o = {};
      o[a] = {}, o[a][r] = H(
        this.writeFeatureElement,
        this
      );
      const l = Object.assign({}, s);
      l.node = t, ge(
        /** @type {import("../xml.js").NodeStackItem} */
        l,
        o,
        xs(r, a),
        e,
        n
      );
    }
    /**
     * @const
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [nodeName] Node name.
     * @return {Node|undefined} Node.
     * @private
     */
    MULTIGEOMETRY_MEMBER_NODE_FACTORY_(t, e, n) {
      const s = e[e.length - 1].node;
      return Ft(
        this.namespace,
        Y1[s.nodeName]
      );
    }
    /**
     * @const
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [nodeName] Node name.
     * @return {Element|undefined} Node.
     * @private
     */
    GEOMETRY_NODE_FACTORY_(t, e, n) {
      const s = e[e.length - 1], r = s.multiSurface, a = s.surface, o = s.curve, l = s.multiCurve;
      return Array.isArray(t) ? n = "Envelope" : (n = /** @type {import("../geom/Geometry.js").default} */
      t.getType(), n === "MultiPolygon" && r === !0 ? n = "MultiSurface" : n === "Polygon" && a === !0 ? n = "Surface" : n === "LineString" && o === !0 ? n = "Curve" : n === "MultiLineString" && l === !0 && (n = "MultiCurve")), Ft(this.namespace, n);
    }
    /**
     * Encode a geometry in GML 3.1.1 Simple Features.
     *
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [options] Options.
     * @return {Node} Node.
     * @api
     * @override
     */
    writeGeometryNode(t, e) {
      e = this.adaptOptions(e);
      const n = Ft(this.namespace, "geom"), s = {
        node: n,
        hasZ: this.hasZ,
        srsName: this.srsName,
        curve: this.curve_,
        surface: this.surface_,
        multiSurface: this.multiSurface_,
        multiCurve: this.multiCurve_
      };
      return e && Object.assign(s, e), this.writeGeometryElement(n, t, [s]), n;
    }
    /**
     * Encode an array of features in the GML 3.1.1 format as an XML node.
     *
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Options.
     * @return {Element} Node.
     * @api
     * @override
     */
    writeFeaturesNode(t, e) {
      e = this.adaptOptions(e);
      const n = Ft(this.namespace, "featureMembers");
      n.setAttributeNS(
        D1,
        "xsi:schemaLocation",
        this.schemaLocation
      );
      const s = {
        srsName: this.srsName,
        hasZ: this.hasZ,
        curve: this.curve_,
        surface: this.surface_,
        multiSurface: this.multiSurface_,
        multiCurve: this.multiCurve_,
        featureNS: this.featureNS,
        featureType: this.featureType
      };
      return e && Object.assign(s, e), this.writeFeatureMembers_(n, t, [s]), n;
    }
  }
  G.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
    "http://www.opengis.net/gml": {
      pos: st(G.prototype.readFlatPos),
      posList: st(G.prototype.readFlatPosList),
      coordinates: st(vt.prototype.readFlatCoordinates)
    }
  };
  G.prototype.FLAT_LINEAR_RINGS_PARSERS = {
    "http://www.opengis.net/gml": {
      interior: G.prototype.interiorParser,
      exterior: G.prototype.exteriorParser
    }
  };
  G.prototype.GEOMETRY_PARSERS = {
    "http://www.opengis.net/gml": {
      Point: st(tt.prototype.readPoint),
      MultiPoint: st(tt.prototype.readMultiPoint),
      LineString: st(tt.prototype.readLineString),
      MultiLineString: st(tt.prototype.readMultiLineString),
      LinearRing: st(tt.prototype.readLinearRing),
      Polygon: st(tt.prototype.readPolygon),
      MultiPolygon: st(tt.prototype.readMultiPolygon),
      Surface: st(G.prototype.readSurface),
      MultiSurface: st(G.prototype.readMultiSurface),
      Curve: st(G.prototype.readCurve),
      MultiCurve: st(G.prototype.readMultiCurve),
      Envelope: st(G.prototype.readEnvelope)
    }
  };
  G.prototype.MULTICURVE_PARSERS = {
    "http://www.opengis.net/gml": {
      curveMember: ut(G.prototype.curveMemberParser),
      curveMembers: ut(G.prototype.curveMemberParser)
    }
  };
  G.prototype.MULTISURFACE_PARSERS = {
    "http://www.opengis.net/gml": {
      surfaceMember: ut(G.prototype.surfaceMemberParser),
      surfaceMembers: ut(G.prototype.surfaceMemberParser)
    }
  };
  G.prototype.CURVEMEMBER_PARSERS = {
    "http://www.opengis.net/gml": {
      LineString: ut(tt.prototype.readLineString),
      Curve: ut(G.prototype.readCurve)
    }
  };
  G.prototype.SURFACEMEMBER_PARSERS = {
    "http://www.opengis.net/gml": {
      Polygon: ut(tt.prototype.readPolygon),
      Surface: ut(G.prototype.readSurface)
    }
  };
  G.prototype.SURFACE_PARSERS = {
    "http://www.opengis.net/gml": {
      patches: st(G.prototype.readPatch)
    }
  };
  G.prototype.CURVE_PARSERS = {
    "http://www.opengis.net/gml": {
      segments: st(G.prototype.readSegment)
    }
  };
  G.prototype.ENVELOPE_PARSERS = {
    "http://www.opengis.net/gml": {
      lowerCorner: ut(G.prototype.readFlatPosList),
      upperCorner: ut(G.prototype.readFlatPosList)
    }
  };
  G.prototype.PATCHES_PARSERS = {
    "http://www.opengis.net/gml": {
      PolygonPatch: st(G.prototype.readPolygonPatch)
    }
  };
  G.prototype.SEGMENTS_PARSERS = {
    "http://www.opengis.net/gml": {
      LineStringSegment: Gf(
        G.prototype.readLineStringSegment
      )
    }
  };
  tt.prototype.RING_PARSERS = {
    "http://www.opengis.net/gml": {
      LinearRing: st(tt.prototype.readFlatLinearRing),
      Ring: st(G.prototype.readFlatCurveRing)
    }
  };
  G.prototype.RING_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      exterior: H(G.prototype.writeRing),
      interior: H(G.prototype.writeRing)
    }
  };
  G.prototype.ENVELOPE_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      lowerCorner: H(Ye),
      upperCorner: H(Ye)
    }
  };
  G.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      surfaceMember: H(
        G.prototype.writeSurfaceOrPolygonMember
      ),
      polygonMember: H(
        G.prototype.writeSurfaceOrPolygonMember
      )
    }
  };
  G.prototype.POINTMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      pointMember: H(G.prototype.writePointMember)
    }
  };
  G.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      lineStringMember: H(
        G.prototype.writeLineStringOrCurveMember
      ),
      curveMember: H(
        G.prototype.writeLineStringOrCurveMember
      )
    }
  };
  G.prototype.GEOMETRY_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      Curve: H(G.prototype.writeCurveOrLineString),
      MultiCurve: H(G.prototype.writeMultiCurveOrLineString),
      Point: H(G.prototype.writePoint),
      MultiPoint: H(G.prototype.writeMultiPoint),
      LineString: H(G.prototype.writeCurveOrLineString),
      MultiLineString: H(
        G.prototype.writeMultiCurveOrLineString
      ),
      LinearRing: H(G.prototype.writeLinearRing),
      Polygon: H(G.prototype.writeSurfaceOrPolygon),
      MultiPolygon: H(
        G.prototype.writeMultiSurfaceOrPolygon
      ),
      Surface: H(G.prototype.writeSurfaceOrPolygon),
      MultiSurface: H(
        G.prototype.writeMultiSurfaceOrPolygon
      ),
      Envelope: H(G.prototype.writeEnvelope)
    }
  };
  class wt extends G {
    /**
     * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
     */
    constructor(t) {
      t = t || {}, super(t), this.schemaLocation = t.schemaLocation ? t.schemaLocation : this.namespace + " http://schemas.opengis.net/gml/3.2.1/gml.xsd";
    }
    /**
     * @param {Node} node Node.
     * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
     * @param {Array<*>} objectStack Node stack.
     * @override
     */
    writeGeometryElement(t, e, n) {
      const s = n[n.length - 1];
      n[n.length - 1] = Object.assign(
        { multiCurve: !0, multiSurface: !0 },
        s
      ), super.writeGeometryElement(t, e, n);
    }
  }
  wt.prototype.namespace = "http://www.opengis.net/gml/3.2";
  wt.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      pos: st(G.prototype.readFlatPos),
      posList: st(G.prototype.readFlatPosList),
      coordinates: st(vt.prototype.readFlatCoordinates)
    }
  };
  wt.prototype.FLAT_LINEAR_RINGS_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      interior: G.prototype.interiorParser,
      exterior: G.prototype.exteriorParser
    }
  };
  wt.prototype.GEOMETRY_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      Point: st(tt.prototype.readPoint),
      MultiPoint: st(tt.prototype.readMultiPoint),
      LineString: st(tt.prototype.readLineString),
      MultiLineString: st(tt.prototype.readMultiLineString),
      LinearRing: st(tt.prototype.readLinearRing),
      Polygon: st(tt.prototype.readPolygon),
      MultiPolygon: st(tt.prototype.readMultiPolygon),
      Surface: st(wt.prototype.readSurface),
      MultiSurface: st(G.prototype.readMultiSurface),
      Curve: st(wt.prototype.readCurve),
      MultiCurve: st(G.prototype.readMultiCurve),
      Envelope: st(wt.prototype.readEnvelope)
    }
  };
  wt.prototype.MULTICURVE_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      curveMember: ut(G.prototype.curveMemberParser),
      curveMembers: ut(G.prototype.curveMemberParser)
    }
  };
  wt.prototype.MULTISURFACE_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      surfaceMember: ut(G.prototype.surfaceMemberParser),
      surfaceMembers: ut(G.prototype.surfaceMemberParser)
    }
  };
  wt.prototype.CURVEMEMBER_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      LineString: ut(tt.prototype.readLineString),
      Curve: ut(G.prototype.readCurve)
    }
  };
  wt.prototype.SURFACEMEMBER_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      Polygon: ut(tt.prototype.readPolygon),
      Surface: ut(G.prototype.readSurface)
    }
  };
  wt.prototype.SURFACE_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      patches: st(G.prototype.readPatch)
    }
  };
  wt.prototype.CURVE_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      segments: st(G.prototype.readSegment)
    }
  };
  wt.prototype.ENVELOPE_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      lowerCorner: ut(G.prototype.readFlatPosList),
      upperCorner: ut(G.prototype.readFlatPosList)
    }
  };
  wt.prototype.PATCHES_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      PolygonPatch: st(G.prototype.readPolygonPatch)
    }
  };
  wt.prototype.SEGMENTS_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      LineStringSegment: Gf(
        G.prototype.readLineStringSegment
      )
    }
  };
  wt.prototype.MULTIPOINT_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      pointMember: ut(tt.prototype.pointMemberParser),
      pointMembers: ut(tt.prototype.pointMemberParser)
    }
  };
  wt.prototype.MULTILINESTRING_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      lineStringMember: ut(
        tt.prototype.lineStringMemberParser
      ),
      lineStringMembers: ut(
        tt.prototype.lineStringMemberParser
      )
    }
  };
  wt.prototype.MULTIPOLYGON_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      polygonMember: ut(tt.prototype.polygonMemberParser),
      polygonMembers: ut(tt.prototype.polygonMemberParser)
    }
  };
  wt.prototype.POINTMEMBER_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      Point: ut(tt.prototype.readFlatCoordinatesFromNode)
    }
  };
  wt.prototype.LINESTRINGMEMBER_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      LineString: ut(tt.prototype.readLineString)
    }
  };
  wt.prototype.POLYGONMEMBER_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      Polygon: ut(tt.prototype.readPolygon)
    }
  };
  wt.prototype.RING_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      LinearRing: st(tt.prototype.readFlatLinearRing),
      Ring: st(wt.prototype.readFlatCurveRing)
    }
  };
  wt.prototype.RING_SERIALIZERS = {
    "http://www.opengis.net/gml/3.2": {
      exterior: H(G.prototype.writeRing),
      interior: H(G.prototype.writeRing)
    }
  };
  wt.prototype.ENVELOPE_SERIALIZERS = {
    "http://www.opengis.net/gml/3.2": {
      lowerCorner: H(Ye),
      upperCorner: H(Ye)
    }
  };
  wt.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml/3.2": {
      surfaceMember: H(
        G.prototype.writeSurfaceOrPolygonMember
      ),
      polygonMember: H(
        G.prototype.writeSurfaceOrPolygonMember
      )
    }
  };
  wt.prototype.POINTMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml/3.2": {
      pointMember: H(G.prototype.writePointMember)
    }
  };
  wt.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml/3.2": {
      lineStringMember: H(
        G.prototype.writeLineStringOrCurveMember
      ),
      curveMember: H(
        G.prototype.writeLineStringOrCurveMember
      )
    }
  };
  wt.prototype.GEOMETRY_SERIALIZERS = {
    "http://www.opengis.net/gml/3.2": {
      Curve: H(G.prototype.writeCurveOrLineString),
      MultiCurve: H(G.prototype.writeMultiCurveOrLineString),
      Point: H(wt.prototype.writePoint),
      MultiPoint: H(G.prototype.writeMultiPoint),
      LineString: H(G.prototype.writeCurveOrLineString),
      MultiLineString: H(
        G.prototype.writeMultiCurveOrLineString
      ),
      LinearRing: H(G.prototype.writeLinearRing),
      Polygon: H(G.prototype.writeSurfaceOrPolygon),
      MultiPolygon: H(
        G.prototype.writeMultiSurfaceOrPolygon
      ),
      Surface: H(G.prototype.writeSurfaceOrPolygon),
      MultiSurface: H(
        G.prototype.writeMultiSurfaceOrPolygon
      ),
      Envelope: H(G.prototype.writeEnvelope)
    }
  };
  function Z1(i) {
    const t = Object.keys(i.defs), e = t.length;
    let n, s;
    for (n = 0; n < e; ++n) {
      const r = t[n];
      if (!Pa(r)) {
        const a = i.defs(r);
        let o = (
          /** @type {import("./Units.js").Units} */
          a.units
        );
        !o && a.projName === "longlat" && (o = "degrees"), Xa(
          new fo({
            code: r,
            axisOrientation: a.axis,
            metersPerUnit: a.to_meter,
            units: o
          })
        );
      }
    }
    for (n = 0; n < e; ++n) {
      const r = t[n], a = Pa(r);
      for (s = 0; s < e; ++s) {
        const o = t[s], l = Pa(o);
        if (!ba(r, o))
          if (i.defs[r] === i.defs[o])
            bl([a, l]);
          else {
            const h = i(r, o);
            vm(
              a,
              l,
              Zc(a, l, h.forward),
              Zc(l, a, h.inverse)
            );
          }
      }
    }
  }
  function q1(i) {
    i("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), i("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), i("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
    for (var t = 1; t <= 60; ++t)
      i("EPSG:" + (32600 + t), "+proj=utm +zone=" + t + " +datum=WGS84 +units=m"), i("EPSG:" + (32700 + t), "+proj=utm +zone=" + t + " +south +datum=WGS84 +units=m");
    i.WGS84 = i["EPSG:4326"], i["EPSG:3785"] = i["EPSG:3857"], i.GOOGLE = i["EPSG:3857"], i["EPSG:900913"] = i["EPSG:3857"], i["EPSG:102113"] = i["EPSG:3857"];
  }
  var zn = 1, Bn = 2, ws = 3, K1 = 4, jl = 5, zu = 6378137, j1 = 6356752314e-3, Bu = 0.0066943799901413165, fr = 484813681109536e-20, k = Math.PI / 2, V1 = 0.16666666666666666, H1 = 0.04722222222222222, J1 = 0.022156084656084655, Z = 1e-10, te = 0.017453292519943295, ui = 57.29577951308232, Tt = Math.PI / 4, br = Math.PI * 2, ee = 3.14159265359, Pe = {};
  Pe.greenwich = 0;
  Pe.lisbon = -9.131906111111;
  Pe.paris = 2.337229166667;
  Pe.bogota = -74.080916666667;
  Pe.madrid = -3.687938888889;
  Pe.rome = 12.452333333333;
  Pe.bern = 7.439583333333;
  Pe.jakarta = 106.807719444444;
  Pe.ferro = -17.666666666667;
  Pe.brussels = 4.367975;
  Pe.stockholm = 18.058277777778;
  Pe.athens = 23.7163375;
  Pe.oslo = 10.722916666667;
  const Q1 = {
    mm: { to_meter: 1e-3 },
    cm: { to_meter: 0.01 },
    ft: { to_meter: 0.3048 },
    "us-ft": { to_meter: 1200 / 3937 },
    fath: { to_meter: 1.8288 },
    kmi: { to_meter: 1852 },
    "us-ch": { to_meter: 20.1168402336805 },
    "us-mi": { to_meter: 1609.34721869444 },
    km: { to_meter: 1e3 },
    "ind-ft": { to_meter: 0.30479841 },
    "ind-yd": { to_meter: 0.91439523 },
    mi: { to_meter: 1609.344 },
    yd: { to_meter: 0.9144 },
    ch: { to_meter: 20.1168 },
    link: { to_meter: 0.201168 },
    dm: { to_meter: 0.01 },
    in: { to_meter: 0.0254 },
    "ind-ch": { to_meter: 20.11669506 },
    "us-in": { to_meter: 0.025400050800101 },
    "us-yd": { to_meter: 0.914401828803658 }
  };
  var $u = /[\s_\-\/\(\)]/g;
  function un(i, t) {
    if (i[t])
      return i[t];
    for (var e = Object.keys(i), n = t.toLowerCase().replace($u, ""), s = -1, r, a; ++s < e.length; )
      if (r = e[s], a = r.toLowerCase().replace($u, ""), a === n)
        return i[r];
  }
  function Vl(i) {
    var t = {}, e = i.split("+").map(function(o) {
      return o.trim();
    }).filter(function(o) {
      return o;
    }).reduce(function(o, l) {
      var h = l.split("=");
      return h.push(!0), o[h[0].toLowerCase()] = h[1], o;
    }, {}), n, s, r, a = {
      proj: "projName",
      datum: "datumCode",
      rf: function(o) {
        t.rf = parseFloat(o);
      },
      lat_0: function(o) {
        t.lat0 = o * te;
      },
      lat_1: function(o) {
        t.lat1 = o * te;
      },
      lat_2: function(o) {
        t.lat2 = o * te;
      },
      lat_ts: function(o) {
        t.lat_ts = o * te;
      },
      lon_0: function(o) {
        t.long0 = o * te;
      },
      lon_1: function(o) {
        t.long1 = o * te;
      },
      lon_2: function(o) {
        t.long2 = o * te;
      },
      alpha: function(o) {
        t.alpha = parseFloat(o) * te;
      },
      gamma: function(o) {
        t.rectified_grid_angle = parseFloat(o);
      },
      lonc: function(o) {
        t.longc = o * te;
      },
      x_0: function(o) {
        t.x0 = parseFloat(o);
      },
      y_0: function(o) {
        t.y0 = parseFloat(o);
      },
      k_0: function(o) {
        t.k0 = parseFloat(o);
      },
      k: function(o) {
        t.k0 = parseFloat(o);
      },
      a: function(o) {
        t.a = parseFloat(o);
      },
      b: function(o) {
        t.b = parseFloat(o);
      },
      r: function(o) {
        t.a = t.b = parseFloat(o);
      },
      r_a: function() {
        t.R_A = !0;
      },
      zone: function(o) {
        t.zone = parseInt(o, 10);
      },
      south: function() {
        t.utmSouth = !0;
      },
      towgs84: function(o) {
        t.datum_params = o.split(",").map(function(l) {
          return parseFloat(l);
        });
      },
      to_meter: function(o) {
        t.to_meter = parseFloat(o);
      },
      units: function(o) {
        t.units = o;
        var l = un(Q1, o);
        l && (t.to_meter = l.to_meter);
      },
      from_greenwich: function(o) {
        t.from_greenwich = o * te;
      },
      pm: function(o) {
        var l = un(Pe, o);
        t.from_greenwich = (l || parseFloat(o)) * te;
      },
      nadgrids: function(o) {
        o === "@null" ? t.datumCode = "none" : t.nadgrids = o;
      },
      axis: function(o) {
        var l = "ewnsud";
        o.length === 3 && l.indexOf(o.substr(0, 1)) !== -1 && l.indexOf(o.substr(1, 1)) !== -1 && l.indexOf(o.substr(2, 1)) !== -1 && (t.axis = o);
      },
      approx: function() {
        t.approx = !0;
      }
    };
    for (n in e)
      s = e[n], n in a ? (r = a[n], typeof r == "function" ? r(s) : t[r] = s) : t[n] = s;
    return typeof t.datumCode == "string" && t.datumCode !== "WGS84" && (t.datumCode = t.datumCode.toLowerCase()), t;
  }
  var Lr = 1, Bf = 2, $f = 3, io = 4, Xf = 5, ic = -1, tv = /\s/, ev = /[A-Za-z]/, iv = /[A-Za-z84_]/, ko = /[,\]]/, Wf = /[\d\.E\-\+]/;
  function ki(i) {
    if (typeof i != "string")
      throw new Error("not a string");
    this.text = i.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = Lr;
  }
  ki.prototype.readCharicter = function() {
    var i = this.text[this.place++];
    if (this.state !== io)
      for (; tv.test(i); ) {
        if (this.place >= this.text.length)
          return;
        i = this.text[this.place++];
      }
    switch (this.state) {
      case Lr:
        return this.neutral(i);
      case Bf:
        return this.keyword(i);
      case io:
        return this.quoted(i);
      case Xf:
        return this.afterquote(i);
      case $f:
        return this.number(i);
      case ic:
        return;
    }
  };
  ki.prototype.afterquote = function(i) {
    if (i === '"') {
      this.word += '"', this.state = io;
      return;
    }
    if (ko.test(i)) {
      this.word = this.word.trim(), this.afterItem(i);
      return;
    }
    throw new Error(`havn't handled "` + i + '" in afterquote yet, index ' + this.place);
  };
  ki.prototype.afterItem = function(i) {
    if (i === ",") {
      this.word !== null && this.currentObject.push(this.word), this.word = null, this.state = Lr;
      return;
    }
    if (i === "]") {
      this.level--, this.word !== null && (this.currentObject.push(this.word), this.word = null), this.state = Lr, this.currentObject = this.stack.pop(), this.currentObject || (this.state = ic);
      return;
    }
  };
  ki.prototype.number = function(i) {
    if (Wf.test(i)) {
      this.word += i;
      return;
    }
    if (ko.test(i)) {
      this.word = parseFloat(this.word), this.afterItem(i);
      return;
    }
    throw new Error(`havn't handled "` + i + '" in number yet, index ' + this.place);
  };
  ki.prototype.quoted = function(i) {
    if (i === '"') {
      this.state = Xf;
      return;
    }
    this.word += i;
  };
  ki.prototype.keyword = function(i) {
    if (iv.test(i)) {
      this.word += i;
      return;
    }
    if (i === "[") {
      var t = [];
      t.push(this.word), this.level++, this.root === null ? this.root = t : this.currentObject.push(t), this.stack.push(this.currentObject), this.currentObject = t, this.state = Lr;
      return;
    }
    if (ko.test(i)) {
      this.afterItem(i);
      return;
    }
    throw new Error(`havn't handled "` + i + '" in keyword yet, index ' + this.place);
  };
  ki.prototype.neutral = function(i) {
    if (ev.test(i)) {
      this.word = i, this.state = Bf;
      return;
    }
    if (i === '"') {
      this.word = "", this.state = io;
      return;
    }
    if (Wf.test(i)) {
      this.word = i, this.state = $f;
      return;
    }
    if (ko.test(i)) {
      this.afterItem(i);
      return;
    }
    throw new Error(`havn't handled "` + i + '" in neutral yet, index ' + this.place);
  };
  ki.prototype.output = function() {
    for (; this.place < this.text.length; )
      this.readCharicter();
    if (this.state === ic)
      return this.root;
    throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
  };
  function nv(i) {
    var t = new ki(i);
    return t.output();
  }
  function xl(i, t, e) {
    Array.isArray(t) && (e.unshift(t), t = null);
    var n = t ? {} : i, s = e.reduce(function(r, a) {
      return ds(a, r), r;
    }, n);
    t && (i[t] = s);
  }
  function ds(i, t) {
    if (!Array.isArray(i)) {
      t[i] = !0;
      return;
    }
    var e = i.shift();
    if (e === "PARAMETER" && (e = i.shift()), i.length === 1) {
      if (Array.isArray(i[0])) {
        t[e] = {}, ds(i[0], t[e]);
        return;
      }
      t[e] = i[0];
      return;
    }
    if (!i.length) {
      t[e] = !0;
      return;
    }
    if (e === "TOWGS84") {
      t[e] = i;
      return;
    }
    if (e === "AXIS") {
      e in t || (t[e] = []), t[e].push(i);
      return;
    }
    Array.isArray(e) || (t[e] = {});
    var n;
    switch (e) {
      case "UNIT":
      case "PRIMEM":
      case "VERT_DATUM":
        t[e] = {
          name: i[0].toLowerCase(),
          convert: i[1]
        }, i.length === 3 && ds(i[2], t[e]);
        return;
      case "SPHEROID":
      case "ELLIPSOID":
        t[e] = {
          name: i[0],
          a: i[1],
          rf: i[2]
        }, i.length === 4 && ds(i[3], t[e]);
        return;
      case "EDATUM":
      case "ENGINEERINGDATUM":
      case "LOCAL_DATUM":
      case "DATUM":
      case "VERT_CS":
      case "VERTCRS":
      case "VERTICALCRS":
        i[0] = ["name", i[0]], xl(t, e, i);
        return;
      case "COMPD_CS":
      case "COMPOUNDCRS":
      case "FITTED_CS":
      // the followings are the crs defined in
      // https://github.com/proj4js/proj4js/blob/1da4ed0b865d0fcb51c136090569210cdcc9019e/lib/parseCode.js#L11
      case "PROJECTEDCRS":
      case "PROJCRS":
      case "GEOGCS":
      case "GEOCCS":
      case "PROJCS":
      case "LOCAL_CS":
      case "GEODCRS":
      case "GEODETICCRS":
      case "GEODETICDATUM":
      case "ENGCRS":
      case "ENGINEERINGCRS":
        i[0] = ["name", i[0]], xl(t, e, i), t[e].type = e;
        return;
      default:
        for (n = -1; ++n < i.length; )
          if (!Array.isArray(i[n]))
            return ds(i, t[e]);
        return xl(t, e, i);
    }
  }
  var sv = 0.017453292519943295, rv = [
    "PROJECTEDCRS",
    "PROJCRS",
    "GEOGCS",
    "GEOCCS",
    "PROJCS",
    "LOCAL_CS",
    "GEODCRS",
    "GEODETICCRS",
    "GEODETICDATUM",
    "ENGCRS",
    "ENGINEERINGCRS"
  ];
  function av(i, t) {
    var e = t[0], n = t[1];
    !(e in i) && n in i && (i[e] = i[n], t.length === 3 && (i[e] = t[2](i[e])));
  }
  function ai(i) {
    return i * sv;
  }
  function Yf(i) {
    for (var t = Object.keys(i), e = 0, n = t.length; e < n; ++e) {
      var s = t[e];
      rv.indexOf(s) !== -1 && ov(i[s]), typeof i[s] == "object" && Yf(i[s]);
    }
  }
  function ov(i) {
    if (i.AUTHORITY) {
      var t = Object.keys(i.AUTHORITY)[0];
      t && t in i.AUTHORITY && (i.title = t + ":" + i.AUTHORITY[t]);
    }
    if (i.type === "GEOGCS" ? i.projName = "longlat" : i.type === "LOCAL_CS" ? (i.projName = "identity", i.local = !0) : typeof i.PROJECTION == "object" ? i.projName = Object.keys(i.PROJECTION)[0] : i.projName = i.PROJECTION, i.AXIS) {
      for (var e = "", n = 0, s = i.AXIS.length; n < s; ++n) {
        var r = [i.AXIS[n][0].toLowerCase(), i.AXIS[n][1].toLowerCase()];
        r[0].indexOf("north") !== -1 || (r[0] === "y" || r[0] === "lat") && r[1] === "north" ? e += "n" : r[0].indexOf("south") !== -1 || (r[0] === "y" || r[0] === "lat") && r[1] === "south" ? e += "s" : r[0].indexOf("east") !== -1 || (r[0] === "x" || r[0] === "lon") && r[1] === "east" ? e += "e" : (r[0].indexOf("west") !== -1 || (r[0] === "x" || r[0] === "lon") && r[1] === "west") && (e += "w");
      }
      e.length === 2 && (e += "u"), e.length === 3 && (i.axis = e);
    }
    i.UNIT && (i.units = i.UNIT.name.toLowerCase(), i.units === "metre" && (i.units = "meter"), i.UNIT.convert && (i.type === "GEOGCS" ? i.DATUM && i.DATUM.SPHEROID && (i.to_meter = i.UNIT.convert * i.DATUM.SPHEROID.a) : i.to_meter = i.UNIT.convert));
    var a = i.GEOGCS;
    i.type === "GEOGCS" && (a = i), a && (a.DATUM ? i.datumCode = a.DATUM.name.toLowerCase() : i.datumCode = a.name.toLowerCase(), i.datumCode.slice(0, 2) === "d_" && (i.datumCode = i.datumCode.slice(2)), i.datumCode === "new_zealand_1949" && (i.datumCode = "nzgd49"), (i.datumCode === "wgs_1984" || i.datumCode === "world_geodetic_system_1984") && (i.PROJECTION === "Mercator_Auxiliary_Sphere" && (i.sphere = !0), i.datumCode = "wgs84"), i.datumCode === "belge_1972" && (i.datumCode = "rnb72"), a.DATUM && a.DATUM.SPHEROID && (i.ellps = a.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), i.ellps.toLowerCase().slice(0, 13) === "international" && (i.ellps = "intl"), i.a = a.DATUM.SPHEROID.a, i.rf = parseFloat(a.DATUM.SPHEROID.rf, 10)), a.DATUM && a.DATUM.TOWGS84 && (i.datum_params = a.DATUM.TOWGS84), ~i.datumCode.indexOf("osgb_1936") && (i.datumCode = "osgb36"), ~i.datumCode.indexOf("osni_1952") && (i.datumCode = "osni52"), (~i.datumCode.indexOf("tm65") || ~i.datumCode.indexOf("geodetic_datum_of_1965")) && (i.datumCode = "ire65"), i.datumCode === "ch1903+" && (i.datumCode = "ch1903"), ~i.datumCode.indexOf("israel") && (i.datumCode = "isr93")), i.b && !isFinite(i.b) && (i.b = i.a);
    function o(c) {
      var u = i.to_meter || 1;
      return c * u;
    }
    var l = function(c) {
      return av(i, c);
    }, h = [
      ["standard_parallel_1", "Standard_Parallel_1"],
      ["standard_parallel_1", "Latitude of 1st standard parallel"],
      ["standard_parallel_2", "Standard_Parallel_2"],
      ["standard_parallel_2", "Latitude of 2nd standard parallel"],
      ["false_easting", "False_Easting"],
      ["false_easting", "False easting"],
      ["false-easting", "Easting at false origin"],
      ["false_northing", "False_Northing"],
      ["false_northing", "False northing"],
      ["false_northing", "Northing at false origin"],
      ["central_meridian", "Central_Meridian"],
      ["central_meridian", "Longitude of natural origin"],
      ["central_meridian", "Longitude of false origin"],
      ["latitude_of_origin", "Latitude_Of_Origin"],
      ["latitude_of_origin", "Central_Parallel"],
      ["latitude_of_origin", "Latitude of natural origin"],
      ["latitude_of_origin", "Latitude of false origin"],
      ["scale_factor", "Scale_Factor"],
      ["k0", "scale_factor"],
      ["latitude_of_center", "Latitude_Of_Center"],
      ["latitude_of_center", "Latitude_of_center"],
      ["lat0", "latitude_of_center", ai],
      ["longitude_of_center", "Longitude_Of_Center"],
      ["longitude_of_center", "Longitude_of_center"],
      ["longc", "longitude_of_center", ai],
      ["x0", "false_easting", o],
      ["y0", "false_northing", o],
      ["long0", "central_meridian", ai],
      ["lat0", "latitude_of_origin", ai],
      ["lat0", "standard_parallel_1", ai],
      ["lat1", "standard_parallel_1", ai],
      ["lat2", "standard_parallel_2", ai],
      ["azimuth", "Azimuth"],
      ["alpha", "azimuth", ai],
      ["srsCode", "name"]
    ];
    h.forEach(l), !i.long0 && i.longc && (i.projName === "Albers_Conic_Equal_Area" || i.projName === "Lambert_Azimuthal_Equal_Area") && (i.long0 = i.longc), !i.lat_ts && i.lat1 && (i.projName === "Stereographic_South_Pole" || i.projName === "Polar Stereographic (variant B)") ? (i.lat0 = ai(i.lat1 > 0 ? 90 : -90), i.lat_ts = i.lat1) : !i.lat_ts && i.lat0 && i.projName === "Polar_Stereographic" && (i.lat_ts = i.lat0, i.lat0 = ai(i.lat0 > 0 ? 90 : -90));
  }
  function Zf(i) {
    var t = nv(i), e = t[0], n = {};
    return ds(t, n), Yf(n), n[e];
  }
  function fe(i) {
    var t = this;
    if (arguments.length === 2) {
      var e = arguments[1];
      typeof e == "string" ? e.charAt(0) === "+" ? fe[i] = Vl(arguments[1]) : fe[i] = Zf(arguments[1]) : fe[i] = e;
    } else if (arguments.length === 1) {
      if (Array.isArray(i))
        return i.map(function(n) {
          Array.isArray(n) ? fe.apply(t, n) : fe(n);
        });
      if (typeof i == "string") {
        if (i in fe)
          return fe[i];
      } else "EPSG" in i ? fe["EPSG:" + i.EPSG] = i : "ESRI" in i ? fe["ESRI:" + i.ESRI] = i : "IAU2000" in i ? fe["IAU2000:" + i.IAU2000] = i : console.log(i);
      return;
    }
  }
  q1(fe);
  function lv(i) {
    return typeof i == "string";
  }
  function hv(i) {
    return i in fe;
  }
  var cv = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
  function uv(i) {
    return cv.some(function(t) {
      return i.indexOf(t) > -1;
    });
  }
  var dv = ["3857", "900913", "3785", "102113"];
  function fv(i) {
    var t = un(i, "authority");
    if (t) {
      var e = un(t, "epsg");
      return e && dv.indexOf(e) > -1;
    }
  }
  function gv(i) {
    var t = un(i, "extension");
    if (t)
      return un(t, "proj4");
  }
  function mv(i) {
    return i[0] === "+";
  }
  function _v(i) {
    if (lv(i)) {
      if (hv(i))
        return fe[i];
      if (uv(i)) {
        var t = Zf(i);
        if (fv(t))
          return fe["EPSG:3857"];
        var e = gv(t);
        return e ? Vl(e) : t;
      }
      if (mv(i))
        return Vl(i);
    } else
      return i;
  }
  function Xu(i, t) {
    i = i || {};
    var e, n;
    if (!t)
      return i;
    for (n in t)
      e = t[n], e !== void 0 && (i[n] = e);
    return i;
  }
  function mi(i, t, e) {
    var n = i * t;
    return e / Math.sqrt(1 - n * n);
  }
  function Hr(i) {
    return i < 0 ? -1 : 1;
  }
  function K(i) {
    return Math.abs(i) <= ee ? i : i - Hr(i) * br;
  }
  function ii(i, t, e) {
    var n = i * e, s = 0.5 * i;
    return n = Math.pow((1 - n) / (1 + n), s), Math.tan(0.5 * (k - t)) / n;
  }
  function Or(i, t) {
    for (var e = 0.5 * i, n, s, r = k - 2 * Math.atan(t), a = 0; a <= 15; a++)
      if (n = i * Math.sin(r), s = k - 2 * Math.atan(t * Math.pow((1 - n) / (1 + n), e)) - r, r += s, Math.abs(s) <= 1e-10)
        return r;
    return -9999;
  }
  function pv() {
    var i = this.b / this.a;
    this.es = 1 - i * i, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = mi(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
  }
  function yv(i) {
    var t = i.x, e = i.y;
    if (e * ui > 90 && e * ui < -90 && t * ui > 180 && t * ui < -180)
      return null;
    var n, s;
    if (Math.abs(Math.abs(e) - k) <= Z)
      return null;
    if (this.sphere)
      n = this.x0 + this.a * this.k0 * K(t - this.long0), s = this.y0 + this.a * this.k0 * Math.log(Math.tan(Tt + 0.5 * e));
    else {
      var r = Math.sin(e), a = ii(this.e, e, r);
      n = this.x0 + this.a * this.k0 * K(t - this.long0), s = this.y0 - this.a * this.k0 * Math.log(a);
    }
    return i.x = n, i.y = s, i;
  }
  function vv(i) {
    var t = i.x - this.x0, e = i.y - this.y0, n, s;
    if (this.sphere)
      s = k - 2 * Math.atan(Math.exp(-e / (this.a * this.k0)));
    else {
      var r = Math.exp(-e / (this.a * this.k0));
      if (s = Or(this.e, r), s === -9999)
        return null;
    }
    return n = K(this.long0 + t / (this.a * this.k0)), i.x = n, i.y = s, i;
  }
  var Ev = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
  const xv = {
    init: pv,
    forward: yv,
    inverse: vv,
    names: Ev
  };
  function Mv() {
  }
  function Wu(i) {
    return i;
  }
  var wv = ["longlat", "identity"];
  const Rv = {
    init: Mv,
    forward: Wu,
    inverse: Wu,
    names: wv
  };
  var Sv = [xv, Rv], La = {}, no = [];
  function qf(i, t) {
    var e = no.length;
    return i.names ? (no[e] = i, i.names.forEach(function(n) {
      La[n.toLowerCase()] = e;
    }), this) : (console.log(t), !0);
  }
  function Cv(i) {
    if (!i)
      return !1;
    var t = i.toLowerCase();
    if (typeof La[t] < "u" && no[La[t]])
      return no[La[t]];
  }
  function Tv() {
    Sv.forEach(qf);
  }
  const Iv = {
    start: Tv,
    add: qf,
    get: Cv
  };
  var at = {};
  at.MERIT = {
    a: 6378137,
    rf: 298.257,
    ellipseName: "MERIT 1983"
  };
  at.SGS85 = {
    a: 6378136,
    rf: 298.257,
    ellipseName: "Soviet Geodetic System 85"
  };
  at.GRS80 = {
    a: 6378137,
    rf: 298.257222101,
    ellipseName: "GRS 1980(IUGG, 1980)"
  };
  at.IAU76 = {
    a: 6378140,
    rf: 298.257,
    ellipseName: "IAU 1976"
  };
  at.airy = {
    a: 6377563396e-3,
    b: 635625691e-2,
    ellipseName: "Airy 1830"
  };
  at.APL4 = {
    a: 6378137,
    rf: 298.25,
    ellipseName: "Appl. Physics. 1965"
  };
  at.NWL9D = {
    a: 6378145,
    rf: 298.25,
    ellipseName: "Naval Weapons Lab., 1965"
  };
  at.mod_airy = {
    a: 6377340189e-3,
    b: 6356034446e-3,
    ellipseName: "Modified Airy"
  };
  at.andrae = {
    a: 637710443e-2,
    rf: 300,
    ellipseName: "Andrae 1876 (Den., Iclnd.)"
  };
  at.aust_SA = {
    a: 6378160,
    rf: 298.25,
    ellipseName: "Australian Natl & S. Amer. 1969"
  };
  at.GRS67 = {
    a: 6378160,
    rf: 298.247167427,
    ellipseName: "GRS 67(IUGG 1967)"
  };
  at.bessel = {
    a: 6377397155e-3,
    rf: 299.1528128,
    ellipseName: "Bessel 1841"
  };
  at.bess_nam = {
    a: 6377483865e-3,
    rf: 299.1528128,
    ellipseName: "Bessel 1841 (Namibia)"
  };
  at.clrk66 = {
    a: 63782064e-1,
    b: 63565838e-1,
    ellipseName: "Clarke 1866"
  };
  at.clrk80 = {
    a: 6378249145e-3,
    rf: 293.4663,
    ellipseName: "Clarke 1880 mod."
  };
  at.clrk80ign = {
    a: 63782492e-1,
    b: 6356515,
    rf: 293.4660213,
    ellipseName: "Clarke 1880 (IGN)"
  };
  at.clrk58 = {
    a: 6378293645208759e-9,
    rf: 294.2606763692654,
    ellipseName: "Clarke 1858"
  };
  at.CPM = {
    a: 63757387e-1,
    rf: 334.29,
    ellipseName: "Comm. des Poids et Mesures 1799"
  };
  at.delmbr = {
    a: 6376428,
    rf: 311.5,
    ellipseName: "Delambre 1810 (Belgium)"
  };
  at.engelis = {
    a: 637813605e-2,
    rf: 298.2566,
    ellipseName: "Engelis 1985"
  };
  at.evrst30 = {
    a: 6377276345e-3,
    rf: 300.8017,
    ellipseName: "Everest 1830"
  };
  at.evrst48 = {
    a: 6377304063e-3,
    rf: 300.8017,
    ellipseName: "Everest 1948"
  };
  at.evrst56 = {
    a: 6377301243e-3,
    rf: 300.8017,
    ellipseName: "Everest 1956"
  };
  at.evrst69 = {
    a: 6377295664e-3,
    rf: 300.8017,
    ellipseName: "Everest 1969"
  };
  at.evrstSS = {
    a: 6377298556e-3,
    rf: 300.8017,
    ellipseName: "Everest (Sabah & Sarawak)"
  };
  at.fschr60 = {
    a: 6378166,
    rf: 298.3,
    ellipseName: "Fischer (Mercury Datum) 1960"
  };
  at.fschr60m = {
    a: 6378155,
    rf: 298.3,
    ellipseName: "Fischer 1960"
  };
  at.fschr68 = {
    a: 6378150,
    rf: 298.3,
    ellipseName: "Fischer 1968"
  };
  at.helmert = {
    a: 6378200,
    rf: 298.3,
    ellipseName: "Helmert 1906"
  };
  at.hough = {
    a: 6378270,
    rf: 297,
    ellipseName: "Hough"
  };
  at.intl = {
    a: 6378388,
    rf: 297,
    ellipseName: "International 1909 (Hayford)"
  };
  at.kaula = {
    a: 6378163,
    rf: 298.24,
    ellipseName: "Kaula 1961"
  };
  at.lerch = {
    a: 6378139,
    rf: 298.257,
    ellipseName: "Lerch 1979"
  };
  at.mprts = {
    a: 6397300,
    rf: 191,
    ellipseName: "Maupertius 1738"
  };
  at.new_intl = {
    a: 63781575e-1,
    b: 63567722e-1,
    ellipseName: "New International 1967"
  };
  at.plessis = {
    a: 6376523,
    rf: 6355863,
    ellipseName: "Plessis 1817 (France)"
  };
  at.krass = {
    a: 6378245,
    rf: 298.3,
    ellipseName: "Krassovsky, 1942"
  };
  at.SEasia = {
    a: 6378155,
    b: 63567733205e-4,
    ellipseName: "Southeast Asia"
  };
  at.walbeck = {
    a: 6376896,
    b: 63558348467e-4,
    ellipseName: "Walbeck"
  };
  at.WGS60 = {
    a: 6378165,
    rf: 298.3,
    ellipseName: "WGS 60"
  };
  at.WGS66 = {
    a: 6378145,
    rf: 298.25,
    ellipseName: "WGS 66"
  };
  at.WGS7 = {
    a: 6378135,
    rf: 298.26,
    ellipseName: "WGS 72"
  };
  var Av = at.WGS84 = {
    a: 6378137,
    rf: 298.257223563,
    ellipseName: "WGS 84"
  };
  at.sphere = {
    a: 6370997,
    b: 6370997,
    ellipseName: "Normal Sphere (r=6370997)"
  };
  function Pv(i, t, e, n) {
    var s = i * i, r = t * t, a = (s - r) / s, o = 0;
    n ? (i *= 1 - a * (V1 + a * (H1 + a * J1)), s = i * i, a = 0) : o = Math.sqrt(a);
    var l = (s - r) / r;
    return {
      es: a,
      e: o,
      ep2: l
    };
  }
  function bv(i, t, e, n, s) {
    if (!i) {
      var r = un(at, n);
      r || (r = Av), i = r.a, t = r.b, e = r.rf;
    }
    return e && !t && (t = (1 - 1 / e) * i), (e === 0 || Math.abs(i - t) < Z) && (s = !0, t = i), {
      a: i,
      b: t,
      rf: e,
      sphere: s
    };
  }
  var Oa = {
    wgs84: {
      towgs84: "0,0,0",
      ellipse: "WGS84",
      datumName: "WGS84"
    },
    ch1903: {
      towgs84: "674.374,15.056,405.346",
      ellipse: "bessel",
      datumName: "swiss"
    },
    ggrs87: {
      towgs84: "-199.87,74.79,246.62",
      ellipse: "GRS80",
      datumName: "Greek_Geodetic_Reference_System_1987"
    },
    nad83: {
      towgs84: "0,0,0",
      ellipse: "GRS80",
      datumName: "North_American_Datum_1983"
    },
    nad27: {
      nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
      ellipse: "clrk66",
      datumName: "North_American_Datum_1927"
    },
    potsdam: {
      towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
      ellipse: "bessel",
      datumName: "Potsdam Rauenberg 1950 DHDN"
    },
    carthage: {
      towgs84: "-263.0,6.0,431.0",
      ellipse: "clark80",
      datumName: "Carthage 1934 Tunisia"
    },
    hermannskogel: {
      towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
      ellipse: "bessel",
      datumName: "Hermannskogel"
    },
    mgi: {
      towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
      ellipse: "bessel",
      datumName: "Militar-Geographische Institut"
    },
    osni52: {
      towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
      ellipse: "airy",
      datumName: "Irish National"
    },
    ire65: {
      towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
      ellipse: "mod_airy",
      datumName: "Ireland 1965"
    },
    rassadiran: {
      towgs84: "-133.63,-157.5,-158.62",
      ellipse: "intl",
      datumName: "Rassadiran"
    },
    nzgd49: {
      towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
      ellipse: "intl",
      datumName: "New Zealand Geodetic Datum 1949"
    },
    osgb36: {
      towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
      ellipse: "airy",
      datumName: "Ordnance Survey of Great Britain 1936"
    },
    s_jtsk: {
      towgs84: "589,76,480",
      ellipse: "bessel",
      datumName: "S-JTSK (Ferro)"
    },
    beduaram: {
      towgs84: "-106,-87,188",
      ellipse: "clrk80",
      datumName: "Beduaram"
    },
    gunung_segara: {
      towgs84: "-403,684,41",
      ellipse: "bessel",
      datumName: "Gunung Segara Jakarta"
    },
    rnb72: {
      towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
      ellipse: "intl",
      datumName: "Reseau National Belge 1972"
    }
  };
  for (var Lv in Oa) {
    var Yu = Oa[Lv];
    Oa[Yu.datumName] = Yu;
  }
  function Ov(i, t, e, n, s, r, a) {
    var o = {};
    return i === void 0 || i === "none" ? o.datum_type = jl : o.datum_type = K1, t && (o.datum_params = t.map(parseFloat), (o.datum_params[0] !== 0 || o.datum_params[1] !== 0 || o.datum_params[2] !== 0) && (o.datum_type = zn), o.datum_params.length > 3 && (o.datum_params[3] !== 0 || o.datum_params[4] !== 0 || o.datum_params[5] !== 0 || o.datum_params[6] !== 0) && (o.datum_type = Bn, o.datum_params[3] *= fr, o.datum_params[4] *= fr, o.datum_params[5] *= fr, o.datum_params[6] = o.datum_params[6] / 1e6 + 1)), a && (o.datum_type = ws, o.grids = a), o.a = e, o.b = n, o.es = s, o.ep2 = r, o;
  }
  var Kf = {};
  function Nv(i, t) {
    var e = new DataView(t), n = kv(e), s = Gv(e, n), r = Uv(e, s, n), a = { header: s, subgrids: r };
    return Kf[i] = a, a;
  }
  function Fv(i) {
    if (i === void 0)
      return null;
    var t = i.split(",");
    return t.map(Dv);
  }
  function Dv(i) {
    if (i.length === 0)
      return null;
    var t = i[0] === "@";
    return t && (i = i.slice(1)), i === "null" ? { name: "null", mandatory: !t, grid: null, isNull: !0 } : {
      name: i,
      mandatory: !t,
      grid: Kf[i] || null,
      isNull: !1
    };
  }
  function fs(i) {
    return i / 3600 * Math.PI / 180;
  }
  function kv(i) {
    var t = i.getInt32(8, !1);
    return t === 11 ? !1 : (t = i.getInt32(8, !0), t !== 11 && console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian"), !0);
  }
  function Gv(i, t) {
    return {
      nFields: i.getInt32(8, t),
      nSubgridFields: i.getInt32(24, t),
      nSubgrids: i.getInt32(40, t),
      shiftType: Hl(i, 56, 64).trim(),
      fromSemiMajorAxis: i.getFloat64(120, t),
      fromSemiMinorAxis: i.getFloat64(136, t),
      toSemiMajorAxis: i.getFloat64(152, t),
      toSemiMinorAxis: i.getFloat64(168, t)
    };
  }
  function Hl(i, t, e) {
    return String.fromCharCode.apply(null, new Uint8Array(i.buffer.slice(t, e)));
  }
  function Uv(i, t, e) {
    for (var n = 176, s = [], r = 0; r < t.nSubgrids; r++) {
      var a = Bv(i, n, e), o = $v(i, n, a, e), l = Math.round(
        1 + (a.upperLongitude - a.lowerLongitude) / a.longitudeInterval
      ), h = Math.round(
        1 + (a.upperLatitude - a.lowerLatitude) / a.latitudeInterval
      );
      s.push({
        ll: [fs(a.lowerLongitude), fs(a.lowerLatitude)],
        del: [fs(a.longitudeInterval), fs(a.latitudeInterval)],
        lim: [l, h],
        count: a.gridNodeCount,
        cvs: zv(o)
      }), n += 176 + a.gridNodeCount * 16;
    }
    return s;
  }
  function zv(i) {
    return i.map(function(t) {
      return [fs(t.longitudeShift), fs(t.latitudeShift)];
    });
  }
  function Bv(i, t, e) {
    return {
      name: Hl(i, t + 8, t + 16).trim(),
      parent: Hl(i, t + 24, t + 24 + 8).trim(),
      lowerLatitude: i.getFloat64(t + 72, e),
      upperLatitude: i.getFloat64(t + 88, e),
      lowerLongitude: i.getFloat64(t + 104, e),
      upperLongitude: i.getFloat64(t + 120, e),
      latitudeInterval: i.getFloat64(t + 136, e),
      longitudeInterval: i.getFloat64(t + 152, e),
      gridNodeCount: i.getInt32(t + 168, e)
    };
  }
  function $v(i, t, e, n) {
    for (var s = t + 176, r = 16, a = [], o = 0; o < e.gridNodeCount; o++) {
      var l = {
        latitudeShift: i.getFloat32(s + o * r, n),
        longitudeShift: i.getFloat32(s + o * r + 4, n),
        latitudeAccuracy: i.getFloat32(s + o * r + 8, n),
        longitudeAccuracy: i.getFloat32(s + o * r + 12, n)
      };
      a.push(l);
    }
    return a;
  }
  function di(i, t) {
    if (!(this instanceof di))
      return new di(i);
    t = t || function(h) {
      if (h)
        throw h;
    };
    var e = _v(i);
    if (typeof e != "object") {
      t("Could not parse to valid json: " + i);
      return;
    }
    var n = di.projections.get(e.projName);
    if (!n) {
      t("Could not get projection name from: " + i);
      return;
    }
    if (e.datumCode && e.datumCode !== "none") {
      var s = un(Oa, e.datumCode);
      s && (e.datum_params = e.datum_params || (s.towgs84 ? s.towgs84.split(",") : null), e.ellps = s.ellipse, e.datumName = s.datumName ? s.datumName : e.datumCode);
    }
    e.k0 = e.k0 || 1, e.axis = e.axis || "enu", e.ellps = e.ellps || "wgs84", e.lat1 = e.lat1 || e.lat0;
    var r = bv(e.a, e.b, e.rf, e.ellps, e.sphere), a = Pv(r.a, r.b, r.rf, e.R_A), o = Fv(e.nadgrids), l = e.datum || Ov(
      e.datumCode,
      e.datum_params,
      r.a,
      r.b,
      a.es,
      a.ep2,
      o
    );
    Xu(this, e), Xu(this, n), this.a = r.a, this.b = r.b, this.rf = r.rf, this.sphere = r.sphere, this.es = a.es, this.e = a.e, this.ep2 = a.ep2, this.datum = l, this.init(), t(null, this);
  }
  di.projections = Iv;
  di.projections.start();
  function Xv(i, t) {
    return i.datum_type !== t.datum_type || i.a !== t.a || Math.abs(i.es - t.es) > 5e-11 ? !1 : i.datum_type === zn ? i.datum_params[0] === t.datum_params[0] && i.datum_params[1] === t.datum_params[1] && i.datum_params[2] === t.datum_params[2] : i.datum_type === Bn ? i.datum_params[0] === t.datum_params[0] && i.datum_params[1] === t.datum_params[1] && i.datum_params[2] === t.datum_params[2] && i.datum_params[3] === t.datum_params[3] && i.datum_params[4] === t.datum_params[4] && i.datum_params[5] === t.datum_params[5] && i.datum_params[6] === t.datum_params[6] : !0;
  }
  function jf(i, t, e) {
    var n = i.x, s = i.y, r = i.z ? i.z : 0, a, o, l, h;
    if (s < -k && s > -1.001 * k)
      s = -k;
    else if (s > k && s < 1.001 * k)
      s = k;
    else {
      if (s < -k)
        return { x: -1 / 0, y: -1 / 0, z: i.z };
      if (s > k)
        return { x: 1 / 0, y: 1 / 0, z: i.z };
    }
    return n > Math.PI && (n -= 2 * Math.PI), o = Math.sin(s), h = Math.cos(s), l = o * o, a = e / Math.sqrt(1 - t * l), {
      x: (a + r) * h * Math.cos(n),
      y: (a + r) * h * Math.sin(n),
      z: (a * (1 - t) + r) * o
    };
  }
  function Vf(i, t, e, n) {
    var s = 1e-12, r = s * s, a = 30, o, l, h, c, u, d, m, f, y, E, x, M, C, R = i.x, S = i.y, A = i.z ? i.z : 0, O, P, L;
    if (o = Math.sqrt(R * R + S * S), l = Math.sqrt(R * R + S * S + A * A), o / e < s) {
      if (O = 0, l / e < s)
        return P = k, L = -n, {
          x: i.x,
          y: i.y,
          z: i.z
        };
    } else
      O = Math.atan2(S, R);
    h = A / l, c = o / l, u = 1 / Math.sqrt(1 - t * (2 - t) * c * c), f = c * (1 - t) * u, y = h * u, C = 0;
    do
      C++, m = e / Math.sqrt(1 - t * y * y), L = o * f + A * y - m * (1 - t * y * y), d = t * m / (m + L), u = 1 / Math.sqrt(1 - d * (2 - d) * c * c), E = c * (1 - d) * u, x = h * u, M = x * f - E * y, f = E, y = x;
    while (M * M > r && C < a);
    return P = Math.atan(x / Math.abs(E)), {
      x: O,
      y: P,
      z: L
    };
  }
  function Wv(i, t, e) {
    if (t === zn)
      return {
        x: i.x + e[0],
        y: i.y + e[1],
        z: i.z + e[2]
      };
    if (t === Bn) {
      var n = e[0], s = e[1], r = e[2], a = e[3], o = e[4], l = e[5], h = e[6];
      return {
        x: h * (i.x - l * i.y + o * i.z) + n,
        y: h * (l * i.x + i.y - a * i.z) + s,
        z: h * (-o * i.x + a * i.y + i.z) + r
      };
    }
  }
  function Yv(i, t, e) {
    if (t === zn)
      return {
        x: i.x - e[0],
        y: i.y - e[1],
        z: i.z - e[2]
      };
    if (t === Bn) {
      var n = e[0], s = e[1], r = e[2], a = e[3], o = e[4], l = e[5], h = e[6], c = (i.x - n) / h, u = (i.y - s) / h, d = (i.z - r) / h;
      return {
        x: c + l * u - o * d,
        y: -l * c + u + a * d,
        z: o * c - a * u + d
      };
    }
  }
  function Ca(i) {
    return i === zn || i === Bn;
  }
  function Zv(i, t, e) {
    if (Xv(i, t) || i.datum_type === jl || t.datum_type === jl)
      return e;
    var n = i.a, s = i.es;
    if (i.datum_type === ws) {
      var r = Zu(i, !1, e);
      if (r !== 0)
        return;
      n = zu, s = Bu;
    }
    var a = t.a, o = t.b, l = t.es;
    if (t.datum_type === ws && (a = zu, o = j1, l = Bu), s === l && n === a && !Ca(i.datum_type) && !Ca(t.datum_type))
      return e;
    if (e = jf(e, s, n), Ca(i.datum_type) && (e = Wv(e, i.datum_type, i.datum_params)), Ca(t.datum_type) && (e = Yv(e, t.datum_type, t.datum_params)), e = Vf(e, l, a, o), t.datum_type === ws) {
      var h = Zu(t, !0, e);
      if (h !== 0)
        return;
    }
    return e;
  }
  function Zu(i, t, e) {
    if (i.grids === null || i.grids.length === 0)
      return console.log("Grid shift grids not found"), -1;
    var n = { x: -e.x, y: e.y }, s = { x: Number.NaN, y: Number.NaN }, r = [];
    t:
      for (var a = 0; a < i.grids.length; a++) {
        var o = i.grids[a];
        if (r.push(o.name), o.isNull) {
          s = n;
          break;
        }
        if (o.mandatory, o.grid === null) {
          if (o.mandatory)
            return console.log("Unable to find mandatory grid '" + o.name + "'"), -1;
          continue;
        }
        for (var l = o.grid.subgrids, h = 0, c = l.length; h < c; h++) {
          var u = l[h], d = (Math.abs(u.del[1]) + Math.abs(u.del[0])) / 1e4, m = u.ll[0] - d, f = u.ll[1] - d, y = u.ll[0] + (u.lim[0] - 1) * u.del[0] + d, E = u.ll[1] + (u.lim[1] - 1) * u.del[1] + d;
          if (!(f > n.y || m > n.x || E < n.y || y < n.x) && (s = qv(n, t, u), !isNaN(s.x)))
            break t;
        }
      }
    return isNaN(s.x) ? (console.log("Failed to find a grid shift table for location '" + -n.x * ui + " " + n.y * ui + " tried: '" + r + "'"), -1) : (e.x = -s.x, e.y = s.y, 0);
  }
  function qv(i, t, e) {
    var n = { x: Number.NaN, y: Number.NaN };
    if (isNaN(i.x))
      return n;
    var s = { x: i.x, y: i.y };
    s.x -= e.ll[0], s.y -= e.ll[1], s.x = K(s.x - Math.PI) + Math.PI;
    var r = qu(s, e);
    if (t) {
      if (isNaN(r.x))
        return n;
      r.x = s.x - r.x, r.y = s.y - r.y;
      var a = 9, o = 1e-12, l, h;
      do {
        if (h = qu(r, e), isNaN(h.x)) {
          console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
          break;
        }
        l = { x: s.x - (h.x + r.x), y: s.y - (h.y + r.y) }, r.x += l.x, r.y += l.y;
      } while (a-- && Math.abs(l.x) > o && Math.abs(l.y) > o);
      if (a < 0)
        return console.log("Inverse grid shift iterator failed to converge."), n;
      n.x = K(r.x + e.ll[0]), n.y = r.y + e.ll[1];
    } else
      isNaN(r.x) || (n.x = i.x + r.x, n.y = i.y + r.y);
    return n;
  }
  function qu(i, t) {
    var e = { x: i.x / t.del[0], y: i.y / t.del[1] }, n = { x: Math.floor(e.x), y: Math.floor(e.y) }, s = { x: e.x - 1 * n.x, y: e.y - 1 * n.y }, r = { x: Number.NaN, y: Number.NaN }, a;
    if (n.x < 0 || n.x >= t.lim[0] || n.y < 0 || n.y >= t.lim[1])
      return r;
    a = n.y * t.lim[0] + n.x;
    var o = { x: t.cvs[a][0], y: t.cvs[a][1] };
    a++;
    var l = { x: t.cvs[a][0], y: t.cvs[a][1] };
    a += t.lim[0];
    var h = { x: t.cvs[a][0], y: t.cvs[a][1] };
    a--;
    var c = { x: t.cvs[a][0], y: t.cvs[a][1] }, u = s.x * s.y, d = s.x * (1 - s.y), m = (1 - s.x) * (1 - s.y), f = (1 - s.x) * s.y;
    return r.x = m * o.x + d * l.x + f * c.x + u * h.x, r.y = m * o.y + d * l.y + f * c.y + u * h.y, r;
  }
  function Ku(i, t, e) {
    var n = e.x, s = e.y, r = e.z || 0, a, o, l, h = {};
    for (l = 0; l < 3; l++)
      if (!(t && l === 2 && e.z === void 0))
        switch (l === 0 ? (a = n, "ew".indexOf(i.axis[l]) !== -1 ? o = "x" : o = "y") : l === 1 ? (a = s, "ns".indexOf(i.axis[l]) !== -1 ? o = "y" : o = "x") : (a = r, o = "z"), i.axis[l]) {
          case "e":
            h[o] = a;
            break;
          case "w":
            h[o] = -a;
            break;
          case "n":
            h[o] = a;
            break;
          case "s":
            h[o] = -a;
            break;
          case "u":
            e[o] !== void 0 && (h.z = a);
            break;
          case "d":
            e[o] !== void 0 && (h.z = -a);
            break;
          default:
            return null;
        }
    return h;
  }
  function Hf(i) {
    var t = {
      x: i[0],
      y: i[1]
    };
    return i.length > 2 && (t.z = i[2]), i.length > 3 && (t.m = i[3]), t;
  }
  function Kv(i) {
    ju(i.x), ju(i.y);
  }
  function ju(i) {
    if (typeof Number.isFinite == "function") {
      if (Number.isFinite(i))
        return;
      throw new TypeError("coordinates must be finite numbers");
    }
    if (typeof i != "number" || i !== i || !isFinite(i))
      throw new TypeError("coordinates must be finite numbers");
  }
  function jv(i, t) {
    return (i.datum.datum_type === zn || i.datum.datum_type === Bn || i.datum.datum_type === ws) && t.datumCode !== "WGS84" || (t.datum.datum_type === zn || t.datum.datum_type === Bn || t.datum.datum_type === ws) && i.datumCode !== "WGS84";
  }
  function so(i, t, e, n) {
    var s;
    Array.isArray(e) ? e = Hf(e) : e = {
      x: e.x,
      y: e.y,
      z: e.z,
      m: e.m
    };
    var r = e.z !== void 0;
    if (Kv(e), i.datum && t.datum && jv(i, t) && (s = new di("WGS84"), e = so(i, s, e, n), i = s), n && i.axis !== "enu" && (e = Ku(i, !1, e)), i.projName === "longlat")
      e = {
        x: e.x * te,
        y: e.y * te,
        z: e.z || 0
      };
    else if (i.to_meter && (e = {
      x: e.x * i.to_meter,
      y: e.y * i.to_meter,
      z: e.z || 0
    }), e = i.inverse(e), !e)
      return;
    if (i.from_greenwich && (e.x += i.from_greenwich), e = Zv(i.datum, t.datum, e), !!e)
      return t.from_greenwich && (e = {
        x: e.x - t.from_greenwich,
        y: e.y,
        z: e.z || 0
      }), t.projName === "longlat" ? e = {
        x: e.x * ui,
        y: e.y * ui,
        z: e.z || 0
      } : (e = t.forward(e), t.to_meter && (e = {
        x: e.x / t.to_meter,
        y: e.y / t.to_meter,
        z: e.z || 0
      })), n && t.axis !== "enu" ? Ku(t, !0, e) : (e && !r && delete e.z, e);
  }
  var Vu = di("WGS84");
  function Ml(i, t, e, n) {
    var s, r, a;
    return Array.isArray(e) ? (s = so(i, t, e, n) || { x: NaN, y: NaN }, e.length > 2 ? typeof i.name < "u" && i.name === "geocent" || typeof t.name < "u" && t.name === "geocent" ? typeof s.z == "number" ? [s.x, s.y, s.z].concat(e.slice(3)) : [s.x, s.y, e[2]].concat(e.slice(3)) : [s.x, s.y].concat(e.slice(2)) : [s.x, s.y]) : (r = so(i, t, e, n), a = Object.keys(e), a.length === 2 || a.forEach(function(o) {
      if (typeof i.name < "u" && i.name === "geocent" || typeof t.name < "u" && t.name === "geocent") {
        if (o === "x" || o === "y" || o === "z")
          return;
      } else if (o === "x" || o === "y")
        return;
      r[o] = e[o];
    }), r);
  }
  function Hu(i) {
    return i instanceof di ? i : i.oProj ? i.oProj : di(i);
  }
  function ue(i, t, e) {
    i = Hu(i);
    var n = !1, s;
    return typeof t > "u" ? (t = i, i = Vu, n = !0) : (typeof t.x < "u" || Array.isArray(t)) && (e = t, t = i, i = Vu, n = !0), t = Hu(t), e ? Ml(i, t, e) : (s = {
      forward: function(r, a) {
        return Ml(i, t, r, a);
      },
      inverse: function(r, a) {
        return Ml(t, i, r, a);
      }
    }, n && (s.oProj = t), s);
  }
  var Ju = 6, Jf = "AJSAJS", Qf = "AFAFAF", gs = 65, Me = 73, ze = 79, ar = 86, or = 90;
  const Vv = {
    forward: tg,
    inverse: Hv,
    toPoint: eg
  };
  function tg(i, t) {
    return t = t || 5, tE(Jv({
      lat: i[1],
      lon: i[0]
    }), t);
  }
  function Hv(i) {
    var t = nc(ng(i.toUpperCase()));
    return t.lat && t.lon ? [t.lon, t.lat, t.lon, t.lat] : [t.left, t.bottom, t.right, t.top];
  }
  function eg(i) {
    var t = nc(ng(i.toUpperCase()));
    return t.lat && t.lon ? [t.lon, t.lat] : [(t.left + t.right) / 2, (t.top + t.bottom) / 2];
  }
  function wl(i) {
    return i * (Math.PI / 180);
  }
  function Qu(i) {
    return 180 * (i / Math.PI);
  }
  function Jv(i) {
    var t = i.lat, e = i.lon, n = 6378137, s = 669438e-8, r = 0.9996, a, o, l, h, c, u, d, m = wl(t), f = wl(e), y, E;
    E = Math.floor((e + 180) / 6) + 1, e === 180 && (E = 60), t >= 56 && t < 64 && e >= 3 && e < 12 && (E = 32), t >= 72 && t < 84 && (e >= 0 && e < 9 ? E = 31 : e >= 9 && e < 21 ? E = 33 : e >= 21 && e < 33 ? E = 35 : e >= 33 && e < 42 && (E = 37)), a = (E - 1) * 6 - 180 + 3, y = wl(a), o = s / (1 - s), l = n / Math.sqrt(1 - s * Math.sin(m) * Math.sin(m)), h = Math.tan(m) * Math.tan(m), c = o * Math.cos(m) * Math.cos(m), u = Math.cos(m) * (f - y), d = n * ((1 - s / 4 - 3 * s * s / 64 - 5 * s * s * s / 256) * m - (3 * s / 8 + 3 * s * s / 32 + 45 * s * s * s / 1024) * Math.sin(2 * m) + (15 * s * s / 256 + 45 * s * s * s / 1024) * Math.sin(4 * m) - 35 * s * s * s / 3072 * Math.sin(6 * m));
    var x = r * l * (u + (1 - h + c) * u * u * u / 6 + (5 - 18 * h + h * h + 72 * c - 58 * o) * u * u * u * u * u / 120) + 5e5, M = r * (d + l * Math.tan(m) * (u * u / 2 + (5 - h + 9 * c + 4 * c * c) * u * u * u * u / 24 + (61 - 58 * h + h * h + 600 * c - 330 * o) * u * u * u * u * u * u / 720));
    return t < 0 && (M += 1e7), {
      northing: Math.round(M),
      easting: Math.round(x),
      zoneNumber: E,
      zoneLetter: Qv(t)
    };
  }
  function nc(i) {
    var t = i.northing, e = i.easting, n = i.zoneLetter, s = i.zoneNumber;
    if (s < 0 || s > 60)
      return null;
    var r = 0.9996, a = 6378137, o = 669438e-8, l, h = (1 - Math.sqrt(1 - o)) / (1 + Math.sqrt(1 - o)), c, u, d, m, f, y, E, x, M, C = e - 5e5, R = t;
    n < "N" && (R -= 1e7), E = (s - 1) * 6 - 180 + 3, l = o / (1 - o), y = R / r, x = y / (a * (1 - o / 4 - 3 * o * o / 64 - 5 * o * o * o / 256)), M = x + (3 * h / 2 - 27 * h * h * h / 32) * Math.sin(2 * x) + (21 * h * h / 16 - 55 * h * h * h * h / 32) * Math.sin(4 * x) + 151 * h * h * h / 96 * Math.sin(6 * x), c = a / Math.sqrt(1 - o * Math.sin(M) * Math.sin(M)), u = Math.tan(M) * Math.tan(M), d = l * Math.cos(M) * Math.cos(M), m = a * (1 - o) / Math.pow(1 - o * Math.sin(M) * Math.sin(M), 1.5), f = C / (c * r);
    var S = M - c * Math.tan(M) / m * (f * f / 2 - (5 + 3 * u + 10 * d - 4 * d * d - 9 * l) * f * f * f * f / 24 + (61 + 90 * u + 298 * d + 45 * u * u - 252 * l - 3 * d * d) * f * f * f * f * f * f / 720);
    S = Qu(S);
    var A = (f - (1 + 2 * u + d) * f * f * f / 6 + (5 - 2 * d + 28 * u - 3 * d * d + 8 * l + 24 * u * u) * f * f * f * f * f / 120) / Math.cos(M);
    A = E + Qu(A);
    var O;
    if (i.accuracy) {
      var P = nc({
        northing: i.northing + i.accuracy,
        easting: i.easting + i.accuracy,
        zoneLetter: i.zoneLetter,
        zoneNumber: i.zoneNumber
      });
      O = {
        top: P.lat,
        right: P.lon,
        bottom: S,
        left: A
      };
    } else
      O = {
        lat: S,
        lon: A
      };
    return O;
  }
  function Qv(i) {
    var t = "Z";
    return 84 >= i && i >= 72 ? t = "X" : 72 > i && i >= 64 ? t = "W" : 64 > i && i >= 56 ? t = "V" : 56 > i && i >= 48 ? t = "U" : 48 > i && i >= 40 ? t = "T" : 40 > i && i >= 32 ? t = "S" : 32 > i && i >= 24 ? t = "R" : 24 > i && i >= 16 ? t = "Q" : 16 > i && i >= 8 ? t = "P" : 8 > i && i >= 0 ? t = "N" : 0 > i && i >= -8 ? t = "M" : -8 > i && i >= -16 ? t = "L" : -16 > i && i >= -24 ? t = "K" : -24 > i && i >= -32 ? t = "J" : -32 > i && i >= -40 ? t = "H" : -40 > i && i >= -48 ? t = "G" : -48 > i && i >= -56 ? t = "F" : -56 > i && i >= -64 ? t = "E" : -64 > i && i >= -72 ? t = "D" : -72 > i && i >= -80 && (t = "C"), t;
  }
  function tE(i, t) {
    var e = "00000" + i.easting, n = "00000" + i.northing;
    return i.zoneNumber + i.zoneLetter + eE(i.easting, i.northing, i.zoneNumber) + e.substr(e.length - 5, t) + n.substr(n.length - 5, t);
  }
  function eE(i, t, e) {
    var n = ig(e), s = Math.floor(i / 1e5), r = Math.floor(t / 1e5) % 20;
    return iE(s, r, n);
  }
  function ig(i) {
    var t = i % Ju;
    return t === 0 && (t = Ju), t;
  }
  function iE(i, t, e) {
    var n = e - 1, s = Jf.charCodeAt(n), r = Qf.charCodeAt(n), a = s + i - 1, o = r + t, l = !1;
    a > or && (a = a - or + gs - 1, l = !0), (a === Me || s < Me && a > Me || (a > Me || s < Me) && l) && a++, (a === ze || s < ze && a > ze || (a > ze || s < ze) && l) && (a++, a === Me && a++), a > or && (a = a - or + gs - 1), o > ar ? (o = o - ar + gs - 1, l = !0) : l = !1, (o === Me || r < Me && o > Me || (o > Me || r < Me) && l) && o++, (o === ze || r < ze && o > ze || (o > ze || r < ze) && l) && (o++, o === Me && o++), o > ar && (o = o - ar + gs - 1);
    var h = String.fromCharCode(a) + String.fromCharCode(o);
    return h;
  }
  function ng(i) {
    if (i && i.length === 0)
      throw "MGRSPoint coverting from nothing";
    for (var t = i.length, e = null, n = "", s, r = 0; !/[A-Z]/.test(s = i.charAt(r)); ) {
      if (r >= 2)
        throw "MGRSPoint bad conversion from: " + i;
      n += s, r++;
    }
    var a = parseInt(n, 10);
    if (r === 0 || r + 3 > t)
      throw "MGRSPoint bad conversion from: " + i;
    var o = i.charAt(r++);
    if (o <= "A" || o === "B" || o === "Y" || o >= "Z" || o === "I" || o === "O")
      throw "MGRSPoint zone letter " + o + " not handled: " + i;
    e = i.substring(r, r += 2);
    for (var l = ig(a), h = nE(e.charAt(0), l), c = sE(e.charAt(1), l); c < rE(o); )
      c += 2e6;
    var u = t - r;
    if (u % 2 !== 0)
      throw `MGRSPoint has to have an even number 
of digits after the zone letter and two 100km letters - front 
half for easting meters, second half for 
northing meters` + i;
    var d = u / 2, m = 0, f = 0, y, E, x, M, C;
    return d > 0 && (y = 1e5 / Math.pow(10, d), E = i.substring(r, r + d), m = parseFloat(E) * y, x = i.substring(r + d), f = parseFloat(x) * y), M = m + h, C = f + c, {
      easting: M,
      northing: C,
      zoneLetter: o,
      zoneNumber: a,
      accuracy: y
    };
  }
  function nE(i, t) {
    for (var e = Jf.charCodeAt(t - 1), n = 1e5, s = !1; e !== i.charCodeAt(0); ) {
      if (e++, e === Me && e++, e === ze && e++, e > or) {
        if (s)
          throw "Bad character: " + i;
        e = gs, s = !0;
      }
      n += 1e5;
    }
    return n;
  }
  function sE(i, t) {
    if (i > "V")
      throw "MGRSPoint given invalid Northing " + i;
    for (var e = Qf.charCodeAt(t - 1), n = 0, s = !1; e !== i.charCodeAt(0); ) {
      if (e++, e === Me && e++, e === ze && e++, e > ar) {
        if (s)
          throw "Bad character: " + i;
        e = gs, s = !0;
      }
      n += 1e5;
    }
    return n;
  }
  function rE(i) {
    var t;
    switch (i) {
      case "C":
        t = 11e5;
        break;
      case "D":
        t = 2e6;
        break;
      case "E":
        t = 28e5;
        break;
      case "F":
        t = 37e5;
        break;
      case "G":
        t = 46e5;
        break;
      case "H":
        t = 55e5;
        break;
      case "J":
        t = 64e5;
        break;
      case "K":
        t = 73e5;
        break;
      case "L":
        t = 82e5;
        break;
      case "M":
        t = 91e5;
        break;
      case "N":
        t = 0;
        break;
      case "P":
        t = 8e5;
        break;
      case "Q":
        t = 17e5;
        break;
      case "R":
        t = 26e5;
        break;
      case "S":
        t = 35e5;
        break;
      case "T":
        t = 44e5;
        break;
      case "U":
        t = 53e5;
        break;
      case "V":
        t = 62e5;
        break;
      case "W":
        t = 7e6;
        break;
      case "X":
        t = 79e5;
        break;
      default:
        t = -1;
    }
    if (t >= 0)
      return t;
    throw "Invalid zone letter: " + i;
  }
  function Gs(i, t, e) {
    if (!(this instanceof Gs))
      return new Gs(i, t, e);
    if (Array.isArray(i))
      this.x = i[0], this.y = i[1], this.z = i[2] || 0;
    else if (typeof i == "object")
      this.x = i.x, this.y = i.y, this.z = i.z || 0;
    else if (typeof i == "string" && typeof t > "u") {
      var n = i.split(",");
      this.x = parseFloat(n[0], 10), this.y = parseFloat(n[1], 10), this.z = parseFloat(n[2], 10) || 0;
    } else
      this.x = i, this.y = t, this.z = e || 0;
    console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
  }
  Gs.fromMGRS = function(i) {
    return new Gs(eg(i));
  };
  Gs.prototype.toMGRS = function(i) {
    return tg([this.x, this.y], i);
  };
  var aE = 1, oE = 0.25, td = 0.046875, ed = 0.01953125, id = 0.01068115234375, lE = 0.75, hE = 0.46875, cE = 0.013020833333333334, uE = 0.007120768229166667, dE = 0.3645833333333333, fE = 0.005696614583333333, gE = 0.3076171875;
  function sc(i) {
    var t = [];
    t[0] = aE - i * (oE + i * (td + i * (ed + i * id))), t[1] = i * (lE - i * (td + i * (ed + i * id)));
    var e = i * i;
    return t[2] = e * (hE - i * (cE + i * uE)), e *= i, t[3] = e * (dE - i * fE), t[4] = e * i * gE, t;
  }
  function Xs(i, t, e, n) {
    return e *= t, t *= t, n[0] * i - e * (n[1] + t * (n[2] + t * (n[3] + t * n[4])));
  }
  var mE = 20;
  function rc(i, t, e) {
    for (var n = 1 / (1 - t), s = i, r = mE; r; --r) {
      var a = Math.sin(s), o = 1 - t * a * a;
      if (o = (Xs(s, a, Math.cos(s), e) - i) * (o * Math.sqrt(o)) * n, s -= o, Math.abs(o) < Z)
        return s;
    }
    return s;
  }
  function _E() {
    this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.es && (this.en = sc(this.es), this.ml0 = Xs(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
  }
  function pE(i) {
    var t = i.x, e = i.y, n = K(t - this.long0), s, r, a, o = Math.sin(e), l = Math.cos(e);
    if (this.es) {
      var c = l * n, u = Math.pow(c, 2), d = this.ep2 * Math.pow(l, 2), m = Math.pow(d, 2), f = Math.abs(l) > Z ? Math.tan(e) : 0, y = Math.pow(f, 2), E = Math.pow(y, 2);
      s = 1 - this.es * Math.pow(o, 2), c = c / Math.sqrt(s);
      var x = Xs(e, o, l, this.en);
      r = this.a * (this.k0 * c * (1 + u / 6 * (1 - y + d + u / 20 * (5 - 18 * y + E + 14 * d - 58 * y * d + u / 42 * (61 + 179 * E - E * y - 479 * y))))) + this.x0, a = this.a * (this.k0 * (x - this.ml0 + o * n * c / 2 * (1 + u / 12 * (5 - y + 9 * d + 4 * m + u / 30 * (61 + E - 58 * y + 270 * d - 330 * y * d + u / 56 * (1385 + 543 * E - E * y - 3111 * y)))))) + this.y0;
    } else {
      var h = l * Math.sin(n);
      if (Math.abs(Math.abs(h) - 1) < Z)
        return 93;
      if (r = 0.5 * this.a * this.k0 * Math.log((1 + h) / (1 - h)) + this.x0, a = l * Math.cos(n) / Math.sqrt(1 - Math.pow(h, 2)), h = Math.abs(a), h >= 1) {
        if (h - 1 > Z)
          return 93;
        a = 0;
      } else
        a = Math.acos(a);
      e < 0 && (a = -a), a = this.a * this.k0 * (a - this.lat0) + this.y0;
    }
    return i.x = r, i.y = a, i;
  }
  function yE(i) {
    var t, e, n, s, r = (i.x - this.x0) * (1 / this.a), a = (i.y - this.y0) * (1 / this.a);
    if (this.es)
      if (t = this.ml0 + a / this.k0, e = rc(t, this.es, this.en), Math.abs(e) < k) {
        var u = Math.sin(e), d = Math.cos(e), m = Math.abs(d) > Z ? Math.tan(e) : 0, f = this.ep2 * Math.pow(d, 2), y = Math.pow(f, 2), E = Math.pow(m, 2), x = Math.pow(E, 2);
        t = 1 - this.es * Math.pow(u, 2);
        var M = r * Math.sqrt(t) / this.k0, C = Math.pow(M, 2);
        t = t * m, n = e - t * C / (1 - this.es) * 0.5 * (1 - C / 12 * (5 + 3 * E - 9 * f * E + f - 4 * y - C / 30 * (61 + 90 * E - 252 * f * E + 45 * x + 46 * f - C / 56 * (1385 + 3633 * E + 4095 * x + 1574 * x * E)))), s = K(this.long0 + M * (1 - C / 6 * (1 + 2 * E + f - C / 20 * (5 + 28 * E + 24 * x + 8 * f * E + 6 * f - C / 42 * (61 + 662 * E + 1320 * x + 720 * x * E)))) / d);
      } else
        n = k * Hr(a), s = 0;
    else {
      var o = Math.exp(r / this.k0), l = 0.5 * (o - 1 / o), h = this.lat0 + a / this.k0, c = Math.cos(h);
      t = Math.sqrt((1 - Math.pow(c, 2)) / (1 + Math.pow(l, 2))), n = Math.asin(t), a < 0 && (n = -n), l === 0 && c === 0 ? s = 0 : s = K(Math.atan2(l, c) + this.long0);
    }
    return i.x = s, i.y = n, i;
  }
  var vE = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
  const Na = {
    init: _E,
    forward: pE,
    inverse: yE,
    names: vE
  };
  function sg(i) {
    var t = Math.exp(i);
    return t = (t - 1 / t) / 2, t;
  }
  function Te(i, t) {
    i = Math.abs(i), t = Math.abs(t);
    var e = Math.max(i, t), n = Math.min(i, t) / (e || 1);
    return e * Math.sqrt(1 + Math.pow(n, 2));
  }
  function EE(i) {
    var t = 1 + i, e = t - 1;
    return e === 0 ? i : i * Math.log(t) / e;
  }
  function xE(i) {
    var t = Math.abs(i);
    return t = EE(t * (1 + t / (Te(1, t) + 1))), i < 0 ? -t : t;
  }
  function ac(i, t) {
    for (var e = 2 * Math.cos(2 * t), n = i.length - 1, s = i[n], r = 0, a; --n >= 0; )
      a = -r + e * s + i[n], r = s, s = a;
    return t + a * Math.sin(2 * t);
  }
  function ME(i, t) {
    for (var e = 2 * Math.cos(t), n = i.length - 1, s = i[n], r = 0, a; --n >= 0; )
      a = -r + e * s + i[n], r = s, s = a;
    return Math.sin(t) * a;
  }
  function wE(i) {
    var t = Math.exp(i);
    return t = (t + 1 / t) / 2, t;
  }
  function rg(i, t, e) {
    for (var n = Math.sin(t), s = Math.cos(t), r = sg(e), a = wE(e), o = 2 * s * a, l = -2 * n * r, h = i.length - 1, c = i[h], u = 0, d = 0, m = 0, f, y; --h >= 0; )
      f = d, y = u, d = c, u = m, c = -f + o * d - l * u + i[h], m = -y + l * d + o * u;
    return o = n * a, l = s * r, [o * c - l * m, o * m + l * c];
  }
  function RE() {
    if (!this.approx && (isNaN(this.es) || this.es <= 0))
      throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
    this.approx && (Na.init.apply(this), this.forward = Na.forward, this.inverse = Na.inverse), this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
    var i = this.es / (1 + Math.sqrt(1 - this.es)), t = i / (2 - i), e = t;
    this.cgb[0] = t * (2 + t * (-2 / 3 + t * (-2 + t * (116 / 45 + t * (26 / 45 + t * (-2854 / 675)))))), this.cbg[0] = t * (-2 + t * (2 / 3 + t * (4 / 3 + t * (-82 / 45 + t * (32 / 45 + t * (4642 / 4725)))))), e = e * t, this.cgb[1] = e * (7 / 3 + t * (-8 / 5 + t * (-227 / 45 + t * (2704 / 315 + t * (2323 / 945))))), this.cbg[1] = e * (5 / 3 + t * (-16 / 15 + t * (-13 / 9 + t * (904 / 315 + t * (-1522 / 945))))), e = e * t, this.cgb[2] = e * (56 / 15 + t * (-136 / 35 + t * (-1262 / 105 + t * (73814 / 2835)))), this.cbg[2] = e * (-26 / 15 + t * (34 / 21 + t * (8 / 5 + t * (-12686 / 2835)))), e = e * t, this.cgb[3] = e * (4279 / 630 + t * (-332 / 35 + t * (-399572 / 14175))), this.cbg[3] = e * (1237 / 630 + t * (-12 / 5 + t * (-24832 / 14175))), e = e * t, this.cgb[4] = e * (4174 / 315 + t * (-144838 / 6237)), this.cbg[4] = e * (-734 / 315 + t * (109598 / 31185)), e = e * t, this.cgb[5] = e * (601676 / 22275), this.cbg[5] = e * (444337 / 155925), e = Math.pow(t, 2), this.Qn = this.k0 / (1 + t) * (1 + e * (1 / 4 + e * (1 / 64 + e / 256))), this.utg[0] = t * (-0.5 + t * (2 / 3 + t * (-37 / 96 + t * (1 / 360 + t * (81 / 512 + t * (-96199 / 604800)))))), this.gtu[0] = t * (0.5 + t * (-2 / 3 + t * (5 / 16 + t * (41 / 180 + t * (-127 / 288 + t * (7891 / 37800)))))), this.utg[1] = e * (-1 / 48 + t * (-1 / 15 + t * (437 / 1440 + t * (-46 / 105 + t * (1118711 / 3870720))))), this.gtu[1] = e * (13 / 48 + t * (-3 / 5 + t * (557 / 1440 + t * (281 / 630 + t * (-1983433 / 1935360))))), e = e * t, this.utg[2] = e * (-17 / 480 + t * (37 / 840 + t * (209 / 4480 + t * (-5569 / 90720)))), this.gtu[2] = e * (61 / 240 + t * (-103 / 140 + t * (15061 / 26880 + t * (167603 / 181440)))), e = e * t, this.utg[3] = e * (-4397 / 161280 + t * (11 / 504 + t * (830251 / 7257600))), this.gtu[3] = e * (49561 / 161280 + t * (-179 / 168 + t * (6601661 / 7257600))), e = e * t, this.utg[4] = e * (-4583 / 161280 + t * (108847 / 3991680)), this.gtu[4] = e * (34729 / 80640 + t * (-3418889 / 1995840)), e = e * t, this.utg[5] = e * (-20648693 / 638668800), this.gtu[5] = e * (212378941 / 319334400);
    var n = ac(this.cbg, this.lat0);
    this.Zb = -this.Qn * (n + ME(this.gtu, 2 * n));
  }
  function SE(i) {
    var t = K(i.x - this.long0), e = i.y;
    e = ac(this.cbg, e);
    var n = Math.sin(e), s = Math.cos(e), r = Math.sin(t), a = Math.cos(t);
    e = Math.atan2(n, a * s), t = Math.atan2(r * s, Te(n, s * a)), t = xE(Math.tan(t));
    var o = rg(this.gtu, 2 * e, 2 * t);
    e = e + o[0], t = t + o[1];
    var l, h;
    return Math.abs(t) <= 2.623395162778 ? (l = this.a * (this.Qn * t) + this.x0, h = this.a * (this.Qn * e + this.Zb) + this.y0) : (l = 1 / 0, h = 1 / 0), i.x = l, i.y = h, i;
  }
  function CE(i) {
    var t = (i.x - this.x0) * (1 / this.a), e = (i.y - this.y0) * (1 / this.a);
    e = (e - this.Zb) / this.Qn, t = t / this.Qn;
    var n, s;
    if (Math.abs(t) <= 2.623395162778) {
      var r = rg(this.utg, 2 * e, 2 * t);
      e = e + r[0], t = t + r[1], t = Math.atan(sg(t));
      var a = Math.sin(e), o = Math.cos(e), l = Math.sin(t), h = Math.cos(t);
      e = Math.atan2(a * h, Te(l, h * o)), t = Math.atan2(l, h * o), n = K(t + this.long0), s = ac(this.cgb, e);
    } else
      n = 1 / 0, s = 1 / 0;
    return i.x = n, i.y = s, i;
  }
  var TE = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "Gauss Kruger", "Gauss_Kruger", "tmerc"];
  const Fa = {
    init: RE,
    forward: SE,
    inverse: CE,
    names: TE
  };
  function IE(i, t) {
    if (i === void 0) {
      if (i = Math.floor((K(t) + Math.PI) * 30 / Math.PI) + 1, i < 0)
        return 0;
      if (i > 60)
        return 60;
    }
    return i;
  }
  var AE = "etmerc";
  function PE() {
    var i = IE(this.zone, this.long0);
    if (i === void 0)
      throw new Error("unknown utm zone");
    this.lat0 = 0, this.long0 = (6 * Math.abs(i) - 183) * te, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, Fa.init.apply(this), this.forward = Fa.forward, this.inverse = Fa.inverse;
  }
  var bE = ["Universal Transverse Mercator System", "utm"];
  const LE = {
    init: PE,
    names: bE,
    dependsOn: AE
  };
  function oc(i, t) {
    return Math.pow((1 - i) / (1 + i), t);
  }
  var OE = 20;
  function NE() {
    var i = Math.sin(this.lat0), t = Math.cos(this.lat0);
    t *= t, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * i * i), this.C = Math.sqrt(1 + this.es * t * t / (1 - this.es)), this.phic0 = Math.asin(i / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + Tt) / (Math.pow(Math.tan(0.5 * this.lat0 + Tt), this.C) * oc(this.e * i, this.ratexp));
  }
  function FE(i) {
    var t = i.x, e = i.y;
    return i.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * e + Tt), this.C) * oc(this.e * Math.sin(e), this.ratexp)) - k, i.x = this.C * t, i;
  }
  function DE(i) {
    for (var t = 1e-14, e = i.x / this.C, n = i.y, s = Math.pow(Math.tan(0.5 * n + Tt) / this.K, 1 / this.C), r = OE; r > 0 && (n = 2 * Math.atan(s * oc(this.e * Math.sin(i.y), -0.5 * this.e)) - k, !(Math.abs(n - i.y) < t)); --r)
      i.y = n;
    return r ? (i.x = e, i.y = n, i) : null;
  }
  var kE = ["gauss"];
  const lc = {
    init: NE,
    forward: FE,
    inverse: DE,
    names: kE
  };
  function GE() {
    lc.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
  }
  function UE(i) {
    var t, e, n, s;
    return i.x = K(i.x - this.long0), lc.forward.apply(this, [i]), t = Math.sin(i.y), e = Math.cos(i.y), n = Math.cos(i.x), s = this.k0 * this.R2 / (1 + this.sinc0 * t + this.cosc0 * e * n), i.x = s * e * Math.sin(i.x), i.y = s * (this.cosc0 * t - this.sinc0 * e * n), i.x = this.a * i.x + this.x0, i.y = this.a * i.y + this.y0, i;
  }
  function zE(i) {
    var t, e, n, s, r;
    if (i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a, i.x /= this.k0, i.y /= this.k0, r = Te(i.x, i.y)) {
      var a = 2 * Math.atan2(r, this.R2);
      t = Math.sin(a), e = Math.cos(a), s = Math.asin(e * this.sinc0 + i.y * t * this.cosc0 / r), n = Math.atan2(i.x * t, r * this.cosc0 * e - i.y * this.sinc0 * t);
    } else
      s = this.phic0, n = 0;
    return i.x = n, i.y = s, lc.inverse.apply(this, [i]), i.x = K(i.x + this.long0), i;
  }
  var BE = ["Stereographic_North_Pole", "Oblique_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
  const $E = {
    init: GE,
    forward: UE,
    inverse: zE,
    names: BE
  };
  function XE(i, t, e) {
    return t *= e, Math.tan(0.5 * (k + i)) * Math.pow((1 - t) / (1 + t), 0.5 * e);
  }
  function WE() {
    this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= Z && (this.k0 = 0.5 * (1 + Hr(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= Z && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= Z && Math.abs(Math.cos(this.lat_ts)) > Z && (this.k0 = 0.5 * this.cons * mi(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / ii(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = mi(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - k, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
  }
  function YE(i) {
    var t = i.x, e = i.y, n = Math.sin(e), s = Math.cos(e), r, a, o, l, h, c, u = K(t - this.long0);
    return Math.abs(Math.abs(t - this.long0) - Math.PI) <= Z && Math.abs(e + this.lat0) <= Z ? (i.x = NaN, i.y = NaN, i) : this.sphere ? (r = 2 * this.k0 / (1 + this.sinlat0 * n + this.coslat0 * s * Math.cos(u)), i.x = this.a * r * s * Math.sin(u) + this.x0, i.y = this.a * r * (this.coslat0 * n - this.sinlat0 * s * Math.cos(u)) + this.y0, i) : (a = 2 * Math.atan(this.ssfn_(e, n, this.e)) - k, l = Math.cos(a), o = Math.sin(a), Math.abs(this.coslat0) <= Z ? (h = ii(this.e, e * this.con, this.con * n), c = 2 * this.a * this.k0 * h / this.cons, i.x = this.x0 + c * Math.sin(t - this.long0), i.y = this.y0 - this.con * c * Math.cos(t - this.long0), i) : (Math.abs(this.sinlat0) < Z ? (r = 2 * this.a * this.k0 / (1 + l * Math.cos(u)), i.y = r * o) : (r = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * o + this.cosX0 * l * Math.cos(u))), i.y = r * (this.cosX0 * o - this.sinX0 * l * Math.cos(u)) + this.y0), i.x = r * l * Math.sin(u) + this.x0, i));
  }
  function ZE(i) {
    i.x -= this.x0, i.y -= this.y0;
    var t, e, n, s, r, a = Math.sqrt(i.x * i.x + i.y * i.y);
    if (this.sphere) {
      var o = 2 * Math.atan(a / (2 * this.a * this.k0));
      return t = this.long0, e = this.lat0, a <= Z ? (i.x = t, i.y = e, i) : (e = Math.asin(Math.cos(o) * this.sinlat0 + i.y * Math.sin(o) * this.coslat0 / a), Math.abs(this.coslat0) < Z ? this.lat0 > 0 ? t = K(this.long0 + Math.atan2(i.x, -1 * i.y)) : t = K(this.long0 + Math.atan2(i.x, i.y)) : t = K(this.long0 + Math.atan2(i.x * Math.sin(o), a * this.coslat0 * Math.cos(o) - i.y * this.sinlat0 * Math.sin(o))), i.x = t, i.y = e, i);
    } else if (Math.abs(this.coslat0) <= Z) {
      if (a <= Z)
        return e = this.lat0, t = this.long0, i.x = t, i.y = e, i;
      i.x *= this.con, i.y *= this.con, n = a * this.cons / (2 * this.a * this.k0), e = this.con * Or(this.e, n), t = this.con * K(this.con * this.long0 + Math.atan2(i.x, -1 * i.y));
    } else
      s = 2 * Math.atan(a * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), t = this.long0, a <= Z ? r = this.X0 : (r = Math.asin(Math.cos(s) * this.sinX0 + i.y * Math.sin(s) * this.cosX0 / a), t = K(this.long0 + Math.atan2(i.x * Math.sin(s), a * this.cosX0 * Math.cos(s) - i.y * this.sinX0 * Math.sin(s)))), e = -1 * Or(this.e, Math.tan(0.5 * (k + r)));
    return i.x = t, i.y = e, i;
  }
  var qE = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)", "Polar_Stereographic"];
  const KE = {
    init: WE,
    forward: YE,
    inverse: ZE,
    names: qE,
    ssfn_: XE
  };
  function jE() {
    var i = this.lat0;
    this.lambda0 = this.long0;
    var t = Math.sin(i), e = this.a, n = this.rf, s = 1 / n, r = 2 * s - Math.pow(s, 2), a = this.e = Math.sqrt(r);
    this.R = this.k0 * e * Math.sqrt(1 - r) / (1 - r * Math.pow(t, 2)), this.alpha = Math.sqrt(1 + r / (1 - r) * Math.pow(Math.cos(i), 4)), this.b0 = Math.asin(t / this.alpha);
    var o = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), l = Math.log(Math.tan(Math.PI / 4 + i / 2)), h = Math.log((1 + a * t) / (1 - a * t));
    this.K = o - this.alpha * l + this.alpha * a / 2 * h;
  }
  function VE(i) {
    var t = Math.log(Math.tan(Math.PI / 4 - i.y / 2)), e = this.e / 2 * Math.log((1 + this.e * Math.sin(i.y)) / (1 - this.e * Math.sin(i.y))), n = -this.alpha * (t + e) + this.K, s = 2 * (Math.atan(Math.exp(n)) - Math.PI / 4), r = this.alpha * (i.x - this.lambda0), a = Math.atan(Math.sin(r) / (Math.sin(this.b0) * Math.tan(s) + Math.cos(this.b0) * Math.cos(r))), o = Math.asin(Math.cos(this.b0) * Math.sin(s) - Math.sin(this.b0) * Math.cos(s) * Math.cos(r));
    return i.y = this.R / 2 * Math.log((1 + Math.sin(o)) / (1 - Math.sin(o))) + this.y0, i.x = this.R * a + this.x0, i;
  }
  function HE(i) {
    for (var t = i.x - this.x0, e = i.y - this.y0, n = t / this.R, s = 2 * (Math.atan(Math.exp(e / this.R)) - Math.PI / 4), r = Math.asin(Math.cos(this.b0) * Math.sin(s) + Math.sin(this.b0) * Math.cos(s) * Math.cos(n)), a = Math.atan(Math.sin(n) / (Math.cos(this.b0) * Math.cos(n) - Math.sin(this.b0) * Math.tan(s))), o = this.lambda0 + a / this.alpha, l = 0, h = r, c = -1e3, u = 0; Math.abs(h - c) > 1e-7; ) {
      if (++u > 20)
        return;
      l = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + r / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(h)) / 2)), c = h, h = 2 * Math.atan(Math.exp(l)) - Math.PI / 2;
    }
    return i.x = o, i.y = h, i;
  }
  var JE = ["somerc"];
  const QE = {
    init: jE,
    forward: VE,
    inverse: HE,
    names: JE
  };
  var hs = 1e-7;
  function tx(i) {
    var t = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"], e = typeof i.PROJECTION == "object" ? Object.keys(i.PROJECTION)[0] : i.PROJECTION;
    return "no_uoff" in i || "no_off" in i || t.indexOf(e) !== -1;
  }
  function ex() {
    var i, t, e, n, s, r, a, o, l, h, c = 0, u, d = 0, m = 0, f = 0, y = 0, E = 0, x = 0;
    this.no_off = tx(this), this.no_rot = "no_rot" in this;
    var M = !1;
    "alpha" in this && (M = !0);
    var C = !1;
    if ("rectified_grid_angle" in this && (C = !0), M && (x = this.alpha), C && (c = this.rectified_grid_angle * te), M || C)
      d = this.longc;
    else if (m = this.long1, y = this.lat1, f = this.long2, E = this.lat2, Math.abs(y - E) <= hs || (i = Math.abs(y)) <= hs || Math.abs(i - k) <= hs || Math.abs(Math.abs(this.lat0) - k) <= hs || Math.abs(Math.abs(E) - k) <= hs)
      throw new Error();
    var R = 1 - this.es;
    t = Math.sqrt(R), Math.abs(this.lat0) > Z ? (o = Math.sin(this.lat0), e = Math.cos(this.lat0), i = 1 - this.es * o * o, this.B = e * e, this.B = Math.sqrt(1 + this.es * this.B * this.B / R), this.A = this.B * this.k0 * t / i, n = this.B * t / (e * Math.sqrt(i)), s = n * n - 1, s <= 0 ? s = 0 : (s = Math.sqrt(s), this.lat0 < 0 && (s = -s)), this.E = s += n, this.E *= Math.pow(ii(this.e, this.lat0, o), this.B)) : (this.B = 1 / t, this.A = this.k0, this.E = n = s = 1), M || C ? (M ? (u = Math.asin(Math.sin(x) / n), C || (c = x)) : (u = c, x = Math.asin(n * Math.sin(u))), this.lam0 = d - Math.asin(0.5 * (s - 1 / s) * Math.tan(u)) / this.B) : (r = Math.pow(ii(this.e, y, Math.sin(y)), this.B), a = Math.pow(ii(this.e, E, Math.sin(E)), this.B), s = this.E / r, l = (a - r) / (a + r), h = this.E * this.E, h = (h - a * r) / (h + a * r), i = m - f, i < -Math.pi ? f -= br : i > Math.pi && (f += br), this.lam0 = K(0.5 * (m + f) - Math.atan(h * Math.tan(0.5 * this.B * (m - f)) / l) / this.B), u = Math.atan(2 * Math.sin(this.B * K(m - this.lam0)) / (s - 1 / s)), c = x = Math.asin(n * Math.sin(u))), this.singam = Math.sin(u), this.cosgam = Math.cos(u), this.sinrot = Math.sin(c), this.cosrot = Math.cos(c), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.A * this.B, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(n * n - 1) / Math.cos(x))), this.lat0 < 0 && (this.u_0 = -this.u_0)), s = 0.5 * u, this.v_pole_n = this.ArB * Math.log(Math.tan(Tt - s)), this.v_pole_s = this.ArB * Math.log(Math.tan(Tt + s));
  }
  function ix(i) {
    var t = {}, e, n, s, r, a, o, l, h;
    if (i.x = i.x - this.lam0, Math.abs(Math.abs(i.y) - k) > Z) {
      if (a = this.E / Math.pow(ii(this.e, i.y, Math.sin(i.y)), this.B), o = 1 / a, e = 0.5 * (a - o), n = 0.5 * (a + o), r = Math.sin(this.B * i.x), s = (e * this.singam - r * this.cosgam) / n, Math.abs(Math.abs(s) - 1) < Z)
        throw new Error();
      h = 0.5 * this.ArB * Math.log((1 - s) / (1 + s)), o = Math.cos(this.B * i.x), Math.abs(o) < hs ? l = this.A * i.x : l = this.ArB * Math.atan2(e * this.cosgam + r * this.singam, o);
    } else
      h = i.y > 0 ? this.v_pole_n : this.v_pole_s, l = this.ArB * i.y;
    return this.no_rot ? (t.x = l, t.y = h) : (l -= this.u_0, t.x = h * this.cosrot + l * this.sinrot, t.y = l * this.cosrot - h * this.sinrot), t.x = this.a * t.x + this.x0, t.y = this.a * t.y + this.y0, t;
  }
  function nx(i) {
    var t, e, n, s, r, a, o, l = {};
    if (i.x = (i.x - this.x0) * (1 / this.a), i.y = (i.y - this.y0) * (1 / this.a), this.no_rot ? (e = i.y, t = i.x) : (e = i.x * this.cosrot - i.y * this.sinrot, t = i.y * this.cosrot + i.x * this.sinrot + this.u_0), n = Math.exp(-this.BrA * e), s = 0.5 * (n - 1 / n), r = 0.5 * (n + 1 / n), a = Math.sin(this.BrA * t), o = (a * this.cosgam + s * this.singam) / r, Math.abs(Math.abs(o) - 1) < Z)
      l.x = 0, l.y = o < 0 ? -k : k;
    else {
      if (l.y = this.E / Math.sqrt((1 + o) / (1 - o)), l.y = Or(this.e, Math.pow(l.y, 1 / this.B)), l.y === 1 / 0)
        throw new Error();
      l.x = -this.rB * Math.atan2(s * this.cosgam - a * this.singam, Math.cos(this.BrA * t));
    }
    return l.x += this.lam0, l;
  }
  var sx = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
  const rx = {
    init: ex,
    forward: ix,
    inverse: nx,
    names: sx
  };
  function ax() {
    if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < Z)) {
      var i = this.b / this.a;
      this.e = Math.sqrt(1 - i * i);
      var t = Math.sin(this.lat1), e = Math.cos(this.lat1), n = mi(this.e, t, e), s = ii(this.e, this.lat1, t), r = Math.sin(this.lat2), a = Math.cos(this.lat2), o = mi(this.e, r, a), l = ii(this.e, this.lat2, r), h = ii(this.e, this.lat0, Math.sin(this.lat0));
      Math.abs(this.lat1 - this.lat2) > Z ? this.ns = Math.log(n / o) / Math.log(s / l) : this.ns = t, isNaN(this.ns) && (this.ns = t), this.f0 = n / (this.ns * Math.pow(s, this.ns)), this.rh = this.a * this.f0 * Math.pow(h, this.ns), this.title || (this.title = "Lambert Conformal Conic");
    }
  }
  function ox(i) {
    var t = i.x, e = i.y;
    Math.abs(2 * Math.abs(e) - Math.PI) <= Z && (e = Hr(e) * (k - 2 * Z));
    var n = Math.abs(Math.abs(e) - k), s, r;
    if (n > Z)
      s = ii(this.e, e, Math.sin(e)), r = this.a * this.f0 * Math.pow(s, this.ns);
    else {
      if (n = e * this.ns, n <= 0)
        return null;
      r = 0;
    }
    var a = this.ns * K(t - this.long0);
    return i.x = this.k0 * (r * Math.sin(a)) + this.x0, i.y = this.k0 * (this.rh - r * Math.cos(a)) + this.y0, i;
  }
  function lx(i) {
    var t, e, n, s, r, a = (i.x - this.x0) / this.k0, o = this.rh - (i.y - this.y0) / this.k0;
    this.ns > 0 ? (t = Math.sqrt(a * a + o * o), e = 1) : (t = -Math.sqrt(a * a + o * o), e = -1);
    var l = 0;
    if (t !== 0 && (l = Math.atan2(e * a, e * o)), t !== 0 || this.ns > 0) {
      if (e = 1 / this.ns, n = Math.pow(t / (this.a * this.f0), e), s = Or(this.e, n), s === -9999)
        return null;
    } else
      s = -k;
    return r = K(l / this.ns + this.long0), i.x = r, i.y = s, i;
  }
  var hx = [
    "Lambert Tangential Conformal Conic Projection",
    "Lambert_Conformal_Conic",
    "Lambert_Conformal_Conic_1SP",
    "Lambert_Conformal_Conic_2SP",
    "lcc",
    "Lambert Conic Conformal (1SP)",
    "Lambert Conic Conformal (2SP)"
  ];
  const cx = {
    init: ax,
    forward: ox,
    inverse: lx,
    names: hx
  };
  function ux() {
    this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.7417649320975901 - 0.308341501185665), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
  }
  function dx(i) {
    var t, e, n, s, r, a, o, l = i.x, h = i.y, c = K(l - this.long0);
    return t = Math.pow((1 + this.e * Math.sin(h)) / (1 - this.e * Math.sin(h)), this.alfa * this.e / 2), e = 2 * (Math.atan(this.k * Math.pow(Math.tan(h / 2 + this.s45), this.alfa) / t) - this.s45), n = -c * this.alfa, s = Math.asin(Math.cos(this.ad) * Math.sin(e) + Math.sin(this.ad) * Math.cos(e) * Math.cos(n)), r = Math.asin(Math.cos(e) * Math.sin(n) / Math.cos(s)), a = this.n * r, o = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n), i.y = o * Math.cos(a) / 1, i.x = o * Math.sin(a) / 1, this.czech || (i.y *= -1, i.x *= -1), i;
  }
  function fx(i) {
    var t, e, n, s, r, a, o, l, h = i.x;
    i.x = i.y, i.y = h, this.czech || (i.y *= -1, i.x *= -1), a = Math.sqrt(i.x * i.x + i.y * i.y), r = Math.atan2(i.y, i.x), s = r / Math.sin(this.s0), n = 2 * (Math.atan(Math.pow(this.ro0 / a, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), t = Math.asin(Math.cos(this.ad) * Math.sin(n) - Math.sin(this.ad) * Math.cos(n) * Math.cos(s)), e = Math.asin(Math.cos(n) * Math.sin(s) / Math.cos(t)), i.x = this.long0 - e / this.alfa, o = t, l = 0;
    var c = 0;
    do
      i.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(t / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(o)) / (1 - this.e * Math.sin(o)), this.e / 2)) - this.s45), Math.abs(o - i.y) < 1e-10 && (l = 1), o = i.y, c += 1;
    while (l === 0 && c < 15);
    return c >= 15 ? null : i;
  }
  var gx = ["Krovak", "krovak"];
  const mx = {
    init: ux,
    forward: dx,
    inverse: fx,
    names: gx
  };
  function _e(i, t, e, n, s) {
    return i * s - t * Math.sin(2 * s) + e * Math.sin(4 * s) - n * Math.sin(6 * s);
  }
  function Jr(i) {
    return 1 - 0.25 * i * (1 + i / 16 * (3 + 1.25 * i));
  }
  function Qr(i) {
    return 0.375 * i * (1 + 0.25 * i * (1 + 0.46875 * i));
  }
  function ta(i) {
    return 0.05859375 * i * i * (1 + 0.75 * i);
  }
  function ea(i) {
    return i * i * i * (35 / 3072);
  }
  function Us(i, t, e) {
    var n = t * e;
    return i / Math.sqrt(1 - n * n);
  }
  function mn(i) {
    return Math.abs(i) < k ? i : i - Hr(i) * Math.PI;
  }
  function ro(i, t, e, n, s) {
    var r, a;
    r = i / t;
    for (var o = 0; o < 15; o++)
      if (a = (i - (t * r - e * Math.sin(2 * r) + n * Math.sin(4 * r) - s * Math.sin(6 * r))) / (t - 2 * e * Math.cos(2 * r) + 4 * n * Math.cos(4 * r) - 6 * s * Math.cos(6 * r)), r += a, Math.abs(a) <= 1e-10)
        return r;
    return NaN;
  }
  function _x() {
    this.sphere || (this.e0 = Jr(this.es), this.e1 = Qr(this.es), this.e2 = ta(this.es), this.e3 = ea(this.es), this.ml0 = this.a * _e(this.e0, this.e1, this.e2, this.e3, this.lat0));
  }
  function px(i) {
    var t, e, n = i.x, s = i.y;
    if (n = K(n - this.long0), this.sphere)
      t = this.a * Math.asin(Math.cos(s) * Math.sin(n)), e = this.a * (Math.atan2(Math.tan(s), Math.cos(n)) - this.lat0);
    else {
      var r = Math.sin(s), a = Math.cos(s), o = Us(this.a, this.e, r), l = Math.tan(s) * Math.tan(s), h = n * Math.cos(s), c = h * h, u = this.es * a * a / (1 - this.es), d = this.a * _e(this.e0, this.e1, this.e2, this.e3, s);
      t = o * h * (1 - c * l * (1 / 6 - (8 - l + 8 * u) * c / 120)), e = d - this.ml0 + o * r / a * c * (0.5 + (5 - l + 6 * u) * c / 24);
    }
    return i.x = t + this.x0, i.y = e + this.y0, i;
  }
  function yx(i) {
    i.x -= this.x0, i.y -= this.y0;
    var t = i.x / this.a, e = i.y / this.a, n, s;
    if (this.sphere) {
      var r = e + this.lat0;
      n = Math.asin(Math.sin(r) * Math.cos(t)), s = Math.atan2(Math.tan(t), Math.cos(r));
    } else {
      var a = this.ml0 / this.a + e, o = ro(a, this.e0, this.e1, this.e2, this.e3);
      if (Math.abs(Math.abs(o) - k) <= Z)
        return i.x = this.long0, i.y = k, e < 0 && (i.y *= -1), i;
      var l = Us(this.a, this.e, Math.sin(o)), h = l * l * l / this.a / this.a * (1 - this.es), c = Math.pow(Math.tan(o), 2), u = t * this.a / l, d = u * u;
      n = o - l * Math.tan(o) / h * u * u * (0.5 - (1 + 3 * c) * u * u / 24), s = u * (1 - d * (c / 3 + (1 + 3 * c) * c * d / 15)) / Math.cos(o);
    }
    return i.x = K(s + this.long0), i.y = mn(n), i;
  }
  var vx = ["Cassini", "Cassini_Soldner", "cass"];
  const Ex = {
    init: _x,
    forward: px,
    inverse: yx,
    names: vx
  };
  function ln(i, t) {
    var e;
    return i > 1e-7 ? (e = i * t, (1 - i * i) * (t / (1 - e * e) - 0.5 / i * Math.log((1 - e) / (1 + e)))) : 2 * t;
  }
  var xx = 1, Mx = 2, wx = 3, Rx = 4;
  function Sx() {
    var i = Math.abs(this.lat0);
    if (Math.abs(i - k) < Z ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(i) < Z ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) {
      var t;
      switch (this.qp = ln(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = Nx(this.es), this.mode) {
        case this.N_POLE:
          this.dd = 1;
          break;
        case this.S_POLE:
          this.dd = 1;
          break;
        case this.EQUIT:
          this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
          break;
        case this.OBLIQ:
          this.rq = Math.sqrt(0.5 * this.qp), t = Math.sin(this.lat0), this.sinb1 = ln(this.e, t) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * t * t) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
          break;
      }
    } else
      this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
  }
  function Cx(i) {
    var t, e, n, s, r, a, o, l, h, c, u = i.x, d = i.y;
    if (u = K(u - this.long0), this.sphere) {
      if (r = Math.sin(d), c = Math.cos(d), n = Math.cos(u), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        if (e = this.mode === this.EQUIT ? 1 + c * n : 1 + this.sinph0 * r + this.cosph0 * c * n, e <= Z)
          return null;
        e = Math.sqrt(2 / e), t = e * c * Math.sin(u), e *= this.mode === this.EQUIT ? r : this.cosph0 * r - this.sinph0 * c * n;
      } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
        if (this.mode === this.N_POLE && (n = -n), Math.abs(d + this.lat0) < Z)
          return null;
        e = Tt - d * 0.5, e = 2 * (this.mode === this.S_POLE ? Math.cos(e) : Math.sin(e)), t = e * Math.sin(u), e *= n;
      }
    } else {
      switch (o = 0, l = 0, h = 0, n = Math.cos(u), s = Math.sin(u), r = Math.sin(d), a = ln(this.e, r), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (o = a / this.qp, l = Math.sqrt(1 - o * o)), this.mode) {
        case this.OBLIQ:
          h = 1 + this.sinb1 * o + this.cosb1 * l * n;
          break;
        case this.EQUIT:
          h = 1 + l * n;
          break;
        case this.N_POLE:
          h = k + d, a = this.qp - a;
          break;
        case this.S_POLE:
          h = d - k, a = this.qp + a;
          break;
      }
      if (Math.abs(h) < Z)
        return null;
      switch (this.mode) {
        case this.OBLIQ:
        case this.EQUIT:
          h = Math.sqrt(2 / h), this.mode === this.OBLIQ ? e = this.ymf * h * (this.cosb1 * o - this.sinb1 * l * n) : e = (h = Math.sqrt(2 / (1 + l * n))) * o * this.ymf, t = this.xmf * h * l * s;
          break;
        case this.N_POLE:
        case this.S_POLE:
          a >= 0 ? (t = (h = Math.sqrt(a)) * s, e = n * (this.mode === this.S_POLE ? h : -h)) : t = e = 0;
          break;
      }
    }
    return i.x = this.a * t + this.x0, i.y = this.a * e + this.y0, i;
  }
  function Tx(i) {
    i.x -= this.x0, i.y -= this.y0;
    var t = i.x / this.a, e = i.y / this.a, n, s, r, a, o, l, h;
    if (this.sphere) {
      var c = 0, u, d = 0;
      if (u = Math.sqrt(t * t + e * e), s = u * 0.5, s > 1)
        return null;
      switch (s = 2 * Math.asin(s), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (d = Math.sin(s), c = Math.cos(s)), this.mode) {
        case this.EQUIT:
          s = Math.abs(u) <= Z ? 0 : Math.asin(e * d / u), t *= d, e = c * u;
          break;
        case this.OBLIQ:
          s = Math.abs(u) <= Z ? this.lat0 : Math.asin(c * this.sinph0 + e * d * this.cosph0 / u), t *= d * this.cosph0, e = (c - Math.sin(s) * this.sinph0) * u;
          break;
        case this.N_POLE:
          e = -e, s = k - s;
          break;
        case this.S_POLE:
          s -= k;
          break;
      }
      n = e === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(t, e);
    } else {
      if (h = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        if (t /= this.dd, e *= this.dd, l = Math.sqrt(t * t + e * e), l < Z)
          return i.x = this.long0, i.y = this.lat0, i;
        a = 2 * Math.asin(0.5 * l / this.rq), r = Math.cos(a), t *= a = Math.sin(a), this.mode === this.OBLIQ ? (h = r * this.sinb1 + e * a * this.cosb1 / l, o = this.qp * h, e = l * this.cosb1 * r - e * this.sinb1 * a) : (h = e * a / l, o = this.qp * h, e = l * r);
      } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
        if (this.mode === this.N_POLE && (e = -e), o = t * t + e * e, !o)
          return i.x = this.long0, i.y = this.lat0, i;
        h = 1 - o / this.qp, this.mode === this.S_POLE && (h = -h);
      }
      n = Math.atan2(t, e), s = Fx(Math.asin(h), this.apa);
    }
    return i.x = K(this.long0 + n), i.y = s, i;
  }
  var Ix = 0.3333333333333333, Ax = 0.17222222222222222, Px = 0.10257936507936508, bx = 0.06388888888888888, Lx = 0.0664021164021164, Ox = 0.016415012942191543;
  function Nx(i) {
    var t, e = [];
    return e[0] = i * Ix, t = i * i, e[0] += t * Ax, e[1] = t * bx, t *= i, e[0] += t * Px, e[1] += t * Lx, e[2] = t * Ox, e;
  }
  function Fx(i, t) {
    var e = i + i;
    return i + t[0] * Math.sin(e) + t[1] * Math.sin(e + e) + t[2] * Math.sin(e + e + e);
  }
  var Dx = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
  const kx = {
    init: Sx,
    forward: Cx,
    inverse: Tx,
    names: Dx,
    S_POLE: xx,
    N_POLE: Mx,
    EQUIT: wx,
    OBLIQ: Rx
  };
  function dn(i) {
    return Math.abs(i) > 1 && (i = i > 1 ? 1 : -1), Math.asin(i);
  }
  function Gx() {
    Math.abs(this.lat1 + this.lat2) < Z || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = mi(this.e3, this.sin_po, this.cos_po), this.qs1 = ln(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = mi(this.e3, this.sin_po, this.cos_po), this.qs2 = ln(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = ln(this.e3, this.sin_po), Math.abs(this.lat1 - this.lat2) > Z ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
  }
  function Ux(i) {
    var t = i.x, e = i.y;
    this.sin_phi = Math.sin(e), this.cos_phi = Math.cos(e);
    var n = ln(this.e3, this.sin_phi), s = this.a * Math.sqrt(this.c - this.ns0 * n) / this.ns0, r = this.ns0 * K(t - this.long0), a = s * Math.sin(r) + this.x0, o = this.rh - s * Math.cos(r) + this.y0;
    return i.x = a, i.y = o, i;
  }
  function zx(i) {
    var t, e, n, s, r, a;
    return i.x -= this.x0, i.y = this.rh - i.y + this.y0, this.ns0 >= 0 ? (t = Math.sqrt(i.x * i.x + i.y * i.y), n = 1) : (t = -Math.sqrt(i.x * i.x + i.y * i.y), n = -1), s = 0, t !== 0 && (s = Math.atan2(n * i.x, n * i.y)), n = t * this.ns0 / this.a, this.sphere ? a = Math.asin((this.c - n * n) / (2 * this.ns0)) : (e = (this.c - n * n) / this.ns0, a = this.phi1z(this.e3, e)), r = K(s / this.ns0 + this.long0), i.x = r, i.y = a, i;
  }
  function Bx(i, t) {
    var e, n, s, r, a, o = dn(0.5 * t);
    if (i < Z)
      return o;
    for (var l = i * i, h = 1; h <= 25; h++)
      if (e = Math.sin(o), n = Math.cos(o), s = i * e, r = 1 - s * s, a = 0.5 * r * r / n * (t / (1 - l) - e / r + 0.5 / i * Math.log((1 - s) / (1 + s))), o = o + a, Math.abs(a) <= 1e-7)
        return o;
    return null;
  }
  var $x = ["Albers_Conic_Equal_Area", "Albers", "aea"];
  const Xx = {
    init: Gx,
    forward: Ux,
    inverse: zx,
    names: $x,
    phi1z: Bx
  };
  function Wx() {
    this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
  }
  function Yx(i) {
    var t, e, n, s, r, a, o, l, h = i.x, c = i.y;
    return n = K(h - this.long0), t = Math.sin(c), e = Math.cos(c), s = Math.cos(n), a = this.sin_p14 * t + this.cos_p14 * e * s, r = 1, a > 0 || Math.abs(a) <= Z ? (o = this.x0 + this.a * r * e * Math.sin(n) / a, l = this.y0 + this.a * r * (this.cos_p14 * t - this.sin_p14 * e * s) / a) : (o = this.x0 + this.infinity_dist * e * Math.sin(n), l = this.y0 + this.infinity_dist * (this.cos_p14 * t - this.sin_p14 * e * s)), i.x = o, i.y = l, i;
  }
  function Zx(i) {
    var t, e, n, s, r, a;
    return i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a, i.x /= this.k0, i.y /= this.k0, (t = Math.sqrt(i.x * i.x + i.y * i.y)) ? (s = Math.atan2(t, this.rc), e = Math.sin(s), n = Math.cos(s), a = dn(n * this.sin_p14 + i.y * e * this.cos_p14 / t), r = Math.atan2(i.x * e, t * this.cos_p14 * n - i.y * this.sin_p14 * e), r = K(this.long0 + r)) : (a = this.phic0, r = 0), i.x = r, i.y = a, i;
  }
  var qx = ["gnom"];
  const Kx = {
    init: Wx,
    forward: Yx,
    inverse: Zx,
    names: qx
  };
  function jx(i, t) {
    var e = 1 - (1 - i * i) / (2 * i) * Math.log((1 - i) / (1 + i));
    if (Math.abs(Math.abs(t) - e) < 1e-6)
      return t < 0 ? -1 * k : k;
    for (var n = Math.asin(0.5 * t), s, r, a, o, l = 0; l < 30; l++)
      if (r = Math.sin(n), a = Math.cos(n), o = i * r, s = Math.pow(1 - o * o, 2) / (2 * a) * (t / (1 - i * i) - r / (1 - o * o) + 0.5 / i * Math.log((1 - o) / (1 + o))), n += s, Math.abs(s) <= 1e-10)
        return n;
    return NaN;
  }
  function Vx() {
    this.sphere || (this.k0 = mi(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
  }
  function Hx(i) {
    var t = i.x, e = i.y, n, s, r = K(t - this.long0);
    if (this.sphere)
      n = this.x0 + this.a * r * Math.cos(this.lat_ts), s = this.y0 + this.a * Math.sin(e) / Math.cos(this.lat_ts);
    else {
      var a = ln(this.e, Math.sin(e));
      n = this.x0 + this.a * this.k0 * r, s = this.y0 + this.a * a * 0.5 / this.k0;
    }
    return i.x = n, i.y = s, i;
  }
  function Jx(i) {
    i.x -= this.x0, i.y -= this.y0;
    var t, e;
    return this.sphere ? (t = K(this.long0 + i.x / this.a / Math.cos(this.lat_ts)), e = Math.asin(i.y / this.a * Math.cos(this.lat_ts))) : (e = jx(this.e, 2 * i.y * this.k0 / this.a), t = K(this.long0 + i.x / (this.a * this.k0))), i.x = t, i.y = e, i;
  }
  var Qx = ["cea"];
  const tM = {
    init: Vx,
    forward: Hx,
    inverse: Jx,
    names: Qx
  };
  function eM() {
    this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
  }
  function iM(i) {
    var t = i.x, e = i.y, n = K(t - this.long0), s = mn(e - this.lat0);
    return i.x = this.x0 + this.a * n * this.rc, i.y = this.y0 + this.a * s, i;
  }
  function nM(i) {
    var t = i.x, e = i.y;
    return i.x = K(this.long0 + (t - this.x0) / (this.a * this.rc)), i.y = mn(this.lat0 + (e - this.y0) / this.a), i;
  }
  var sM = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
  const rM = {
    init: eM,
    forward: iM,
    inverse: nM,
    names: sM
  };
  var nd = 20;
  function aM() {
    this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Jr(this.es), this.e1 = Qr(this.es), this.e2 = ta(this.es), this.e3 = ea(this.es), this.ml0 = this.a * _e(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
  function oM(i) {
    var t = i.x, e = i.y, n, s, r, a = K(t - this.long0);
    if (r = a * Math.sin(e), this.sphere)
      Math.abs(e) <= Z ? (n = this.a * a, s = -1 * this.a * this.lat0) : (n = this.a * Math.sin(r) / Math.tan(e), s = this.a * (mn(e - this.lat0) + (1 - Math.cos(r)) / Math.tan(e)));
    else if (Math.abs(e) <= Z)
      n = this.a * a, s = -1 * this.ml0;
    else {
      var o = Us(this.a, this.e, Math.sin(e)) / Math.tan(e);
      n = o * Math.sin(r), s = this.a * _e(this.e0, this.e1, this.e2, this.e3, e) - this.ml0 + o * (1 - Math.cos(r));
    }
    return i.x = n + this.x0, i.y = s + this.y0, i;
  }
  function lM(i) {
    var t, e, n, s, r, a, o, l, h;
    if (n = i.x - this.x0, s = i.y - this.y0, this.sphere)
      if (Math.abs(s + this.a * this.lat0) <= Z)
        t = K(n / this.a + this.long0), e = 0;
      else {
        a = this.lat0 + s / this.a, o = n * n / this.a / this.a + a * a, l = a;
        var c;
        for (r = nd; r; --r)
          if (c = Math.tan(l), h = -1 * (a * (l * c + 1) - l - 0.5 * (l * l + o) * c) / ((l - a) / c - 1), l += h, Math.abs(h) <= Z) {
            e = l;
            break;
          }
        t = K(this.long0 + Math.asin(n * Math.tan(l) / this.a) / Math.sin(e));
      }
    else if (Math.abs(s + this.ml0) <= Z)
      e = 0, t = K(this.long0 + n / this.a);
    else {
      a = (this.ml0 + s) / this.a, o = n * n / this.a / this.a + a * a, l = a;
      var u, d, m, f, y;
      for (r = nd; r; --r)
        if (y = this.e * Math.sin(l), u = Math.sqrt(1 - y * y) * Math.tan(l), d = this.a * _e(this.e0, this.e1, this.e2, this.e3, l), m = this.e0 - 2 * this.e1 * Math.cos(2 * l) + 4 * this.e2 * Math.cos(4 * l) - 6 * this.e3 * Math.cos(6 * l), f = d / this.a, h = (a * (u * f + 1) - f - 0.5 * u * (f * f + o)) / (this.es * Math.sin(2 * l) * (f * f + o - 2 * a * f) / (4 * u) + (a - f) * (u * m - 2 / Math.sin(2 * l)) - m), l -= h, Math.abs(h) <= Z) {
          e = l;
          break;
        }
      u = Math.sqrt(1 - this.es * Math.pow(Math.sin(e), 2)) * Math.tan(e), t = K(this.long0 + Math.asin(n * u / this.a) / Math.sin(e));
    }
    return i.x = t, i.y = e, i;
  }
  var hM = ["Polyconic", "poly"];
  const cM = {
    init: aM,
    forward: oM,
    inverse: lM,
    names: hM
  };
  function uM() {
    this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
  }
  function dM(i) {
    var t, e = i.x, n = i.y, s = n - this.lat0, r = e - this.long0, a = s / fr * 1e-5, o = r, l = 1, h = 0;
    for (t = 1; t <= 10; t++)
      l = l * a, h = h + this.A[t] * l;
    var c = h, u = o, d = 1, m = 0, f, y, E = 0, x = 0;
    for (t = 1; t <= 6; t++)
      f = d * c - m * u, y = m * c + d * u, d = f, m = y, E = E + this.B_re[t] * d - this.B_im[t] * m, x = x + this.B_im[t] * d + this.B_re[t] * m;
    return i.x = x * this.a + this.x0, i.y = E * this.a + this.y0, i;
  }
  function fM(i) {
    var t, e = i.x, n = i.y, s = e - this.x0, r = n - this.y0, a = r / this.a, o = s / this.a, l = 1, h = 0, c, u, d = 0, m = 0;
    for (t = 1; t <= 6; t++)
      c = l * a - h * o, u = h * a + l * o, l = c, h = u, d = d + this.C_re[t] * l - this.C_im[t] * h, m = m + this.C_im[t] * l + this.C_re[t] * h;
    for (var f = 0; f < this.iterations; f++) {
      var y = d, E = m, x, M, C = a, R = o;
      for (t = 2; t <= 6; t++)
        x = y * d - E * m, M = E * d + y * m, y = x, E = M, C = C + (t - 1) * (this.B_re[t] * y - this.B_im[t] * E), R = R + (t - 1) * (this.B_im[t] * y + this.B_re[t] * E);
      y = 1, E = 0;
      var S = this.B_re[1], A = this.B_im[1];
      for (t = 2; t <= 6; t++)
        x = y * d - E * m, M = E * d + y * m, y = x, E = M, S = S + t * (this.B_re[t] * y - this.B_im[t] * E), A = A + t * (this.B_im[t] * y + this.B_re[t] * E);
      var O = S * S + A * A;
      d = (C * S + R * A) / O, m = (R * S - C * A) / O;
    }
    var P = d, L = m, F = 1, z = 0;
    for (t = 1; t <= 9; t++)
      F = F * P, z = z + this.D[t] * F;
    var D = this.lat0 + z * fr * 1e5, j = this.long0 + L;
    return i.x = j, i.y = D, i;
  }
  var gM = ["New_Zealand_Map_Grid", "nzmg"];
  const mM = {
    init: uM,
    forward: dM,
    inverse: fM,
    names: gM
  };
  function _M() {
  }
  function pM(i) {
    var t = i.x, e = i.y, n = K(t - this.long0), s = this.x0 + this.a * n, r = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + e / 2.5)) * 1.25;
    return i.x = s, i.y = r, i;
  }
  function yM(i) {
    i.x -= this.x0, i.y -= this.y0;
    var t = K(this.long0 + i.x / this.a), e = 2.5 * (Math.atan(Math.exp(0.8 * i.y / this.a)) - Math.PI / 4);
    return i.x = t, i.y = e, i;
  }
  var vM = ["Miller_Cylindrical", "mill"];
  const EM = {
    init: _M,
    forward: pM,
    inverse: yM,
    names: vM
  };
  var xM = 20;
  function MM() {
    this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = sc(this.es);
  }
  function wM(i) {
    var t, e, n = i.x, s = i.y;
    if (n = K(n - this.long0), this.sphere) {
      if (!this.m)
        s = this.n !== 1 ? Math.asin(this.n * Math.sin(s)) : s;
      else
        for (var r = this.n * Math.sin(s), a = xM; a; --a) {
          var o = (this.m * s + Math.sin(s) - r) / (this.m + Math.cos(s));
          if (s -= o, Math.abs(o) < Z)
            break;
        }
      t = this.a * this.C_x * n * (this.m + Math.cos(s)), e = this.a * this.C_y * s;
    } else {
      var l = Math.sin(s), h = Math.cos(s);
      e = this.a * Xs(s, l, h, this.en), t = this.a * n * h / Math.sqrt(1 - this.es * l * l);
    }
    return i.x = t, i.y = e, i;
  }
  function RM(i) {
    var t, e, n, s;
    return i.x -= this.x0, n = i.x / this.a, i.y -= this.y0, t = i.y / this.a, this.sphere ? (t /= this.C_y, n = n / (this.C_x * (this.m + Math.cos(t))), this.m ? t = dn((this.m * t + Math.sin(t)) / this.n) : this.n !== 1 && (t = dn(Math.sin(t) / this.n)), n = K(n + this.long0), t = mn(t)) : (t = rc(i.y / this.a, this.es, this.en), s = Math.abs(t), s < k ? (s = Math.sin(t), e = this.long0 + i.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(t)), n = K(e)) : s - Z < k && (n = this.long0)), i.x = n, i.y = t, i;
  }
  var SM = ["Sinusoidal", "sinu"];
  const CM = {
    init: MM,
    forward: wM,
    inverse: RM,
    names: SM
  };
  function TM() {
  }
  function IM(i) {
    for (var t = i.x, e = i.y, n = K(t - this.long0), s = e, r = Math.PI * Math.sin(e); ; ) {
      var a = -(s + Math.sin(s) - r) / (1 + Math.cos(s));
      if (s += a, Math.abs(a) < Z)
        break;
    }
    s /= 2, Math.PI / 2 - Math.abs(e) < Z && (n = 0);
    var o = 0.900316316158 * this.a * n * Math.cos(s) + this.x0, l = 1.4142135623731 * this.a * Math.sin(s) + this.y0;
    return i.x = o, i.y = l, i;
  }
  function AM(i) {
    var t, e;
    i.x -= this.x0, i.y -= this.y0, e = i.y / (1.4142135623731 * this.a), Math.abs(e) > 0.999999999999 && (e = 0.999999999999), t = Math.asin(e);
    var n = K(this.long0 + i.x / (0.900316316158 * this.a * Math.cos(t)));
    n < -Math.PI && (n = -Math.PI), n > Math.PI && (n = Math.PI), e = (2 * t + Math.sin(2 * t)) / Math.PI, Math.abs(e) > 1 && (e = 1);
    var s = Math.asin(e);
    return i.x = n, i.y = s, i;
  }
  var PM = ["Mollweide", "moll"];
  const bM = {
    init: TM,
    forward: IM,
    inverse: AM,
    names: PM
  };
  function LM() {
    Math.abs(this.lat1 + this.lat2) < Z || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Jr(this.es), this.e1 = Qr(this.es), this.e2 = ta(this.es), this.e3 = ea(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = mi(this.e, this.sinphi, this.cosphi), this.ml1 = _e(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < Z ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = mi(this.e, this.sinphi, this.cosphi), this.ml2 = _e(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = _e(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
  }
  function OM(i) {
    var t = i.x, e = i.y, n;
    if (this.sphere)
      n = this.a * (this.g - e);
    else {
      var s = _e(this.e0, this.e1, this.e2, this.e3, e);
      n = this.a * (this.g - s);
    }
    var r = this.ns * K(t - this.long0), a = this.x0 + n * Math.sin(r), o = this.y0 + this.rh - n * Math.cos(r);
    return i.x = a, i.y = o, i;
  }
  function NM(i) {
    i.x -= this.x0, i.y = this.rh - i.y + this.y0;
    var t, e, n, s;
    this.ns >= 0 ? (e = Math.sqrt(i.x * i.x + i.y * i.y), t = 1) : (e = -Math.sqrt(i.x * i.x + i.y * i.y), t = -1);
    var r = 0;
    if (e !== 0 && (r = Math.atan2(t * i.x, t * i.y)), this.sphere)
      return s = K(this.long0 + r / this.ns), n = mn(this.g - e / this.a), i.x = s, i.y = n, i;
    var a = this.g - e / this.a;
    return n = ro(a, this.e0, this.e1, this.e2, this.e3), s = K(this.long0 + r / this.ns), i.x = s, i.y = n, i;
  }
  var FM = ["Equidistant_Conic", "eqdc"];
  const DM = {
    init: LM,
    forward: OM,
    inverse: NM,
    names: FM
  };
  function kM() {
    this.R = this.a;
  }
  function GM(i) {
    var t = i.x, e = i.y, n = K(t - this.long0), s, r;
    Math.abs(e) <= Z && (s = this.x0 + this.R * n, r = this.y0);
    var a = dn(2 * Math.abs(e / Math.PI));
    (Math.abs(n) <= Z || Math.abs(Math.abs(e) - k) <= Z) && (s = this.x0, e >= 0 ? r = this.y0 + Math.PI * this.R * Math.tan(0.5 * a) : r = this.y0 + Math.PI * this.R * -Math.tan(0.5 * a));
    var o = 0.5 * Math.abs(Math.PI / n - n / Math.PI), l = o * o, h = Math.sin(a), c = Math.cos(a), u = c / (h + c - 1), d = u * u, m = u * (2 / h - 1), f = m * m, y = Math.PI * this.R * (o * (u - f) + Math.sqrt(l * (u - f) * (u - f) - (f + l) * (d - f))) / (f + l);
    n < 0 && (y = -y), s = this.x0 + y;
    var E = l + u;
    return y = Math.PI * this.R * (m * E - o * Math.sqrt((f + l) * (l + 1) - E * E)) / (f + l), e >= 0 ? r = this.y0 + y : r = this.y0 - y, i.x = s, i.y = r, i;
  }
  function UM(i) {
    var t, e, n, s, r, a, o, l, h, c, u, d, m;
    return i.x -= this.x0, i.y -= this.y0, u = Math.PI * this.R, n = i.x / u, s = i.y / u, r = n * n + s * s, a = -Math.abs(s) * (1 + r), o = a - 2 * s * s + n * n, l = -2 * a + 1 + 2 * s * s + r * r, m = s * s / l + (2 * o * o * o / l / l / l - 9 * a * o / l / l) / 27, h = (a - o * o / 3 / l) / l, c = 2 * Math.sqrt(-h / 3), u = 3 * m / h / c, Math.abs(u) > 1 && (u >= 0 ? u = 1 : u = -1), d = Math.acos(u) / 3, i.y >= 0 ? e = (-c * Math.cos(d + Math.PI / 3) - o / 3 / l) * Math.PI : e = -(-c * Math.cos(d + Math.PI / 3) - o / 3 / l) * Math.PI, Math.abs(n) < Z ? t = this.long0 : t = K(this.long0 + Math.PI * (r - 1 + Math.sqrt(1 + 2 * (n * n - s * s) + r * r)) / 2 / n), i.x = t, i.y = e, i;
  }
  var zM = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
  const BM = {
    init: kM,
    forward: GM,
    inverse: UM,
    names: zM
  };
  function $M() {
    this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0);
  }
  function XM(i) {
    var t = i.x, e = i.y, n = Math.sin(i.y), s = Math.cos(i.y), r = K(t - this.long0), a, o, l, h, c, u, d, m, f, y, E, x, M, C, R, S, A, O, P, L, F, z, D;
    return this.sphere ? Math.abs(this.sin_p12 - 1) <= Z ? (i.x = this.x0 + this.a * (k - e) * Math.sin(r), i.y = this.y0 - this.a * (k - e) * Math.cos(r), i) : Math.abs(this.sin_p12 + 1) <= Z ? (i.x = this.x0 + this.a * (k + e) * Math.sin(r), i.y = this.y0 + this.a * (k + e) * Math.cos(r), i) : (O = this.sin_p12 * n + this.cos_p12 * s * Math.cos(r), S = Math.acos(O), A = S ? S / Math.sin(S) : 1, i.x = this.x0 + this.a * A * s * Math.sin(r), i.y = this.y0 + this.a * A * (this.cos_p12 * n - this.sin_p12 * s * Math.cos(r)), i) : (a = Jr(this.es), o = Qr(this.es), l = ta(this.es), h = ea(this.es), Math.abs(this.sin_p12 - 1) <= Z ? (c = this.a * _e(a, o, l, h, k), u = this.a * _e(a, o, l, h, e), i.x = this.x0 + (c - u) * Math.sin(r), i.y = this.y0 - (c - u) * Math.cos(r), i) : Math.abs(this.sin_p12 + 1) <= Z ? (c = this.a * _e(a, o, l, h, k), u = this.a * _e(a, o, l, h, e), i.x = this.x0 + (c + u) * Math.sin(r), i.y = this.y0 + (c + u) * Math.cos(r), i) : (d = n / s, m = Us(this.a, this.e, this.sin_p12), f = Us(this.a, this.e, n), y = Math.atan((1 - this.es) * d + this.es * m * this.sin_p12 / (f * s)), E = Math.atan2(Math.sin(r), this.cos_p12 * Math.tan(y) - this.sin_p12 * Math.cos(r)), E === 0 ? P = Math.asin(this.cos_p12 * Math.sin(y) - this.sin_p12 * Math.cos(y)) : Math.abs(Math.abs(E) - Math.PI) <= Z ? P = -Math.asin(this.cos_p12 * Math.sin(y) - this.sin_p12 * Math.cos(y)) : P = Math.asin(Math.sin(r) * Math.cos(y) / Math.sin(E)), x = this.e * this.sin_p12 / Math.sqrt(1 - this.es), M = this.e * this.cos_p12 * Math.cos(E) / Math.sqrt(1 - this.es), C = x * M, R = M * M, L = P * P, F = L * P, z = F * P, D = z * P, S = m * P * (1 - L * R * (1 - R) / 6 + F / 8 * C * (1 - 2 * R) + z / 120 * (R * (4 - 7 * R) - 3 * x * x * (1 - 7 * R)) - D / 48 * C), i.x = this.x0 + S * Math.sin(E), i.y = this.y0 + S * Math.cos(E), i));
  }
  function WM(i) {
    i.x -= this.x0, i.y -= this.y0;
    var t, e, n, s, r, a, o, l, h, c, u, d, m, f, y, E, x, M, C, R, S, A, O, P;
    return this.sphere ? (t = Math.sqrt(i.x * i.x + i.y * i.y), t > 2 * k * this.a ? void 0 : (e = t / this.a, n = Math.sin(e), s = Math.cos(e), r = this.long0, Math.abs(t) <= Z ? a = this.lat0 : (a = dn(s * this.sin_p12 + i.y * n * this.cos_p12 / t), o = Math.abs(this.lat0) - k, Math.abs(o) <= Z ? this.lat0 >= 0 ? r = K(this.long0 + Math.atan2(i.x, -i.y)) : r = K(this.long0 - Math.atan2(-i.x, i.y)) : r = K(this.long0 + Math.atan2(i.x * n, t * this.cos_p12 * s - i.y * this.sin_p12 * n))), i.x = r, i.y = a, i)) : (l = Jr(this.es), h = Qr(this.es), c = ta(this.es), u = ea(this.es), Math.abs(this.sin_p12 - 1) <= Z ? (d = this.a * _e(l, h, c, u, k), t = Math.sqrt(i.x * i.x + i.y * i.y), m = d - t, a = ro(m / this.a, l, h, c, u), r = K(this.long0 + Math.atan2(i.x, -1 * i.y)), i.x = r, i.y = a, i) : Math.abs(this.sin_p12 + 1) <= Z ? (d = this.a * _e(l, h, c, u, k), t = Math.sqrt(i.x * i.x + i.y * i.y), m = t - d, a = ro(m / this.a, l, h, c, u), r = K(this.long0 + Math.atan2(i.x, i.y)), i.x = r, i.y = a, i) : (t = Math.sqrt(i.x * i.x + i.y * i.y), E = Math.atan2(i.x, i.y), f = Us(this.a, this.e, this.sin_p12), x = Math.cos(E), M = this.e * this.cos_p12 * x, C = -M * M / (1 - this.es), R = 3 * this.es * (1 - C) * this.sin_p12 * this.cos_p12 * x / (1 - this.es), S = t / f, A = S - C * (1 + C) * Math.pow(S, 3) / 6 - R * (1 + 3 * C) * Math.pow(S, 4) / 24, O = 1 - C * A * A / 2 - S * A * A * A / 6, y = Math.asin(this.sin_p12 * Math.cos(A) + this.cos_p12 * Math.sin(A) * x), r = K(this.long0 + Math.asin(Math.sin(E) * Math.sin(A) / Math.cos(y))), P = Math.sin(y), a = Math.atan2((P - this.es * O * this.sin_p12) * Math.tan(y), P * (1 - this.es)), i.x = r, i.y = a, i));
  }
  var YM = ["Azimuthal_Equidistant", "aeqd"];
  const ZM = {
    init: $M,
    forward: XM,
    inverse: WM,
    names: YM
  };
  function qM() {
    this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
  }
  function KM(i) {
    var t, e, n, s, r, a, o, l, h = i.x, c = i.y;
    return n = K(h - this.long0), t = Math.sin(c), e = Math.cos(c), s = Math.cos(n), a = this.sin_p14 * t + this.cos_p14 * e * s, r = 1, (a > 0 || Math.abs(a) <= Z) && (o = this.a * r * e * Math.sin(n), l = this.y0 + this.a * r * (this.cos_p14 * t - this.sin_p14 * e * s)), i.x = o, i.y = l, i;
  }
  function jM(i) {
    var t, e, n, s, r, a, o;
    return i.x -= this.x0, i.y -= this.y0, t = Math.sqrt(i.x * i.x + i.y * i.y), e = dn(t / this.a), n = Math.sin(e), s = Math.cos(e), a = this.long0, Math.abs(t) <= Z ? (o = this.lat0, i.x = a, i.y = o, i) : (o = dn(s * this.sin_p14 + i.y * n * this.cos_p14 / t), r = Math.abs(this.lat0) - k, Math.abs(r) <= Z ? (this.lat0 >= 0 ? a = K(this.long0 + Math.atan2(i.x, -i.y)) : a = K(this.long0 - Math.atan2(-i.x, i.y)), i.x = a, i.y = o, i) : (a = K(this.long0 + Math.atan2(i.x * n, t * this.cos_p14 * s - i.y * this.sin_p14 * n)), i.x = a, i.y = o, i));
  }
  var VM = ["ortho"];
  const HM = {
    init: qM,
    forward: KM,
    inverse: jM,
    names: VM
  };
  var Ut = {
    FRONT: 1,
    RIGHT: 2,
    BACK: 3,
    LEFT: 4,
    TOP: 5,
    BOTTOM: 6
  }, It = {
    AREA_0: 1,
    AREA_1: 2,
    AREA_2: 3,
    AREA_3: 4
  };
  function JM() {
    this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= k - Tt / 2 ? this.face = Ut.TOP : this.lat0 <= -(k - Tt / 2) ? this.face = Ut.BOTTOM : Math.abs(this.long0) <= Tt ? this.face = Ut.FRONT : Math.abs(this.long0) <= k + Tt ? this.face = this.long0 > 0 ? Ut.RIGHT : Ut.LEFT : this.face = Ut.BACK, this.es !== 0 && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
  }
  function QM(i) {
    var t = { x: 0, y: 0 }, e, n, s, r, a, o, l = { value: 0 };
    if (i.x -= this.long0, this.es !== 0 ? e = Math.atan(this.one_minus_f_squared * Math.tan(i.y)) : e = i.y, n = i.x, this.face === Ut.TOP)
      r = k - e, n >= Tt && n <= k + Tt ? (l.value = It.AREA_0, s = n - k) : n > k + Tt || n <= -(k + Tt) ? (l.value = It.AREA_1, s = n > 0 ? n - ee : n + ee) : n > -(k + Tt) && n <= -Tt ? (l.value = It.AREA_2, s = n + k) : (l.value = It.AREA_3, s = n);
    else if (this.face === Ut.BOTTOM)
      r = k + e, n >= Tt && n <= k + Tt ? (l.value = It.AREA_0, s = -n + k) : n < Tt && n >= -Tt ? (l.value = It.AREA_1, s = -n) : n < -Tt && n >= -(k + Tt) ? (l.value = It.AREA_2, s = -n - k) : (l.value = It.AREA_3, s = n > 0 ? -n + ee : -n - ee);
    else {
      var h, c, u, d, m, f, y;
      this.face === Ut.RIGHT ? n = Rs(n, +k) : this.face === Ut.BACK ? n = Rs(n, 3.14159265359) : this.face === Ut.LEFT && (n = Rs(n, -k)), d = Math.sin(e), m = Math.cos(e), f = Math.sin(n), y = Math.cos(n), h = m * y, c = m * f, u = d, this.face === Ut.FRONT ? (r = Math.acos(h), s = Ta(r, u, c, l)) : this.face === Ut.RIGHT ? (r = Math.acos(c), s = Ta(r, u, -h, l)) : this.face === Ut.BACK ? (r = Math.acos(-h), s = Ta(r, u, -c, l)) : this.face === Ut.LEFT ? (r = Math.acos(-c), s = Ta(r, u, h, l)) : (r = s = 0, l.value = It.AREA_0);
    }
    return o = Math.atan(12 / ee * (s + Math.acos(Math.sin(s) * Math.cos(Tt)) - k)), a = Math.sqrt((1 - Math.cos(r)) / (Math.cos(o) * Math.cos(o)) / (1 - Math.cos(Math.atan(1 / Math.cos(s))))), l.value === It.AREA_1 ? o += k : l.value === It.AREA_2 ? o += ee : l.value === It.AREA_3 && (o += 1.5 * ee), t.x = a * Math.cos(o), t.y = a * Math.sin(o), t.x = t.x * this.a + this.x0, t.y = t.y * this.a + this.y0, i.x = t.x, i.y = t.y, i;
  }
  function t2(i) {
    var t = { lam: 0, phi: 0 }, e, n, s, r, a, o, l, h, c, u = { value: 0 };
    if (i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a, n = Math.atan(Math.sqrt(i.x * i.x + i.y * i.y)), e = Math.atan2(i.y, i.x), i.x >= 0 && i.x >= Math.abs(i.y) ? u.value = It.AREA_0 : i.y >= 0 && i.y >= Math.abs(i.x) ? (u.value = It.AREA_1, e -= k) : i.x < 0 && -i.x >= Math.abs(i.y) ? (u.value = It.AREA_2, e = e < 0 ? e + ee : e - ee) : (u.value = It.AREA_3, e += k), c = ee / 12 * Math.tan(e), a = Math.sin(c) / (Math.cos(c) - 1 / Math.sqrt(2)), o = Math.atan(a), s = Math.cos(e), r = Math.tan(n), l = 1 - s * s * r * r * (1 - Math.cos(Math.atan(1 / Math.cos(o)))), l < -1 ? l = -1 : l > 1 && (l = 1), this.face === Ut.TOP)
      h = Math.acos(l), t.phi = k - h, u.value === It.AREA_0 ? t.lam = o + k : u.value === It.AREA_1 ? t.lam = o < 0 ? o + ee : o - ee : u.value === It.AREA_2 ? t.lam = o - k : t.lam = o;
    else if (this.face === Ut.BOTTOM)
      h = Math.acos(l), t.phi = h - k, u.value === It.AREA_0 ? t.lam = -o + k : u.value === It.AREA_1 ? t.lam = -o : u.value === It.AREA_2 ? t.lam = -o - k : t.lam = o < 0 ? -o - ee : -o + ee;
    else {
      var d, m, f;
      d = l, c = d * d, c >= 1 ? f = 0 : f = Math.sqrt(1 - c) * Math.sin(o), c += f * f, c >= 1 ? m = 0 : m = Math.sqrt(1 - c), u.value === It.AREA_1 ? (c = m, m = -f, f = c) : u.value === It.AREA_2 ? (m = -m, f = -f) : u.value === It.AREA_3 && (c = m, m = f, f = -c), this.face === Ut.RIGHT ? (c = d, d = -m, m = c) : this.face === Ut.BACK ? (d = -d, m = -m) : this.face === Ut.LEFT && (c = d, d = m, m = -c), t.phi = Math.acos(-f) - k, t.lam = Math.atan2(m, d), this.face === Ut.RIGHT ? t.lam = Rs(t.lam, -k) : this.face === Ut.BACK ? t.lam = Rs(t.lam, -3.14159265359) : this.face === Ut.LEFT && (t.lam = Rs(t.lam, +k));
    }
    if (this.es !== 0) {
      var y, E, x;
      y = t.phi < 0 ? 1 : 0, E = Math.tan(t.phi), x = this.b / Math.sqrt(E * E + this.one_minus_f_squared), t.phi = Math.atan(Math.sqrt(this.a * this.a - x * x) / (this.one_minus_f * x)), y && (t.phi = -t.phi);
    }
    return t.lam += this.long0, i.x = t.lam, i.y = t.phi, i;
  }
  function Ta(i, t, e, n) {
    var s;
    return i < Z ? (n.value = It.AREA_0, s = 0) : (s = Math.atan2(t, e), Math.abs(s) <= Tt ? n.value = It.AREA_0 : s > Tt && s <= k + Tt ? (n.value = It.AREA_1, s -= k) : s > k + Tt || s <= -(k + Tt) ? (n.value = It.AREA_2, s = s >= 0 ? s - ee : s + ee) : (n.value = It.AREA_3, s += k)), s;
  }
  function Rs(i, t) {
    var e = i + t;
    return e < -3.14159265359 ? e += br : e > 3.14159265359 && (e -= br), e;
  }
  var e2 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
  const i2 = {
    init: JM,
    forward: QM,
    inverse: t2,
    names: e2
  };
  var Jl = [
    [1, 22199e-21, -715515e-10, 31103e-10],
    [0.9986, -482243e-9, -24897e-9, -13309e-10],
    [0.9954, -83103e-8, -448605e-10, -986701e-12],
    [0.99, -135364e-8, -59661e-9, 36777e-10],
    [0.9822, -167442e-8, -449547e-11, -572411e-11],
    [0.973, -214868e-8, -903571e-10, 18736e-12],
    [0.96, -305085e-8, -900761e-10, 164917e-11],
    [0.9427, -382792e-8, -653386e-10, -26154e-10],
    [0.9216, -467746e-8, -10457e-8, 481243e-11],
    [0.8962, -536223e-8, -323831e-10, -543432e-11],
    [0.8679, -609363e-8, -113898e-9, 332484e-11],
    [0.835, -698325e-8, -640253e-10, 934959e-12],
    [0.7986, -755338e-8, -500009e-10, 935324e-12],
    [0.7597, -798324e-8, -35971e-9, -227626e-11],
    [0.7186, -851367e-8, -701149e-10, -86303e-10],
    [0.6732, -986209e-8, -199569e-9, 191974e-10],
    [0.6213, -0.010418, 883923e-10, 624051e-11],
    [0.5722, -906601e-8, 182e-6, 624051e-11],
    [0.5322, -677797e-8, 275608e-9, 624051e-11]
  ], lr = [
    [-520417e-23, 0.0124, 121431e-23, -845284e-16],
    [0.062, 0.0124, -126793e-14, 422642e-15],
    [0.124, 0.0124, 507171e-14, -160604e-14],
    [0.186, 0.0123999, -190189e-13, 600152e-14],
    [0.248, 0.0124002, 710039e-13, -224e-10],
    [0.31, 0.0123992, -264997e-12, 835986e-13],
    [0.372, 0.0124029, 988983e-12, -311994e-12],
    [0.434, 0.0123893, -369093e-11, -435621e-12],
    [0.4958, 0.0123198, -102252e-10, -345523e-12],
    [0.5571, 0.0121916, -154081e-10, -582288e-12],
    [0.6176, 0.0119938, -241424e-10, -525327e-12],
    [0.6769, 0.011713, -320223e-10, -516405e-12],
    [0.7346, 0.0113541, -397684e-10, -609052e-12],
    [0.7903, 0.0109107, -489042e-10, -104739e-11],
    [0.8435, 0.0103431, -64615e-9, -140374e-14],
    [0.8936, 969686e-8, -64636e-9, -8547e-9],
    [0.9394, 840947e-8, -192841e-9, -42106e-10],
    [0.9761, 616527e-8, -256e-6, -42106e-10],
    [1, 328947e-8, -319159e-9, -42106e-10]
  ], ag = 0.8487, og = 1.3523, lg = ui / 5, n2 = 1 / lg, ms = 18, ao = function(i, t) {
    return i[0] + t * (i[1] + t * (i[2] + t * i[3]));
  }, s2 = function(i, t) {
    return i[1] + t * (2 * i[2] + t * 3 * i[3]);
  };
  function r2(i, t, e, n) {
    for (var s = t; n; --n) {
      var r = i(s);
      if (s -= r, Math.abs(r) < e)
        break;
    }
    return s;
  }
  function a2() {
    this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
  }
  function o2(i) {
    var t = K(i.x - this.long0), e = Math.abs(i.y), n = Math.floor(e * lg);
    n < 0 ? n = 0 : n >= ms && (n = ms - 1), e = ui * (e - n2 * n);
    var s = {
      x: ao(Jl[n], e) * t,
      y: ao(lr[n], e)
    };
    return i.y < 0 && (s.y = -s.y), s.x = s.x * this.a * ag + this.x0, s.y = s.y * this.a * og + this.y0, s;
  }
  function l2(i) {
    var t = {
      x: (i.x - this.x0) / (this.a * ag),
      y: Math.abs(i.y - this.y0) / (this.a * og)
    };
    if (t.y >= 1)
      t.x /= Jl[ms][0], t.y = i.y < 0 ? -k : k;
    else {
      var e = Math.floor(t.y * ms);
      for (e < 0 ? e = 0 : e >= ms && (e = ms - 1); ; )
        if (lr[e][0] > t.y)
          --e;
        else if (lr[e + 1][0] <= t.y)
          ++e;
        else
          break;
      var n = lr[e], s = 5 * (t.y - n[0]) / (lr[e + 1][0] - n[0]);
      s = r2(function(r) {
        return (ao(n, r) - t.y) / s2(n, r);
      }, s, Z, 100), t.x /= ao(Jl[e], s), t.y = (5 * e + s) * te, i.y < 0 && (t.y = -t.y);
    }
    return t.x = K(t.x + this.long0), t;
  }
  var h2 = ["Robinson", "robin"];
  const c2 = {
    init: a2,
    forward: o2,
    inverse: l2,
    names: h2
  };
  function u2() {
    this.name = "geocent";
  }
  function d2(i) {
    var t = jf(i, this.es, this.a);
    return t;
  }
  function f2(i) {
    var t = Vf(i, this.es, this.a, this.b);
    return t;
  }
  var g2 = ["Geocentric", "geocentric", "geocent", "Geocent"];
  const m2 = {
    init: u2,
    forward: d2,
    inverse: f2,
    names: g2
  };
  var le = {
    N_POLE: 0,
    S_POLE: 1,
    EQUIT: 2,
    OBLIQ: 3
  }, Qs = {
    h: { def: 1e5, num: !0 },
    // default is Karman line, no default in PROJ.7
    azi: { def: 0, num: !0, degrees: !0 },
    // default is North
    tilt: { def: 0, num: !0, degrees: !0 },
    // default is Nadir
    long0: { def: 0, num: !0 },
    // default is Greenwich, conversion to rad is automatic
    lat0: { def: 0, num: !0 }
    // default is Equator, conversion to rad is automatic
  };
  function _2() {
    if (Object.keys(Qs).forEach((function(e) {
      if (typeof this[e] > "u")
        this[e] = Qs[e].def;
      else {
        if (Qs[e].num && isNaN(this[e]))
          throw new Error("Invalid parameter value, must be numeric " + e + " = " + this[e]);
        Qs[e].num && (this[e] = parseFloat(this[e]));
      }
      Qs[e].degrees && (this[e] = this[e] * te);
    }).bind(this)), Math.abs(Math.abs(this.lat0) - k) < Z ? this.mode = this.lat0 < 0 ? le.S_POLE : le.N_POLE : Math.abs(this.lat0) < Z ? this.mode = le.EQUIT : (this.mode = le.OBLIQ, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10)
      throw new Error("Invalid height");
    this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
    var i = this.tilt, t = this.azi;
    this.cg = Math.cos(t), this.sg = Math.sin(t), this.cw = Math.cos(i), this.sw = Math.sin(i);
  }
  function p2(i) {
    i.x -= this.long0;
    var t = Math.sin(i.y), e = Math.cos(i.y), n = Math.cos(i.x), s, r;
    switch (this.mode) {
      case le.OBLIQ:
        r = this.sinph0 * t + this.cosph0 * e * n;
        break;
      case le.EQUIT:
        r = e * n;
        break;
      case le.S_POLE:
        r = -t;
        break;
      case le.N_POLE:
        r = t;
        break;
    }
    switch (r = this.pn1 / (this.p - r), s = r * e * Math.sin(i.x), this.mode) {
      case le.OBLIQ:
        r *= this.cosph0 * t - this.sinph0 * e * n;
        break;
      case le.EQUIT:
        r *= t;
        break;
      case le.N_POLE:
        r *= -(e * n);
        break;
      case le.S_POLE:
        r *= e * n;
        break;
    }
    var a, o;
    return a = r * this.cg + s * this.sg, o = 1 / (a * this.sw * this.h1 + this.cw), s = (s * this.cg - r * this.sg) * this.cw * o, r = a * o, i.x = s * this.a, i.y = r * this.a, i;
  }
  function y2(i) {
    i.x /= this.a, i.y /= this.a;
    var t = { x: i.x, y: i.y }, e, n, s;
    s = 1 / (this.pn1 - i.y * this.sw), e = this.pn1 * i.x * s, n = this.pn1 * i.y * this.cw * s, i.x = e * this.cg + n * this.sg, i.y = n * this.cg - e * this.sg;
    var r = Te(i.x, i.y);
    if (Math.abs(r) < Z)
      t.x = 0, t.y = i.y;
    else {
      var a, o;
      switch (o = 1 - r * r * this.pfact, o = (this.p - Math.sqrt(o)) / (this.pn1 / r + r / this.pn1), a = Math.sqrt(1 - o * o), this.mode) {
        case le.OBLIQ:
          t.y = Math.asin(a * this.sinph0 + i.y * o * this.cosph0 / r), i.y = (a - this.sinph0 * Math.sin(t.y)) * r, i.x *= o * this.cosph0;
          break;
        case le.EQUIT:
          t.y = Math.asin(i.y * o / r), i.y = a * r, i.x *= o;
          break;
        case le.N_POLE:
          t.y = Math.asin(a), i.y = -i.y;
          break;
        case le.S_POLE:
          t.y = -Math.asin(a);
          break;
      }
      t.x = Math.atan2(i.x, i.y);
    }
    return i.x = t.x + this.long0, i.y = t.y, i;
  }
  var v2 = ["Tilted_Perspective", "tpers"];
  const E2 = {
    init: _2,
    forward: p2,
    inverse: y2,
    names: v2
  };
  function x2() {
    if (this.flip_axis = this.sweep === "x" ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10)
      throw new Error();
    if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, this.es !== 0) {
      var i = 1 - this.es, t = 1 / i;
      this.radius_p = Math.sqrt(i), this.radius_p2 = i, this.radius_p_inv2 = t, this.shape = "ellipse";
    } else
      this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
    this.title || (this.title = "Geostationary Satellite View");
  }
  function M2(i) {
    var t = i.x, e = i.y, n, s, r, a;
    if (t = t - this.long0, this.shape === "ellipse") {
      e = Math.atan(this.radius_p2 * Math.tan(e));
      var o = this.radius_p / Te(this.radius_p * Math.cos(e), Math.sin(e));
      if (s = o * Math.cos(t) * Math.cos(e), r = o * Math.sin(t) * Math.cos(e), a = o * Math.sin(e), (this.radius_g - s) * s - r * r - a * a * this.radius_p_inv2 < 0)
        return i.x = Number.NaN, i.y = Number.NaN, i;
      n = this.radius_g - s, this.flip_axis ? (i.x = this.radius_g_1 * Math.atan(r / Te(a, n)), i.y = this.radius_g_1 * Math.atan(a / n)) : (i.x = this.radius_g_1 * Math.atan(r / n), i.y = this.radius_g_1 * Math.atan(a / Te(r, n)));
    } else this.shape === "sphere" && (n = Math.cos(e), s = Math.cos(t) * n, r = Math.sin(t) * n, a = Math.sin(e), n = this.radius_g - s, this.flip_axis ? (i.x = this.radius_g_1 * Math.atan(r / Te(a, n)), i.y = this.radius_g_1 * Math.atan(a / n)) : (i.x = this.radius_g_1 * Math.atan(r / n), i.y = this.radius_g_1 * Math.atan(a / Te(r, n))));
    return i.x = i.x * this.a, i.y = i.y * this.a, i;
  }
  function w2(i) {
    var t = -1, e = 0, n = 0, s, r, a, o;
    if (i.x = i.x / this.a, i.y = i.y / this.a, this.shape === "ellipse") {
      this.flip_axis ? (n = Math.tan(i.y / this.radius_g_1), e = Math.tan(i.x / this.radius_g_1) * Te(1, n)) : (e = Math.tan(i.x / this.radius_g_1), n = Math.tan(i.y / this.radius_g_1) * Te(1, e));
      var l = n / this.radius_p;
      if (s = e * e + l * l + t * t, r = 2 * this.radius_g * t, a = r * r - 4 * s * this.C, a < 0)
        return i.x = Number.NaN, i.y = Number.NaN, i;
      o = (-r - Math.sqrt(a)) / (2 * s), t = this.radius_g + o * t, e *= o, n *= o, i.x = Math.atan2(e, t), i.y = Math.atan(n * Math.cos(i.x) / t), i.y = Math.atan(this.radius_p_inv2 * Math.tan(i.y));
    } else if (this.shape === "sphere") {
      if (this.flip_axis ? (n = Math.tan(i.y / this.radius_g_1), e = Math.tan(i.x / this.radius_g_1) * Math.sqrt(1 + n * n)) : (e = Math.tan(i.x / this.radius_g_1), n = Math.tan(i.y / this.radius_g_1) * Math.sqrt(1 + e * e)), s = e * e + n * n + t * t, r = 2 * this.radius_g * t, a = r * r - 4 * s * this.C, a < 0)
        return i.x = Number.NaN, i.y = Number.NaN, i;
      o = (-r - Math.sqrt(a)) / (2 * s), t = this.radius_g + o * t, e *= o, n *= o, i.x = Math.atan2(e, t), i.y = Math.atan(n * Math.cos(i.x) / t);
    }
    return i.x = i.x + this.long0, i;
  }
  var R2 = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
  const S2 = {
    init: x2,
    forward: M2,
    inverse: w2,
    names: R2
  };
  var gr = 1.340264, mr = -0.081106, _r = 893e-6, pr = 3796e-6, oo = Math.sqrt(3) / 2;
  function C2() {
    this.es = 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0;
  }
  function T2(i) {
    var t = K(i.x - this.long0), e = i.y, n = Math.asin(oo * Math.sin(e)), s = n * n, r = s * s * s;
    return i.x = t * Math.cos(n) / (oo * (gr + 3 * mr * s + r * (7 * _r + 9 * pr * s))), i.y = n * (gr + mr * s + r * (_r + pr * s)), i.x = this.a * i.x + this.x0, i.y = this.a * i.y + this.y0, i;
  }
  function I2(i) {
    i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a;
    var t = 1e-9, e = 12, n = i.y, s, r, a, o, l, h;
    for (h = 0; h < e && (s = n * n, r = s * s * s, a = n * (gr + mr * s + r * (_r + pr * s)) - i.y, o = gr + 3 * mr * s + r * (7 * _r + 9 * pr * s), n -= l = a / o, !(Math.abs(l) < t)); ++h)
      ;
    return s = n * n, r = s * s * s, i.x = oo * i.x * (gr + 3 * mr * s + r * (7 * _r + 9 * pr * s)) / Math.cos(n), i.y = Math.asin(Math.sin(n) / oo), i.x = K(i.x + this.long0), i;
  }
  var A2 = ["eqearth", "Equal Earth", "Equal_Earth"];
  const P2 = {
    init: C2,
    forward: T2,
    inverse: I2,
    names: A2
  };
  var Nr = 1e-10;
  function b2() {
    var i;
    if (this.phi1 = this.lat1, Math.abs(this.phi1) < Nr)
      throw new Error();
    this.es ? (this.en = sc(this.es), this.m1 = Xs(
      this.phi1,
      this.am1 = Math.sin(this.phi1),
      i = Math.cos(this.phi1),
      this.en
    ), this.am1 = i / (Math.sqrt(1 - this.es * this.am1 * this.am1) * this.am1), this.inverse = O2, this.forward = L2) : (Math.abs(this.phi1) + Nr >= k ? this.cphi1 = 0 : this.cphi1 = 1 / Math.tan(this.phi1), this.inverse = F2, this.forward = N2);
  }
  function L2(i) {
    var t = K(i.x - (this.long0 || 0)), e = i.y, n, s, r;
    return n = this.am1 + this.m1 - Xs(e, s = Math.sin(e), r = Math.cos(e), this.en), s = r * t / (n * Math.sqrt(1 - this.es * s * s)), i.x = n * Math.sin(s), i.y = this.am1 - n * Math.cos(s), i.x = this.a * i.x + (this.x0 || 0), i.y = this.a * i.y + (this.y0 || 0), i;
  }
  function O2(i) {
    i.x = (i.x - (this.x0 || 0)) / this.a, i.y = (i.y - (this.y0 || 0)) / this.a;
    var t, e, n, s;
    if (e = Te(i.x, i.y = this.am1 - i.y), s = rc(this.am1 + this.m1 - e, this.es, this.en), (t = Math.abs(s)) < k)
      t = Math.sin(s), n = e * Math.atan2(i.x, i.y) * Math.sqrt(1 - this.es * t * t) / Math.cos(s);
    else if (Math.abs(t - k) <= Nr)
      n = 0;
    else
      throw new Error();
    return i.x = K(n + (this.long0 || 0)), i.y = mn(s), i;
  }
  function N2(i) {
    var t = K(i.x - (this.long0 || 0)), e = i.y, n, s;
    return s = this.cphi1 + this.phi1 - e, Math.abs(s) > Nr ? (i.x = s * Math.sin(n = t * Math.cos(e) / s), i.y = this.cphi1 - s * Math.cos(n)) : i.x = i.y = 0, i.x = this.a * i.x + (this.x0 || 0), i.y = this.a * i.y + (this.y0 || 0), i;
  }
  function F2(i) {
    i.x = (i.x - (this.x0 || 0)) / this.a, i.y = (i.y - (this.y0 || 0)) / this.a;
    var t, e, n = Te(i.x, i.y = this.cphi1 - i.y);
    if (e = this.cphi1 + this.phi1 - n, Math.abs(e) > k)
      throw new Error();
    return Math.abs(Math.abs(e) - k) <= Nr ? t = 0 : t = n * Math.atan2(i.x, i.y) / Math.cos(e), i.x = K(t + (this.long0 || 0)), i.y = mn(e), i;
  }
  var D2 = ["bonne", "Bonne (Werner lat_1=90)"];
  const k2 = {
    init: b2,
    names: D2
  };
  function G2(i) {
    i.Proj.projections.add(Na), i.Proj.projections.add(Fa), i.Proj.projections.add(LE), i.Proj.projections.add($E), i.Proj.projections.add(KE), i.Proj.projections.add(QE), i.Proj.projections.add(rx), i.Proj.projections.add(cx), i.Proj.projections.add(mx), i.Proj.projections.add(Ex), i.Proj.projections.add(kx), i.Proj.projections.add(Xx), i.Proj.projections.add(Kx), i.Proj.projections.add(tM), i.Proj.projections.add(rM), i.Proj.projections.add(cM), i.Proj.projections.add(mM), i.Proj.projections.add(EM), i.Proj.projections.add(CM), i.Proj.projections.add(bM), i.Proj.projections.add(DM), i.Proj.projections.add(BM), i.Proj.projections.add(ZM), i.Proj.projections.add(HM), i.Proj.projections.add(i2), i.Proj.projections.add(c2), i.Proj.projections.add(m2), i.Proj.projections.add(E2), i.Proj.projections.add(S2), i.Proj.projections.add(P2), i.Proj.projections.add(k2);
  }
  ue.defaultDatum = "WGS84";
  ue.Proj = di;
  ue.WGS84 = new ue.Proj("WGS84");
  ue.Point = Gs;
  ue.toPoint = Hf;
  ue.defs = fe;
  ue.nadgrid = Nv;
  ue.transform = so;
  ue.mgrs = Vv;
  ue.version = "__VERSION__";
  G2(ue);
  const se = {
    ELEMENT: "element",
    MAP: "map",
    OFFSET: "offset",
    POSITION: "position",
    POSITIONING: "positioning"
  };
  class U2 extends si {
    /**
     * @param {Options} options Overlay options.
     */
    constructor(t) {
      super(), this.on, this.once, this.un, this.options = t, this.id = t.id, this.insertFirst = t.insertFirst !== void 0 ? t.insertFirst : !0, this.stopEvent = t.stopEvent !== void 0 ? t.stopEvent : !0, this.element = document.createElement("div"), this.element.className = t.className !== void 0 ? t.className : "ol-overlay-container " + C_, this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.autoPan = t.autoPan === !0 ? {} : t.autoPan || void 0, this.rendered = {
        transform_: "",
        visible: !0
      }, this.mapPostrenderListenerKey = null, this.addChangeListener(se.ELEMENT, this.handleElementChanged), this.addChangeListener(se.MAP, this.handleMapChanged), this.addChangeListener(se.OFFSET, this.handleOffsetChanged), this.addChangeListener(se.POSITION, this.handlePositionChanged), this.addChangeListener(se.POSITIONING, this.handlePositioningChanged), t.element !== void 0 && this.setElement(t.element), this.setOffset(t.offset !== void 0 ? t.offset : [0, 0]), this.setPositioning(t.positioning || "top-left"), t.position !== void 0 && this.setPosition(t.position);
    }
    /**
     * Get the DOM element of this overlay.
     * @return {HTMLElement|undefined} The Element containing the overlay.
     * @observable
     * @api
     */
    getElement() {
      return (
        /** @type {HTMLElement|undefined} */
        this.get(se.ELEMENT)
      );
    }
    /**
     * Get the overlay identifier which is set on constructor.
     * @return {number|string|undefined} Id.
     * @api
     */
    getId() {
      return this.id;
    }
    /**
     * Get the map associated with this overlay.
     * @return {import("./Map.js").default|null} The map that the
     * overlay is part of.
     * @observable
     * @api
     */
    getMap() {
      return (
        /** @type {import("./Map.js").default|null} */
        this.get(se.MAP) || null
      );
    }
    /**
     * Get the offset of this overlay.
     * @return {Array<number>} The offset.
     * @observable
     * @api
     */
    getOffset() {
      return (
        /** @type {Array<number>} */
        this.get(se.OFFSET)
      );
    }
    /**
     * Get the current position of this overlay.
     * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
     *     anchored at.
     * @observable
     * @api
     */
    getPosition() {
      return (
        /** @type {import("./coordinate.js").Coordinate|undefined} */
        this.get(se.POSITION)
      );
    }
    /**
     * Get the current positioning of this overlay.
     * @return {Positioning} How the overlay is positioned
     *     relative to its point on the map.
     * @observable
     * @api
     */
    getPositioning() {
      return (
        /** @type {Positioning} */
        this.get(se.POSITIONING)
      );
    }
    /**
     * @protected
     */
    handleElementChanged() {
      Jd(this.element);
      const t = this.getElement();
      t && this.element.appendChild(t);
    }
    /**
     * @protected
     */
    handleMapChanged() {
      var e;
      this.mapPostrenderListenerKey && ((e = this.element) == null || e.remove(), bt(this.mapPostrenderListenerKey), this.mapPostrenderListenerKey = null);
      const t = this.getMap();
      if (t) {
        this.mapPostrenderListenerKey = xt(
          t,
          Ti.POSTRENDER,
          this.render,
          this
        ), this.updatePixelPosition();
        const n = this.stopEvent ? t.getOverlayContainerStopEvent() : t.getOverlayContainer();
        this.insertFirst ? n.insertBefore(this.element, n.childNodes[0] || null) : n.appendChild(this.element), this.performAutoPan();
      }
    }
    /**
     * @protected
     */
    render() {
      this.updatePixelPosition();
    }
    /**
     * @protected
     */
    handleOffsetChanged() {
      this.updatePixelPosition();
    }
    /**
     * @protected
     */
    handlePositionChanged() {
      this.updatePixelPosition(), this.performAutoPan();
    }
    /**
     * @protected
     */
    handlePositioningChanged() {
      this.updatePixelPosition();
    }
    /**
     * Set the DOM element to be associated with this overlay.
     * @param {HTMLElement|undefined} element The Element containing the overlay.
     * @observable
     * @api
     */
    setElement(t) {
      this.set(se.ELEMENT, t);
    }
    /**
     * Set the map to be associated with this overlay.
     * @param {import("./Map.js").default|null} map The map that the
     * overlay is part of. Pass `null` to just remove the overlay from the current map.
     * @observable
     * @api
     */
    setMap(t) {
      this.set(se.MAP, t);
    }
    /**
     * Set the offset for this overlay.
     * @param {Array<number>} offset Offset.
     * @observable
     * @api
     */
    setOffset(t) {
      this.set(se.OFFSET, t);
    }
    /**
     * Set the position for this overlay. If the position is `undefined` the
     * overlay is hidden.
     * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
     *     is anchored at.
     * @observable
     * @api
     */
    setPosition(t) {
      this.set(se.POSITION, t);
    }
    /**
     * Pan the map so that the overlay is entirely visible in the current viewport
     * (if necessary) using the configured autoPan parameters
     * @protected
     */
    performAutoPan() {
      this.autoPan && this.panIntoView(this.autoPan);
    }
    /**
     * Pan the map so that the overlay is entirely visible in the current viewport
     * (if necessary).
     * @param {PanIntoViewOptions} [panIntoViewOptions] Options for the pan action
     * @api
     */
    panIntoView(t) {
      const e = this.getMap();
      if (!e || !e.getTargetElement() || !this.get(se.POSITION))
        return;
      const n = this.getRect(e.getTargetElement(), e.getSize()), s = this.getElement(), r = this.getRect(s, [
        p_(s),
        y_(s)
      ]);
      t = t || {};
      const a = t.margin === void 0 ? 20 : t.margin;
      if (!Qi(n, r)) {
        const o = r[0] - n[0], l = n[2] - r[2], h = r[1] - n[1], c = n[3] - r[3], u = [0, 0];
        if (o < 0 ? u[0] = o - a : l < 0 && (u[0] = Math.abs(l) + a), h < 0 ? u[1] = h - a : c < 0 && (u[1] = Math.abs(c) + a), u[0] !== 0 || u[1] !== 0) {
          const d = (
            /** @type {import("./coordinate.js").Coordinate} */
            e.getView().getCenterInternal()
          ), m = e.getPixelFromCoordinateInternal(d);
          if (!m)
            return;
          const f = [m[0] + u[0], m[1] + u[1]], y = t.animation || {};
          e.getView().animateInternal({
            center: e.getCoordinateFromPixelInternal(f),
            duration: y.duration,
            easing: y.easing
          });
        }
      }
    }
    /**
     * Get the extent of an element relative to the document
     * @param {HTMLElement} element The element.
     * @param {import("./size.js").Size} size The size of the element.
     * @return {import("./extent.js").Extent} The extent.
     * @protected
     */
    getRect(t, e) {
      const n = t.getBoundingClientRect(), s = n.left + window.pageXOffset, r = n.top + window.pageYOffset;
      return [s, r, s + e[0], r + e[1]];
    }
    /**
     * Set the positioning for this overlay.
     * @param {Positioning} positioning how the overlay is
     *     positioned relative to its point on the map.
     * @observable
     * @api
     */
    setPositioning(t) {
      this.set(se.POSITIONING, t);
    }
    /**
     * Modify the visibility of the element.
     * @param {boolean} visible Element visibility.
     * @protected
     */
    setVisible(t) {
      this.rendered.visible !== t && (this.element.style.display = t ? "" : "none", this.rendered.visible = t);
    }
    /**
     * Update pixel position.
     * @protected
     */
    updatePixelPosition() {
      const t = this.getMap(), e = this.getPosition();
      if (!t || !t.isRendered() || !e) {
        this.setVisible(!1);
        return;
      }
      const n = t.getPixelFromCoordinate(e), s = t.getSize();
      this.updateRenderedPosition(n, s);
    }
    /**
     * @param {import("./pixel.js").Pixel} pixel The pixel location.
     * @param {import("./size.js").Size|undefined} mapSize The map size.
     * @protected
     */
    updateRenderedPosition(t, e) {
      const n = this.element.style, s = this.getOffset(), r = this.getPositioning();
      this.setVisible(!0);
      const a = Math.round(t[0] + s[0]) + "px", o = Math.round(t[1] + s[1]) + "px";
      let l = "0%", h = "0%";
      r == "bottom-right" || r == "center-right" || r == "top-right" ? l = "-100%" : (r == "bottom-center" || r == "center-center" || r == "top-center") && (l = "-50%"), r == "bottom-left" || r == "bottom-center" || r == "bottom-right" ? h = "-100%" : (r == "center-left" || r == "center-center" || r == "center-right") && (h = "-50%");
      const c = `translate(${l}, ${h}) translate(${a}, ${o})`;
      this.rendered.transform_ != c && (this.rendered.transform_ = c, n.transform = c);
    }
    /**
     * returns the options this Overlay has been created with
     * @return {Options} overlay options
     */
    getOptions() {
      return this.options;
    }
  }
  var hr = { exports: {} };
  const z2 = /* @__PURE__ */ Vr(py), B2 = /* @__PURE__ */ Vr(By), $2 = /* @__PURE__ */ Vr(Oy), X2 = /* @__PURE__ */ Vr(V0), W2 = /* @__PURE__ */ Vr(__);
  var Y2 = hr.exports, sd;
  function Z2() {
    return sd || (sd = 1, function(i, t) {
      (function(e, n) {
        n(t, z2, B2, $2, X2, W2);
      })(Y2, function(e, n, s, r, a, o) {
        var l = "comparison", h = [
          "PropertyIsEqualTo",
          "PropertyIsNotEqualTo",
          "PropertyIsLessThan",
          "PropertyIsLessThanOrEqualTo",
          "PropertyIsGreaterThan",
          "PropertyIsGreaterThanOrEqualTo"
        ], c = h.concat([
          "PropertyIsLike",
          "PropertyIsNull",
          "PropertyIsBetween"
        ]);
        function u(g) {
          return c.includes(g.localName);
        }
        function d(g) {
          return ["or", "and"].includes(g.localName.toLowerCase());
        }
        function m(g, _) {
          if (h.includes(g.localName))
            return f(g, _);
          if (g.localName === "PropertyIsBetween")
            return x(g, _);
          if (g.localName === "PropertyIsNull")
            return E(g, _);
          if (g.localName === "PropertyIsLike")
            return y(g, _);
          throw new Error("Unknown comparison element " + g.localName);
        }
        function f(g, _) {
          var p = {
            type: l,
            operator: g.localName.toLowerCase(),
            // Match case attribute is true by default, so only make it false if the attribute value equals 'false'.
            matchcase: g.getAttribute("matchCase") !== "false"
          }, v = {};
          return _(g, v, "expressions", {
            concatenateLiterals: !1
          }), v.expressions && v.expressions.children && (p.expression1 = v.expressions.children[0], p.expression2 = v.expressions.children[1]), p;
        }
        function y(g, _) {
          var p = f(g, _);
          return Object.assign(
            {},
            p,
            {
              wildcard: g.getAttribute("wildCard"),
              singlechar: g.getAttribute("singleChar"),
              escapechar: g.getAttribute("escapeChar")
            }
          );
        }
        function E(g, _) {
          var p = {};
          return _(g, p, "expressions", {
            concatenateLiterals: !1
          }), {
            type: l,
            operator: g.localName.toLowerCase(),
            expression: p.expressions
          };
        }
        function x(g, _) {
          var p = {
            type: l,
            operator: g.localName.toLowerCase(),
            // Match case attribute is true by default, so only make it false if the attribute value equals 'false'.
            matchcase: g.getAttribute("matchCase") !== "false"
          }, v = {};
          return _(g, v, "expressions", {
            concatenateLiterals: !1
          }), v.expressions && v.expressions.children && (p.expression = v.expressions.children[0], p.lowerboundary = v.expressions.children[1], p.upperboundary = v.expressions.children[2]), p;
        }
        function M(g, _) {
          for (var p = [], v = g.firstElementChild; v; v = v.nextElementSibling)
            v && u(v) && p.push(m(v, _)), v && d(v) && p.push(M(v, _)), v && v.localName.toLowerCase() === "not" && p.push(C(v, _));
          return {
            type: g.localName.toLowerCase(),
            predicates: p
          };
        }
        function C(g, _) {
          var p = null, v = g.firstElementChild;
          return v && u(v) && (p = m(v, _)), v && d(v) && (p = M(v, _)), v && v.localName.toLowerCase() === "not" && (p = C(v, _)), {
            type: g.localName.toLowerCase(),
            predicate: p
          };
        }
        function R(g, _) {
          for (var p = {}, v = g.firstElementChild; v; v = v.nextElementSibling)
            u(v) && (p = m(v, _)), d(v) && (p = M(v, _)), v.localName.toLowerCase() === "not" && (p = C(v, _)), v.localName.toLowerCase() === "featureid" && (p.type = "featureid", p.fids = p.fids || [], p.fids.push(v.getAttribute("fid")));
          return p;
        }
        var S = /* @__PURE__ */ new Set([
          "strokeWidth",
          "strokeOpacity",
          "strokeDashoffset",
          "fillOpacity",
          "fontSize"
        ]);
        function A(g, _, p) {
          var v = p.toLowerCase();
          _[v] = _[v] || [];
          var w = {};
          et(g, w), _[v].push(w);
        }
        function O(g, _, p) {
          var v = p.toLowerCase();
          _[v] = {}, et(g, _[v]);
        }
        function P(g, _, p, v) {
          v === void 0 && (v = !1);
          var w = p.toLowerCase();
          v ? _[w] = g.textContent.trim() : _[w] = g.textContent;
        }
        function L(g, _, p) {
          var v = p.toLowerCase(), w = parseFloat(g.textContent.trim());
          _[v] = w;
        }
        function F(g, _, p) {
          if (!Array.isArray(g))
            return g;
          var v = g.map(function(I) {
            return I.type === "literal" ? I.value : I;
          }).filter(function(I) {
            return I !== "";
          });
          if (p) {
            var w = v.every(
              function(I) {
                return typeof I != "object" || I === null;
              }
            );
            if (w)
              return v.join("");
          }
          return v.length === 1 ? v[0] : {
            type: "expression",
            typeHint: _,
            children: v
          };
        }
        function z(g, _, p, v) {
          v === void 0 && (v = {});
          for (var w = {
            skipEmptyNodes: !0,
            forceLowerCase: !0,
            typeHint: "string",
            concatenateLiterals: !0
          }, I = Object.assign(
            {},
            w,
            v
          ), N = [], B = 0; B < g.childNodes.length; B += 1) {
            var U = g.childNodes[B], $ = {};
            if (U.namespaceURI === "http://www.opengis.net/ogc" && U.localName === "PropertyName")
              $.type = "propertyname", $.typeHint = I.typeHint, $.value = U.textContent.trim();
            else if (U.namespaceURI === "http://www.opengis.net/ogc" && U.localName === "Function") {
              var ct = U.getAttribute("name"), pt = U.getAttribute("fallbackValue") || null;
              $.type = "function", $.name = ct, $.fallbackValue = pt;
              var yt = {};
              z(U, yt, "params", {
                concatenateLiterals: !1
              }), Array.isArray(yt.params.children) ? $.params = yt.params.children : $.params = [yt.params];
            } else if (U.localName === "Add" || U.localName === "Sub" || U.localName === "Mul" || U.localName === "Div") {
              $.type = "function", $.name = "__fe:" + U.localName + "__", $.typeHint = "number";
              var Ot = {};
              z(U, Ot, "params", {
                concatenateLiterals: !1
              }), Array.isArray(Ot.params.children) ? $.params = Ot.params.children : $.params = [Ot.params];
            } else U.nodeName === "#cdata-section" ? ($.type = "literal", $.typeHint = I.typeHint, $.value = U.textContent) : ($.type = "literal", $.typeHint = I.typeHint, $.value = U.textContent.trim());
            $.type === "literal" && I.skipEmptyNodes ? $.value.trim() && N.push($) : N.push($);
          }
          var Nt = I.forceLowerCase ? p.toLowerCase() : p, Kt = F(
            N,
            I.typeHint,
            I.concatenateLiterals
          );
          typeof Kt == "string" && I.typeHint === "number" && (Kt = parseFloat(Kt)), _[Nt] = Kt;
        }
        function D(g, _, p, v) {
          v === void 0 && (v = {}), z(g, _, p, Object.assign({}, v, { typeHint: "number" }));
        }
        function j(g, _) {
          var p = g.getElementsByTagNameNS(
            "http://www.opengis.net/sld",
            _
          );
          return p.length ? !!p.item(0).textContent : !1;
        }
        function Y(g, _, p, v) {
          _[v] = _[v] || {};
          var w = g.getAttribute("name").toLowerCase().replace(/-(.)/g, function(N, B) {
            return B.toUpperCase();
          }), I = "string";
          v === "styling" && S.has(w) && (I = "number"), z(g, _[v], w, {
            skipEmptyNodes: !0,
            forceLowerCase: !1,
            typeHint: I
          });
        }
        var q = {
          Filter: function(g, _) {
            _.filter = R(g, z);
          },
          ElseFilter: function(g, _) {
            _.elsefilter = !0;
          }
        }, J = {
          PolygonSymbolizer: A,
          LineSymbolizer: A,
          PointSymbolizer: A,
          TextSymbolizer: A,
          Fill: O,
          Stroke: O,
          GraphicStroke: O,
          GraphicFill: O,
          Graphic: O,
          ExternalGraphic: O,
          Gap: D,
          InitialGap: D,
          Mark: O,
          Label: function(g, _, p) {
            return z(g, _, p, { skipEmptyNodes: !1 });
          },
          Halo: O,
          Font: O,
          Radius: D,
          LabelPlacement: O,
          PointPlacement: O,
          LinePlacement: O,
          PerpendicularOffset: D,
          AnchorPoint: O,
          AnchorPointX: D,
          AnchorPointY: D,
          Opacity: D,
          Rotation: D,
          Displacement: O,
          DisplacementX: D,
          DisplacementY: D,
          Size: D,
          WellKnownName: P,
          MarkIndex: L,
          VendorOption: function(g, _, p) {
            return Y(g, _, p, "vendoroptions");
          },
          OnlineResource: function(g, _) {
            _.onlineresource = g.getAttribute("xlink:href");
          },
          CssParameter: function(g, _, p) {
            return Y(g, _, p, "styling");
          },
          SvgParameter: function(g, _, p) {
            return Y(g, _, p, "styling");
          }
        }, X = Object.assign(
          {},
          {
            NamedLayer: function(g, _) {
              A(g, _, "layers");
            },
            UserLayer: function(g, _) {
              A(g, _, "layers");
            },
            UserStyle: function(g, _) {
              _.styles = _.styles || [];
              var p = {
                default: j(g, "IsDefault"),
                featuretypestyles: []
              };
              et(g, p), _.styles.push(p);
            },
            FeatureTypeStyle: function(g, _) {
              _.featuretypestyle = _.featuretypestyle || [];
              var p = {
                rules: []
              };
              et(g, p), _.featuretypestyles.push(p);
            },
            Rule: function(g, _) {
              var p = {};
              et(g, p), _.rules.push(p);
            },
            Name: P,
            Title: P,
            Abstract: P,
            MaxScaleDenominator: L,
            MinScaleDenominator: L
          },
          q,
          J
        );
        function et(g, _) {
          for (var p = g.firstElementChild; p; p = p.nextElementSibling)
            X[p.localName] && X[p.localName](p, _, p.localName);
        }
        function lt(g) {
          for (var _ = {}, p = new DOMParser(), v = p.parseFromString(g, "application/xml"), w = v.firstChild; w; w = w.nextSibling)
            _.version = w.getAttribute("version"), et(w, _);
          return _;
        }
        var Q = /* @__PURE__ */ new Map();
        function W(g, _) {
          if (typeof _ != "function")
            throw new Error("Function implementation is not a function");
          Q[g] = _;
        }
        function gt(g) {
          return Q[g] || null;
        }
        function it(g) {
          switch ((g || {}).type) {
            case "expression":
              return !0;
            case "literal":
              return !1;
            case "propertyname":
              return !0;
            case "function":
              return !0;
            default:
              return !1;
          }
        }
        function T(g, _, p, v) {
          v === void 0 && (v = null);
          var w = null, I = typeof g;
          if (I === "string" || I === "number" || I === "undefined" || I === "boolean" || g === null)
            w = g;
          else if (g.type === "literal")
            w = g.value;
          else if (g.type === "propertyname") {
            var N = g.value;
            _ ? typeof _.getGeometryName == "function" && N === _.getGeometryName() ? w = _.getGeometry() : w = p(_, N) : w = v;
          } else if (g.type === "expression")
            if (g.children.length === 1)
              w = T(
                g.children[0],
                _,
                p,
                v
              );
            else {
              for (var B = [], U = 0; U < g.children.length; U += 1)
                B.push(
                  // Do not use default values when evaluating children. Only apply default is
                  // the concatenated result is empty.
                  T(g.children[U], _, p, null)
                );
              w = B.join("");
            }
          else if (g.type === "function") {
            var $ = gt(g.name);
            if (!$)
              w = g.fallbackValue;
            else
              try {
                var ct = g.params.map(
                  function(pt) {
                    return T(pt, _, p);
                  }
                );
                w = $.apply(void 0, ct);
              } catch {
                w = g.fallbackValue;
              }
          }
          return w === 0 ? w : w === null || typeof w > "u" || w === "" || Number.isNaN(w) || g && g.typeHint === "number" && (w = Number(w), Number.isNaN(w)) ? v : w;
        }
        function ot(g) {
          return g == null;
        }
        function Ct(g, _) {
          return g < _ ? -1 : g === _ ? 0 : 1;
        }
        function Lt(g) {
          return g === "" ? NaN : Number(g);
        }
        function Zt(g, _, p) {
          var v = Lt(g), w = Lt(_);
          if (!(Number.isNaN(v) || Number.isNaN(w)))
            return Ct(v, w);
          var I = g.toString(), N = _.toString();
          return p ? I.localeCompare(N) : I.toLowerCase().localeCompare(N.toLowerCase());
        }
        function be(g, _, p) {
          var v = T(g.expression, _, p);
          return ot(v);
        }
        function Jt(g, _, p) {
          var v = T(g.expression1, _, p);
          if (ot(v))
            return !1;
          var w = T(g.expression2, _, p);
          return ot(w) ? !1 : Zt(v, w) < 0;
        }
        function Le(g, _, p) {
          var v = T(g.expression1, _, p);
          if (ot(v))
            return !1;
          var w = T(g.expression2, _, p);
          return ot(w) ? !1 : Zt(v, w) > 0;
        }
        function _i(g, _, p) {
          var v = T(g.expression, _, p);
          if (ot(v))
            return !1;
          var w = T(
            g.lowerboundary,
            _,
            p
          );
          if (ot(w))
            return !1;
          var I = T(
            g.upperboundary,
            _,
            p
          );
          return ot(I) ? !1 : Zt(w, v) <= 0 && Zt(I, v) >= 0;
        }
        function Ze(g, _, p) {
          var v = T(g.expression1, _, p);
          if (ot(v))
            return !1;
          var w = T(g.expression2, _, p);
          return ot(w) ? !1 : !g.matchcase || typeof v == "boolean" || typeof w == "boolean" ? Zt(v, w, !1) === 0 : v == w;
        }
        function _n(g, _, p) {
          var v = T(g.expression1, _, p);
          if (ot(v))
            return !1;
          var w = T(g.expression2, _, p);
          return ot(w) ? !1 : !Ze(g, _, p);
        }
        function pi(g, _, p) {
          var v = T(g.expression1, _, p);
          if (ot(v))
            return !1;
          var w = T(g.expression2, _, p);
          if (ot(w))
            return !1;
          var I = g.wildcard, N = g.singlechar, B = g.escapechar, U = g.matchcase, $ = w.replace(new RegExp("[" + I + "]", "g"), ".*");
          $ = $.replace(
            new RegExp("[" + N + "]", "g"),
            "."
          ), B !== "\\" && ($ = $.replace(
            new RegExp("[" + B + "]", "g"),
            "\\"
          )), $ = "^" + $ + "$";
          var ct = U === !1 ? new RegExp($, "i") : new RegExp($);
          return ct.test(v);
        }
        function qe(g, _, p) {
          switch (g.operator) {
            case "propertyislessthan":
              return Jt(g, _, p);
            case "propertyisequalto":
              return Ze(g, _, p);
            case "propertyislessthanorequalto":
              return Ze(g, _, p) || Jt(g, _, p);
            case "propertyisnotequalto":
              return _n(g, _, p);
            case "propertyisgreaterthan":
              return Le(g, _, p);
            case "propertyisgreaterthanorequalto":
              return Ze(g, _, p) || Le(g, _, p);
            case "propertyisbetween":
              return _i(g, _, p);
            case "propertyisnull":
              return be(g, _, p);
            case "propertyislike":
              return pi(g, _, p);
            default:
              throw new Error("Unkown comparison operator " + g.operator);
          }
        }
        function ye(g, _) {
          for (var p = 0; p < g.length; p += 1)
            if (g[p] === _)
              return !0;
          return !1;
        }
        function Ge(g, _) {
          return g.properties[_];
        }
        function Gi(g) {
          return g.id;
        }
        function Ke(g, _, p) {
          p === void 0 && (p = {});
          var v = typeof p.getProperty == "function" ? p.getProperty : Ge, w = typeof p.getFeatureId == "function" ? p.getFeatureId : Gi, I = g.type;
          switch (I) {
            case "featureid":
              return ye(g.fids, w(_));
            case "comparison":
              return qe(g, _, v);
            case "and": {
              if (!g.predicates)
                throw new Error("And filter must have predicates array.");
              return g.predicates.length === 0 ? !1 : g.predicates.every(
                function(N) {
                  return Ke(N, _, p);
                }
              );
            }
            case "or": {
              if (!g.predicates)
                throw new Error("Or filter must have predicates array.");
              return g.predicates.some(
                function(N) {
                  return Ke(N, _, p);
                }
              );
            }
            case "not": {
              if (!g.predicate)
                throw new Error("Not filter must have predicate.");
              return !Ke(g.predicate, _, p);
            }
            default:
              throw new Error("Unknown filter type: " + I);
          }
        }
        function pn(g, _) {
          return g.maxscaledenominator !== void 0 && g.minscaledenominator !== void 0 ? _ / 28e-5 < g.maxscaledenominator && _ / 28e-5 > g.minscaledenominator : g.maxscaledenominator !== void 0 ? _ / 28e-5 < g.maxscaledenominator : g.minscaledenominator !== void 0 ? _ / 28e-5 > g.minscaledenominator : !0;
        }
        function yi(g) {
          return g.layers.map(function(_) {
            return _.name;
          });
        }
        function Ui(g, _) {
          return _ ? g.layers.find(function(p) {
            return p.name === _;
          }) : g.layers[0];
        }
        function zi(g) {
          return g.styles.map(function(_) {
            return _.name;
          });
        }
        function Bt(g, _) {
          if (_)
            return g.styles.find(function(v) {
              return v.name === _;
            });
          var p = g.styles.find(function(v) {
            return v.default;
          });
          return p || g.styles[0];
        }
        function Xn(g, _, p, v) {
          v === void 0 && (v = {});
          for (var w = [], I = 0, N = 0; N < g.rules.length; N += 1) {
            var B = g.rules[N];
            pn(B, p) && (B.elsefilter ? (w.push(B), I += 1) : B.filter ? Ke(B.filter, _, v) && w.push(B) : w.push(B));
          }
          return I === w.length ? w : w.filter(function(U) {
            return !U.elsefilter;
          });
        }
        function Wn(g) {
          var _ = (g.polygonsymbolizer || []).concat(
            g.linesymbolizer || [],
            g.pointsymbolizer || [],
            g.textsymbolizer || []
          );
          return _;
        }
        function Bi(g, _) {
          if (g) {
            for (var p = g, v = (_ || "").split("."), w = 0; w < v.length; w += 1) {
              var I = v[w];
              if (!(I in p))
                return;
              p = p[I];
            }
            return p;
          }
        }
        function $i(g) {
          var _ = {
            polygonSymbolizers: [],
            lineSymbolizers: [],
            pointSymbolizers: [],
            textSymbolizers: []
          };
          return (g || []).forEach(function(p) {
            p.polygonsymbolizer && (_.polygonSymbolizers = _.polygonSymbolizers.concat(p.polygonsymbolizer)), p.linesymbolizer && (_.lineSymbolizers = _.lineSymbolizers.concat(p.linesymbolizer)), p.pointsymbolizer && (_.pointSymbolizers = _.pointSymbolizers.concat(p.pointsymbolizer)), p.textsymbolizer && (_.textSymbolizers = _.textSymbolizers.concat(p.textsymbolizer));
          }), _;
        }
        var Yn = "IMAGE_LOADING", Zn = "IMAGE_LOADED", qn = "IMAGE_ERROR", vi = 6, Go = 16, Uo = "PLACEMENT_DEFAULT", Ws = "PLACEMENT_FIRSTPOINT", Ys = "PLACEMENT_LASTPOINT", yn = [
          "graphic.externalgraphic",
          "stroke.graphicstroke.graphic.externalgraphic",
          "fill.graphicfill.graphic.externalgraphic"
        ], Zs = {};
        function zo(g, _) {
          Zs[g] = _;
        }
        function Kn(g) {
          return Zs[g];
        }
        var Xi = {};
        function Ei(g, _) {
          Xi[g] = _;
        }
        function xi(g) {
          return Xi[g];
        }
        var qs = {};
        function ia(g) {
          return qs[g];
        }
        function ve(g, _) {
          qs[g] = _;
        }
        function ri(g, _) {
          for (var p = 0; p < yn.length; p += 1) {
            var v = yn[p], w = Bi(g, v);
            w && w.onlineresource === _ && (g.__invalidated = !0, v.indexOf("graphicstroke") > -1 && (g.stroke.graphicstroke.__invalidated = !0));
          }
        }
        function ne(g, _) {
          if (g)
            if (!Array.isArray(g))
              ri(g, _);
            else
              for (var p = 0; p < g.length; p += 1)
                ri(g[p], _);
        }
        function Ee(g, _) {
          g.rules && g.rules.forEach(function(p) {
            ne(p.pointsymbolizer, _), ne(p.linesymbolizer, _), ne(p.polygonsymbolizer, _);
          });
        }
        function xe(g) {
          var _ = ia(g);
          return _ || (_ = new Promise(function(p, v) {
            var w = new Image();
            w.onload = function() {
              zo(g, {
                url: g,
                image: w,
                width: w.naturalWidth,
                height: w.naturalHeight
              }), Ei(g, Zn), p(g);
            }, w.onerror = function() {
              Ei(g, qn), v();
            }, w.src = g;
          }), Ei(g, Yn), ve(g, _), _);
        }
        function je(g, _, p) {
          Ee(_, g), xe(g).then(function() {
            Ee(_, g), typeof p == "function" && p(g);
          }).catch(function() {
            Ee(_, g), typeof p == "function" && p();
          });
        }
        function Ve(g, _, p, v) {
          g.forEach(function(w) {
            var I = Wn(w);
            I.forEach(function(N) {
              yn.forEach(function(B) {
                var U = Bi(N, B);
                if (U) {
                  var $ = U.onlineresource, ct = xi($);
                  (!ct || ct === Yn) && (v[$] || (v[$] = !0, je(
                    $,
                    _,
                    p
                  )));
                }
              });
            });
          });
        }
        function kt(g, _, p) {
          p === void 0 && (p = 0);
          var v = Kn(g), w = v.image, I = v.width, N = v.height;
          return new n.Style({
            image: new n.Icon({
              img: w,
              imgSize: [I, N],
              // According to SLD spec, if size is given, image height should equal the given size.
              scale: _ / N || 1,
              rotation: Math.PI * p / 180
            })
          });
        }
        var qt = new n.Style({}), He = new n.Style({
          image: new n.Circle({
            radius: 8,
            fill: new n.Fill({
              color: "blue",
              fillOpacity: 0.7
            })
          })
        }), na = new n.Style({
          image: new n.Circle({
            radius: 5,
            fill: new n.Fill({
              color: "#DDDDDD"
            }),
            stroke: new n.Stroke({
              width: 1,
              color: "#888888"
            })
          })
        }), hc = new n.Style({
          fill: new n.Fill({
            color: "#DDDDDD"
          }),
          stroke: new n.Stroke({
            color: "#888888",
            width: 1
          })
        }), ug = new n.Style({
          image: new n.RegularShape({
            angle: Math.PI / 4,
            fill: new n.Fill({
              color: "red"
            }),
            points: 4,
            radius: 8,
            radius2: 0,
            stroke: new n.Stroke({
              color: "red",
              width: 4
            })
          })
        }), dg = new n.Style({
          fill: new n.Fill({
            color: "red"
          }),
          stroke: new n.Stroke({
            color: "red",
            width: 1
          })
        });
        function sa(g) {
          var _ = /* @__PURE__ */ new WeakMap();
          return function(p) {
            var v = _.get(p);
            return (!v || p.__invalidated) && (v = g(p), p.__invalidated = !1, _.set(p, v)), v;
          };
        }
        function fg(g, _) {
          var p = parseInt(g.slice(1, 3), 16), v = parseInt(g.slice(3, 5), 16), w = parseInt(g.slice(5, 7), 16);
          return _ || _ === 0 ? "rgba(" + p + ", " + v + ", " + w + ", " + _ + ")" : "rgb(" + p + ", " + v + ", " + w + ")";
        }
        function jn(g, _) {
          return _ !== null && _ < 1 && g.startsWith("#") ? fg(g, _) : g;
        }
        function gg(g, _) {
          var p = g.stroke, v = p.graphicstroke, w = p.styling;
          if ("gap" in v)
            return v.gap + _;
          var I = 1;
          if (w && w.strokeDasharray) {
            var N = w.strokeDasharray.split(" ");
            N.length >= 2 && N[0] !== 0 && (I = N[1] / N[0] + 1);
          }
          return I * _;
        }
        function mg(g) {
          var _ = g.stroke, p = _.graphicstroke;
          return p.initialgap || 0;
        }
        function ra(g, _, p, v, w) {
          w === void 0 && (w = 0);
          var I = _ / 2, N = Math.PI * w / 180, B;
          switch (v && v.getColor() && (B = v.getColor()), g) {
            case "circle":
              return new n.Circle({
                fill: v,
                radius: I,
                stroke: p
              });
            case "triangle":
              return new n.RegularShape({
                fill: v,
                points: 3,
                radius: I,
                stroke: p,
                rotation: N
              });
            case "star":
              return new n.RegularShape({
                fill: v,
                points: 5,
                radius: I,
                radius2: I / 2.5,
                stroke: p,
                rotation: N
              });
            case "cross":
              return new n.RegularShape({
                fill: v,
                points: 4,
                radius: I,
                radius2: 0,
                stroke: p || new n.Stroke({
                  color: B,
                  width: I / 2
                }),
                rotation: N
              });
            case "hexagon":
              return new n.RegularShape({
                fill: v,
                points: 6,
                radius: I,
                stroke: p || new n.Stroke({
                  color: B,
                  width: I / 2
                }),
                rotation: N
              });
            case "octagon":
              return new n.RegularShape({
                angle: Math.PI / 8,
                fill: v,
                points: 8,
                radius: I / Math.cos(Math.PI / 8),
                stroke: p || new n.Stroke({
                  color: B,
                  width: I / 2
                }),
                rotation: N
              });
            case "cross2":
            // cross2 is used by QGIS for the x symbol.
            case "x":
              return new n.RegularShape({
                angle: Math.PI / 4,
                fill: v,
                points: 4,
                radius: Math.sqrt(2) * I,
                radius2: 0,
                stroke: p || new n.Stroke({
                  color: B,
                  width: I / 2
                }),
                rotation: N
              });
            case "diamond":
              return new n.RegularShape({
                fill: v,
                points: 4,
                radius: I,
                stroke: p,
                rotation: N
              });
            case "horline":
              return new n.RegularShape({
                fill: v,
                points: 2,
                radius: I,
                angle: Math.PI / 2,
                stroke: p,
                rotation: N
              });
            case "line":
              return new n.RegularShape({
                fill: v,
                points: 2,
                radius: I,
                angle: 0,
                stroke: p,
                rotation: N
              });
            case "backslash":
              return new n.RegularShape({
                fill: v,
                points: 2,
                radius: I * Math.sqrt(2),
                angle: -Math.PI / 4,
                stroke: p,
                rotation: N
              });
            case "slash":
              return new n.RegularShape({
                fill: v,
                points: 2,
                radius: I * Math.sqrt(2),
                angle: Math.PI / 4,
                stroke: p,
                rotation: N
              });
            default:
              return new n.RegularShape({
                angle: Math.PI / 4,
                fill: v,
                points: 4,
                // For square, scale radius so the height of the square equals the given size.
                radius: I * Math.sqrt(2),
                stroke: p,
                rotation: N
              });
          }
        }
        function aa(g) {
          if (g) {
            var _ = g.styling || {}, p = T(_.stroke, null, null, "#000000"), v = T(_.strokeOpacity, null, null, 1), w = T(_.strokeWidth, null, null, 1), I = T(
              _.strokeDashoffset,
              null,
              null,
              0
            ), N = {
              color: jn(p, v),
              width: w,
              lineDashOffset: I
            }, B = T(_.strokeLinejoin, null, null);
            B !== null && (N.lineJoin = B);
            var U = T(_.strokeLinecap, null, null);
            U !== null && (N.lineCap = U);
            var $ = T(_.strokeDasharray, null, null);
            return $ !== null && (N.lineDash = $.split(" ")), new n.Stroke(N);
          }
        }
        function Bo(g) {
          if (g) {
            var _ = g.styling || {}, p = T(_.fill, null, null, "#808080"), v = T(_.fillOpacity, null, null, 1);
            return new n.Fill({ color: jn(p, v) });
          }
        }
        function $o(g, _, p, v) {
          var w = g.getFill();
          if (!w || typeof v != "function")
            return !1;
          var I = !1, N = _.fill || {}, B = N.styling || {};
          if (it(B.fill) || it(B.fillOpacity)) {
            var U = T(B.fill, p, v, "#808080"), $ = T(
              B.fillOpacity,
              p,
              v,
              1
            );
            w.setColor(jn(U, $)), I = !0;
          }
          return I;
        }
        function oa(g, _, p, v) {
          var w = g.getStroke();
          if (!w || typeof v != "function")
            return !1;
          var I = !1, N = _.stroke || {}, B = N.styling || {};
          if (it(B.strokeWidth)) {
            var U = T(
              B.strokeWidth,
              p,
              v,
              1
            );
            w.setWidth(U), I = !0;
          }
          if (it(B.stroke) || it(B.strokeOpacity)) {
            var $ = T(
              B.stroke,
              p,
              v,
              "#000000"
            ), ct = T(
              B.strokeOpacity,
              p,
              v,
              1
            );
            w.setColor(jn($, ct)), I = !0;
          }
          return I;
        }
        function _g(g, _, p, v) {
          var w = g.getText();
          if (!w || typeof v != "function")
            return !1;
          if (_.fill && _.fill.styling && (it(_.fill.styling.fill) || it(_.fill.styling.fillOpacity))) {
            var I = {
              stroke: {
                styling: {
                  stroke: _.fill.styling.fill,
                  strokeOpacity: _.fill.styling.fillOpacity
                }
              }
            };
            oa(
              w,
              I,
              p,
              v
            );
          }
          if (_.halo && _.halo.fill && _.halo.fill.styling && (it(_.halo.fill.styling.fill) || it(_.halo.fill.styling.fillOpacity)) && $o(w, _.halo, p, v), _.halo && it(_.halo.radius)) {
            var N = T(
              _.halo.radius,
              p,
              v,
              1
            ), B = w.getStroke();
            if (B) {
              var U = (N === 2 || N === 4 ? N - 1e-5 : N) * 2;
              B.setWidth(U);
            }
          }
          return !1;
        }
        var pg = Bo({ styling: { fill: "#888888" } }), yg = aa({ styling: { stroke: {} } });
        function vg(g) {
          var _ = g.graphic, p = T(_.size, null, null, vi), v = T(_.rotation, null, null, 0);
          if (_.externalgraphic && _.externalgraphic.onlineresource) {
            _.size || (p = null);
            var w = _.externalgraphic.onlineresource;
            switch (xi(w)) {
              case Zn:
                return kt(
                  w,
                  p,
                  v
                );
              case Yn:
                return na;
              case qn:
                return ug;
              default:
                return na;
            }
          }
          if (_.mark) {
            var I = _.mark, N = I.wellknownname, B = Bo(_.mark.fill), U = aa(_.mark.stroke);
            return new n.Style({
              // Note: size will be set dynamically later.
              image: ra(
                N,
                p,
                U,
                B,
                v
              )
            });
          }
          return new n.Style({
            image: ra(
              "square",
              p,
              yg,
              pg,
              v
            )
          });
        }
        var Eg = sa(vg);
        function vn(g, _, p) {
          if (!(g && g.graphic))
            return qt;
          var v = Eg(g);
          v.setGeometry(null);
          var w = v.getImage(), I = g.graphic, N = I.size, B = I.rotation, U = Number(T(N, _, p)) || vi, $ = Number(T(B, _, p)) || 0;
          if (it(N))
            if (I.externalgraphic && I.externalgraphic.onlineresource) {
              var ct = w.getSize()[1], pt = U / ct || 1;
              w.setScale(pt);
            } else I.mark && I.mark.wellknownname === "circle" ? w.setRadius(U * 0.5) : (w = ra(
              I.mark && I.mark.wellknownname || "square",
              U,
              // Note: re-use stroke and fill instances for a (small?) performance gain.
              w.getStroke(),
              w.getFill(),
              $
            ), v.setImage(w));
          if (it(B)) {
            var yt = Math.PI * $ / 180;
            w.setRotation(yt);
          }
          if (I.mark) {
            var Ot = oa(
              w,
              I.mark,
              _,
              p
            ), Nt = $o(
              w,
              I.mark,
              _,
              p
            );
            (Ot || Nt) && (w = ra(
              I.mark && I.mark.wellknownname || "square",
              U,
              w.getStroke(),
              w.getFill(),
              $
            ), v.setImage(w));
          }
          var Kt = I.displacement;
          if (Kt) {
            var jt = Kt.displacementx, de = Kt.displacementy;
            if (typeof jt < "u" || typeof de < "u") {
              var Qt = T(jt, _, p) || 0, Oe = T(de, _, p) || 0;
              (Qt !== 0 || Oe !== 0) && w.setDisplacement([Qt, Oe]);
            }
          }
          return v;
        }
        function cc(g, _) {
          var p = g[0] - _[0], v = g[1] - _[1];
          return Math.sqrt(p * p + v * v);
        }
        function xg(g, _, p) {
          var v = cc(g, _), w = p / v, I = g[0] + (_[0] - g[0]) * w, N = g[1] + (_[1] - g[1]) * w;
          return [I, N];
        }
        function Xo(g, _, p) {
          var v = _[0] - g[0], w = _[1] - g[1], I = -Math.atan2(p ? -w : w, v);
          return I;
        }
        function uc(g, _, p) {
          p === void 0 && (p = {});
          var v = g.getCoordinates();
          if (v.length === 0)
            return [];
          if (v.length === 1)
            return [v[0].concat([0])];
          if (p.placement === Ws) {
            var w = v[0], I = v[1];
            return [[w[0], w[1], Xo(w, I, p.invertY)]];
          }
          if (p.placement === Ys) {
            var N = v[v.length - 2], B = v[v.length - 1];
            return [[B[0], B[1], Xo(N, B, p.invertY)]];
          }
          for (var U = g.getLength(), $ = Math.max(_, 0.1), ct = p.initialGap || 0, pt = 0, yt = [].concat(v[0]), Ot = [].concat(v[1]), Nt = 0, Kt = []; ct <= U; ) {
            var jt = cc(
              yt,
              Ot
            );
            if (Nt + jt < ct) {
              if (pt === v.length - 2)
                break;
              yt[0] = Ot[0], yt[1] = Ot[1], Ot[0] = v[pt + 2][0], Ot[1] = v[pt + 2][1], pt += 1, Nt += jt;
            } else {
              var de = ct - Nt, Qt = xg(
                yt,
                Ot,
                de
              ), Oe = Xo(
                yt,
                Ot,
                p.invertY
              );
              (!p.extent || a.containsCoordinate(p.extent, Qt)) && (Qt.push(Oe), Kt.push(Qt)), ct += $;
            }
          }
          return Kt;
        }
        var dc = !1;
        function Mg(g) {
          if (!dc) {
            var _ = Object.getPrototypeOf(g);
            _.setImageStyle2 = function(p, v) {
              _.setImageStyle.call(this, p), this.image_ && (this.imageRotation_ = v);
            }, dc = !0;
          }
        }
        function fc(g, _, p, v, w, I) {
          if (_) {
            if (Array.isArray(_[0][0])) {
              _.forEach(function(U) {
                fc(
                  g,
                  U,
                  p,
                  v,
                  w,
                  I
                );
              });
              return;
            }
            if (!(_.length < 2)) {
              var N = v.getImage();
              if (N) {
                var B = uc(
                  new r.LineString(_),
                  p * w,
                  {
                    invertY: !0,
                    // Pixel y-coordinates increase downwards in screen space.
                    extent: g.extent_,
                    placement: I.placement,
                    initialGap: I.initialGap
                  }
                );
                B.forEach(function(U) {
                  var $ = N.getRotation() + U[2];
                  g.setImageStyle2(N, $), g.drawPoint(new r.Point([U[0] / w, U[1] / w]));
                });
              }
            }
          }
        }
        function gc(g, _) {
          if (!(g.stroke && g.stroke.graphicstroke))
            throw new Error(
              "getGraphicStrokeRenderer error: symbolizer.stroke.graphicstroke null or undefined."
            );
          var p = g.stroke, v = p.graphicstroke, w = {
            placement: Uo
          };
          return g.vendoroptions && (g.vendoroptions.placement === "firstPoint" ? w.placement = Ws : g.vendoroptions.placement === "lastPoint" && (w.placement = Ys)), function(I, N) {
            var B = N.feature.getGeometry().getType();
            if (!(B === "Point" || B === "MultiPoint")) {
              var U = N.pixelRatio || 1, $ = s.toContext(N.context);
              Mg($);
              var ct = vi;
              v.graphic && v.graphic.externalgraphic && (ct = Go);
              var pt = vn(
                v,
                N.feature,
                _
              ), yt = v.graphic && v.graphic.size || ct, Ot = Number(
                T(
                  yt,
                  N.feature,
                  _,
                  ct
                )
              ), Nt = gg(g, Ot);
              w.initialGap = mg(g), fc(
                $,
                I,
                Nt,
                pt,
                U,
                w
              );
            }
          };
        }
        function wg(g, _) {
          if (!(g.stroke && g.stroke.graphicstroke))
            throw new Error(
              "getGraphicStrokeStyle error: linesymbolizer.stroke.graphicstroke null or undefined."
            );
          return new n.Style({
            renderer: gc(g, _)
          });
        }
        function Rg(g) {
          return g.stroke && g.stroke.graphicstroke ? wg(g) : new n.Style({
            stroke: aa(g.stroke)
          });
        }
        var Sg = sa(Rg);
        function mc(g, _, p) {
          var v = Sg(g);
          return oa(v, g, _, p), v;
        }
        var _c = [[1, 1]], pc = [
          [0, 0],
          [2, 2]
        ], yc = [
          [0, 0],
          [1, 1],
          [2, 2],
          [3, 3],
          [2, 0],
          [0, 2]
        ], Cg = [
          [0, 0],
          [1, 1]
        ];
        function Tg(g, _) {
          _.forEach(function(p) {
            var v = p[0], w = p[1];
            g.fillRect(v, w, 1, 1);
          });
        }
        function Ig(g, _) {
          _.forEach(function(p) {
            var v = p[0], w = p[1];
            g.clearRect(v, w, 1, 1);
          });
        }
        function vc(g) {
          var _ = g.getContext("2d");
          if (o.DEVICE_PIXEL_RATIO === 1)
            return _.createPattern(g, "repeat");
          var p = document.createElement("canvas");
          p.width = g.width * o.DEVICE_PIXEL_RATIO, p.height = g.height * o.DEVICE_PIXEL_RATIO;
          var v = p.getContext("2d");
          return v.imageSmoothingEnabled = !1, v.drawImage(
            g,
            0,
            0,
            g.width,
            g.height,
            0,
            0,
            p.width,
            p.height
          ), v.createPattern(p, "repeat");
        }
        function la(g, _, p) {
          var v = document.createElement("canvas");
          v.width = g, v.height = g;
          var w = v.getContext("2d");
          return w.fillStyle = _, Tg(w, p), vc(v);
        }
        function Wo(g, _, p) {
          var v = document.createElement("canvas");
          v.width = g, v.height = g;
          var w = v.getContext("2d");
          return w.fillStyle = _, w.fillRect(0, 0, g, g), Ig(w, p), vc(v);
        }
        function Ag(g, _) {
          var p = null;
          switch (g) {
            case "brush://dense1":
              p = new n.Fill({
                color: Wo(4, _, _c)
              });
              break;
            case "brush://dense2":
              p = new n.Fill({
                color: Wo(4, _, pc)
              });
              break;
            case "brush://dense3":
              p = new n.Fill({
                color: Wo(4, _, yc)
              });
              break;
            case "brush://dense4":
              p = new n.Fill({
                color: la(2, _, Cg)
              });
              break;
            case "brush://dense5":
              p = new n.Fill({
                color: la(4, _, yc)
              });
              break;
            case "brush://dense6":
              p = new n.Fill({
                color: la(4, _, pc)
              });
              break;
            case "brush://dense7":
              p = new n.Fill({
                color: la(4, _, _c)
              });
              break;
            default:
              p = new n.Fill({ color: _ });
              break;
          }
          return p;
        }
        function Pg(g) {
          var _ = Kn(
            g.externalgraphic.onlineresource
          ), p = _.image, v = _.width, w = _.height, I = document.createElement("canvas"), N = I.getContext("2d"), B = o.DEVICE_PIXEL_RATIO;
          if (g.size && w !== g.size && (B *= g.size / w), B === 1)
            return N.createPattern(p, "repeat");
          var U = document.createElement("canvas"), $ = U.getContext("2d");
          return U.width = v * B, U.height = w * B, $.drawImage(
            p,
            0,
            0,
            v,
            w,
            0,
            0,
            v * B,
            w * B
          ), N.createPattern(U, "repeat");
        }
        function bg(g) {
          var _ = g.fill.graphicfill, p = _.graphic, v = p.externalgraphic.onlineresource;
          switch (xi(v)) {
            case Zn:
              return new n.Fill({
                color: Pg(g.fill.graphicfill.graphic)
              });
            case Yn:
              return hc.getFill();
            case qn:
              return dg.getFill();
            default:
              return hc.getFill();
          }
        }
        function Lg(g, _) {
          if (!g.graphic)
            return g;
          var p = JSON.parse(JSON.stringify(g)), v = p.graphic, w = Number(v.size) || vi;
          v.size = _ * w;
          var I = v.mark;
          if (I && I.stroke) {
            I.stroke.styling || (I.stroke.styling = {
              stroke: "#000000",
              strokeWidth: 1
            }), I.stroke.styling.strokeWidth || (I.stroke.styling.strokeWidth = Number(I.stroke.styling.strokeWidth) || 1);
            var N = I.stroke.styling.strokeWidth;
            N > 1 && (I.stroke.styling.strokeWidth = _ * N);
          }
          return p;
        }
        function Og(g) {
          var _ = g.fill, p = _.graphicfill, v = p.graphic, w = v.mark, I = w || {}, N = I.wellknownname;
          if (N && N.indexOf("brush://") === 0) {
            var B = "#000000";
            return w.fill && w.fill.styling && w.fill.styling.fill && (B = w.fill.styling.fill), Ag(N, B);
          }
          var U = Number(v.size) || vi, $ = U * o.DEVICE_PIXEL_RATIO, ct = null, pt = 2;
          try {
            var yt = document.createElement("canvas");
            yt.width = $ * pt, yt.height = $ * pt;
            var Ot = yt.getContext("2d"), Nt = Lg(p, pt), Kt = vn(Nt), jt = s.toContext(Ot, {
              size: [U * pt, U * pt]
            });
            Ot.imageSmoothingEnabled = !1, jt.setStyle(Kt);
            var de = pt * (U / 2), Qt = pt * (U / 2);
            jt.drawGeometry(new r.Point([de, Qt])), N && N.indexOf("slash") > -1 && (jt.drawGeometry(
              new r.Point([de - pt * U, Qt])
            ), jt.drawGeometry(
              new r.Point([de + pt * U, Qt])
            ), jt.drawGeometry(
              new r.Point([de, Qt - pt * U])
            ), jt.drawGeometry(
              new r.Point([de, Qt + pt * U])
            ));
            var Oe = document.createElement("canvas");
            Oe.width = $, Oe.height = $;
            var ha = Oe.getContext("2d");
            ha.drawImage(
              yt,
              0,
              0,
              $ * pt,
              $ * pt,
              0,
              0,
              $,
              $
            );
            var ca = ha.createPattern(Oe, "repeat");
            ct = new n.Fill({
              color: ca
            });
          } catch {
            ct = new n.Fill({
              color: "#000000"
            });
          }
          return ct;
        }
        function Ng(g) {
          var _ = g.fill && g.fill.graphicfill && g.fill.graphicfill.graphic && g.fill.graphicfill.graphic.externalgraphic && g.fill.graphicfill.graphic.externalgraphic.onlineresource, p = g.fill && g.fill.graphicfill && g.fill.graphicfill.graphic && g.fill.graphicfill.graphic.mark, v = null;
          if (_ ? v = bg(g) : p ? v = Og(g) : v = Bo(g.fill), g.stroke && g.stroke.graphicstroke) {
            var w = gc(g);
            return new n.Style({
              renderer: function(N, B) {
                if (v) {
                  var U = B.feature, $ = B.context, ct = s.toContext($);
                  ct.setFillStrokeStyle(v, void 0);
                  var pt = U.getGeometry().getType();
                  pt === "Polygon" ? ct.drawPolygon(new r.Polygon(N)) : pt === "MultiPolygon" && ct.drawMultiPolygon(new r.MultiPolygon(N));
                }
                w(N, B);
              }
            });
          }
          var I = aa(g.stroke);
          return new n.Style({
            fill: v,
            stroke: I
          });
        }
        var Fg = sa(Ng);
        function Dg(g, _, p) {
          var v = Fg(g);
          return $o(v, g, _, p), oa(v, g, _, p), v;
        }
        function kg(g) {
          if (!(g && g.label))
            return qt;
          var _ = T(g.label, null, null, ""), p = g.font ? g.font.styling || {} : {}, v = T(p.fontFamily, null, null, "sans-serif"), w = T(p.fontSize, null, null, 10), I = T(p.fontStyle, null, null, ""), N = T(p.fontWeight, null, null, ""), B = I + " " + N + " " + w + "px " + v, U = g && g.labelplacement && g.labelplacement.pointplacement ? g.labelplacement.pointplacement : {}, $ = T(
            U.rotation,
            null,
            null,
            0
          ), ct = U && U.displacement ? U.displacement : {}, pt = T(ct.displacementx, null, null, 0), yt = -T(ct.displacementy, null, null, 0), Ot = U && U.anchorpoint || {}, Nt = "center", Kt = T(Ot.anchorpointx, null, null, NaN);
          Kt < 0.25 ? Nt = "left" : Kt > 0.75 && (Nt = "right");
          var jt = "middle", de = T(Ot.anchorpointy, null, null, NaN);
          de < 0.25 ? jt = "bottom" : de > 0.75 && (jt = "top");
          var Qt = g.fill ? g.fill.styling : {}, Oe = T(Qt.fill, null, null, "#000000"), ha = T(Qt.fillOpacity, null, null, 1), ca = {
            text: _,
            font: B,
            offsetX: pt,
            offsetY: yt,
            rotation: Math.PI * $ / 180,
            textAlign: Nt,
            textBaseline: jt,
            fill: new n.Fill({
              color: jn(Oe, ha)
            })
          };
          if (g.halo) {
            var Ko = g.halo && g.halo.fill ? g.halo.fill.styling : {}, Jg = T(Ko.fill, null, null, "#FFFFFF"), Qg = T(Ko.fillOpacity, null, null, 1), ua = T(g.halo.radius, null, null, 1);
            ca.stroke = new n.Stroke({
              color: jn(Jg, Qg),
              // wrong position width radius equal to 2 or 4
              width: (ua === 2 || ua === 4 ? ua - 1e-5 : ua) * 2
            });
          }
          return new n.Style({
            text: new n.Text(ca)
          });
        }
        var Gg = sa(kg);
        function Yo(g, _, p) {
          var v = Gg(g), w = v.getText();
          if (!w)
            return v;
          var I = g.label, N = g.labelplacement;
          if (it(I)) {
            var B = T(I, _, p, "");
            w.setText(B.toString());
          }
          if (N) {
            var U = N.pointplacement && N.pointplacement.rotation || 0;
            if (it(U)) {
              var $ = T(
                U,
                _,
                p,
                0
              );
              w.setRotation(Math.PI * $ / 180);
            }
          }
          var ct = _.getGeometry ? _.getGeometry() : _.geometry, pt = ct.getType ? ct.getType() : ct.type, yt = g && g.labelplacement && g.labelplacement.lineplacement ? g.labelplacement.lineplacement : null, Ot = pt !== "point" && yt ? "line" : "point";
          if (w.setPlacement(Ot), _g(v, g, _, p), g.font && g.font.styling) {
            var Nt = g.font.styling || {};
            if (it(Nt.fontFamily) || it(Nt.fontStyle) || it(Nt.fontWeight) || it(Nt.fontSize)) {
              var Kt = T(
                Nt.fontFamily,
                _,
                p,
                "sans-serif"
              ), jt = T(
                Nt.fontStyle,
                _,
                p,
                ""
              ), de = T(
                Nt.fontWeight,
                _,
                p,
                ""
              ), Qt = T(Nt.fontSize, _, p, 10), Oe = jt + " " + de + " " + Qt + "px " + Kt;
              w.setFont(Oe);
            }
          }
          return v;
        }
        function Ec(g) {
          var _ = uc(g, g.getLength() / 2), p = _[1], v = p[0], w = p[1];
          return [v, w];
        }
        function Ug(g, _) {
          if (typeof _.getGeometry != "function")
            return null;
          var p = _.getGeometry();
          if (!p)
            return null;
          var v = null, w = p.getType();
          if (w === "LineString")
            v = vn(g, _), v.setGeometry(new r.Point(Ec(p)));
          else if (w === "MultiLineString") {
            var I = p.getLineStrings(), N = I.map(Ec);
            v = vn(g, _), v.setGeometry(new r.MultiPoint(N));
          }
          return v;
        }
        function xc(g) {
          var _ = g.getInteriorPoint().getCoordinates(), p = _[0], v = _[1];
          return [p, v];
        }
        function zg(g, _) {
          if (typeof _.getGeometry != "function")
            return null;
          var p = _.getGeometry();
          if (!p)
            return null;
          var v = null, w = p.getType();
          if (w === "Polygon")
            v = vn(g, _), v.setGeometry(new r.Point(xc(p)));
          else if (w === "MultiPolygon") {
            var I = p.getPolygons(), N = I.map(xc);
            v = vn(g, _), v.setGeometry(new r.MultiPoint(N));
          }
          return v;
        }
        var Bg = [He];
        function Mi(g, _, p, v, w) {
          (_ || []).forEach(function(I) {
            var N = v(I, p, w);
            N && g.push(N);
          });
        }
        function Zo(g, _, p, v) {
          v === void 0 && (v = {});
          var w = g.polygonSymbolizers, I = g.lineSymbolizers, N = g.pointSymbolizers, B = g.textSymbolizers, U = {
            strictGeometryMatch: !1,
            useFallbackStyles: !0
          }, $ = Object.assign({}, U, v), ct = _.getGeometry ? _.getGeometry() : _.geometry, pt = ct.getType ? ct.getType() : ct.type, yt = [];
          switch (pt) {
            case "Point":
            case "MultiPoint":
              Mi(
                yt,
                N,
                _,
                vn,
                p
              ), Mi(yt, B, _, Yo, p);
              break;
            case "LineString":
            case "MultiLineString":
              Mi(yt, I, _, mc, p), $.strictGeometryMatch || Mi(
                yt,
                N,
                _,
                Ug,
                p
              ), Mi(yt, B, _, Yo, p);
              break;
            case "Polygon":
            case "MultiPolygon":
              Mi(
                yt,
                w,
                _,
                Dg,
                p
              ), $.strictGeometryMatch || Mi(
                yt,
                I,
                _,
                mc,
                p
              ), Mi(
                yt,
                N,
                _,
                zg,
                p
              ), Mi(yt, B, _, Yo, p);
              break;
            default:
              $.useFallbackStyles && (yt = Bg);
          }
          return yt.forEach(function(Ot, Nt) {
            return Ot.setZIndex(Nt);
          }), yt;
        }
        function $g(g) {
          return g.getId();
        }
        function Xg(g, _) {
          return g.get(_);
        }
        function Wg(g, _) {
          _ === void 0 && (_ = {});
          var p = _.imageLoadedCallback || function() {
          }, v = {};
          return function(w, I) {
            var N = typeof _.convertResolution == "function" ? _.convertResolution(I) : I, B = typeof _.getProperty == "function" ? _.getProperty : Xg, U = Xn(g, w, N, {
              getProperty: B,
              getFeatureId: $g
            });
            Ve(
              U,
              g,
              p,
              v
            );
            var $ = $i(U), ct = Zo($, w, B);
            return ct;
          };
        }
        function Yg(g, _) {
          var p = $i([g]), v = Zo(
            p,
            { geometry: { type: _ } },
            function() {
              return null;
            },
            { strictGeometryMatch: !0, useFallbackStyles: !1 }
          );
          return v.filter(function(w) {
            return w !== null;
          });
        }
        function En(g) {
          if (g === null)
            return "";
          var _ = typeof g;
          switch (_) {
            case "string":
              return g;
            case "number":
            case "bigint":
            case "boolean":
              return g.toString();
            case "undefined":
              return "";
            default:
              return _;
          }
        }
        function Mc(g) {
          return En(g).toLowerCase();
        }
        function wc(g) {
          return En(g).toUpperCase();
        }
        function Zg(g, _, p) {
          var v = Number(_), w = Number(p);
          if (Number.isNaN(v))
            return "";
          var I = En(g);
          return Number.isNaN(w) ? v > 0 ? I.slice(v - 1) : I.slice(v) : w === 0 ? "" : v > 0 ? w > 0 ? I.slice(v - 1, v - 1 + w) : I.slice(v - 1, w) : w > 0 ? v + w < 0 ? I.slice(v, v + w) : I.slice(v) : I.slice(v, w);
        }
        function qg(g, _, p) {
          var v = En(g), w = Number(_), I = Number(p);
          return Number.isNaN(w) || Number.isNaN(I) ? "" : v.slice(w, I);
        }
        function Kg(g, _) {
          var p = En(g), v = Number(_);
          return Number.isNaN(v) ? "" : p.slice(v);
        }
        function qo(g) {
          return g && typeof g.getType == "function" ? g.getType() : "Unknown";
        }
        function jg(g) {
          switch (qo(g)) {
            case "Point":
            case "MultiPoint":
              return 0;
            case "LineString":
            case "LinearRing":
            case "Circle":
            case "MultiLineString":
              return 1;
            case "Polygon":
            case "MultiPolygon":
              return 2;
            default:
              return 0;
          }
        }
        function Vg(g) {
          switch (qo(g)) {
            case "Point":
            case "MultiPoint":
              return "Point";
            case "LineString":
            case "LinearRing":
            case "Circle":
            case "MultiLineString":
              return "Line";
            case "Polygon":
            case "MultiPolygon":
              return "Polygon";
            default:
              return "Unknown";
          }
        }
        function Rc() {
          for (var g = [], _ = arguments.length; _--; ) g[_] = arguments[_];
          var p = g[0], v = g.slice(1), w = En(p);
          return v.some(function(I) {
            return En(I) === w;
          });
        }
        function Hg() {
          W("lower", Mc), W("upper", wc), W("geometry_type", Vg), W("substr", Zg), W("strToLowerCase", Mc), W("strToUpperCase", wc), W("strSubstring", qg), W("strSubstringStart", Kg), W("geometryType", qo), W("dimension", jg), W("in", Rc);
          for (var g = 2; g <= 10; g += 1)
            W("in" + g, Rc);
          W("__fe:Add__", function(_, p) {
            return Number(_) + Number(p);
          }), W("__fe:Sub__", function(_, p) {
            return Number(_) - Number(p);
          }), W("__fe:Mul__", function(_, p) {
            return Number(_) * Number(p);
          }), W("__fe:Div__", function(_, p) {
            return Number(_) / Number(p);
          });
        }
        Hg(), e.OlStyler = Zo, e.Reader = lt, e.categorizeSymbolizers = $i, e.createOlStyle = Yg, e.createOlStyleFunction = Wg, e.getByPath = Bi, e.getFunction = gt, e.getLayer = Ui, e.getLayerNames = yi, e.getRuleSymbolizers = Wn, e.getRules = Xn, e.getStyle = Bt, e.getStyleNames = zi, e.registerFunction = W;
      });
    }(hr, hr.exports)), hr.exports;
  }
  var Ia = Z2();
  ue.defs("EPSG:25832", "+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs +axis=enu");
  ue.defs("http://www.opengis.net/def/crs/EPSG/0/25832", ue.defs("EPSG:25832"));
  Z1(ue);
  const Rl = Pt("EPSG:25832");
  class Ql extends Pn {
    // Initialize custom properties
    constructor() {
      super(), this.vectorLayers = [], this.styles = {
        fillColor: "#ffffff",
        strokeColor: "#000000",
        strokeWidth: 1
      }, this.gmlFile = null, this.sldFile = null, this.xmlFile = null;
    }
    /**
     * Called when the component is added to the DOM. Retrieve the GML, SLD and metadata
     * files and pass them to the respective loading functions.
     */
    connectedCallback() {
      super.connectedCallback(), console.log("Connected Properties:", this.gmlFile, this.xmlFile, this.sldFile), this.gmlFile && fetch(this.gmlFile).then((t) => t.text()).then((t) => {
        if (this.sldFile)
          return fetch(this.sldFile).then((e) => e.text()).then((e) => {
            this.loadGML(t, e);
          });
        this.loadGML(t, null);
      }).catch((t) => console.error("Error loading GML or SLD:", t)), this.xmlFile && fetch(this.xmlFile).then((t) => t.text()).then((t) => {
        this.loadMetadata(t);
      }).catch((t) => console.error("Error loading XML:", t));
    }
    firstUpdated() {
      this.initMaps(), this.initHoverPopup();
    }
    // Initialize the map
    initMaps() {
      this.map = new Hp({
        // Set the target element
        target: this.shadowRoot.getElementById("map"),
        // Set the layers
        layers: [
          new p1({
            source: new N1({
              url: "https://services.datafordeler.dk/DKskaermkort/topo_skaermkort_daempet/1.0.0/wmts?username=QKJBQATHVS&password=ytxCA8UGM5n0Z*zi",
              layer: "topo_skaermkort_daempet",
              matrixSet: "View1",
              format: "image/jpeg",
              style: "default",
              tileGrid: new y1({
                extent: [12e4, 59e5, 1e6, 65e5],
                resolutions: [1638.4, 819.2, 409.6, 204.8, 102.4, 51.2, 25.6, 12.8, 6.4, 3.2, 1.6, 0.8, 0.4, 0.2],
                matrixIds: ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13"]
              })
            }),
            visible: !0
          })
        ],
        // Set the view
        view: new oi({
          center: [6e5, 6225e3],
          zoom: 9,
          projection: Rl
        }),
        controls: []
      });
    }
    initHoverPopup() {
      const t = document.createElement("div");
      t.id = "popup", t.style.cssText = `
      background: white;
      border: 1px solid black;
      padding: 5px;
      border-radius: 5px;
      font-size: 12px;
      box-shadow: 0px 2px 10px rgba(0, 0, 0, 0.2);
      pointer-events: none;
      position: absolute;
      display: none;
      width: max-content;
    `, this.shadowRoot.appendChild(t), this.overlay = new U2({
        element: t,
        offset: [10, 10],
        positioning: "center-left"
      }), this.map.addOverlay(this.overlay), this.map.on("pointermove", (e) => {
        const n = this.map.forEachFeatureAtPixel(e.pixel, (s) => s);
        if (n) {
          const s = n.get("navn"), r = n.get("type");
          let a = "";
          s && (a += `<strong>${s}</strong><br/>`), r && (a += `Type: ${r}`), a ? (t.innerHTML = a, t.style.display = "block", this.overlay.setPosition(e.coordinate)) : t.style.display = "none";
        } else
          t.style.display = "none";
      });
    }
    // Zoom in on map
    zoomIn() {
      const t = this.map.getView();
      t.setZoom(t.getZoom() + 1);
    }
    // Zoom out on map
    zoomOut() {
      const t = this.map.getView();
      t.setZoom(t.getZoom() - 1);
    }
    /**
     * Gets the style for the given geometry type
     * @param {string} geometryType The type of geometry (Polygon, MultiPolygon, LineString, Point)
     * @param {Style} [sldStyle] The SLD style to use (optional)
     * @returns {Style} The style for the given geometry type
     */
    getStyle(t, e = null) {
      if (e)
        return e;
      const { fillColor: n, strokeColor: s, strokeWidth: r } = this.styles;
      switch (t) {
        case "Polygon":
        case "MultiPolygon":
          return new oe({
            fill: new ti({ color: n }),
            stroke: new Ne({ color: s, width: r })
          });
        case "LineString":
          return new oe({
            stroke: new Ne({ color: s, width: r })
          });
        case "Point":
          return new oe({
            image: new Gn({
              radius: 5,
              fill: new ti({ color: n }),
              stroke: new Ne({ color: s, width: 1 })
            })
          });
        default:
          return console.warn(`No style found for geometry type: ${t}`), null;
      }
    }
    /**
     * Uploads the given files to the map.
     * @param {Event} event The event containing the files.
     */
    uploadFiles(t) {
      const e = [...t.target.files], n = e.find((o) => o.name.endsWith(".gml")), s = e.find((o) => o.name.endsWith(".sld")), r = e.find((o) => o.name.endsWith(".geojson")), a = e.find((o) => o.name.endsWith(".xml"));
      if (n) {
        const o = new FileReader();
        o.onload = () => {
          if (s) {
            const l = new FileReader();
            l.onload = () => {
              this.loadGML(o.result, l.result);
            }, l.readAsText(s);
          } else
            this.loadGML(o.result, null);
        }, o.readAsText(n);
      }
      if (r) {
        const o = new FileReader();
        o.onload = () => {
          this.loadMetadata(JSON.parse(o.result));
        }, o.readAsText(r);
      }
      if (a) {
        const o = new FileReader();
        o.onload = () => {
          this.loadMetadata(o.result);
        }, o.readAsText(a);
      }
    }
    /**
     * Loads metadata from a given string or object.
     *
     * If the metadata is a string, it is assumed to be in XML format and is parsed using a DOMParser.
     * If the metadata is an object, it is assumed to have a 'properties' property that contains the metadata.
     *
     * The metadata is then displayed on the map or in a designated UI element.
     *
     * @param {string|object} metadata - The metadata to load.
     */
    loadMetadata(t) {
      let e;
      if (typeof t == "string") {
        const h = new DOMParser().parseFromString(t, "application/xml");
        e = Array.from(h.documentElement.children).reduce((c, u) => (c[u.tagName] = u.textContent, c), {});
      } else if (t.properties)
        e = t.properties;
      else {
        console.warn("Unsupported metadata format.");
        return;
      }
      const n = this.shadowRoot.querySelector("#map-container");
      if (!n) {
        console.error("Map container not found");
        return;
      }
      let s = n.querySelector("#metadata-box");
      s || (s = document.createElement("div"), s.id = "metadata-box", s.style.cssText = `
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(255, 255, 255, 0.95);
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      max-height: 300px;
      overflow-y: auto;
      max-width: 25rem;
      z-index: 10;
    `, n.appendChild(s));
      let r = "";
      for (const [l, h] of Object.entries(e)) {
        const c = l.charAt(0).toUpperCase() + l.slice(1);
        r += `<div style="margin-bottom: 8px;"><strong>${c}:</strong> ${h}</div>`;
      }
      s.innerHTML = `
    <button id="toggle-metadata" style="background:none; border:none; font-size:1rem; cursor:pointer;">
        Metadata 
    </button>
    <div id="metadata-content" style="display:none; margin-top:10px;">
        ${r}
    </div>
  `;
      const a = s.querySelector("#toggle-metadata"), o = s.querySelector("#metadata-content");
      a.addEventListener("click", () => {
        const l = o.style.display === "block";
        o.style.display = l ? "none" : "block", a.textContent = l ? "Metadata " : "Metadata ";
      });
    }
    /**
     * Loads GML data from a given string and applies it to the map.
     *
     * The GML data is parsed using a DOMParser and then grouped by feature type.
     * The feature groups are then applied to the map using the applyFeatureGroupsToMap method.
     *
     * @param {string} gmlString - The GML data to load.
     * @param {string} [sldString] - The SLD data to use for styling.
     */
    loadGML(t, e = null) {
      const { features: n, xmlDoc: s } = this.parseGML(t), r = this.groupFeaturesByType(n, s);
      this.resetLayers(), this.applyFeatureGroupsToMap(r, e);
      const a = n.length > 0 ? n[0].getGeometry().getExtent().slice() : null;
      n.forEach((o) => {
        const l = o.getGeometry().getExtent();
        a && Gr(a, l);
      }), a && this.map.getView().fit(a, {
        size: this.map.getSize(),
        padding: [50, 50, 50, 50],
        maxZoom: 18
      });
    }
    /**
     * Applies feature groups to the map, optionally using SLD styles for styling.
     *
     * This function iterates over the feature groups and adds them to the map with appropriate styles.
     * If SLD data is provided, it will attempt to apply the SLD styles to the features.
     *
     * @param {Object} featureGroups - An object containing groups of features categorized by type.
     * @param {string} [sldString] - The SLD data to use for styling the features.
     */
    applyFeatureGroupsToMap(t, e) {
      const n = this.map.getView().getProjection(), s = e ? Ia.Reader(e) : null;
      Object.keys(t).forEach((r) => {
        const a = new ky({ features: t[r] }), o = this.applySLDStyles(s, r, n);
        this.addLayerWithControls(r, a, o || this.getStyle(r));
      }), this.map.render(), this.requestUpdate();
    }
    /**
     * Parses GML data from a given string, returning features and the XML document.
     *
     * This function attempts to parse the provided GML string using the GML32 format.
     * It returns an object containing the parsed features and the XML document.
     *
     * @param {string} gmlString - The GML data to parse.
     * @returns {Object} An object with 'features' array and 'xmlDoc' XML document.
     */
    parseGML(t) {
      try {
        const e = new wt(), s = new DOMParser().parseFromString(t, "application/xml");
        return { features: e.readFeatures(t, {
          featureProjection: Rl,
          dataProjection: Rl
        }), xmlDoc: s };
      } catch (e) {
        return console.error("Failed to parse GML file:", e), { features: [], xmlDoc: null };
      }
    }
    /**
     * Groups features by their feature type.
     *
     * This function takes the parsed features and an XML document as input and
     * groups the features by their feature type. The feature type is determined by
     * the local name of the first child element of the feature member element.
     *
     * @param {Array<ol/Feature>} features - The parsed features to group.
     * @param {XMLDocument} xmlDoc - The XML document containing the feature members.
     * @returns {Object} An object with feature type as keys and arrays of features as values.
     */
    groupFeaturesByType(t, e) {
      return t.reduce((n, s, r) => {
        const o = e.getElementsByTagNameNS("*", "featureMember")[r], l = o ? o.firstElementChild : null, h = l ? l.localName : "Unknown Type";
        return n[h] || (n[h] = []), n[h].push(s), n;
      }, {});
    }
    /**
     * Removes all vector layers from the map and resets the data toggle.
     *
     * This function is called when a new GML file is selected and we want to remove all the
     * previously added vector layers from the map and reset the data toggle.
     */
    resetLayers() {
      this.vectorLayers.forEach((t) => {
        this.map.removeLayer(t);
      }), this.vectorLayers = [], this.shadowRoot.getElementById("data-toggle").innerHTML = "";
    }
    /**
     * Applies SLD styles to the map.
     *
     * This function takes an SLD object, a feature type and the view projection as input and
     * applies the SLD styles to the map. If the SLD object is null, null is returned. If the
     * feature type is not found in the SLD object, a warning is logged and null is returned. If
     * the feature type is found but the style is not found, a warning is logged and null is
     * returned.
     *
     * @param {Object} sldObject - The SLD object to apply styles from.
     * @param {string} type - The feature type to apply the styles to.
     * @param {ol/proj/Projection} viewProjection - The view projection of the map.
     * @returns {ol/style/StyleFunction} The style function to apply to the map.
     */
    applySLDStyles(t, e, n) {
      if (!t) return null;
      const s = Ia.getLayer(t, e);
      if (!s)
        return console.warn("No named layer found for " + e), null;
      const r = Ia.getStyle(s);
      if (!r)
        return console.warn("No style found for layer " + s), null;
      const a = r.featuretypestyles[0];
      return Ia.createOlStyleFunction(a, {
        convertResolution: (o) => {
          const l = this.map.getView().getCenter();
          return Pl(n, o, l);
        },
        imageLoadedCallback: () => {
          this.map.changed();
        }
      });
    }
    /**
     * Updates the style of the given vector layer with the given style options.
     *
     * The style options are:
     * - `fillColor`: The color to use for filling polygons.
     * - `strokeColor`: The color to use for drawing lines.
     * - `strokeWidth`: The width of lines.
     *
     * The style function is then applied to the vector layer.
     *
     * @param {ol/layer/Vector} vectorLayer - The vector layer to update the style of.
     * @param {{fillColor: string, strokeColor: string, strokeWidth: number}} styleOptions - The style options to apply.
     */
    updateLayerStyle(t, { fillColor: e, strokeColor: n, strokeWidth: s }) {
      t.setStyle((r) => {
        const a = r.getGeometry().getType();
        return a === "Point" ? new oe({
          image: new Gn({
            radius: 5,
            fill: new ti({ color: e }),
            stroke: new Ne({ color: n, width: s })
          })
        }) : a === "Polygon" || a === "MultiPolygon" ? new oe({
          fill: new ti({ color: e }),
          stroke: new Ne({ color: n, width: s })
        }) : a === "LineString" ? new oe({
          stroke: new Ne({
            color: n,
            width: s
          })
        }) : a === "Circle" ? new oe({
          stroke: new Ne({
            color: n,
            width: s
          })
        }) : new oe({
          fill: new ti({ color: e }),
          stroke: new Ne({ color: n, width: s })
        });
      });
    }
    /**
     * Creates a checkbox to toggle the visibility of a layer.
     *
     * The checkbox is wrapped in a container element with class 'checkbox-container'.
     * The checkbox is given an ID of the form `checkbox-${type}`, where type is the type of the layer.
     * The checkbox is also given an event listener that toggles the visibility of the layer when changed.
     *
     * @param {string} type - The type of the layer.
     * @param {ol/layer/Layer} vectorLayer - The vector layer to toggle the visibility of.
     * @returns {HTMLElement} The container element containing the checkbox.
     */
    createLayerToggleCheckbox(t, e) {
      const n = document.createElement("div");
      n.className = "checkbox-container";
      const s = document.createElement("input");
      s.type = "checkbox", s.id = `checkbox-${t}`, s.checked = !0, s.addEventListener("change", () => {
        e.setVisible(s.checked);
      });
      const r = document.createElement("label");
      return r.htmlFor = `checkbox-${t}`, r.textContent = t, n.appendChild(s), n.appendChild(r), n;
    }
    /**
     * Creates color pickers for a layer and adds them to the given container.
     * The color pickers are three `input` elements with types `color`, `color`, and `number`.
     * The first two are for the fill and stroke colors, respectively, and the third is for the stroke width.
     * Each color picker is given an event listener that updates the style of the given layer
     * when the color picker is changed.
     *
     * @param {HTMLElement} container - The container element to add the color pickers to.
     * @param {string} type - The type of the layer.
     * @param {ol/layer/Layer} vectorLayer - The vector layer to update the style of when the color picker is changed.
     */
    addColorPickers(t, e, n) {
      const s = document.createElement("input");
      s.type = "color", s.value = this.styles.fillColor, s.addEventListener("input", () => {
        this.updateLayerStyle(n, {
          fillColor: s.value,
          strokeColor: r.value,
          strokeWidth: a.value
        });
      });
      const r = document.createElement("input");
      r.type = "color", r.value = this.styles.strokeColor, r.addEventListener("input", () => {
        this.updateLayerStyle(n, {
          fillColor: s.value,
          strokeColor: r.value,
          strokeWidth: a.value
        });
      });
      const a = document.createElement("input");
      a.type = "number", a.value = this.styles.strokeWidth, a.min = 1, a.max = 10, a.addEventListener("input", () => {
        this.updateLayerStyle(n, {
          fillColor: s.value,
          strokeColor: r.value,
          strokeWidth: a.value
        });
      }), t.appendChild(s), t.appendChild(r), t.appendChild(a);
    }
    /**
     * Adds a vector layer to the map with controls for visibility and styling.
     *
     * This function creates a vector layer using the provided vector source and style function.
     * It also adds a checkbox to toggle the visibility of the layer, and color pickers
     * for adjusting the layer's fill color, stroke color, and stroke width.
     *
     * @param {string} type - The type or name of the layer.
     * @param {ol/source/Vector} vectorSource - The vector source for the layer.
     * @param {function} [sldStyleFunction] - Optional style function for the layer.
     */
    addLayerWithControls(t, e, n) {
      const s = new Ly({
        source: e,
        style: n || ((d) => this.getStyle(d.getGeometry().getType()))
      });
      this.map.addLayer(s), this.vectorLayers.push(s);
      const r = document.createElement("div");
      r.classList.add("layer-toggle");
      const a = document.createElement("input");
      a.type = "checkbox", a.checked = !0, a.addEventListener("change", () => {
        s.setVisible(a.checked);
      });
      const o = document.createElement("label");
      o.textContent = t;
      const l = document.createElement("div");
      l.classList.add("color-pickers");
      const h = this.createColorInput("Fill", this.styles.fillColor, (d) => {
        this.styles.fillColor = d, s.setStyle(this.getStyle("Polygon"));
      }), c = this.createColorInput("Stroke", this.styles.strokeColor, (d) => {
        this.styles.strokeColor = d, s.setStyle(this.getStyle("Polygon"));
      }), u = this.createNumberInput("Width", this.styles.strokeWidth, (d) => {
        this.styles.strokeWidth = d, s.setStyle(this.getStyle("Polygon"));
      });
      l.appendChild(h), l.appendChild(c), l.appendChild(u), r.appendChild(a), r.appendChild(o), this.shadowRoot.getElementById("data-toggle").appendChild(r);
    }
    /**
     * Creates a color input field with a label and an event listener that calls the `onChange` function with the new value.
     * @param {string} label - The label for the color input field.
     * @param {string} initialValue - The initial color value.
     * @param {function} onChange - The function to call when the color is changed.
     * @returns {HTMLElement} The container element containing the color input field.
     */
    createColorInput(t, e, n) {
      const s = document.createElement("div");
      s.style.marginBottom = "5px";
      const r = document.createElement("span");
      r.textContent = `${t} Color: `;
      const a = document.createElement("input");
      return a.type = "color", a.value = e, a.addEventListener("input", (o) => n(o.target.value)), s.appendChild(a), s;
    }
    /**
     * Creates a number input field with a label and an event listener that calls the `onChange` function with the new value.
     * @param {string} label - The label for the number input field.
     * @param {number} initialValue - The initial number value.
     * @param {function} onChange - The function to call when the number is changed.
     * @returns {HTMLElement} The container element containing the number input field.
     */
    createNumberInput(t, e, n) {
      const s = document.createElement("div");
      s.style.marginBottom = "5px";
      const r = document.createElement("span");
      r.textContent = `${t}: `;
      const a = document.createElement("input");
      return a.type = "number", a.value = e, a.min = 1, a.addEventListener("input", (o) => n(Number(o.target.value))), s.appendChild(a), s;
    }
    // Drag and Drop Functions
    onDragOver(t) {
      t.preventDefault(), this.shadowRoot.getElementById("drop-zone").classList.add("dragover");
    }
    onDragLeave() {
      this.shadowRoot.getElementById("drop-zone").classList.remove("dragover");
    }
    onDrop(t) {
      t.preventDefault(), this.shadowRoot.getElementById("drop-zone").classList.remove("dragover");
      const n = [...t.dataTransfer.files], s = n.find((o) => o.name.endsWith(".gml")), r = n.find((o) => o.name.endsWith(".xml")), a = n.find((o) => o.name.endsWith(".sld"));
      if (s || a || r) {
        const o = document.createElement("input");
        o.type = "file", o.files = new DataTransfer().files, o.dispatchEvent(new Event("change", { bubbles: !0 })), this.uploadFiles({ target: { files: n } });
      }
    }
    render() {
      return _s`
      <div part="map-container" class="map-container" id="map-container" @dragover="${this.onDragOver}" @dragleave="${this.onDragLeave}" @drop="${this.onDrop}">
        <div id="map" class="map"></div>

        <div id="data-toggle"></div>
        <div id="metadata"></div>
        

        <div id="controls-container">
          <label class="control-icon" title="Zoom In" @click="${this.zoomIn}">
            <svg class="ds-icon" width="29" height="29" viewBox="0 0 29 29" fill="none" xmlns="http://www.w3.org/2000/svg">
              <g stroke="var(--ds-icon-color, black)" stroke-linejoin="round" stroke-linecap="round" stroke-width="var(--ds-icon-stroke, 1)">
                <path d="M0.5 14.5H28.5M14.5 0.5L14.5 28.5"/>
              </g>
            </svg>
          </label>
          <label class="control-icon" title="Zoom Out" @click="${this.zoomOut}">
            <svg class="ds-icon" width="29" height="29" viewBox="0 0 29 29" fill="none" xmlns="http://www.w3.org/2000/svg">
              <g stroke="var(--ds-icon-color, black)" stroke-linejoin="round" stroke-linecap="round" stroke-width="var(--ds-icon-stroke, 1)">
                <path d="M0.5 14.5H28.5"/>
              </g>
            </svg>
          </label>
          <label class="control-icon" id="drop-zone" title="Upload Files">
            <input type="file" multiple @change="${this.uploadFiles}"/>
            <svg class="ds-icon" width="29" height="29" viewBox="0 0 29 29" fill="none" xmlns="http://www.w3.org/2000/svg">
              <g stroke="var(--ds-icon-color, black)" stroke-linecap="round" fill="none" stroke-width="var(--ds-icon-stroke, 1)">
                <path d="M1.5 26.5H27.5"/>
                <path d="M2 13.0858L13.7929 1.29292C14.1834 0.902398 14.8166 0.902399 15.2071 1.29292L27 13.0858M14.5 1.08582L14.5 20.4999"/>
              </g>
            </svg>
          </label>
        </div>
        <div id="compass-container">
          <svg class="ds-icon" width="40" height="40" viewBox="0 0 31 31" fill="none" xmlns="http://www.w3.org/2000/svg">
            <circle cx="15.5" cy="15.5" r="15" fill="var(--c8, black)" stroke="var(--white, white)" stroke-width="var(--ds-icon-stroke, 1)"/>
            <g stroke="var(--white, white)" stroke-linecap="round" stroke-linejoin="round">
              <path id="west" d="M3.9 16.79L7.12 15.5L3.9 14.21"/>
              <path id="east" d="M23.88 16.79L27.1 14.21M25.81 16.79H25.16C24.45 16.79 23.88 16.21 23.88 15.5C23.88 14.79 24.45 14.21 25.16 14.21H25.81C26.52 14.21 27.1 14.79 27.1 15.5C27.1 16.21 26.52 16.79 25.81 16.79Z"/>
              <path id="south" d="M14.21 26.46C14.21 26.81 14.5 27.1 14.86 27.1H16.06C16.46 27.1 16.79 26.78 16.79 26.38C16.79 26.05 16.56 25.76 16.24 25.68L14.76 25.3C14.44 25.22 14.21 24.93 14.21 24.6C14.21 24.2 14.54 23.88 14.93 23.88H16.14C16.5 23.88 16.79 24.17 16.79 24.52"/>
              <path id="north" d="M14.21 7.12L14.22 3.9L16.79 7.12V3.9"/>
            </g>
            <path id="north-pointer" d="M12.13 15.49C12.12 15.02 12.29 14.72 12.45 14.41L14.96 9.4C15.15 8.99 15.8 9.01 15.99 9.37L18.63 14.65C18.73 14.87 18.85 15.16 18.84 15.49L17.21 15.49C17.21 15.49 17.12 13.78 15.49 13.77C13.86 13.76 13.75 15.49 13.75 15.49L12.13 15.49Z" fill="var(--r5, red)"/>
            <path id="south-pointer" d="M12.12 15.5C12.12 15.96 12.28 16.26 12.44 16.58L14.95 21.58C15.14 21.99 15.79 21.97 15.98 21.61L18.62 16.33C18.73 16.12 18.84 15.82 18.83 15.49L17.2 15.49C17.2 15.49 17.12 17.2 15.48 17.21C13.85 17.22 13.75 15.5 13.75 15.5L12.12 15.5Z" fill="var(--white, white)"/>
            <path d="M5.19 5.19L7.77 7.77M25.81 5.19L23.23 7.77M25.81 25.81L23.23 23.23M5.19 25.81L7.77 23.23" stroke="white" stroke-linecap="round" stroke-linejoin="round" stroke-width="var(--ds-icon-stroke, 1)"/>
          </svg>
        </div>
      </div>

      <a href="#map-example" role="button">MapExample</a>
      <a href="#map-template" role="button">MapTemplate</a>
      <a href="#map" role="button">Kort</a>
    `;
    }
  }
  Wi(Ql, "styles", nh`

      :host {
          display: block;
          width: var(--map-viewer-width, 100%);
          height: var(--map-viewer-height, 100%);
          border: var(--map-viewer-border, none);
          box-shadow: var(--map-viewer-box-shadow, none);
      }

      .map-container {
          display: flex;
          justify-content: center;
          align-items: center;
          width: 100%;
          height: 100%;
          position: relative;
      }

      .map {
          width: 100%;
          height: 100%;
      }


      #compass-container {
          position: absolute;
          top: 1rem;
          right: 1rem;
          display: flex;
          flex-direction: column;
          padding: 8px;
          width: 3rem;
          height: 3rem;
      }

      #controls-container {
          position: absolute;
          bottom: 1rem;
          right: 1rem;
          display: flex;
          flex-direction: column;
          gap: 10px;
          background: rgba(255, 255, 255, 0.8);
          border-radius: 8px;
          padding: 10px;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      .control-icon {
          width: 40px;
          height: 40px;
          display: flex;
          justify-content: center;
          align-items: center;
          background-color: white;
          border: 1px solid #ccc;
          border-radius: 50%;
          cursor: pointer;
          transition: background-color 0.3s, transform 0.2s;
      }

      #data-toggle {
          position: absolute;
          bottom: 1rem;
          left: 1rem;
          background: rgba(255, 255, 255, 0.8);
          border-radius: 8px;
          padding: 8px;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      button:hover, label:hover {
          transform: scale(1.1);
      }

      label svg {
          width: 20px;
          height: 20px;
          fill: #333;
      }

      input[type="file"] {
          display: none;
      }
  `), // Define custom properties
  Wi(Ql, "properties", {
    gmlFile: { type: String, reflect: !0 },
    xmlFile: { type: String, reflect: !0 },
    sldFile: { type: String, reflect: !0 }
  });
  class th extends Pn {
    constructor() {
      super(), this.gmlFile = "", this.xmlFile = "", this.sldFile = "";
    }
    updated(t) {
      (t.has("gmlFile") || t.has("xmlFile") || t.has("sldFile")) && console.log("Updated Properties:", this.gmlFile, this.xmlFile, this.sldFile);
    }
    render() {
      return console.log("Rendering with:", this.gmlFile, this.xmlFile, this.sldFile), _s`
      <map-viewer
        .gmlFile="${this.gmlFile}"
        .xmlFile="${this.xmlFile}"
        .sldFile="${this.sldFile}">
      </map-viewer>
    `;
    }
  }
  Wi(th, "styles", nh`
      /* Add your styles here */
  `), Wi(th, "properties", {
    gmlFile: { type: String, reflect: !0 },
    xmlFile: { type: String, reflect: !0 },
    sldFile: { type: String, reflect: !0 }
  });
  class hg extends Pn {
    render() {
      const t = "./examples/2019/713/data_demo.gml", e = "./examples/2019/713/metadata.xml", n = "./examples/2019/713/styles.sld";
      return console.log("MapExample XML", e), console.log("MapExample GML", t), console.log("MapExample SLD", n), _s`
          <map-viewer
              .gmlFile="${t}"
              .xmlFile="${e}"
              .sldFile="${n}">
          </map-viewer>
          <a href="#map-example" role="button">MapExample</a>
          <a href="#map-template" role="button">MapTemplate</a>
          <a href="#map" role="button">Kort</a>
      `;
    }
  }
  Wi(hg, "styles", nh`
  
  `);
  function q2(i) {
    if (i === "#map-viewer")
      return _s`
    <map-viewer></map-viewer>`;
    if (i === "#map-example")
      return _s`
    <map-example></map-example>`;
    if (i === "#map-template")
      return _s`
    <map-template></map-template>`;
  }
  class cg extends n0 {
    constructor() {
      super(), this.route = window.location.hash || "#map-viewer", this._setupRouting();
    }
    /**
     * Initializes a hashchange listener to update the route dynamically.
     * The hashchange event is dispatched when the fragment identifier of the URL changes.
     * @private
     */
    _setupRouting() {
      window.addEventListener("hashchange", () => {
        this.route = window.location.hash || "#map-viewer";
      });
    }
    render() {
      return s0`
      <main>
        ${q2(this.route)} <!-- Pass the current route to the router -->
      </main>
    `;
    }
    // Optional: Render into the light DOM (if required for styling)
    createRenderRoot() {
      return this;
    }
  }
  Wi(cg, "properties", {
    route: { type: String }
    // Dynamic route property
  });
  customElements.define("main-component", cg);
  customElements.define("map-viewer", Ql);
  customElements.define("map-template", th);
  customElements.define("map-example", hg);
});
export default K2();
